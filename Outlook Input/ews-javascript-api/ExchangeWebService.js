(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/C:\\Users\\gs\\AppData\\Roaming\\nvm\\v8.4.0\\node_modules\\browserify\\node_modules\\base64-js\\index.js","/C:\\Users\\gs\\AppData\\Roaming\\nvm\\v8.4.0\\node_modules\\browserify\\node_modules\\base64-js")
},{"_process":4,"buffer":2}],2:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (isArrayBufferView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (isArrayBufferView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`
function isArrayBufferView (obj) {
  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/C:\\Users\\gs\\AppData\\Roaming\\nvm\\v8.4.0\\node_modules\\browserify\\node_modules\\buffer\\index.js","/C:\\Users\\gs\\AppData\\Roaming\\nvm\\v8.4.0\\node_modules\\browserify\\node_modules\\buffer")
},{"_process":4,"base64-js":1,"buffer":2,"ieee754":3}],3:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/C:\\Users\\gs\\AppData\\Roaming\\nvm\\v8.4.0\\node_modules\\browserify\\node_modules\\ieee754\\index.js","/C:\\Users\\gs\\AppData\\Roaming\\nvm\\v8.4.0\\node_modules\\browserify\\node_modules\\ieee754")
},{"_process":4,"buffer":2}],4:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/C:\\Users\\gs\\AppData\\Roaming\\nvm\\v8.4.0\\node_modules\\browserify\\node_modules\\process\\browser.js","/C:\\Users\\gs\\AppData\\Roaming\\nvm\\v8.4.0\\node_modules\\browserify\\node_modules\\process")
},{"_process":4,"buffer":2}],5:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
// Copyright (c) 2014-2017 Gautam Singh
// MIT License; Full text at - https://github.com/gautamsi/ews-javascript-api/blob/master/LICENSE
// Packages license notices pending
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var b64 = require("base64-js");
var uuid = require("uuid");
var moment = require("moment-timezone");
var Dictionary = (function () {
    function Dictionary(keyPickerFunc) {
        this.keys = [];
        this.keysToObjs = {};
        this.objects = {}; // {[key:string]:TValue};
        if (typeof keyPickerFunc !== 'function')
            throw new Error("Dictionary - keyPickerFunc must be a function");
        this.keyPicker = keyPickerFunc;
    }
    Object.defineProperty(Dictionary.prototype, "Keys", {
        /** get all keys */
        get: function () {
            var keys = [];
            for (var _a = 0, _b = this.keys; _a < _b.length; _a++) {
                var key = _b[_a];
                keys.push(this.keysToObjs[key]);
            }
            return keys;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dictionary.prototype, "Items", {
        /**get all items in key,value pair array */
        get: function () {
            var items = [];
            for (var _a = 0, _b = this.keys; _a < _b.length; _a++) {
                var k = _b[_a];
                items.push({ key: this.keysToObjs[k], value: this.objects[k] });
            }
            return items;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dictionary.prototype, "Values", {
        /** get all values */
        get: function () {
            var ret = [];
            for (var _a = 0, _b = this.keys; _a < _b.length; _a++) {
                var key = _b[_a];
                ret.push(this.objects[key]);
            }
            return ret;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dictionary.prototype, "length", {
        /** get number of objects in dictionary */
        get: function () { return this.keys.length; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dictionary.prototype, "Count", {
        /** get number of objects in the dictionary */
        get: function () { return this.length; },
        enumerable: true,
        configurable: true
    });
    /** get string values of all keys */
    Dictionary.prototype.getStringKeys = function () { return this.keys; };
    /** add value or update the value for key */
    Dictionary.prototype.Add = function (key, value) { return this.addUpdate(key, value); };
    /** add value or update the value for key */
    Dictionary.prototype.addUpdate = function (key, value) {
        var strKey = this.keyPicker(key);
        if (StringHelper.IsNullOrEmpty(strKey))
            throw new Error("Dictionary - invalid key object, keyPicker return null");
        if (!this.containsKey(strKey)) {
            this.keys.push(strKey);
        }
        this.keysToObjs[strKey] = key;
        this.objects[strKey] = value;
    };
    /** Set value for key */
    Dictionary.prototype.set = function (key, value) {
        this.addUpdate(key, value);
    };
    Dictionary.prototype.setEntry = function (oldKey, newKey) {
        var strKey = oldKey;
        if (typeof oldKey !== 'string')
            strKey = this.keyPicker(oldKey);
        if (StringHelper.IsNullOrEmpty(strKey))
            throw new Error("Dictionary - invalid key object, keyPicker return null");
        if (this.containsKey(strKey)) {
            throw new Error("Dictionary - does not contain old key");
        }
        var oldval = this.objects[strKey];
        //oldval =   null:value;
        this.remove(strKey);
        this.addUpdate(newKey, oldval);
    };
    Dictionary.prototype.get = function (key) {
        var strKey = key;
        if (typeof key !== 'string')
            strKey = this.keyPicker(key);
        if (StringHelper.IsNullOrEmpty(strKey))
            throw new Error("Dictionary - invalid key object, keyPicker return null");
        return this.objects[strKey];
    };
    Dictionary.prototype.tryGetValue = function (key, outValue) {
        outValue.outValue = null;
        outValue.success = false;
        var strKey = key;
        if (typeof key !== 'string')
            strKey = this.keyPicker(key);
        if (StringHelper.IsNullOrEmpty(strKey)) {
            outValue.exception = new Error("Dictionary - invalid key,not a string value or keyPicker return null");
            return false;
        }
        if (this.containsKey(strKey)) {
            outValue.outValue = this.objects[strKey];
            outValue.success = true;
            return true;
        }
        return false;
    };
    Dictionary.prototype.remove = function (key) {
        var strKey = key;
        if (typeof key !== 'string')
            strKey = this.keyPicker(key);
        if (StringHelper.IsNullOrEmpty(strKey))
            throw new Error("Dictionary - invalid key,not a string value or keyPicker return null");
        if (!this.containsKey(strKey))
            return false;
        var keyindex = this.keys.indexOf(strKey);
        var delKeyAr = this.keys.splice(keyindex, 1);
        var delkeyObj = delete this.keysToObjs[strKey];
        var delObj = delete this.objects[strKey];
        return delKeyAr.length > 0 && delkeyObj && delObj;
    };
    Dictionary.prototype.containsKey = function (key) {
        var strKey = key;
        if (typeof key !== 'string')
            strKey = this.keyPicker(key);
        if (StringHelper.IsNullOrEmpty(strKey))
            throw new Error("Dictionary - invalid key object, keyPicker return null");
        if (this.keys.indexOf(strKey) >= 0)
            return true;
        return false;
    };
    /** clear dictionary */
    Dictionary.prototype.clear = function () {
        this.keys = [];
        this.keysToObjs = {};
        this.objects = {};
    };
    return Dictionary;
}());
exports.Dictionary = Dictionary;
/**@internal */
var StringPropertyDefinitionBaseDictionary = (function (_super) {
    __extends(StringPropertyDefinitionBaseDictionary, _super);
    function StringPropertyDefinitionBaseDictionary() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StringPropertyDefinitionBaseDictionary;
}(Dictionary));
exports.StringPropertyDefinitionBaseDictionary = StringPropertyDefinitionBaseDictionary;
/**@internal */
var PropertyDefinitionDictionary = (function (_super) {
    __extends(PropertyDefinitionDictionary, _super);
    function PropertyDefinitionDictionary() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PropertyDefinitionDictionary;
}(StringPropertyDefinitionBaseDictionary));
exports.PropertyDefinitionDictionary = PropertyDefinitionDictionary;
/**@internal */
var DictionaryWithStringKey = (function (_super) {
    __extends(DictionaryWithStringKey, _super);
    function DictionaryWithStringKey() {
        return _super.call(this, function (value) { return value; }) || this;
    }
    return DictionaryWithStringKey;
}(Dictionary));
exports.DictionaryWithStringKey = DictionaryWithStringKey;
/**@internal */
var DictionaryWithNumericKey = (function (_super) {
    __extends(DictionaryWithNumericKey, _super);
    function DictionaryWithNumericKey() {
        return _super.call(this, function (value) { return value.toString(); }) || this;
    }
    return DictionaryWithNumericKey;
}(Dictionary));
exports.DictionaryWithNumericKey = DictionaryWithNumericKey;
/**@internal */
var DictionaryWithPropertyDefitionKey = (function (_super) {
    __extends(DictionaryWithPropertyDefitionKey, _super);
    function DictionaryWithPropertyDefitionKey() {
        return _super.call(this, function (value) { return value.Name; }) || this;
    }
    return DictionaryWithPropertyDefitionKey;
}(Dictionary));
exports.DictionaryWithPropertyDefitionKey = DictionaryWithPropertyDefitionKey;
var PropDictionary2 = (function () {
    function PropDictionary2() {
        this.keys = [];
        this.objects = {}; // {[key:string]:TValue};
    }
    Object.defineProperty(PropDictionary2.prototype, "KeyNames", {
        get: function () { return this.keys; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropDictionary2.prototype, "Keys", {
        get: function () {
            var ret = [];
            for (var key in this.objects) {
                ret.push(this.objects[key].keyObject);
            }
            return ret;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropDictionary2.prototype, "Items", {
        get: function () {
            var all = [];
            for (var obj in this.objects) {
                all.push({ key: this.objects[obj].keyObject, value: this.objects[obj].value });
            }
            return all;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropDictionary2.prototype, "Values", {
        get: function () {
            var ret = [];
            for (var key in this.objects) {
                ret.push(this.objects[key].value);
            }
            return ret;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropDictionary2.prototype, "length", {
        get: function () { return this.keys.length; },
        enumerable: true,
        configurable: true
    });
    PropDictionary2.prototype.add = function (key, value) {
        var keyString = key.Name;
        if (this.keys.indexOf(key.Name) == -1) {
            this.keys.push(keyString);
        }
        this.objects[keyString] = { key: keyString, keyObject: key, value: value };
    };
    PropDictionary2.prototype.set = function (key, value) {
        this.add(key, value);
    };
    PropDictionary2.prototype.setEntry = function (oldKeyString, oldKey, value, isNull) {
        if (isNull === void 0) { isNull = false; }
        if (this.keys.indexOf(oldKeyString) == -1 || typeof this.objects[oldKeyString] === 'undefined') {
            throw new Error("invalid old keystring");
        }
        var oldval = isNull ? null : value || this.objects[oldKeyString].value;
        //oldval =   null:value;
        this.objects[oldKeyString] = { key: oldKey.Name, keyObject: oldKey, value: value || oldval };
    };
    PropDictionary2.prototype.get = function (key) {
        if (StringHelper.IsNullOrEmpty(key.Name))
            throw new Error("invalid operation, object does not have valid Name property");
        //if(this.keys.indexOf(key.Name)>=0)
        var val = this.objects[key.Name];
        return val ? val.value : undefined;
    };
    PropDictionary2.prototype.tryGet = function (key, outValue) {
        outValue.outValue = null;
        outValue.success = false;
        if (StringHelper.IsNullOrEmpty(key.Name))
            outValue.exception = new Error("invalid operation, object does not have valid Name property");
        if (this.containsKey(key)) {
            var val = this.objects[key.Name];
            outValue.outValue = val ? val.value : null;
            return true;
        }
        return false;
    };
    PropDictionary2.prototype.remove = function (key) {
        if (StringHelper.IsNullOrEmpty(key.Name))
            throw new Error("missing keyString");
        return delete this.objects[key.Name];
    };
    PropDictionary2.prototype.containsKey = function (key) {
        if (this.keys.indexOf(key.Name) >= 0 || typeof this.objects[key.Name] !== 'undefined')
            return true;
        return false;
    };
    PropDictionary2.prototype.clear = function () {
        this.keys = [];
        this.objects = {};
    };
    return PropDictionary2;
}());
var ConfigurationApi = (function () {
    function ConfigurationApi() {
    }
    ConfigurationApi.ConfigureXHR = function (xhrApi) {
        XHRFactory.xhrHelper = xhrApi;
    };
    ConfigurationApi.ConfigurePromise = function (promise) {
        ConfigurePromise(promise);
    };
    return ConfigurationApi;
}());
exports.ConfigurationApi = ConfigurationApi;
var ticksToEpoch = 621355968000000000; //can be used when calculating ticks/ms from Windows date to unix date
exports.msToEpoch = 62135596800000;
var invalidDateTimeMessage = {
    "years": "year is less than 1 or greater than 9999.",
    "months": "month is less than 1 or greater than 12.",
    "days": "day is less than 1 or greater than the number of days in month.",
    "hours": "hour is less than 0 or greater than 23.",
    "minutes": "minute is less than 0 or greater than 59.",
    "seconds": "second is less than 0 or greater than 59.",
    "milliseconds": "millisecond is less than 0 or greater than 999."
};
var DateTimeKind;
(function (DateTimeKind) {
    DateTimeKind[DateTimeKind["Unspecified"] = 0] = "Unspecified";
    DateTimeKind[DateTimeKind["Utc"] = 1] = "Utc";
    DateTimeKind[DateTimeKind["Local"] = 2] = "Local";
})(DateTimeKind = exports.DateTimeKind || (exports.DateTimeKind = {}));
/**
 * DateTime - basic date time based on moment.js
 */
var DateTime = (function () {
    function DateTime(msOrDateOrMomentOrYear, monthOrKind, day, hour, minute, second, millisecond, kind) {
        if (kind === void 0) { kind = DateTimeKind.Unspecified; }
        this.kind = DateTimeKind.Unspecified;
        this.originalDateInput = null;
        var argsLength = arguments.length;
        var momentdate = moment();
        this.kind = kind;
        if (argsLength === 1) {
            if (msOrDateOrMomentOrYear instanceof DateTime) {
                momentdate = msOrDateOrMomentOrYear.MomentDate.clone();
                this.kind = msOrDateOrMomentOrYear.kind;
            }
            else {
                momentdate = moment(msOrDateOrMomentOrYear);
                this.originalDateInput = msOrDateOrMomentOrYear;
            }
        }
        else if (argsLength === 2) {
            if (monthOrKind === DateTimeKind.Utc && !(msOrDateOrMomentOrYear instanceof moment)) {
                momentdate = moment.utc(msOrDateOrMomentOrYear);
            }
            else {
                momentdate = moment(msOrDateOrMomentOrYear);
            }
            this.kind = monthOrKind;
            if (this.kind === DateTimeKind.Unspecified && !(msOrDateOrMomentOrYear instanceof moment)) {
                this.originalDateInput = msOrDateOrMomentOrYear;
            }
        }
        else {
            var momentInput = {};
            if (argsLength >= 3) {
                momentInput.year = msOrDateOrMomentOrYear;
                momentInput.month = monthOrKind - 1;
                momentInput.day = day;
            }
            if (argsLength >= 6) {
                momentInput.hour = hour;
                momentInput.minute = minute;
                momentInput.second = second;
            }
            if (argsLength >= 7) {
                momentInput.millisecond = millisecond;
            }
            momentdate = moment(momentInput);
        }
        if (momentdate && !momentdate.isValid()) {
            var invalid = momentdate.invalidAt();
            throw new ArgumentOutOfRangeException(momentValidity[invalid], invalidDateTimeMessage[momentValidity[invalid]]);
        }
        // if (momentdate.isUtc()) {
        //     this.kind = DateTimeKind.Utc
        // }
        // else if (momentdate.isLocal()) {
        //     this.kind = DateTimeKind.Local;
        // }
        this.getMomentDate = function () { return momentdate; };
        this.setMomentDate = function (value) { return momentdate = value; };
    }
    Object.defineProperty(DateTime.prototype, "MomentDate", {
        get: function () { return this.momentDate; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTime.prototype, "currentUtcOffset", {
        get: function () { return this.momentDate.utcOffset(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTime.prototype, "momentDate", {
        get: function () { return this.getMomentDate(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTime, "Now", {
        get: function () {
            return new DateTime(moment());
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTime, "UtcNow", {
        get: function () {
            return new DateTime(moment.utc());
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTime.prototype, "TotalMilliSeconds", {
        get: function () {
            return this.momentDate.valueOf();
        },
        enumerable: true,
        configurable: true
    });
    DateTime.prototype.Add = function (quantity, unit) {
        if (unit === void 0) { unit = "ms"; }
        if (typeof quantity !== 'number') {
            quantity = quantity.TotalMilliseconds;
            unit = "ms";
        }
        var date = moment(this.momentDate);
        date.add(quantity, unit);
        return new DateTime(date);
    };
    DateTime.Compare = function (x, y) {
        var diff = x.momentDate.diff(y.momentDate);
        if (diff === 0)
            return 0;
        if (diff < 0)
            return -1;
        return 1;
    };
    DateTime.prototype.CompareTo = function (toDate) {
        return DateTime.Compare(this, toDate);
    };
    DateTime.prototype.Difference = function (toDate) {
        return new TimeSpan(toDate.momentDate.diff(this.momentDate));
    };
    DateTime.prototype.Format = function (formatting) {
        return this.momentDate.format(formatting);
    };
    DateTime.getKindfromMoment = function (m) {
        if (m.isUTC()) {
            return DateTimeKind.Utc;
        }
        if (m.isLocal()) {
            return DateTimeKind.Local;
        }
        return DateTimeKind.Unspecified;
    };
    DateTime.Parse = function (value, kind) {
        if (kind === void 0) { kind = DateTimeKind.Unspecified; }
        // Update 2019-01-17: add check for date format YYYY-MM-DDTHH:mm:ss[+-]HH:mmZ, which is not a valid format for moment().
        if (value.indexOf('-', 10) != -1) {
            var regex = /[+-]([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]Z/;
            value = value.replace(regex, 'Z');
        }
        var mdate = moment(value);
        var tempDate = null;
        if (mdate.isValid()) {
            switch (kind) {
                case DateTimeKind.Local:
                    tempDate = new DateTime(mdate.local());
                    tempDate.kind = kind;
                    return tempDate;
                case DateTimeKind.Utc:
                    tempDate = new DateTime(moment.utc(value));
                    tempDate.kind = kind;
                    return tempDate;
                default:
                    tempDate = new DateTime(mdate);
                    tempDate.originalDateInput = value;
                    tempDate.kind = kind;
                    return tempDate;
            }
        }
        else {
            throw new ArgumentException("invalid date value");
        }
    };
    DateTime.prototype.ToISOString = function () {
        return this.momentDate.toISOString();
    };
    DateTime.prototype.toString = function () {
        return this.momentDate.toString();
    };
    DateTime.prototype.utcOffset = function (value) {
        this.momentDate.utcOffset(value);
    };
    DateTime.DateimeStringToTimeZone = function (dtStr, zoneStr) {
        return new DateTime(moment.tz(dtStr, zoneStr));
    };
    DateTime.DateTimeToXSDateTime = function (dateTime) {
        var format = 'YYYY-MM-DDTHH:mm:ss.SSSZ'; //using moment format for c#->"yyyy-MM-ddTHH:mm:ss.fff";
        // switch (dateTime.Kind) {
        // 	case DateTimeKind.Utc:
        // 		format += "Z";
        // 		break;
        // 	case DateTimeKind.Local:
        // 		format += "zzz";
        // 		break;
        // 	default:
        // 		break;
        // }
        // Depending on the current culture, DateTime formatter will replace ':' with 
        // the DateTimeFormatInfo.TimeSeparator property which may not be ':'. Force the proper string
        // to be used by using the InvariantCulture.
        return dateTime.Format(format); //, CultureInfo.InvariantCulture);
    };
    DateTime.DateTimeToXSDate = function (date) {
        var format = 'YYYY-MM-DDZ'; //using moment format for c#->"yyyy-MM-dd";
        // switch (date.Kind) {
        // 	case DateTimeKind.Utc:
        // 		format = "yyyy-MM-ddZ";
        // 		break;
        // 	case DateTimeKind.Unspecified:
        // 		format = "yyyy-MM-dd";
        // 		break;
        // 	default: // DateTimeKind.Local is remaining
        // 		format = "yyyy-MM-ddzzz";
        // 		break;
        // }
        // Depending on the current culture, DateTime formatter will 
        // translate dates from one culture to another (e.g. Gregorian to Lunar).  The server
        // however, considers all dates to be in Gregorian, so using the InvariantCulture will
        // ensure this.
        return date.Format(format); //, CultureInfo.InvariantCulture);
    };
    Object.defineProperty(DateTime.prototype, "Date", {
        /* c# DateTime properties */
        get: function () {
            return new DateTime(this.momentDate.format("Y-MM-DD"));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTime.prototype, "Day", {
        get: function () {
            return this.momentDate.date();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTime.prototype, "DayOfWeek", {
        get: function () {
            return this.momentDate.day();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTime.prototype, "DayOfYear", {
        get: function () {
            return this.momentDate.dayOfYear();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTime.prototype, "Hour", {
        get: function () {
            return this.momentDate.hour();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTime.prototype, "Kind", {
        get: function () {
            return this.kind;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTime.prototype, "Millisecond", {
        get: function () {
            return this.momentDate.millisecond();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTime.prototype, "Minute", {
        get: function () {
            return this.momentDate.minute();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTime.prototype, "Month", {
        get: function () {
            return this.momentDate.month() + 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTime.prototype, "Second", {
        get: function () {
            return this.momentDate.second();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTime.prototype, "TimeOfDay", {
        //  public get Ticks(): {
        //      return this.
        //  }
        get: function () {
            return TimeSpan.FromMilliseconds(this.momentDate.millisecond());
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTime.prototype, "Today", {
        get: function () {
            return new DateTime(moment(this.momentDate.format("LL"), "LL"));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTime.prototype, "Year", {
        get: function () {
            return this.momentDate.year();
        },
        enumerable: true,
        configurable: true
    });
    /* c# DateTime Methods */
    //CompareTo
    DateTime.prototype.AddDays = function (days) {
        return this.Add(days, exports.unitOfTime.days);
    };
    DateTime.prototype.AddHours = function (hours) {
        return this.Add(hours, exports.unitOfTime.hours);
    };
    DateTime.prototype.AddMilliseconds = function (ms) {
        return this.Add(ms, exports.unitOfTime.ms);
    };
    DateTime.prototype.AddMinutes = function (minutes) {
        return this.Add(minutes, exports.unitOfTime.minutes);
    };
    DateTime.prototype.AddMonths = function (months) {
        return this.Add(months, exports.unitOfTime.months);
    };
    DateTime.prototype.AddSeconds = function (seconds) {
        return this.Add(seconds, exports.unitOfTime.seconds);
    };
    // public AddTicks(ticks: number): DateTime {
    //     return this.Add(ticks, unitOfTime.);
    // }
    DateTime.prototype.AddYears = function (years) {
        return this.Add(years, exports.unitOfTime.years);
    };
    DateTime.DaysInMonth = function (year, month) {
        if (month < 1 || month > 12)
            throw new ArgumentOutOfRangeException("month", invalidDateTimeMessage["months"]);
        // IsLeapYear checks the year argument
        var days = DateTime.IsLeapYear(year) ? DateTime.DaysToMonth366 : DateTime.DaysToMonth365;
        return days[month] - days[month - 1];
    };
    DateTime.prototype.Equals = function (value) {
        if (value instanceof DateTime) {
            return value.TotalMilliSeconds === this.TotalMilliSeconds;
        }
        return false;
    };
    DateTime.Equals = function (t1, t2) {
        return t1.TotalMilliSeconds === t2.TotalMilliSeconds;
    };
    // FromBinary
    // FromFileTime
    // FromFileTimeUtc
    // FromOADate
    // GetHashCode
    DateTime.prototype.IsDaylightSavingTime = function () {
        return this.momentDate.isDST();
    };
    /**
     *  Checks whether a given year is a leap year. This method returns true if year is a leap year, or false if not.
     * @param {number}  year
     */
    DateTime.IsLeapYear = function (year) {
        if (year < 1 || year > 9999) {
            throw new ArgumentOutOfRangeException("year", invalidDateTimeMessage["years"]);
        }
        return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
    };
    // ParseExact
    DateTime.SpecifyKind = function (value, kind) {
        return new DateTime(value.TotalMilliSeconds, kind);
    };
    DateTime.prototype.Subtract = function (dateTime) {
        if (dateTime instanceof DateTime) {
            return new TimeSpan(this.TotalMilliSeconds - dateTime.TotalMilliSeconds);
        }
        else {
            return new DateTime(this.TotalMilliSeconds - dateTime.TotalMilliseconds);
        }
    };
    // ToBinary
    // ToFileTime
    // ToFileTimeUtc
    DateTime.prototype.ToLocalTime = function () {
        return new DateTime(this.momentDate.local());
    };
    DateTime.prototype.ToLongDateString = function () {
        return this.momentDate.format("dddd, MMMM D, YYYY");
    };
    DateTime.prototype.ToLongTimeString = function () {
        return this.momentDate.format("LTS");
    };
    // ToOADate
    DateTime.prototype.ToShortDateString = function () {
        return this.MomentDate.format("l");
    };
    DateTime.prototype.ToShortTimeString = function () {
        return this.MomentDate.format("LT");
    };
    DateTime.prototype.ToString = function () {
        return this.toString();
    };
    DateTime.prototype.ToUniversalTime = function () {
        return new DateTime(this.MomentDate.utc());
    };
    DateTime.TryParse = function (s, outDate) {
        try {
            outDate.outValue = DateTime.Parse(s);
            outDate.outValue.kind = this.getKindfromMoment(outDate.outValue.momentDate);
            return true;
        }
        catch (error) {
            outDate.exception = error;
        }
        return false;
    };
    // TryParseExact
    DateTime.prototype.valueOf = function () {
        return this.TotalMilliSeconds;
    };
    DateTime.DaysToMonth365 = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
    DateTime.DaysToMonth366 = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];
    DateTime.MinValue = new DateTime('0001-01-01T00:00:00+00:00');
    DateTime.MaxValue = new DateTime("9999-12-31T23:59:59.9999999+00:00");
    return DateTime;
}());
exports.DateTime = DateTime;
//
// Summary:
//     Defines the formatting options that customize string parsing for some date and
//     time parsing methods.
var DateTimeStyles;
(function (DateTimeStyles) {
    //
    // Summary:
    //     Default formatting options must be used. This value represents the default style
    //     for the System.DateTime.Parse(System.String), System.DateTime.ParseExact(System.String,System.String,System.IFormatProvider),
    //     and System.DateTime.TryParse(System.String,System.DateTime@) methods.
    DateTimeStyles[DateTimeStyles["None"] = 0] = "None";
    //
    // Summary:
    //     Leading white-space characters must be ignored during parsing, except if they
    //     occur in the System.Globalization.DateTimeFormatInfo format patterns.
    DateTimeStyles[DateTimeStyles["AllowLeadingWhite"] = 1] = "AllowLeadingWhite";
    //
    // Summary:
    //     Trailing white-space characters must be ignored during parsing, except if they
    //     occur in the System.Globalization.DateTimeFormatInfo format patterns.
    DateTimeStyles[DateTimeStyles["AllowTrailingWhite"] = 2] = "AllowTrailingWhite";
    /**
     * Summary:
     *	    Extra white-space characters in the middle of the string must be ignored during
     *	    parsing, except if they occur in the System.Globalization.DateTimeFormatInfo
     *	    format patterns.
     */
    DateTimeStyles[DateTimeStyles["AllowInnerWhite"] = 4] = "AllowInnerWhite";
    /**
     * 	Summary:
     *	    Extra white-space characters anywhere in the string must be ignored during parsing,
     *	    except if they occur in the System.Globalization.DateTimeFormatInfo format patterns.
     *	    This value is a combination of the System.Globalization.DateTimeStyles.AllowLeadingWhite,
     *	    System.Globalization.DateTimeStyles.AllowTrailingWhite, and System.Globalization.DateTimeStyles.AllowInnerWhite
     *	    values.
     */
    DateTimeStyles[DateTimeStyles["AllowWhiteSpaces"] = 7] = "AllowWhiteSpaces";
    //
    // Summary:
    //     If the parsed string contains only the time and not the date, the parsing methods
    //     assume the Gregorian date with year = 1, month = 1, and day = 1. If this value
    //     is not used, the current date is assumed.
    DateTimeStyles[DateTimeStyles["NoCurrentDateDefault"] = 8] = "NoCurrentDateDefault";
    //
    // Summary:
    //     Date and time are returned as a Coordinated Universal Time (UTC). If the input
    //     string denotes a local time, through a time zone specifier or System.Globalization.DateTimeStyles.AssumeLocal,
    //     the date and time are converted from the local time to UTC. If the input string
    //     denotes a UTC time, through a time zone specifier or System.Globalization.DateTimeStyles.AssumeUniversal,
    //     no conversion occurs. If the input string does not denote a local or UTC time,
    //     no conversion occurs and the resulting System.DateTime.Kind property is System.DateTimeKind.Unspecified.
    DateTimeStyles[DateTimeStyles["AdjustToUniversal"] = 16] = "AdjustToUniversal";
    //
    // Summary:
    //     If no time zone is specified in the parsed string, the string is assumed to denote
    //     a local time.
    DateTimeStyles[DateTimeStyles["AssumeLocal"] = 32] = "AssumeLocal";
    //
    // Summary:
    //     If no time zone is specified in the parsed string, the string is assumed to denote
    //     a UTC.
    DateTimeStyles[DateTimeStyles["AssumeUniversal"] = 64] = "AssumeUniversal";
    //
    // Summary:
    //     The System.DateTimeKind field of a date is preserved when a System.DateTime object
    //     is converted to a string using the "o" or "r" standard format specifier, and
    //     the string is then converted back to a System.DateTime object.
    DateTimeStyles[DateTimeStyles["RoundtripKind"] = 128] = "RoundtripKind";
})(DateTimeStyles = exports.DateTimeStyles || (exports.DateTimeStyles = {}));
exports.unitOfTime = {
    "year": "year",
    "years": "years",
    "y": "y",
    "month": "month",
    "months": "months",
    "M": "M",
    "week": "week",
    "weeks": "weeks",
    "w": "w",
    "day": "day",
    "days": "days",
    "d": "d",
    "hour": "hour",
    "hours": "hours",
    "h": "h",
    "minute": "minute",
    "minutes": "minutes",
    "m": "m",
    "second": "second",
    "seconds": "seconds",
    "s": "s",
    "millisecond": "millisecond",
    "milliseconds": "milliseconds",
    "ms": "ms",
};
var momentValidity;
(function (momentValidity) {
    momentValidity[momentValidity["years"] = 0] = "years";
    momentValidity[momentValidity["months"] = 1] = "months";
    momentValidity[momentValidity["days"] = 2] = "days";
    momentValidity[momentValidity["hours"] = 3] = "hours";
    momentValidity[momentValidity["minutes"] = 4] = "minutes";
    momentValidity[momentValidity["seconds"] = 5] = "seconds";
    momentValidity[momentValidity["milliseconds"] = 6] = "milliseconds";
})(momentValidity || (momentValidity = {}));
/// <reference path="../../typings/base64-js.d.ts" />
var StringHelper;
(function (StringHelper) {
    function IsNullOrEmpty(str) {
        return str == null || typeof str === 'undefined' || str === '';
    }
    StringHelper.IsNullOrEmpty = IsNullOrEmpty;
    /*
    * @author electricessence / https://github.com/electricessence/
    * Liscensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE
      part System.Text at above library
    */
    function Format(source) {
        var args = [];
        for (var _a = 1; _a < arguments.length; _a++) {
            args[_a - 1] = arguments[_a];
        }
        for (var i = 0; i < args.length; i++)
            source = source.replace("{" + i + "}", args[i]);
        return source;
    }
    StringHelper.Format = Format;
    StringHelper.Empty = "";
    function Repeat(str, times) {
        if (str === void 0) { str = ""; }
        if (times === void 0) { times = 1; }
        return new Array(times + 1).join(str);
    }
    StringHelper.Repeat = Repeat;
    function Tabs(times) {
        if (times === void 0) { times = 0; }
        return Repeat("\t", times);
    }
    StringHelper.Tabs = Tabs;
    function Compare(lhs, rhs, ignoreCase) {
        if (ignoreCase === void 0) { ignoreCase = false; }
        if (ignoreCase) {
            return lhs.toLocaleLowerCase().localeCompare(rhs.toLocaleLowerCase());
        }
        else {
            return lhs.localeCompare(rhs);
        }
    }
    StringHelper.Compare = Compare;
})(StringHelper = exports.StringHelper || (exports.StringHelper = {}));
var EnumHelper;
(function (EnumHelper) {
    function HasFlag(flags, checkFlag) {
        return (flags & checkFlag) == checkFlag;
    }
    EnumHelper.HasFlag = HasFlag;
    /**
     * Writes "," separated values from Enumertion anf enum Flags
     *
     * @export
     * @param {*} enumObj The Enumeration Object itself, for example 'ExchangeVersion' as the parameter Value.
     * @param {number} checkFlag Flag value(s) to convert to string
     * @param {boolean} [includeZero=false] include the default 0 value in the string, usually false
     * @returns {string} returns the coma "," separated string representation of Flags
     */
    function ToString(enumObj, checkFlag, includeZero) {
        if (includeZero === void 0) { includeZero = false; }
        if ((checkFlag & (checkFlag - 1)) == 0)
            return enumObj[checkFlag];
        var result = [];
        var diff = checkFlag;
        var largestFlag = 0; // = Math.pow(2, Math.floor(Math.pow(checkFlag, (1 / 2))));
        while (diff > 1) {
            largestFlag = Math.pow(2, Math.floor(Math.log(diff) / Math.log(2)));
            diff = diff - largestFlag;
            var largestValue = enumObj[largestFlag];
            if (largestValue === undefined)
                return undefined;
            result.push(largestValue);
        }
        if (diff == 1)
            result.push(enumObj[1]);
        if (includeZero && enumObj[0])
            result.push(enumObj[0]);
        result.reverse();
        return result.join(", ");
    }
    EnumHelper.ToString = ToString;
})(EnumHelper = exports.EnumHelper || (exports.EnumHelper = {}));
var object;
(function (object) {
    function getPrototypeChain(ctor) {
        //unused
        //http://typescript.codeplex.com/discussions/468576
        var chain = [];
        var proto = ctor.prototype;
        while (proto) {
            chain.push(proto.constructor);
            proto = Object.getPrototypeOf(proto);
        }
        return chain;
        //var ste = JSON.stringify(ste);
    }
})(object || (object = {}));
var ArrayHelper;
(function (ArrayHelper) {
    function AddRange(array, items, uniqueOnly) {
        if (uniqueOnly === void 0) { uniqueOnly = false; }
        if (Object.prototype.toString.call(array) !== "[object Array]")
            throw new Error("input obj is not an array");
        if (Object.prototype.toString.call(items) !== "[object Array]")
            throw new Error("input range is not an array");
        for (var _a = 0, items_1 = items; _a < items_1.length; _a++) {
            var item = items_1[_a];
            if (!(uniqueOnly && array.indexOf(item) >= 0)) {
                array.push(item);
            }
        }
    }
    ArrayHelper.AddRange = AddRange;
    function RemoveEntry(array, entry, comparer) {
        if (comparer === void 0) { comparer = null; }
        var index = array.indexOf(entry);
        if (comparer) {
            var entry_1 = ArrayHelper.Find(array, comparer);
            index = array.indexOf(entry_1);
        }
        var lastLength = array.length;
        if (index >= 0) {
            array.splice(index, 1);
            return lastLength - array.length === 1;
        }
        else {
            return false;
        }
    }
    ArrayHelper.RemoveEntry = RemoveEntry;
    function Find(array, comparer) {
        for (var _a = 0, array_1 = array; _a < array_1.length; _a++) {
            var entry = array_1[_a];
            if (comparer(entry)) {
                return entry;
            }
        }
        return null;
    }
    ArrayHelper.Find = Find;
    function IndexOf(array, comparer) {
        var item = ArrayHelper.Find(array, comparer);
        return array.indexOf(item);
    }
    ArrayHelper.IndexOf = IndexOf;
    function OfType(array, comparer) {
        var result = [];
        for (var _a = 0, array_2 = array; _a < array_2.length; _a++) {
            var entry = array_2[_a];
            if (comparer(entry)) {
                result.push(entry);
            }
        }
        return result;
    }
    ArrayHelper.OfType = OfType;
    /**dirty calculation of max dimension, will return more than one if array contains any array element in first testElementCount items */
    function Rank(array, testElementCount) {
        if (testElementCount === void 0) { testElementCount = 4; }
        var rank = 1;
        if (array.length === 0) {
            return rank;
        }
        var length = array.length <= testElementCount ? array.length : testElementCount;
        var maxDepthRank = 0;
        for (var index = 0; index < length; index++) {
            var element = array[index];
            if (Array.isArray(element)) {
                var _tRank = Rank(element, testElementCount);
                maxDepthRank = _tRank > maxDepthRank ? _tRank : maxDepthRank;
            }
        }
        rank += maxDepthRank;
        return rank;
    }
    ArrayHelper.Rank = Rank;
    function isArray(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
    }
    ArrayHelper.isArray = isArray;
})(ArrayHelper = exports.ArrayHelper || (exports.ArrayHelper = {}));
var TypeSystem = (function () {
    function TypeSystem() {
    }
    TypeSystem.GetProperties = function (obj) {
        var props = new Array();
        for (var s in obj) {
            if (typeof (obj[s]) != "function") {
                props[props.length] = s;
            }
        }
        return props;
    };
    TypeSystem.GetMethods = function (obj) {
        var methods = new Array();
        for (var s in obj) {
            if (typeof (obj[s]) == "function") {
                methods[methods.length] = s;
            }
        }
        return methods;
    };
    TypeSystem.GetObjectStaticPropertiesByClassName = function (className) {
        var obj = this.GetObjectByClassName(className);
        //if (prototype)
        //    obj = obj.prototype;
        if (obj == null || typeof (obj) == undefined)
            return []; //throw new Error("can not determine type");
        return this.GetProperties(obj);
    };
    TypeSystem.GetObjectMethodsByClassName = function (className, instanceMethod) {
        if (instanceMethod === void 0) { instanceMethod = true; }
        var obj = this.GetObjectByClassName(className);
        if (obj == null || typeof (obj) == undefined)
            return []; // throw new Error("can not determine type");
        else if (instanceMethod)
            obj = obj.prototype || obj;
        return this.GetMethods(obj);
    };
    TypeSystem.GetObjectByClassName = function (className) {
        var obj;
        if (className.indexOf(".") > 0) {
            var objs = className.split(".");
            obj = window[objs[0]];
            for (var i = 1; i < objs.length; i++) {
                obj = obj[objs[i]];
            }
        }
        else
            obj = window[className];
        //if (prototype)
        //    obj = obj.prototype;
        return obj;
    };
    TypeSystem.GetJsObjectTypeName = function (obj) {
        var keys = Object.keys(obj);
        if (keys && keys.indexOf("__type") >= 0)
            return obj["__type"];
        return undefined;
    };
    TypeSystem.GetJsObjectOnlyChildName = function (obj) {
        for (var key in obj) {
            if (key.indexOf("__") >= 0)
                continue;
            return key;
        }
        return null;
    };
    TypeSystem.GetJsObjectTypeName_old = function (obj) {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                var element = obj[key];
                if (element["__type"])
                    return element["__type"];
            }
        }
        return undefined;
    };
    TypeSystem.IsGenericType = function (value) {
        if (value === null || typeof value === 'undefined') {
            return false;
        }
        var valueType = typeof value;
        return valueType === 'string' || valueType === 'boolean' || valueType === 'number';
    };
    return TypeSystem;
}());
exports.TypeSystem = TypeSystem;
//use this class to to work with node - https://github.com/jindw/xmldom - tested working with commit f053be7ceb. 
//This library creates DOMParser object like functionality in node.For browsers, skip xmldom library and use inbuilt browser object
//var DOMParser = require('xmldom').DOMParser;
//var dom = new DOMParser().parseFromString("xml data", 'text/xml');
//ewslogging.log(JSON.stringify(xmlToJson(dom.documentElement)));
var xml2JsObject = (function () {
    function xml2JsObject() {
        this.typeIncludedNS = [
            "http://schemas.microsoft.com/exchange/services/2006/types",
            "http://schemas.microsoft.com/exchange/services/2006/messages"
        ];
    }
    xml2JsObject.prototype.parseXMLNode = function (xmlNode, soapMode, xmlnsRoot) {
        if (soapMode === void 0) { soapMode = false; }
        if (xmlnsRoot === void 0) { xmlnsRoot = undefined; }
        var obj = {};
        if (!xmlnsRoot)
            xmlnsRoot = obj;
        if (typeof (xmlNode) === 'undefined')
            return obj;
        var textNodeName = undefined;
        var PREFIX_STR = "__prefix";
        var TYPE_STR = "__type";
        var TEXT_STR = "__text";
        switch (xmlNode.nodeType) {
            case 1 /*Node.ELEMENT_NODE*/:
                if (xmlNode.prefix && xmlNode.localName !== xmlNode.nodeName)
                    obj[PREFIX_STR] = xmlNode.prefix;
                if (this.typeIncludedNS.indexOf(xmlNode.namespaceURI) >= 0) {
                    obj[TYPE_STR] = xmlNode.localName;
                }
                var nonGenericAttributeCount = 0;
                for (var i = 0; i < xmlNode.attributes.length; i++) {
                    nonGenericAttributeCount++;
                    var attr = xmlNode.attributes.item(i);
                    if (attr.prefix)
                        if (attr.prefix === 'xmlns') {
                            this.addXMLNS(xmlnsRoot, attr.localName, attr.value);
                            nonGenericAttributeCount--;
                        }
                        else if (this.containsXMLNS(xmlnsRoot, attr.prefix))
                            obj[attr.localName] = attr.value;
                        else
                            obj[attr.name] = attr.value;
                    else if (attr.localName === 'xmlns') {
                        if (xmlNode.namespaceURI !== attr.value && typeof obj[TYPE_STR] === 'undefiend') {
                            obj[TYPE_STR] = attr.value;
                        }
                        nonGenericAttributeCount--;
                    }
                    else
                        obj[attr.localName] = attr.value;
                }
                if (soapMode) {
                    if (nonGenericAttributeCount === 0 && xmlNode.childNodes.length === 0)
                        return null;
                    if (xmlNode.childNodes.length === 1 && xmlNode.firstChild.nodeType === 3 /*Node.TEXT_NODE*/) {
                        if (xmlNode.firstChild.nodeValue.trim() !== '') {
                            if (nonGenericAttributeCount === 0) {
                                return xmlNode.firstChild.nodeValue.trim();
                            }
                            else {
                                obj[xmlNode.localName] = xmlNode.firstChild.nodeValue.trim();
                                return obj;
                            }
                        }
                    }
                    if (soapMode && obj["nil"] && obj["nil"] === 'true') {
                        return null;
                    }
                }
                break;
            case 2 /*Node.ATTRIBUTE_NODE*/:
                break;
            case 3 /*Node.TEXT_NODE*/:
                return xmlNode.nodeValue;
                break;
            default:
                return obj;
        }
        if (xmlNode.childNodes.length > 0) {
            var skip = false;
            if (soapMode && xmlNode.childNodes.length === 1 && xmlNode.firstChild.nodeType === 3 /*Node.TEXT_NODE*/)
                skip = true;
            if (!skip) {
                for (var i = 0; i < xmlNode.childNodes.length; i++) {
                    var node = xmlNode.childNodes.item(i);
                    var localName = node.localName || TEXT_STR;
                    if (localName === TEXT_STR && node.nodeValue.trim() === "")
                        continue;
                    var nodeObj = this.parseXMLNode(node, soapMode, xmlnsRoot);
                    if (obj[localName])
                        if (Object.prototype.toString.call(obj[localName]) === "[object Array]")
                            obj[localName].push(nodeObj);
                        else {
                            var old = obj[localName];
                            obj[localName] = [];
                            obj[localName].push(old);
                            obj[localName].push(nodeObj);
                        }
                    else
                        obj[localName] = nodeObj;
                }
            }
        }
        return obj;
    };
    xml2JsObject.prototype.addXMLNS = function (xmlnsObj, xmlnsName, xmlnsValue, xmlnsAttrName) {
        if (xmlnsAttrName === void 0) { xmlnsAttrName = "__xmlns"; }
        if (!xmlnsObj[xmlnsAttrName])
            xmlnsObj[xmlnsAttrName] = {};
        (xmlnsObj[xmlnsAttrName])[xmlnsName] = xmlnsValue;
    };
    xml2JsObject.prototype.containsXMLNS = function (obj, xmlnsName, xmlnsAttrName) {
        if (xmlnsAttrName === void 0) { xmlnsAttrName = "__xmlns"; }
        if (obj[xmlnsAttrName])
            return typeof ((obj[xmlnsAttrName])[xmlnsName]) !== 'undefined';
        return false;
    };
    return xml2JsObject;
}());
exports.xml2JsObject = xml2JsObject;
var UriHelper = (function () {
    function UriHelper() {
    }
    //RFC Appendix B - http://www.ietf.org/rfc/rfc3986.txt 
    /*    Appendix B.  Parsing a URI Reference with a Regular Expression
    
       As the "first-match-wins" algorithm is identical to the "greedy"
       disambiguation method used by POSIX regular expressions, it is
       natural and commonplace to use a regular expression for parsing the
       potential five components of a URI reference.
    
       The following line is the regular expression for breaking-down a
       well-formed URI reference into its components.
    
    
    
    Berners-Lee, et al.         Standards Track                    [Page 50]
     
    RFC 3986                   URI Generic Syntax               January 2005
    
    
          ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
           12            3  4          5       6  7        8 9
    
       The numbers in the second line above are only to assist readability;
       they indicate the reference points for each subexpression (i.e., each
       paired parenthesis).  We refer to the value matched for subexpression
       <n> as $<n>.  For example, matching the above expression to
    
          http://www.ics.uci.edu/pub/ietf/uri/#Related
    
       results in the following subexpression matches:
    
          $1 = http:
          $2 = http
          $3 = //www.ics.uci.edu
          $4 = www.ics.uci.edu
          $5 = /pub/ietf/uri/
          $6 = <undefined>
          $7 = <undefined>
          $8 = #Related
          $9 = Related
    
       where <undefined> indicates that the component is not present, as is
       the case for the query component in the above example.  Therefore, we
       can determine the value of the five components as
    
          scheme    = $2
          authority = $4
          path      = $5
          query     = $7
          fragment  = $9
    
       Going in the opposite direction, we can recreate a URI reference from
       its components by using the algorithm of Section 5.3.
    */
    UriHelper.parseString = function (url) {
        var regex = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
        var parts = url.match(regex);
        return {
            scheme: parts[2],
            authority: parts[4],
            path: parts[5],
            query: parts[7],
            fragment: parts[9]
        };
    };
    UriHelper.getDomain = function (url) {
        return this.parseString(url).authority;
    };
    UriHelper.getHost = function (url) {
        return this.getDomain(url);
    };
    return UriHelper;
}());
exports.UriHelper = UriHelper;
var isNode = (typeof window === 'undefined');
var dp = undefined;
// if (isNode) {
//     var dr: any = require('xmldom');
//     dp = dr.DOMParser;
// } else {
dp = window.DOMParser;
// }
exports.DOMParser = dp;
var Convert = (function () {
    function Convert() {
    }
    Convert.toInt = function (value, zeroIfError) {
        if (zeroIfError === void 0) { zeroIfError = true; }
        var result = 0;
        try {
            result = parseInt(value);
        }
        catch (ex) {
            if (!zeroIfError)
                throw ex;
        }
        return result;
    };
    Convert.toNumber = function (value) {
        return Number(value);
    };
    Convert.toBool = function (value, truefalseString, throwIfNotBool) {
        if (truefalseString === void 0) { truefalseString = true; }
        if (throwIfNotBool === void 0) { throwIfNotBool = false; }
        if (typeof value === 'boolean')
            return value;
        var num = Number(value);
        if (!isNaN(num)) {
            return num !== 0;
        }
        if (truefalseString) {
            return value.toLowerCase() === 'true';
        }
        if (throwIfNotBool)
            throw new Error("not a boolean");
        return false;
    };
    // static FromBase64String(encodedStr: string): string {
    //     return base64Helper.atob(encodedStr);
    // }
    // static ToBase64String(str: string): string {
    //     return base64Helper.btoa(str);
    // }
    Convert.FromBase64String = function (encodedStr) {
        return b64.toByteArray(encodedStr);
    };
    Convert.ToBase64String = function (byteArray) {
        return b64.fromByteArray(byteArray);
    };
    return Convert;
}());
exports.Convert = Convert;
var base64Helper;
(function (base64Helper) {
    function btoa(textToEncode) {
        if (isNode) {
            var b = new Buffer(textToEncode);
            return b.toString('base64');
        }
        else {
            return window.btoa(textToEncode);
        }
    }
    base64Helper.btoa = btoa;
    function atob(textToDecode) {
        if (isNode) {
            var b = new Buffer(textToDecode, 'base64');
            return b.toString();
        }
        else {
            return window.atob(textToDecode);
        }
    }
    base64Helper.atob = atob;
})(base64Helper = exports.base64Helper || (exports.base64Helper = {}));
/** Guid proxy class */
var Guid = (function () {
    function Guid(str) {
        this.guid = '00000000-0000-0000-0000-000000000000';
        var regx = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        if (arguments.length > 0) {
            if (StringHelper.IsNullOrEmpty(str) || str === null) {
                throw new TypeError("Guid.ctor - invalid input");
            }
            //str = str.replace("-", "").replace("{", "").replace("}", "").toLowerCase();
            str = str.replace("{", "").replace("}", "").toLowerCase();
            if (regx.test(str)) {
                this.guid = str;
            }
            else {
                throw new TypeError("Guid.ctor - invalid input");
            }
        }
    }
    Guid.prototype.ToString = function () {
        return this.guid;
    };
    Guid.prototype.toString = function () {
        return this.guid;
    };
    Guid.NewGuid = function () {
        return new Guid(uuid.v4());
    };
    Guid.Parse = function (str) {
        return new Guid(str);
    };
    Guid.TryParse = function (str, _parsed_output) {
        if (_parsed_output === void 0) { _parsed_output = { guid: null }; }
        try {
            _parsed_output.guid = new Guid(str);
            return true;
        }
        catch (error) {
            return false;
        }
    };
    Guid.Empty = new Guid();
    return Guid;
}());
exports.Guid = Guid;
exports.Promise = window.Promise;
// class PromiseType<T> {
//     constructor() {
//         throw new NotSupportedException("Promise implementation missing.\nPlease use ConfigurePromise function to assign Promise Object\n" +
//             "bluebird: ConfigurePromise(require('bluebird))\n" +
//             "Q: ConfigurePromise(require('q').Promise)\n" +
//             "winjs-node: ConfigurePromise(require('winjs-node').Promise)")
//     }
// }
// try {
//     var promise = require('bluebird');
//     Promise = promise;
// } catch (e) {
//     Promise = <any>PromiseType;
// }
function ConfigurePromise(promise) {
    exports.Promise = promise;
}
exports.ConfigurePromise = ConfigurePromise;
var Strings = (function () {
    function Strings() {
    }
    Strings.CannotRemoveSubscriptionFromLiveConnection = "Subscriptions can't be removed from an open connection.";
    Strings.ReadAccessInvalidForNonCalendarFolder = "The Permission read access value {0} can't be used with a non-calendar folder.";
    Strings.PropertyDefinitionPropertyMustBeSet = "The PropertyDefinition property must be set.";
    Strings.ArgumentIsBlankString = "The argument contains only white space characters.";
    Strings.InvalidAutodiscoverDomainsCount = "At least one domain name must be requested.";
    Strings.MinutesMustBeBetween0And1439 = "minutes must be between 0 and 1439, inclusive.";
    Strings.DeleteInvalidForUnsavedUserConfiguration = "This user configuration object can't be deleted because it's never been saved.";
    Strings.PeriodNotFound = "Invalid transition. A period with the specified Id couldn't be found: {0}";
    Strings.InvalidAutodiscoverSmtpAddress = "A valid SMTP address must be specified.";
    Strings.InvalidOAuthToken = "The given token is invalid.";
    Strings.MaxScpHopsExceeded = "The number of SCP URL hops exceeded the limit.";
    Strings.ContactGroupMemberCannotBeUpdatedWithoutBeingLoadedFirst = "The contact group's Members property must be reloaded before newly-added members can be updated.";
    Strings.CurrentPositionNotElementStart = "The current position is not the start of an element.";
    Strings.CannotConvertBetweenTimeZones = "Unable to convert {0} from {1} to {2}.";
    Strings.FrequencyMustBeBetween1And1440 = "The frequency must be a value between 1 and 1440.";
    Strings.CannotSetDelegateFolderPermissionLevelToCustom = "This operation can't be performed because one or more folder permission levels were set to Custom.";
    Strings.PartnerTokenIncompatibleWithRequestVersion = "TryGetPartnerAccess only supports {0} or a later version in Microsoft-hosted data center.";
    Strings.InvalidAutodiscoverRequest = "Invalid Autodiscover request: '{0}'";
    Strings.InvalidAsyncResult = "The IAsyncResult object was not returned from the corresponding asynchronous method of the original ExchangeService object.";
    Strings.InvalidMailboxType = "The mailbox type isn't valid.";
    Strings.AttachmentCollectionNotLoaded = "The attachment collection must be loaded.";
    Strings.ParameterIncompatibleWithRequestVersion = "The parameter {0} is only valid for Exchange Server version {1} or a later version.";
    Strings.DayOfWeekIndexMustBeSpecifiedForRecurrencePattern = "The recurrence pattern's DayOfWeekIndex property must be specified.";
    Strings.WLIDCredentialsCannotBeUsedWithLegacyAutodiscover = "This type of credentials can't be used with this AutodiscoverService.";
    Strings.PropertyCannotBeUpdated = "This property can't be updated.";
    Strings.IncompatibleTypeForArray = "Type {0} can't be used as an array of type {1}.";
    Strings.PercentCompleteMustBeBetween0And100 = "PercentComplete must be between 0 and 100.";
    Strings.AutodiscoverServiceIncompatibleWithRequestVersion = "The Autodiscover service only supports {0} or a later version.";
    Strings.InvalidAutodiscoverSmtpAddressesCount = "At least one SMTP address must be requested.";
    Strings.ServiceUrlMustBeSet = "The Url property on the ExchangeService object must be set.";
    Strings.ItemTypeNotCompatible = "The item type returned by the service ({0}) isn't compatible with the requested item type ({1}).";
    Strings.AttachmentItemTypeMismatch = "Can not update this attachment item since the item in the response has a different type.";
    Strings.UnsupportedWebProtocol = "Protocol {0} isn't supported for service requests.";
    Strings.EnumValueIncompatibleWithRequestVersion = "Enumeration value {0} in enumeration type {1} is only valid for Exchange version {2} or later.";
    Strings.UnexpectedElement = "An element node '{0}:{1}' of the type {2} was expected, but node '{3}' of type {4} was found.";
    Strings.InvalidOrderBy = "At least one of the property definitions in the OrderBy clause is null.";
    Strings.NoAppropriateConstructorForItemClass = "No appropriate constructor could be found for this item class.";
    Strings.SearchFilterAtIndexIsInvalid = "The search filter at index {0} is invalid.";
    Strings.DeletingThisObjectTypeNotAuthorized = "Deleting this type of object isn't authorized.";
    Strings.PropertyCannotBeDeleted = "This property can't be deleted.";
    Strings.ValuePropertyMustBeSet = "The Value property must be set.";
    Strings.TagValueIsOutOfRange = "The extended property tag value must be in the range of 0 to 65,535.";
    Strings.ItemToUpdateCannotBeNullOrNew = "Items[{0}] is either null or does not have an Id.";
    Strings.SearchParametersRootFolderIdsEmpty = "SearchParameters must contain at least one folder id.";
    Strings.MailboxQueriesParameterIsNotSpecified = "The collection of query and mailboxes parameter is not specified.";
    Strings.FolderPermissionHasInvalidUserId = "The UserId in the folder permission at index {0} is invalid. The StandardUser, PrimarySmtpAddress, or SID property must be set.";
    Strings.InvalidAutodiscoverDomain = "The domain name must be specified.";
    Strings.MailboxesParameterIsNotSpecified = "The array of mailboxes (in legacy DN) is not specified.";
    Strings.ParentFolderDoesNotHaveId = "parentFolder doesn't have an Id.";
    Strings.DayOfMonthMustBeSpecifiedForRecurrencePattern = "The recurrence pattern's DayOfMonth property must be specified.";
    Strings.ClassIncompatibleWithRequestVersion = "Class {0} is only valid for Exchange version {1} or later.";
    Strings.CertificateHasNoPrivateKey = "The given certificate does not have the private key. The private key is necessary to sign part of the request message.";
    Strings.InvalidOrUnsupportedTimeZoneDefinition = "The time zone definition is invalid or unsupported.";
    Strings.HourMustBeBetween0And23 = "Hour must be between 0 and 23.";
    Strings.TimeoutMustBeBetween1And1440 = "Timeout must be a value between 1 and 1440.";
    Strings.CredentialsRequired = "Credentials are required to make a service request.";
    Strings.MustLoadOrAssignPropertyBeforeAccess = "You must load or assign this property before you can read its value.";
    Strings.InvalidAutodiscoverServiceResponse = "The Autodiscover service response was invalid.";
    Strings.CannotCallConnectDuringLiveConnection = "The connection has already opened.";
    Strings.ObjectDoesNotHaveId = "This service object doesn't have an ID.";
    Strings.CannotAddSubscriptionToLiveConnection = "Subscriptions can't be added to an open connection.";
    Strings.MaxChangesMustBeBetween1And512 = "MaxChangesReturned must be between 1 and 512.";
    Strings.AttributeValueCannotBeSerialized = "Values of type '{0}' can't be used for the '{1}' attribute.";
    Strings.NumberOfDaysMustBePositive = "NumberOfDays must be zero or greater. Zero indicates no limit.";
    Strings.SearchFilterMustBeSet = "The SearchFilter property must be set.";
    Strings.EndDateMustBeGreaterThanStartDate = "EndDate must be greater than StartDate.";
    Strings.InvalidDateTime = "Invalid date and time: {0}.";
    Strings.UpdateItemsDoesNotAllowAttachments = "This operation can't be performed because attachments have been added or deleted for one or more items.";
    Strings.TimeoutMustBeGreaterThanZero = "Timeout must be greater than zero.";
    Strings.AutodiscoverInvalidSettingForOutlookProvider = "The requested setting, '{0}', isn't supported by this Autodiscover endpoint.";
    Strings.InvalidRedirectionResponseReturned = "The service returned an invalid redirection response.";
    Strings.ExpectedStartElement = "The start element was expected, but node '{0}' of type {1} was found.";
    Strings.DaysOfTheWeekNotSpecified = "The recurrence pattern's property DaysOfTheWeek must contain at least one day of the week.";
    Strings.FolderToUpdateCannotBeNullOrNew = "Folders[{0}] is either null or does not have an Id.";
    Strings.PartnerTokenRequestRequiresUrl = "TryGetPartnerAccess request requires the Url be set with the partner's autodiscover url first.";
    Strings.NumberOfOccurrencesMustBeGreaterThanZero = "NumberOfOccurrences must be greater than 0.";
    Strings.StartTimeZoneRequired = "StartTimeZone required when setting the Start, End, IsAllDayEvent, or Recurrence properties.  You must load or assign this property before attempting to update the appointment.";
    Strings.PropertyAlreadyExistsInOrderByCollection = "Property {0} already exists in OrderByCollection.";
    Strings.ItemAttachmentMustBeNamed = "The name of the item attachment at index {0} must be set.";
    Strings.InvalidAutodiscoverSettingsCount = "At least one setting must be requested.";
    Strings.LoadingThisObjectTypeNotSupported = "Loading this type of object is not supported.";
    Strings.UserIdForDelegateUserNotSpecified = "The UserId in the DelegateUser hasn't been specified.";
    Strings.PhoneCallAlreadyDisconnected = "The phone call has already been disconnected.";
    Strings.OperationDoesNotSupportAttachments = "This operation isn't supported on attachments.";
    Strings.UnsupportedTimeZonePeriodTransitionTarget = "The time zone transition target isn't supported.";
    Strings.IEnumerableDoesNotContainThatManyObject = "The IEnumerable doesn't contain that many objects.";
    Strings.UpdateItemsDoesNotSupportNewOrUnchangedItems = "This operation can't be performed because one or more items are new or unmodified.";
    Strings.ValidationFailed = "Validation failed.";
    Strings.InvalidRecurrencePattern = "Invalid recurrence pattern: ({0}).";
    Strings.TimeWindowStartTimeMustBeGreaterThanEndTime = "The time window's end time must be greater than its start time.";
    Strings.InvalidAttributeValue = "The invalid value '{0}' was specified for the '{1}' attribute.";
    Strings.FileAttachmentContentIsNotSet = "The content of the file attachment at index {0} must be set.";
    Strings.AutodiscoverDidNotReturnEwsUrl = "The Autodiscover service didn't return an appropriate URL that can be used for the ExchangeService Autodiscover URL.";
    Strings.RecurrencePatternMustHaveStartDate = "The recurrence pattern's StartDate property must be specified.";
    Strings.OccurrenceIndexMustBeGreaterThanZero = "OccurrenceIndex must be greater than 0.";
    Strings.ServiceResponseDoesNotContainXml = "The response received from the service didn't contain valid XML.";
    Strings.ItemIsOutOfDate = "The operation can't be performed because the item is out of date. Reload the item and try again.";
    Strings.MinuteMustBeBetween0And59 = "Minute must be between 0 and 59.";
    Strings.NoSoapOrWsSecurityEndpointAvailable = "No appropriate Autodiscover SOAP or WS-Security endpoint is available.";
    Strings.ElementNotFound = "The element '{0}' in namespace '{1}' wasn't found at the current position.";
    Strings.IndexIsOutOfRange = "index is out of range.";
    Strings.PropertyIsReadOnly = "This property is read-only and can't be set.";
    Strings.AttachmentCreationFailed = "At least one attachment couldn't be created.";
    Strings.DayOfMonthMustBeBetween1And31 = "DayOfMonth must be between 1 and 31.";
    Strings.ServiceRequestFailed = "The request failed. {0}";
    Strings.DelegateUserHasInvalidUserId = "The UserId in the DelegateUser is invalid. The StandardUser, PrimarySmtpAddress or SID property must be set.";
    Strings.SearchFilterComparisonValueTypeIsNotSupported = "Values of type '{0}' can't be used as comparison values in search filters.";
    Strings.ElementValueCannotBeSerialized = "Values of type '{0}' can't be used for the '{1}' element.";
    Strings.PropertyValueMustBeSpecifiedForRecurrencePattern = "The recurrence pattern's {0} property must be specified.";
    Strings.NonSummaryPropertyCannotBeUsed = "The property {0} can't be used in {1} requests.";
    Strings.HoldIdParameterIsNotSpecified = "The hold id parameter is not specified.";
    Strings.TransitionGroupNotFound = "Invalid transition. A transition group with the specified ID couldn't be found: {0}";
    Strings.ObjectTypeNotSupported = "Objects of type {0} can't be added to the dictionary. The following types are supported: array, byte array, boolean, byte, DateTime, integer, long,, unsigned integer, and unsigned long.";
    Strings.InvalidTimeoutValue = "{0} is not a valid timeout value. Valid values range from 1 to 1440.";
    Strings.AutodiscoverRedirectBlocked = "Autodiscover blocked a potentially insecure redirection to {0}. To allow Autodiscover to follow the redirection, use the AutodiscoverUrl(string, AutodiscoverRedirectionUrlValidationCallback) overload.";
    Strings.PropertySetCannotBeModified = "This PropertySet is read-only and can't be modified.";
    Strings.DayOfTheWeekMustBeSpecifiedForRecurrencePattern = "The recurrence pattern's property DayOfTheWeek must be specified.";
    Strings.ServiceObjectAlreadyHasId = "This operation can't be performed because this service object already has an ID. To update this service object, use the Update() method instead.";
    Strings.MethodIncompatibleWithRequestVersion = "Method {0} is only valid for Exchange Server version {1} or later.";
    Strings.OperationNotSupportedForPropertyDefinitionType = "This operation isn't supported for property definition type {0}.";
    Strings.InvalidElementStringValue = "The invalid value '{0}' was specified for the '{1}' element.";
    Strings.CollectionIsEmpty = "The collection is empty.";
    Strings.InvalidFrequencyValue = "{0} is not a valid frequency value. Valid values range from 1 to 1440.";
    Strings.UnexpectedEndOfXmlDocument = "The XML document ended unexpectedly.";
    Strings.FolderTypeNotCompatible = "The folder type returned by the service ({0}) isn't compatible with the requested folder type ({1}).";
    Strings.RequestIncompatibleWithRequestVersion = "The service request {0} is only valid for Exchange version {1} or later.";
    Strings.PropertyTypeIncompatibleWhenUpdatingCollection = "Can not update the existing collection item since the item in the response has a different type.";
    Strings.ServerVersionNotSupported = "Exchange Server doesn't support the requested version.";
    Strings.DurationMustBeSpecifiedWhenScheduled = "Duration must be specified when State is equal to Scheduled.";
    Strings.NoError = "No error.";
    Strings.CannotUpdateNewUserConfiguration = "This user configuration can't be updated because it's never been saved.";
    Strings.ObjectTypeIncompatibleWithRequestVersion = "The object type {0} is only valid for Exchange Server version {1} or later versions.";
    Strings.NullStringArrayElementInvalid = "The array contains at least one null element.";
    Strings.HttpsIsRequired = "Https is required when partner token is expected.";
    Strings.MergedFreeBusyIntervalMustBeSmallerThanTimeWindow = "MergedFreeBusyInterval must be smaller than the specified time window.";
    Strings.SecondMustBeBetween0And59 = "Second must be between 0 and 59.";
    Strings.AtLeastOneAttachmentCouldNotBeDeleted = "At least one attachment couldn't be deleted.";
    Strings.IdAlreadyInList = "The ID is already in the list.";
    Strings.BothSearchFilterAndQueryStringCannotBeSpecified = "Both search filter and query can't be specified. One of them must be null.";
    Strings.AdditionalPropertyIsNull = "The additional property at index {0} is null.";
    Strings.InvalidEmailAddress = "The e-mail address is formed incorrectly.";
    Strings.MaximumRedirectionHopsExceeded = "The maximum redirection hop count has been reached.";
    Strings.AutodiscoverCouldNotBeLocated = "The Autodiscover service couldn't be located.";
    Strings.NoSubscriptionsOnConnection = "You must add at least one subscription to this connection before it can be opened.";
    Strings.PermissionLevelInvalidForNonCalendarFolder = "The Permission level value {0} can't be used with a non-calendar folder.";
    Strings.InvalidAuthScheme = "The token auth scheme should be bearer.";
    Strings.ValuePropertyNotLoaded = "This property was requested, but it wasn't returned by the server.";
    Strings.PropertyIncompatibleWithRequestVersion = "The property {0} is valid only for Exchange {1} or later versions.";
    Strings.OffsetMustBeGreaterThanZero = "The offset must be greater than 0.";
    Strings.CreateItemsDoesNotAllowAttachments = "This operation doesn't support items that have attachments.";
    Strings.PropertyDefinitionTypeMismatch = "Property definition type '{0}' and type parameter '{1}' aren't compatible.";
    Strings.IntervalMustBeGreaterOrEqualToOne = "The interval must be greater than or equal to 1.";
    Strings.CannotSetPermissionLevelToCustom = "The PermissionLevel property can't be set to FolderPermissionLevel.Custom. To define a custom permission, set its individual properties to the values you want.";
    Strings.CannotAddRequestHeader = "HTTP header '{0}' isn't permitted. Only HTTP headers with the 'X-' prefix are permitted.";
    Strings.ArrayMustHaveAtLeastOneElement = "The Array value must have at least one element.";
    Strings.MonthMustBeSpecifiedForRecurrencePattern = "The recurrence pattern's Month property must be specified.";
    Strings.ValueOfTypeCannotBeConverted = "The value '{0}' of type {1} can't be converted to a value of type {2}.";
    Strings.ValueCannotBeConverted = "The value '{0}' couldn't be converted to type {1}.";
    Strings.ServerErrorAndStackTraceDetails = "{0} -- Server Error: {1}: {2} {3}";
    Strings.FolderPermissionLevelMustBeSet = "The permission level of the folder permission at index {0} must be set.";
    Strings.AutodiscoverError = "The Autodiscover service returned an error.";
    Strings.ArrayMustHaveSingleDimension = "The array value must have a single dimension.";
    Strings.InvalidPropertyValueNotInRange = "{0} must be between {1} and {2}.";
    Strings.RegenerationPatternsOnlyValidForTasks = "Regeneration patterns can only be used with Task items.";
    Strings.ItemAttachmentCannotBeUpdated = "Item attachments can't be updated.";
    Strings.EqualityComparisonFilterIsInvalid = "Either the OtherPropertyDefinition or the Value properties must be set.";
    Strings.AutodiscoverServiceRequestRequiresDomainOrUrl = "This Autodiscover request requires that either the Domain or Url be specified.";
    Strings.InvalidUser = "Invalid user: '{0}'";
    Strings.AccountIsLocked = "This account is locked. Visit {0} to unlock it.";
    Strings.InvalidDomainName = "'{0}' is not a valid domain name.";
    Strings.TooFewServiceReponsesReturned = "The service was expected to return {1} responses of type '{0}', but {2} responses were received.";
    Strings.CannotSubscribeToStatusEvents = "Status events can't be subscribed to.";
    Strings.InvalidSortByPropertyForMailboxSearch = "Specified SortBy property '{0}' is invalid.";
    Strings.UnexpectedElementType = "The expected XML node type was {0}, but the actual type is {1}.";
    Strings.ValueMustBeGreaterThanZero = "The value must be greater than 0.";
    Strings.AttachmentCannotBeUpdated = "Attachments can't be updated.";
    Strings.CreateItemsDoesNotHandleExistingItems = "This operation can't be performed because at least one item already has an ID.";
    Strings.MultipleContactPhotosInAttachment = "This operation only allows at most 1 file attachment with IsContactPhoto set.";
    Strings.InvalidRecurrenceRange = "Invalid recurrence range: ({0}).";
    Strings.CannotSetBothImpersonatedAndPrivilegedUser = "Can't set both impersonated user and privileged user in the ExchangeService object.";
    Strings.NewMessagesWithAttachmentsCannotBeSentDirectly = "New messages with attachments can't be sent directly. You must first save the message and then send it.";
    Strings.CannotCallDisconnectWithNoLiveConnection = "The connection is already closed.";
    Strings.IdPropertyMustBeSet = "The Id property must be set.";
    Strings.ValuePropertyNotAssigned = "You must assign this property before you can read its value.";
    Strings.ZeroLengthArrayInvalid = "The array must contain at least one element.";
    Strings.HoldMailboxesParameterIsNotSpecified = "The hold mailboxes parameter is not specified.";
    Strings.CannotSaveNotNewUserConfiguration = "Calling Save isn't allowed because this user configuration isn't new. To apply local changes to this user configuration, call Update instead.";
    Strings.ServiceObjectDoesNotHaveId = "This operation can't be performed because this service object doesn't have an Id.";
    Strings.PropertyCollectionSizeMismatch = "The collection returned by the service has a different size from the current one.";
    Strings.XsDurationCouldNotBeParsed = "The specified xsDuration argument couldn't be parsed.";
    Strings.UnknownTimeZonePeriodTransitionType = "Unknown time zone transition type: {0}";
    Strings.UserPhotoSizeNotSpecified = "The UserPhotoSize must be not be null or empty.";
    Strings.JsonSerializationNotImplemented = "JSON Serialization is not implemented for this request.Please retry the request with the XML rendering method.";
    Strings.JsonDeserializationNotImplemented = "JSON Deserialization is not implemented for this request.Please retry the request with the XML rendering method.";
    return Strings;
}());
exports.Strings = Strings;
/**
 * @internal TypeContainer  - contains Type as properties. Required to evade circular dependency. Initilized in ExchangeWebService.ts which is going to weave type objects.
 */
var TypeContainer = (function () {
    function TypeContainer(parameters) {
    }
    return TypeContainer;
}());
exports.TypeContainer = TypeContainer;
/**
* Uri: c# uri shim for js
*/
var Uri = (function () {
    function Uri(url) {
        this.m_scheme = null;
        if (StringHelper.IsNullOrEmpty(url)) {
            throw new Error("Uri - ctor- argument is not string or it is null or empty");
        }
        this.url = url;
        var parsed = UriHelper.parseString(url);
        this.m_scheme = parsed.scheme.toLowerCase();
    }
    Object.defineProperty(Uri.prototype, "AbsoluteUri", {
        /**returns string url component, no transformations yet */
        get: function () { return this.url; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Uri.prototype, "Host", {
        get: function () { return UriHelper.getHost(this.url); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Uri.prototype, "Scheme", {
        get: function () { return this.m_scheme; },
        enumerable: true,
        configurable: true
    });
    Uri.prototype.ToString = function () {
        return this.url;
    };
    Uri.prototype.toString = function () {
        return this.url;
    };
    // GetDomain(): string {
    //     return UriHelper.getDomain(this.url);
    // }
    // GetHost(url: string): string {
    //     return this.GetDomain();
    // }
    Uri.ParseString = function (url) {
        return UriHelper.parseString(url);
    };
    Uri.UriSchemeHttp = "http";
    Uri.UriSchemeHttps = "https";
    return Uri;
}());
exports.Uri = Uri;
var XHRFactory = (function () {
    function XHRFactory() {
    }
    Object.defineProperty(XHRFactory, "XHRApi", {
        get: function () {
            if (typeof this.xhrHelper === 'undefined' || this.xhrHelper === null) {
                this.xhrHelper = new XHRBrowser();
            }
            return this.xhrHelper;
        },
        enumerable: true,
        configurable: true
    });
    return XHRFactory;
}());
exports.XHRFactory = XHRFactory;
var schemeRegex = /^(\w+)\:\/\//;
/** @internal */
var XHRBrowser = (function () {
    function XHRBrowser() {
        this._canceled = false;
    }
    XHRBrowser.prototype.xhr = function (xhroptions, progressDelegate) {
        var _this = this;
        return new exports.Promise(function (resolve, reject) {
            _this.req = new XMLHttpRequest();
            var isLocalRequest = false;
            var schemeMatch = schemeRegex.exec(xhroptions.url.toLowerCase());
            if (schemeMatch) {
                if (schemeMatch[1] === 'file') {
                    isLocalRequest = true;
                }
            }
            else if (window.location.protocol === 'file:') {
                isLocalRequest = true;
            }
            _this.req.onreadystatechange = function () {
                if (_this._canceled) {
                    _this.req.onreadystatechange = noop;
                    return;
                }
                if (_this.req.readyState === 4) {
                    if ((_this.req.status >= 200 && _this.req.status < 300) || (isLocalRequest && _this.req.status === 0)) {
                        resolve(_this.req);
                    }
                    else {
                        reject(_this.req);
                    }
                    _this.req.onreadystatechange = noop;
                }
            };
            _this.req.addEventListener('error', function (x) {
                _this.disconnect();
                reject(x);
            });
            _this.req.open(xhroptions.type || "GET", xhroptions.url);
            // this.req.responseType = xhroptions.responseType || "";
            Object.keys(xhroptions.headers || {}).forEach(function (k) {
                _this.req.setRequestHeader(k, xhroptions.headers[k]);
            });
            if (xhroptions.customRequestInitializer) {
                xhroptions.customRequestInitializer(_this.req);
            }
            if (xhroptions.data === undefined) {
                _this.req.send();
            }
            else {
                _this.req.send(xhroptions.data);
            }
        });
    };
    XHRBrowser.prototype.xhrStream = function (xhroptions, progressDelegate) {
        var _this = this;
        return new exports.Promise(function (resolve, reject) {
            _this.req = new XMLHttpRequest();
            var isLocalRequest = false;
            var schemeMatch = schemeRegex.exec(xhroptions.url.toLowerCase());
            if (schemeMatch) {
                if (schemeMatch[1] === 'file') {
                    isLocalRequest = true;
                }
            }
            else if (window.location.protocol === 'file:') {
                isLocalRequest = true;
            }
            var lastChunk = '';
            _this.req.onreadystatechange = function () {
                if (_this._canceled) {
                    _this.req.onreadystatechange = noop;
                    return;
                }
                if (_this.req.readyState === 4) {
                    if ((_this.req.status >= 200 && _this.req.status < 300) || (isLocalRequest && _this.req.status === 0)) {
                        resolve(_this.req);
                    }
                    else {
                        reject(_this.req);
                    }
                    _this.req.onreadystatechange = noop;
                }
                else if (_this.req.readyState === 2) {
                    progressDelegate({ type: "header", headers: _this.req.getAllResponseHeaders() });
                }
                else if (_this.req.readyState === 3) {
                    var chunk = _this.req.responseText.substr(lastChunk.length);
                    lastChunk = _this.req.responseText;
                    progressDelegate({ type: "data", data: chunk });
                }
            };
            _this.req.addEventListener('error', function (error) {
                _this.disconnect();
                progressDelegate({ type: "error", error: error });
                reject(error);
            });
            _this.req.open(xhroptions.type || "GET", xhroptions.url);
            // this.req.responseType = xhroptions.responseType || "";
            Object.keys(xhroptions.headers || {}).forEach(function (k) {
                _this.req.setRequestHeader(k, xhroptions.headers[k]);
            });
            if (xhroptions.customRequestInitializer) {
                xhroptions.customRequestInitializer(_this.req);
            }
            if (xhroptions.data === undefined) {
                _this.req.send();
            }
            else {
                _this.req.send(xhroptions.data);
            }
        });
    };
    XHRBrowser.prototype.disconnect = function () {
        var _this = this;
        if (this.req) {
            try {
                this.req.onreadystatechange = noop;
                this._canceled = true;
                this.req.abort();
                setImmediate(function () { _this.req = null; });
            }
            catch (e) { }
        }
    };
    Object.defineProperty(XHRBrowser.prototype, "apiName", {
        get: function () {
            return "browser";
        },
        enumerable: true,
        configurable: true
    });
    return XHRBrowser;
}());
exports.XHRBrowser = XHRBrowser;
function noop() {
}
var TimeSpan = (function () {
    function TimeSpan(daysOrHoursOrMsOrDuration, hoursOrMinutes, minutesOrSeconds, seconds, milliseconds) {
        var duration = null;
        var argsLength = arguments.length;
        if (argsLength === 1) {
            duration = moment.duration(daysOrHoursOrMsOrDuration);
        }
        else {
            var momentInput = {};
            if (argsLength === 3) {
                momentInput.hours = daysOrHoursOrMsOrDuration;
                momentInput.minutes = hoursOrMinutes;
                momentInput.seconds = minutesOrSeconds;
            }
            if (argsLength >= 4) {
                momentInput.days = daysOrHoursOrMsOrDuration;
                momentInput.hours = hoursOrMinutes;
                momentInput.minutes = minutesOrSeconds;
                momentInput.seconds = seconds;
            }
            if (argsLength === 5) {
                momentInput.millisecond = milliseconds;
            }
            duration = moment.duration(momentInput);
        }
        this.getMomentDuration = function () { return duration; };
        this.setMomentDuration = function (value) { return duration = value; };
    }
    Object.defineProperty(TimeSpan.prototype, "duration", {
        get: function () { return this.getMomentDuration(); },
        enumerable: true,
        configurable: true
    });
    TimeSpan.prototype.humanize = function (withSuffix) { return this.duration.humanize(withSuffix); };
    TimeSpan.prototype.as = function (units) { return this.duration.as(units); };
    Object.defineProperty(TimeSpan.prototype, "Milliseconds", {
        get: function () {
            return this.duration.milliseconds();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSpan.prototype, "TotalMilliseconds", {
        get: function () {
            return this.duration.asMilliseconds();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSpan.prototype, "Seconds", {
        get: function () {
            return this.duration.seconds();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSpan.prototype, "TotalSeconds", {
        get: function () {
            return this.duration.asSeconds();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSpan.prototype, "Minutes", {
        get: function () {
            return this.duration.minutes();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSpan.prototype, "TotalMinutes", {
        get: function () {
            return this.duration.asMinutes();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSpan.prototype, "Hours", {
        get: function () {
            return this.duration.hours();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSpan.prototype, "TotalHours", {
        get: function () {
            return this.duration.asHours();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSpan.prototype, "Days", {
        get: function () {
            return this.duration.days();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSpan.prototype, "TotalDays", {
        get: function () {
            return this.duration.asDays();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSpan.prototype, "Months", {
        get: function () {
            return this.duration.months();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSpan.prototype, "TotalMonths", {
        get: function () {
            return this.duration.asMonths();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSpan.prototype, "Years", {
        get: function () {
            return this.duration.years();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSpan.prototype, "TotalYears", {
        get: function () {
            return this.duration.asYears();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSpan.prototype, "Weeks", {
        get: function () {
            return this.duration.weeks();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSpan.prototype, "Totalweeks", {
        get: function () {
            return this.duration.asWeeks();
        },
        enumerable: true,
        configurable: true
    });
    TimeSpan.prototype.Add = function (a, p) {
        if (arguments.length === 1) {
            return new TimeSpan(typeof a === 'number' ? this.duration.add(a) : a.TotalMilliseconds);
        }
        else {
            return new TimeSpan(this.duration.add(a, p));
        }
    };
    TimeSpan.prototype.Subtract = function (a, p) {
        if (arguments.length === 1) {
            return new TimeSpan(this.duration.subtract(a));
        }
        else {
            return new TimeSpan(this.duration.subtract(a, p));
        }
    };
    TimeSpan.prototype.ToISOString = function () { return this.duration.toISOString(); };
    TimeSpan.prototype.ToJSON = function () { return this.duration.toJSON(); };
    TimeSpan.FromDays = function (value) {
        return new TimeSpan(value * TimeSpan.MillisPerDay);
    };
    TimeSpan.FromHours = function (value) {
        return new TimeSpan(value * TimeSpan.MillisPerHour);
    };
    TimeSpan.FromMilliseconds = function (value) {
        return new TimeSpan(value);
    };
    TimeSpan.FromMinutes = function (value) {
        return new TimeSpan(value * TimeSpan.MillisPerMinute);
    };
    TimeSpan.FromSeconds = function (value) {
        return new TimeSpan(value * TimeSpan.MillisPerSecond);
    };
    TimeSpan.prototype.valueOf = function () {
        return this.duration.asMilliseconds();
    };
    TimeSpan.prototype.toString = function () {
        return this.duration.toISOString();
    };
    /** @internal */
    TimeSpan.MillisPerSecond = 1000; //const
    /** @internal */
    TimeSpan.MillisPerMinute = TimeSpan.MillisPerSecond * 60; //     60,000 //const
    /** @internal */
    TimeSpan.MillisPerHour = TimeSpan.MillisPerMinute * 60; //  3,600,000 //const
    /** @internal */
    TimeSpan.MillisPerDay = TimeSpan.MillisPerHour * 24; // 86,400,000 //const
    TimeSpan.MaxSeconds = Number.MAX_VALUE / TimeSpan.MillisPerSecond; // TimeSpan.TicksPerSecond; //const
    TimeSpan.MinSeconds = Number.MIN_VALUE / TimeSpan.MillisPerSecond; // TimeSpan.TicksPerSecond; //const
    TimeSpan.MaxMilliSeconds = Number.MAX_VALUE; /// TimeSpan.TicksPerMillisecond; //const
    TimeSpan.MinMilliSeconds = Number.MIN_VALUE; /// TimeSpan.TicksPerMillisecond; //const
    //private static  TicksPerTenthSecond:number = TimeSpan.TicksPerMillisecond * 100; //const
    TimeSpan.Zero = new TimeSpan(0); //readonly
    TimeSpan.MaxValueTimeSpan = new TimeSpan(Number.MAX_VALUE); //readonly
    TimeSpan.MinValueTimeSpan = new TimeSpan(Number.MIN_VALUE); //readonly
    return TimeSpan;
}());
exports.TimeSpan = TimeSpan;
var TimeSpan2;
(function (TimeSpan2) {
    /** TimeSpan basics from c# using momentjs */
    var TimeSpan = (function () {
        function TimeSpan(millisOrHrsOrDays, minsOrHrs, secsOrMins, seconds, milliseconds) {
            this._millis = 0;
            var argsLength = arguments.length;
            var millis = 0;
            if (typeof milliseconds !== 'undefined')
                millis = milliseconds;
            switch (argsLength) {
                case 1:
                    this._millis = millisOrHrsOrDays;
                    break;
                case 3:
                    this._millis = TimeSpan.TimeToTicks(millisOrHrsOrDays, minsOrHrs, secsOrMins);
                    break;
                case 4:
                case 5:
                    var totalSeconds = millisOrHrsOrDays * 24 * 3600 + minsOrHrs * 3600 + secsOrMins * 60 + seconds;
                    if (totalSeconds > TimeSpan.MaxSeconds || totalSeconds < TimeSpan.MinSeconds)
                        throw new ArgumentOutOfRangeException("DateTime.ts - TimeSpan.ctor - Overflow_TimeSpanTooLong");
                    this._millis = totalSeconds * TimeSpan.MillisPerSecond + millis;
                    break;
                default:
                    throw new Error("DateTime.ts - TimeSpan.ctor - invalid number of arguments");
            }
        }
        TimeSpan.TimeToTicks = function (hour, minute, second) {
            // totalSeconds is bounded by 2^31 * 2^12 + 2^31 * 2^8 + 2^31,
            // which is less than 2^44, meaning we won't overflow totalSeconds.
            var totalSeconds = hour * 3600 + minute * 60 + second;
            if (totalSeconds > this.MaxSeconds || totalSeconds < this.MinSeconds)
                throw new ArgumentOutOfRangeException("DateTime.ts - TimeSpan.TimeToTicks - Overflow_TimeSpanTooLong");
            return totalSeconds * this.MillisPerSecond;
        };
        Object.defineProperty(TimeSpan.prototype, "Days", {
            get: function () { return Math.floor(this._millis / TimeSpan.MillisPerDay); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeSpan.prototype, "Hours", {
            get: function () { return Math.floor(this._millis / TimeSpan.MillisPerHour); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeSpan.prototype, "Milliseconds", {
            get: function () { return Math.floor(this._millis); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeSpan.prototype, "Minutes", {
            get: function () { return Math.floor(this._millis / TimeSpan.MillisPerMinute); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeSpan.prototype, "Seconds", {
            get: function () { return Math.floor(this._millis / TimeSpan.MillisPerSecond); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeSpan.prototype, "TotalDays", {
            //public get Ticks(): number { return Math.floor( this._millis / TimeSpan.); }
            get: function () { return this._millis / TimeSpan.MillisPerDay; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeSpan.prototype, "TotalHours", {
            get: function () { return this._millis / TimeSpan.MillisPerHour; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeSpan.prototype, "TotalMilliseconds", {
            get: function () { return this._millis; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeSpan.prototype, "TotalMinutes", {
            get: function () { return this._millis / TimeSpan.MillisPerMinute; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TimeSpan.prototype, "TotalSeconds", {
            get: function () { return this._millis / TimeSpan.MillisPerSecond; },
            enumerable: true,
            configurable: true
        });
        // Compares two TimeSpan values, returning an integer that indicates their
        // relationship.
        //
        TimeSpan.Compare = function (t1, t2) {
            if (t1._millis > t2._millis)
                return 1;
            if (t1._millis < t2._millis)
                return -1;
            return 0;
        };
        TimeSpan.Equals = function (t1, t2) { return t1._millis === t2._millis; };
        TimeSpan.FromDays = function (value) { return new TimeSpan(value * TimeSpan.MillisPerDay); };
        TimeSpan.FromHours = function (value) { return new TimeSpan(value * TimeSpan.MillisPerHour); };
        TimeSpan.FromMilliseconds = function (value) { return new TimeSpan(value); };
        TimeSpan.FromMinutes = function (value) { return new TimeSpan(value * TimeSpan.MillisPerMinute); };
        TimeSpan.FromSeconds = function (value) { return new TimeSpan(value * TimeSpan.MillisPerSecond); };
        //public static FromTicks(value: number): TimeSpan{ return new TimeSpan(value * TimeSpan.MillisPerDay); }
        TimeSpan.Parse = function (s) {
            return null;
        };
        //public static Parse(input: string, formatProvider: IFormatProvider): TimeSpan;
        //public static ParseExact(string input, string[] formats, IFormatProvider formatProvider): TimeSpan;
        //public static ParseExact(string input, string format, IFormatProvider formatProvider): TimeSpan;
        //public static ParseExact(string input, string[] formats, IFormatProvider formatProvider, TimeSpanStyles styles): TimeSpan;
        //public static ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles): TimeSpan;
        //public static TryParse(string s, out TimeSpan result): boolean;
        //public static TryParse(string input, IFormatProvider formatProvider, out TimeSpan result): boolean;
        //public static TryParseExact(string input, string[] formats, IFormatProvider formatProvider, out TimeSpan result): boolean;
        //public static TryParseExact(string input, string format, IFormatProvider formatProvider, out TimeSpan result): boolean;
        //public static TryParseExact(string input, string[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, out TimeSpan result): boolean;
        //public static TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, out TimeSpan result): boolean { }
        TimeSpan.prototype.Add = function (ts) {
            var result = this._millis + ts._millis;
            // Overflow if signs of operands was identical and result's sign was opposite.
            // >> 63 gives the sign bit (either 64 1's or 64 0's).
            if ((this._millis >>> 63 === ts._millis >> 63) && (this.Milliseconds >>> 63 !== result >> 63))
                throw new Error("Overflow_TimeSpanTooLong"); //OverflowException
            return new TimeSpan(result);
        };
        TimeSpan.prototype.CompareTo = function (value) {
            if (!(value instanceof TimeSpan))
                throw new Error("Arg_MustBeTimeSpan"); //ArgumentException
            var m = value._millis;
            if (this._millis > m)
                return 1;
            if (this._millis < m)
                return -1;
            return 0;
        };
        // non ticks use in js - public static     TicksPerMillisecond:number =  10000; //const
        // non ticks use in js - private static  MillisecondsPerTick:number = 1.0 / TimeSpan.TicksPerMillisecond; //const
        // non ticks use in js - public static  TicksPerSecond:number = TimeSpan.TicksPerMillisecond * 1000;   // 10,000,000 //const
        // non ticks use in js - private static  SecondsPerTick:number =  1.0 / TimeSpan.TicksPerSecond;         // 0.0001 //const
        // non ticks use in js - public static  TicksPerMinute:number = TimeSpan.TicksPerSecond * 60;         // 600,000,000 //const
        // non ticks use in js - private static  MinutesPerTick:number = 1.0 / TimeSpan.TicksPerMinute; // 1.6666666666667e-9 //const
        // non ticks use in js - public static  TicksPerHour:number = TimeSpan.TicksPerMinute * 60;        // 36,000,000,000 //const
        // non ticks use in js - private static  HoursPerTick:number = 1.0 / TimeSpan.TicksPerHour; // 2.77777777777777778e-11 //const
        // non ticks use in js - public static  TicksPerDay:number = TimeSpan.TicksPerHour * 24;          // 864,000,000,000 //const
        // non ticks use in js - private static  DaysPerTick:number = 1.0 / TimeSpan.TicksPerDay; // 1.1574074074074074074e-12 //const
        TimeSpan.MillisPerSecond = 1000; //const
        TimeSpan.MillisPerMinute = TimeSpan.MillisPerSecond * 60; //     60,000 //const
        TimeSpan.MillisPerHour = TimeSpan.MillisPerMinute * 60; //  3,600,000 //const
        TimeSpan.MillisPerDay = TimeSpan.MillisPerHour * 24; // 86,400,000 //const
        TimeSpan.MaxSeconds = Number.MAX_VALUE / TimeSpan.MillisPerSecond; // TimeSpan.TicksPerSecond; //const
        TimeSpan.MinSeconds = Number.MIN_VALUE / TimeSpan.MillisPerSecond; // TimeSpan.TicksPerSecond; //const
        TimeSpan.MaxMilliSeconds = Number.MAX_VALUE; /// TimeSpan.TicksPerMillisecond; //const
        TimeSpan.MinMilliSeconds = Number.MIN_VALUE; /// TimeSpan.TicksPerMillisecond; //const
        //private static  TicksPerTenthSecond:number = TimeSpan.TicksPerMillisecond * 100; //const
        TimeSpan.Zero = new TimeSpan(0); //readonly
        TimeSpan.MaxValueTimeSpan = new TimeSpan(Number.MAX_VALUE); //readonly
        TimeSpan.MinValueTimeSpan = new TimeSpan(Number.MIN_VALUE); //readonly
        return TimeSpan;
    }());
})(TimeSpan2 || (TimeSpan2 = {}));
exports.TimeZoneMappingData = {
    "America/Aruba": "SA Western Standard Time",
    "Europe/Copenhagen": "Romance Standard Time",
    "Europe/Brussels": "Romance Standard Time",
    "Africa/Tunis": "W. Central Africa Standard Time",
    "America/Pangnirtung": "Eastern Standard Time",
    "Africa/Malabo": "W. Central Africa Standard Time",
    "America/Guyana": "SA Western Standard Time",
    "W. Mongolia Standard Time": [
        [
            "Asia/Hovd"
        ],
        "(UTC+07:00) Hovd",
        "W. Mongolia Standard Time",
        "W. Mongolia Daylight Time",
        true,
        420
    ],
    "Russia Time Zone 10": [
        [
            "Asia/Srednekolymsk"
        ],
        "(UTC+11:00) Chokurdakh",
        "Russia TZ 10 Standard Time",
        "Russia TZ 10 Daylight Time",
        true,
        660
    ],
    "Ekaterinburg Standard Time": [
        [
            "Asia/Yekaterinburg"
        ],
        "(UTC+05:00) Ekaterinburg",
        "Russia TZ 4 Standard Time",
        "Russia TZ 4 Daylight Time",
        true,
        300
    ],
    "Australia/Lindeman": "E. Australia Standard Time",
    "Asia/Famagusta": "Turkey Standard Time",
    "America/Mendoza": "Argentina Standard Time",
    "Indian/Cocos": "Myanmar Standard Time",
    "America/North_Dakota/Beulah": "Central Standard Time",
    "America/Los_Angeles": "Pacific Standard Time",
    "Sakhalin Standard Time": [
        [
            "Asia/Sakhalin"
        ],
        "(UTC+11:00) Sakhalin",
        "Sakhalin Standard Time",
        "Sakhalin Daylight Time",
        true,
        660
    ],
    "Altai Standard Time": [
        [
            "Asia/Barnaul"
        ],
        "(UTC+07:00) Barnaul, Gorno-Altaysk",
        "Altai Standard Time",
        "Altai Daylight Time",
        true,
        420
    ],
    "Pacific/Guam": "West Pacific Standard Time",
    "Pacific/Nauru": "UTC+12",
    "Africa/Brazzaville": "W. Central Africa Standard Time",
    "Europe/Jersey": "GMT Standard Time",
    "Newfoundland Standard Time": [
        [
            "America/St_Johns"
        ],
        "(UTC-03:30) Newfoundland",
        "Newfoundland Standard Time",
        "Newfoundland Daylight Time",
        true,
        -210
    ],
    "Europe/Vaduz": "W. Europe Standard Time",
    "Pacific/Ponape": "Central Pacific Standard Time",
    "America/Indiana/Knox": "Central Standard Time",
    "America/Argentina/Ushuaia": "Argentina Standard Time",
    "Tasmania Standard Time": [
        [
            "Australia/Hobart",
            "Australia/Currie"
        ],
        "(UTC+10:00) Hobart",
        "Tasmania Standard Time",
        "Tasmania Daylight Time",
        true,
        600
    ],
    "Asia/Jakarta": "SE Asia Standard Time",
    "Europe/Vilnius": "FLE Standard Time",
    "Africa/Kigali": "South Africa Standard Time",
    "America/St_Kitts": "SA Western Standard Time",
    "Indian/Kerguelen": "West Asia Standard Time",
    "Africa/Libreville": "W. Central Africa Standard Time",
    "West Pacific Standard Time": [
        [
            "Pacific/Port_Moresby",
            "Antarctica/DumontDUrville",
            "Pacific/Truk",
            "Pacific/Guam",
            "Pacific/Saipan",
            "Etc/GMT-10"
        ],
        "(UTC+10:00) Guam, Port Moresby",
        "West Pacific Standard Time",
        "West Pacific Daylight Time",
        false,
        600
    ],
    "Atlantic Standard Time": [
        [
            "America/Halifax",
            "Atlantic/Bermuda",
            "America/Glace_Bay",
            "America/Goose_Bay",
            "America/Moncton",
            "America/Thule"
        ],
        "(UTC-04:00) Atlantic Time (Canada)",
        "Atlantic Standard Time",
        "Atlantic Daylight Time",
        true,
        -240
    ],
    "W. Central Africa Standard Time": [
        [
            "Africa/Lagos",
            "Africa/Luanda",
            "Africa/Porto-Novo",
            "Africa/Kinshasa",
            "Africa/Bangui",
            "Africa/Brazzaville",
            "Africa/Douala",
            "Africa/Algiers",
            "Africa/Libreville",
            "Africa/Malabo",
            "Africa/Niamey",
            "Africa/Ndjamena",
            "Africa/Tunis",
            "Etc/GMT-1"
        ],
        "(UTC+01:00) West Central Africa",
        "W. Central Africa Standard Time",
        "W. Central Africa Daylight Time",
        false,
        60
    ],
    "Etc/GMT+8": "UTC-08",
    "Atlantic/Faeroe": "GMT Standard Time",
    "America/Sitka": "Alaskan Standard Time",
    "UTC": [
        [
            "Etc/GMT",
            "America/Danmarkshavn",
            "Etc/UTC"
        ],
        "(UTC) Coordinated Universal Time",
        "Coordinated Universal Time",
        "Coordinated Universal Time",
        false,
        0
    ],
    "Fiji Standard Time": [
        [
            "Pacific/Fiji"
        ],
        "(UTC+12:00) Fiji",
        "Fiji Standard Time",
        "Fiji Daylight Time",
        true,
        720
    ],
    "Pacific/Kosrae": "Central Pacific Standard Time",
    "West Asia Standard Time": [
        [
            "Asia/Tashkent",
            "Antarctica/Mawson",
            "Asia/Oral",
            "Asia/Aqtau",
            "Asia/Aqtobe",
            "Asia/Atyrau",
            "Indian/Maldives",
            "Indian/Kerguelen",
            "Asia/Dushanbe",
            "Asia/Ashgabat",
            "Asia/Samarkand",
            "Etc/GMT-5"
        ],
        "(UTC+05:00) Ashgabat, Tashkent",
        "West Asia Standard Time",
        "West Asia Daylight Time",
        false,
        300
    ],
    "Europe/Belgrade": "Central Europe Standard Time",
    "Mid-Atlantic Standard Time": [
        null,
        "(UTC-02:00) Mid-Atlantic - Old",
        "Mid-Atlantic Standard Time",
        "Mid-Atlantic Daylight Time",
        true,
        -120
    ],
    "Magallanes Standard Time": [
        null,
        "(UTC-03:00) Punta Arenas",
        "Magallanes Standard Time",
        "Magallanes Daylight Time",
        true,
        -180
    ],
    "Kamchatka Standard Time": [
        null,
        "(UTC+12:00) Petropavlovsk-Kamchatsky - Old",
        "Kamchatka Standard Time",
        "Kamchatka Daylight Time",
        true,
        720
    ],
    "America/Guatemala": "Central America Standard Time",
    "Asia/Singapore": "Singapore Standard Time",
    "Indian/Mayotte": "E. Africa Standard Time",
    "Nepal Standard Time": [
        [
            "Asia/Katmandu"
        ],
        "(UTC+05:45) Kathmandu",
        "Nepal Standard Time",
        "Nepal Daylight Time",
        false,
        345
    ],
    "UTC-11": [
        [
            "Etc/GMT+11",
            "Pacific/Pago_Pago",
            "Pacific/Niue",
            "Pacific/Midway"
        ],
        "(UTC-11:00) Coordinated Universal Time-11",
        "UTC-11",
        "UTC-11",
        false,
        -660
    ],
    "Asia/Qatar": "Arab Standard Time",
    "Georgian Standard Time": [
        [
            "Asia/Tbilisi"
        ],
        "(UTC+04:00) Tbilisi",
        "Georgian Standard Time",
        "Georgian Daylight Time",
        false,
        240
    ],
    "Europe/Simferopol": "Russian Standard Time",
    "Etc/GMT+10": "Hawaiian Standard Time",
    "Australia/Adelaide": "Cen. Australia Standard Time",
    "America/Fort_Nelson": "US Mountain Standard Time",
    "Transbaikal Standard Time": [
        [
            "Asia/Chita"
        ],
        "(UTC+09:00) Chita",
        "Transbaikal Standard Time",
        "Transbaikal Daylight Time",
        true,
        540
    ],
    "Aleutian Standard Time": [
        [
            "America/Adak"
        ],
        "(UTC-10:00) Aleutian Islands",
        "Aleutian Standard Time",
        "Aleutian Daylight Time",
        true,
        -600
    ],
    "America/Cayman": "SA Pacific Standard Time",
    "Pacific Standard Time (Mexico)": [
        [
            "America/Tijuana",
            "America/Santa_Isabel"
        ],
        "(UTC-08:00) Baja California",
        "Pacific Standard Time (Mexico)",
        "Pacific Daylight Time (Mexico)",
        true,
        -480
    ],
    "America/Thule": "Atlantic Standard Time",
    "America/Puerto_Rico": "SA Western Standard Time",
    "Asia/Dili": "Tokyo Standard Time",
    "Pacific/Kiritimati": "Line Islands Standard Time",
    "Europe/Ljubljana": "Central Europe Standard Time",
    "Europe/Tirane": "Central Europe Standard Time",
    "Etc/GMT-5": "West Asia Standard Time",
    "Etc/GMT+9": "UTC-09",
    "Europe/Gibraltar": "W. Europe Standard Time",
    "America/Manaus": "SA Western Standard Time",
    "America/Argentina/San_Luis": "Argentina Standard Time",
    "Venezuela Standard Time": [
        [
            "America/Caracas"
        ],
        "(UTC-04:00) Caracas",
        "Venezuela Standard Time",
        "Venezuela Daylight Time",
        true,
        -240
    ],
    "Cen. Australia Standard Time": [
        [
            "Australia/Adelaide",
            "Australia/Broken_Hill"
        ],
        "(UTC+09:30) Adelaide",
        "Cen. Australia Standard Time",
        "Cen. Australia Daylight Time",
        true,
        570
    ],
    "America/Guayaquil": "SA Pacific Standard Time",
    "Afghanistan Standard Time": [
        [
            "Asia/Kabul"
        ],
        "(UTC+04:30) Kabul",
        "Afghanistan Standard Time",
        "Afghanistan Daylight Time",
        false,
        270
    ],
    "Mauritius Standard Time": [
        [
            "Indian/Mauritius",
            "Indian/Reunion",
            "Indian/Mahe"
        ],
        "(UTC+04:00) Port Louis",
        "Mauritius Standard Time",
        "Mauritius Daylight Time",
        true,
        240
    ],
    "New Zealand Standard Time": [
        [
            "Pacific/Auckland",
            "Antarctica/McMurdo"
        ],
        "(UTC+12:00) Auckland, Wellington",
        "New Zealand Standard Time",
        "New Zealand Daylight Time",
        true,
        720
    ],
    "US Mountain Standard Time": [
        [
            "America/Phoenix",
            "America/Dawson_Creek",
            "America/Creston",
            "America/Fort_Nelson",
            "America/Hermosillo",
            "Etc/GMT+7"
        ],
        "(UTC-07:00) Arizona",
        "US Mountain Standard Time",
        "US Mountain Daylight Time",
        false,
        -420
    ],
    "Tokyo Standard Time": [
        [
            "Asia/Tokyo",
            "Asia/Jayapura",
            "Pacific/Palau",
            "Asia/Dili",
            "Etc/GMT-9"
        ],
        "(UTC+09:00) Osaka, Sapporo, Tokyo",
        "Tokyo Standard Time",
        "Tokyo Daylight Time",
        false,
        540
    ],
    "Asia/Sakhalin": "Sakhalin Standard Time",
    "Europe/Astrakhan": "Astrakhan Standard Time",
    "America/Catamarca": "Argentina Standard Time",
    "Africa/Lubumbashi": "South Africa Standard Time",
    "America/Boise": "Mountain Standard Time",
    "America/Glace_Bay": "Atlantic Standard Time",
    "America/Tegucigalpa": "Central America Standard Time",
    "America/Chicago": "Central Standard Time",
    "Etc/GMT+6": "Central America Standard Time",
    "Antarctica/Macquarie": "Central Pacific Standard Time",
    "Europe/Kirov": "Russian Standard Time",
    "America/Campo_Grande": "Central Brazilian Standard Time",
    "Indian/Mauritius": "Mauritius Standard Time",
    "America/La_Paz": "SA Western Standard Time",
    "Russian Standard Time": [
        [
            "Europe/Moscow",
            "Europe/Kirov",
            "Europe/Volgograd",
            "Europe/Simferopol"
        ],
        "(UTC+03:00) Moscow, St. Petersburg, Volgograd",
        "Russia TZ 2 Standard Time",
        "Russia TZ 2 Daylight Time",
        true,
        180
    ],
    "America/Miquelon": "Saint Pierre Standard Time",
    "Asia/Tbilisi": "Georgian Standard Time",
    "Asia/Aden": "Arab Standard Time",
    "Asia/Tehran": "Iran Standard Time",
    "Asia/Colombo": "Sri Lanka Standard Time",
    "America/Lower_Princes": "SA Western Standard Time",
    "Azores Standard Time": [
        [
            "Atlantic/Azores",
            "America/Scoresbysund"
        ],
        "(UTC-01:00) Azores",
        "Azores Standard Time",
        "Azores Daylight Time",
        true,
        -60
    ],
    "America/Santo_Domingo": "SA Western Standard Time",
    "Iran Standard Time": [
        [
            "Asia/Tehran"
        ],
        "(UTC+03:30) Tehran",
        "Iran Standard Time",
        "Iran Daylight Time",
        true,
        210
    ],
    "Mountain Standard Time (Mexico)": [
        [
            "America/Chihuahua",
            "America/Mazatlan"
        ],
        "(UTC-07:00) Chihuahua, La Paz, Mazatlan",
        "Mountain Standard Time (Mexico)",
        "Mountain Daylight Time (Mexico)",
        true,
        -420
    ],
    "Central Europe Standard Time": [
        [
            "Europe/Budapest",
            "Europe/Tirane",
            "Europe/Prague",
            "Europe/Podgorica",
            "Europe/Belgrade",
            "Europe/Ljubljana",
            "Europe/Bratislava"
        ],
        "(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague",
        "Central Europe Standard Time",
        "Central Europe Daylight Time",
        true,
        60
    ],
    "Asia/Beirut": "Middle East Standard Time",
    "America/Denver": "Mountain Standard Time",
    "America/Halifax": "Atlantic Standard Time",
    "America/Barbados": "SA Western Standard Time",
    "Pacific/Noumea": "Central Pacific Standard Time",
    "Jordan Standard Time": [
        [
            "Asia/Amman"
        ],
        "(UTC+02:00) Amman",
        "Jordan Standard Time",
        "Jordan Daylight Time",
        true,
        120
    ],
    "Singapore Standard Time": [
        [
            "Asia/Singapore",
            "Asia/Brunei",
            "Asia/Makassar",
            "Asia/Kuala_Lumpur",
            "Asia/Kuching",
            "Asia/Manila",
            "Etc/GMT-8"
        ],
        "(UTC+08:00) Kuala Lumpur, Singapore",
        "Malay Peninsula Standard Time",
        "Malay Peninsula Daylight Time",
        false,
        480
    ],
    "Pacific/Rarotonga": "Hawaiian Standard Time",
    "Asia/Saigon": "SE Asia Standard Time",
    "Europe/Lisbon": "GMT Standard Time",
    "America/Jamaica": "SA Pacific Standard Time",
    "Atlantic/Stanley": "SA Eastern Standard Time",
    "Europe/Sarajevo": "Central European Standard Time",
    "Africa/Abidjan": "Greenwich Standard Time",
    "Europe/London": "GMT Standard Time",
    "Australia/Lord_Howe": "Lord Howe Standard Time",
    "Africa/Kinshasa": "W. Central Africa Standard Time",
    "Africa/Accra": "Greenwich Standard Time",
    "India Standard Time": [
        [
            "Asia/Calcutta"
        ],
        "(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi",
        "India Standard Time",
        "India Daylight Time",
        false,
        330
    ],
    "Europe/Kiev": "FLE Standard Time",
    "America/Caracas": "Venezuela Standard Time",
    "Europe/Guernsey": "GMT Standard Time",
    "Africa/Nairobi": "E. Africa Standard Time",
    "Asia/Gaza": "West Bank Standard Time",
    "America/Kentucky/Monticello": "Eastern Standard Time",
    "Europe/Sofia": "FLE Standard Time",
    "America/Edmonton": "Mountain Standard Time",
    "Asia/Almaty": "Central Asia Standard Time",
    "Asia/Anadyr": "Russia Time Zone 11",
    "Asia/Pontianak": "SE Asia Standard Time",
    "Europe/Madrid": "Romance Standard Time",
    "Asia/Kamchatka": "Russia Time Zone 11",
    "Atlantic/Bermuda": "Atlantic Standard Time",
    "Namibia Standard Time": [
        [
            "Africa/Windhoek"
        ],
        "(UTC+01:00) Windhoek",
        "Namibia Standard Time",
        "Namibia Daylight Time",
        true,
        60
    ],
    "Pacific/Tarawa": "UTC+12",
    "Montevideo Standard Time": [
        [
            "America/Montevideo"
        ],
        "(UTC-03:00) Montevideo",
        "Montevideo Standard Time",
        "Montevideo Daylight Time",
        true,
        -180
    ],
    "America/Costa_Rica": "Central America Standard Time",
    "Hawaiian Standard Time": [
        [
            "Pacific/Honolulu",
            "Pacific/Rarotonga",
            "Pacific/Tahiti",
            "Pacific/Johnston",
            "Etc/GMT+10"
        ],
        "(UTC-10:00) Hawaii",
        "Hawaiian Standard Time",
        "Hawaiian Daylight Time",
        false,
        -600
    ],
    "Asia/Calcutta": "India Standard Time",
    "Asia/Pyongyang": "North Korea Standard Time",
    "Pacific/Palau": "Tokyo Standard Time",
    "America/Asuncion": "Paraguay Standard Time",
    "Sri Lanka Standard Time": [
        [
            "Asia/Colombo"
        ],
        "(UTC+05:30) Sri Jayawardenepura",
        "Sri Lanka Standard Time",
        "Sri Lanka Daylight Time",
        false,
        330
    ],
    "Asia/Dubai": "Arabian Standard Time",
    "Mountain Standard Time": [
        [
            "America/Denver",
            "America/Edmonton",
            "America/Cambridge_Bay",
            "America/Inuvik",
            "America/Yellowknife",
            "America/Ojinaga",
            "America/Boise",
            "MST7MDT"
        ],
        "(UTC-07:00) Mountain Time (US &amp; Canada)",
        "Mountain Standard Time",
        "Mountain Daylight Time",
        true,
        -420
    ],
    "America/Havana": "Cuba Standard Time",
    "Asia/Jerusalem": "Israel Standard Time",
    "Pacific/Gambier": "UTC-09",
    "America/Araguaina": "Tocantins Standard Time",
    "Pacific/Midway": "UTC-11",
    "Asia/Manila": "Singapore Standard Time",
    "MST7MDT": "Mountain Standard Time",
    "Europe/Bucharest": "GTB Standard Time",
    "Asia/Baghdad": "Arabic Standard Time",
    "Asia/Novokuznetsk": "North Asia Standard Time",
    "Antarctica/DumontDUrville": "West Pacific Standard Time",
    "Africa/Blantyre": "South Africa Standard Time",
    "Libya Standard Time": [
        [
            "Africa/Tripoli"
        ],
        "(UTC+02:00) Tripoli",
        "Libya Standard Time",
        "Libya Daylight Time",
        true,
        120
    ],
    "Samoa Standard Time": [
        [
            "Pacific/Apia"
        ],
        "(UTC+13:00) Samoa",
        "Samoa Standard Time",
        "Samoa Daylight Time",
        true,
        780
    ],
    "Pacific/Efate": "Central Pacific Standard Time",
    "Europe/Volgograd": "Russian Standard Time",
    "America/Argentina/Tucuman": "Argentina Standard Time",
    "America/St_Lucia": "SA Western Standard Time",
    "Europe/Budapest": "Central Europe Standard Time",
    "Etc/GMT+1": "Cape Verde Standard Time",
    "Asia/Nicosia": "GTB Standard Time",
    "Asia/Kuching": "Singapore Standard Time",
    "America/Chihuahua": "Mountain Standard Time (Mexico)",
    "Asia/Choibalsan": "Ulaanbaatar Standard Time",
    "Europe/Zagreb": "Central European Standard Time",
    "America/Martinique": "SA Western Standard Time",
    "FLE Standard Time": [
        [
            "Europe/Kiev",
            "Europe/Mariehamn",
            "Europe/Sofia",
            "Europe/Tallinn",
            "Europe/Helsinki",
            "Europe/Vilnius",
            "Europe/Riga",
            "Europe/Uzhgorod",
            "Europe/Zaporozhye"
        ],
        "(UTC+02:00) Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius",
        "FLE Standard Time",
        "FLE Daylight Time",
        true,
        120
    ],
    "America/Swift_Current": "Canada Central Standard Time",
    "America/Hermosillo": "US Mountain Standard Time",
    "Etc/GMT-9": "Tokyo Standard Time",
    "America/Santarem": "SA Eastern Standard Time",
    "Pacific/Fakaofo": "Tonga Standard Time",
    "Greenwich Standard Time": [
        [
            "Atlantic/Reykjavik",
            "Africa/Ouagadougou",
            "Africa/Abidjan",
            "Africa/Accra",
            "Africa/Banjul",
            "Africa/Conakry",
            "Africa/Bissau",
            "Africa/Monrovia",
            "Africa/Bamako",
            "Africa/Nouakchott",
            "Atlantic/St_Helena",
            "Africa/Freetown",
            "Africa/Dakar",
            "Africa/Sao_Tome",
            "Africa/Lome"
        ],
        "(UTC+00:00) Monrovia, Reykjavik",
        "Greenwich Standard Time",
        "Greenwich Daylight Time",
        false,
        0
    ],
    "W. Australia Standard Time": [
        [
            "Australia/Perth"
        ],
        "(UTC+08:00) Perth",
        "W. Australia Standard Time",
        "W. Australia Daylight Time",
        true,
        480
    ],
    "Pacific/Wake": "UTC+12",
    "America/Merida": "Central Standard Time (Mexico)",
    "America/Scoresbysund": "Azores Standard Time",
    "Asia/Barnaul": "Altai Standard Time",
    "Asia/Seoul": "Korea Standard Time",
    "America/Inuvik": "Mountain Standard Time",
    "America/Rainy_River": "Central Standard Time",
    "Pacific/Tahiti": "Hawaiian Standard Time",
    "America/Iqaluit": "Eastern Standard Time",
    "Europe/Moscow": "Russian Standard Time",
    "Korea Standard Time": [
        [
            "Asia/Seoul"
        ],
        "(UTC+09:00) Seoul",
        "Korea Standard Time",
        "Korea Daylight Time",
        false,
        540
    ],
    "Paraguay Standard Time": [
        [
            "America/Asuncion"
        ],
        "(UTC-04:00) Asuncion",
        "Paraguay Standard Time",
        "Paraguay Daylight Time",
        true,
        -240
    ],
    "Asia/Riyadh": "Arab Standard Time",
    "Central European Standard Time": [
        [
            "Europe/Warsaw",
            "Europe/Sarajevo",
            "Europe/Zagreb",
            "Europe/Skopje"
        ],
        "(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb",
        "Central European Standard Time",
        "Central European Daylight Time",
        true,
        60
    ],
    "Europe/Samara": "Russia Time Zone 3",
    "Central Standard Time (Mexico)": [
        [
            "America/Mexico_City",
            "America/Bahia_Banderas",
            "America/Merida",
            "America/Monterrey"
        ],
        "(UTC-06:00) Guadalajara, Mexico City, Monterrey",
        "Central Standard Time (Mexico)",
        "Central Daylight Time (Mexico)",
        true,
        -360
    ],
    "America/Indiana/Winamac": "Eastern Standard Time",
    "North Asia East Standard Time": [
        [
            "Asia/Irkutsk"
        ],
        "(UTC+08:00) Irkutsk",
        "Russia TZ 7 Standard Time",
        "Russia TZ 7 Daylight Time",
        true,
        480
    ],
    "Asia/Yekaterinburg": "Ekaterinburg Standard Time",
    "Africa/Addis_Ababa": "E. Africa Standard Time",
    "Haiti Standard Time": [
        [
            "America/Port-au-Prince"
        ],
        "(UTC-05:00) Haiti",
        "Haiti Standard Time",
        "Haiti Daylight Time",
        true,
        -300
    ],
    "Asia/Jayapura": "Tokyo Standard Time",
    "Etc/GMT-1": "W. Central Africa Standard Time",
    "Europe/Skopje": "Central European Standard Time",
    "America/Dominica": "SA Western Standard Time",
    "Turks And Caicos Standard Time": [
        [
            "America/Grand_Turk"
        ],
        "(UTC-04:00) Turks and Caicos",
        "Turks and Caicos Standard Time",
        "Turks and Caicos Daylight Time",
        true,
        -240
    ],
    "Pacific/Kwajalein": "UTC+12",
    "Etc/GMT": "UTC",
    "AUS Eastern Standard Time": [
        [
            "Australia/Sydney",
            "Australia/Melbourne"
        ],
        "(UTC+10:00) Canberra, Melbourne, Sydney",
        "AUS Eastern Standard Time",
        "AUS Eastern Daylight Time",
        true,
        600
    ],
    "Antarctica/Vostok": "Central Asia Standard Time",
    "E. Europe Standard Time": [
        [
            "Europe/Chisinau"
        ],
        "(UTC+02:00) Chisinau",
        "E. Europe Standard Time",
        "E. Europe Daylight Time",
        true,
        120
    ],
    "Pacific/Majuro": "UTC+12",
    "CST6CDT": "Central Standard Time",
    "Indian/Mahe": "Mauritius Standard Time",
    "America/Yellowknife": "Mountain Standard Time",
    "Etc/GMT+5": "SA Pacific Standard Time",
    "Marquesas Standard Time": [
        [
            "Pacific/Marquesas"
        ],
        "(UTC-09:30) Marquesas Islands",
        "Marquesas Standard Time",
        "Marquesas Daylight Time",
        false,
        -570
    ],
    "Atlantic/Madeira": "GMT Standard Time",
    "Pacific/Tongatapu": "Tonga Standard Time",
    "Europe/Andorra": "W. Europe Standard Time",
    "America/Boa_Vista": "SA Western Standard Time",
    "Europe/Vienna": "W. Europe Standard Time",
    "Asia/Muscat": "Arabian Standard Time",
    "America/Winnipeg": "Central Standard Time",
    "America/Nassau": "Eastern Standard Time",
    "Asia/Aqtobe": "West Asia Standard Time",
    "Antarctica/McMurdo": "New Zealand Standard Time",
    "Eastern Standard Time": [
        [
            "America/New_York",
            "America/Nassau",
            "America/Toronto",
            "America/Iqaluit",
            "America/Montreal",
            "America/Nipigon",
            "America/Pangnirtung",
            "America/Thunder_Bay",
            "America/Detroit",
            "America/Indiana/Petersburg",
            "America/Indiana/Vincennes",
            "America/Indiana/Winamac",
            "America/Kentucky/Monticello",
            "America/Louisville",
            "EST5EDT"
        ],
        "(UTC-05:00) Eastern Time (US &amp; Canada)",
        "Eastern Standard Time",
        "Eastern Daylight Time",
        true,
        -300
    ],
    "America/Anguilla": "SA Western Standard Time",
    "Africa/Ouagadougou": "Greenwich Standard Time",
    "Etc/GMT-4": "Arabian Standard Time",
    "Atlantic/Azores": "Azores Standard Time",
    "Europe/Mariehamn": "FLE Standard Time",
    "Pacific/Saipan": "West Pacific Standard Time",
    "Etc/UTC": "UTC",
    "Australia/Currie": "Tasmania Standard Time",
    "America/Louisville": "Eastern Standard Time",
    "E. Africa Standard Time": [
        [
            "Africa/Nairobi",
            "Antarctica/Syowa",
            "Africa/Djibouti",
            "Africa/Asmera",
            "Africa/Addis_Ababa",
            "Indian/Comoro",
            "Indian/Antananarivo",
            "Africa/Khartoum",
            "Africa/Mogadishu",
            "Africa/Juba",
            "Africa/Dar_es_Salaam",
            "Africa/Kampala",
            "Indian/Mayotte",
            "Etc/GMT-3"
        ],
        "(UTC+03:00) Nairobi",
        "E. Africa Standard Time",
        "E. Africa Daylight Time",
        false,
        180
    ],
    "E. South America Standard Time": [
        [
            "America/Sao_Paulo"
        ],
        "(UTC-03:00) Brasilia",
        "E. South America Standard Time",
        "E. South America Daylight Time",
        true,
        -180
    ],
    "Europe/Uzhgorod": "FLE Standard Time",
    "America/El_Salvador": "Central America Standard Time",
    "Pacific/Johnston": "Hawaiian Standard Time",
    "Syria Standard Time": [
        [
            "Asia/Damascus"
        ],
        "(UTC+02:00) Damascus",
        "Syria Standard Time",
        "Syria Daylight Time",
        true,
        120
    ],
    "America/Toronto": "Eastern Standard Time",
    "Asia/Bishkek": "Central Asia Standard Time",
    "Atlantic/Canary": "GMT Standard Time",
    "America/Dawson": "Pacific Standard Time",
    "Bougainville Standard Time": [
        [
            "Pacific/Bougainville"
        ],
        "(UTC+11:00) Bougainville Island",
        "Bougainville Standard Time",
        "Bougainville Daylight Time",
        true,
        660
    ],
    "Alaskan Standard Time": [
        [
            "America/Anchorage",
            "America/Juneau",
            "America/Metlakatla",
            "America/Nome",
            "America/Sitka",
            "America/Yakutat"
        ],
        "(UTC-09:00) Alaska",
        "Alaskan Standard Time",
        "Alaskan Daylight Time",
        true,
        -540
    ],
    "America/Curacao": "SA Western Standard Time",
    "America/Eirunepe": "SA Pacific Standard Time",
    "Asia/Ust-Nera": "Vladivostok Standard Time",
    "SA Pacific Standard Time": [
        [
            "America/Bogota",
            "America/Rio_Branco",
            "America/Eirunepe",
            "America/Coral_Harbour",
            "America/Guayaquil",
            "America/Jamaica",
            "America/Cayman",
            "America/Panama",
            "America/Lima",
            "Etc/GMT+5"
        ],
        "(UTC-05:00) Bogota, Lima, Quito, Rio Branco",
        "SA Pacific Standard Time",
        "SA Pacific Daylight Time",
        false,
        -300
    ],
    "Africa/Lome": "Greenwich Standard Time",
    "Pacific/Pago_Pago": "UTC-11",
    "America/Cambridge_Bay": "Mountain Standard Time",
    "America/Indianapolis": "US Eastern Standard Time",
    "America/Indiana/Vevay": "US Eastern Standard Time",
    "Antarctica/Davis": "SE Asia Standard Time",
    "Asia/Srednekolymsk": "Russia Time Zone 10",
    "America/Bogota": "SA Pacific Standard Time",
    "Europe/Saratov": "Astrakhan Standard Time",
    "UTC+13": [
        null,
        "(UTC+13:00) Coordinated Universal Time+13",
        "UTC+13",
        "UTC+13",
        false,
        780
    ],
    "Europe/Vatican": "W. Europe Standard Time",
    "Belarus Standard Time": [
        [
            "Europe/Minsk"
        ],
        "(UTC+03:00) Minsk",
        "Belarus Standard Time",
        "Belarus Daylight Time",
        true,
        180
    ],
    "Europe/Riga": "FLE Standard Time",
    "Arctic/Longyearbyen": "W. Europe Standard Time",
    "Asia/Tashkent": "West Asia Standard Time",
    "America/Guadeloupe": "SA Western Standard Time",
    "Africa/Conakry": "Greenwich Standard Time",
    "America/Port-au-Prince": "Haiti Standard Time",
    "America/Belize": "Central America Standard Time",
    "South Africa Standard Time": [
        [
            "Africa/Johannesburg",
            "Africa/Bujumbura",
            "Africa/Gaborone",
            "Africa/Lubumbashi",
            "Africa/Maseru",
            "Africa/Blantyre",
            "Africa/Maputo",
            "Africa/Kigali",
            "Africa/Mbabane",
            "Africa/Lusaka",
            "Africa/Harare",
            "Etc/GMT-2"
        ],
        "(UTC+02:00) Harare, Pretoria",
        "South Africa Standard Time",
        "South Africa Daylight Time",
        false,
        120
    ],
    "Europe/Warsaw": "Central European Standard Time",
    "Africa/Dakar": "Greenwich Standard Time",
    "UTC-08": [
        [
            "Etc/GMT+8",
            "Pacific/Pitcairn"
        ],
        "(UTC-08:00) Coordinated Universal Time-08",
        "UTC-08",
        "UTC-08",
        false,
        -480
    ],
    "America/Vancouver": "Pacific Standard Time",
    "Europe/Ulyanovsk": "Astrakhan Standard Time",
    "Europe/Amsterdam": "W. Europe Standard Time",
    "Cuba Standard Time": [
        [
            "America/Havana"
        ],
        "(UTC-05:00) Havana",
        "Cuba Standard Time",
        "Cuba Daylight Time",
        true,
        -300
    ],
    "Asia/Baku": "Azerbaijan Standard Time",
    "Asia/Ulaanbaatar": "Ulaanbaatar Standard Time",
    "America/Argentina/Rio_Gallegos": "Argentina Standard Time",
    "North Korea Standard Time": [
        [
            "Asia/Pyongyang"
        ],
        "(UTC+08:30) Pyongyang",
        "North Korea Standard Time",
        "North Korea Daylight Time",
        true,
        510
    ],
    "Indian/Maldives": "West Asia Standard Time",
    "SA Western Standard Time": [
        [
            "America/La_Paz",
            "America/Antigua",
            "America/Anguilla",
            "America/Aruba",
            "America/Barbados",
            "America/St_Barthelemy",
            "America/Kralendijk",
            "America/Manaus",
            "America/Boa_Vista",
            "America/Porto_Velho",
            "America/Blanc-Sablon",
            "America/Curacao",
            "America/Dominica",
            "America/Santo_Domingo",
            "America/Grenada",
            "America/Guadeloupe",
            "America/Guyana",
            "America/St_Kitts",
            "America/St_Lucia",
            "America/Marigot",
            "America/Martinique",
            "America/Montserrat",
            "America/Puerto_Rico",
            "America/Lower_Princes",
            "America/Port_of_Spain",
            "America/St_Vincent",
            "America/Tortola",
            "America/St_Thomas",
            "Etc/GMT+4"
        ],
        "(UTC-04:00) Georgetown, La Paz, Manaus, San Juan",
        "SA Western Standard Time",
        "SA Western Daylight Time",
        false,
        -240
    ],
    "Central Pacific Standard Time": [
        [
            "Pacific/Guadalcanal",
            "Antarctica/Casey",
            "Antarctica/Macquarie",
            "Pacific/Ponape",
            "Pacific/Kosrae",
            "Pacific/Noumea",
            "Pacific/Efate",
            "Etc/GMT-11"
        ],
        "(UTC+11:00) Solomon Is., New Caledonia",
        "Central Pacific Standard Time",
        "Central Pacific Daylight Time",
        false,
        660
    ],
    "America/Dawson_Creek": "US Mountain Standard Time",
    "Africa/Dar_es_Salaam": "E. Africa Standard Time",
    "America/Rankin_Inlet": "Central Standard Time",
    "America/Antigua": "SA Western Standard Time",
    "Asia/Thimphu": "Bangladesh Standard Time",
    "Chatham Islands Standard Time": [
        [
            "Pacific/Chatham"
        ],
        "(UTC+12:45) Chatham Islands",
        "Chatham Islands Standard Time",
        "Chatham Islands Daylight Time",
        true,
        765
    ],
    "America/North_Dakota/New_Salem": "Central Standard Time",
    "America/Ojinaga": "Mountain Standard Time",
    "Africa/Asmera": "E. Africa Standard Time",
    "Europe/San_Marino": "W. Europe Standard Time",
    "Pacific/Pitcairn": "UTC-08",
    "Europe/Isle_of_Man": "GMT Standard Time",
    "North Asia Standard Time": [
        [
            "Asia/Krasnoyarsk",
            "Asia/Novokuznetsk"
        ],
        "(UTC+07:00) Krasnoyarsk",
        "Russia TZ 6 Standard Time",
        "Russia TZ 6 Daylight Time",
        true,
        420
    ],
    "America/Danmarkshavn": "UTC",
    "America/Mexico_City": "Central Standard Time (Mexico)",
    "Africa/Banjul": "Greenwich Standard Time",
    "Europe/Zurich": "W. Europe Standard Time",
    "America/St_Johns": "Newfoundland Standard Time",
    "Pacific/Apia": "Samoa Standard Time",
    "Pacific/Niue": "UTC-11",
    "Etc/GMT-3": "E. Africa Standard Time",
    "America/Fortaleza": "SA Eastern Standard Time",
    "China Standard Time": [
        [
            "Asia/Shanghai",
            "Asia/Hong_Kong",
            "Asia/Macau"
        ],
        "(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi",
        "China Standard Time",
        "China Daylight Time",
        false,
        480
    ],
    "America/Mazatlan": "Mountain Standard Time (Mexico)",
    "Asia/Samarkand": "West Asia Standard Time",
    "America/Adak": "Aleutian Standard Time",
    "Russia Time Zone 3": [
        [
            "Europe/Samara"
        ],
        "(UTC+04:00) Izhevsk, Samara",
        "Russia TZ 3 Standard Time",
        "Russia TZ 3 Daylight Time",
        true,
        240
    ],
    "Taipei Standard Time": [
        [
            "Asia/Taipei"
        ],
        "(UTC+08:00) Taipei",
        "Taipei Standard Time",
        "Taipei Daylight Time",
        false,
        480
    ],
    "America/Montreal": "Eastern Standard Time",
    "Russia Time Zone 11": [
        [
            "Asia/Kamchatka",
            "Asia/Anadyr"
        ],
        "(UTC+12:00) Anadyr, Petropavlovsk-Kamchatsky",
        "Russia TZ 11 Standard Time",
        "Russia TZ 11 Daylight Time",
        true,
        720
    ],
    "Arabian Standard Time": [
        [
            "Asia/Dubai",
            "Asia/Muscat",
            "Etc/GMT-4"
        ],
        "(UTC+04:00) Abu Dhabi, Muscat",
        "Arabian Standard Time",
        "Arabian Daylight Time",
        false,
        240
    ],
    "Asia/Oral": "West Asia Standard Time",
    "Asia/Brunei": "Singapore Standard Time",
    "Bangladesh Standard Time": [
        [
            "Asia/Dhaka",
            "Asia/Thimphu"
        ],
        "(UTC+06:00) Dhaka",
        "Bangladesh Standard Time",
        "Bangladesh Daylight Time",
        true,
        360
    ],
    "America/Bahia_Banderas": "Central Standard Time (Mexico)",
    "Africa/Khartoum": "E. Africa Standard Time",
    "Asia/Hovd": "W. Mongolia Standard Time",
    "Antarctica/Mawson": "West Asia Standard Time",
    "Africa/Maseru": "South Africa Standard Time",
    "Asia/Aqtau": "West Asia Standard Time",
    "Europe/Chisinau": "E. Europe Standard Time",
    "Africa/Douala": "W. Central Africa Standard Time",
    "Asia/Hong_Kong": "China Standard Time",
    "Africa/Ndjamena": "W. Central Africa Standard Time",
    "Indian/Reunion": "Mauritius Standard Time",
    "Asia/Krasnoyarsk": "North Asia Standard Time",
    "America/Buenos_Aires": "Argentina Standard Time",
    "America/Grand_Turk": "Turks And Caicos Standard Time",
    "US Eastern Standard Time": [
        [
            "America/Indianapolis",
            "America/Indiana/Marengo",
            "America/Indiana/Vevay"
        ],
        "(UTC-05:00) Indiana (East)",
        "US Eastern Standard Time",
        "US Eastern Daylight Time",
        true,
        -300
    ],
    "Etc/GMT-6": "Central Asia Standard Time",
    "Europe/Monaco": "W. Europe Standard Time",
    "W. Europe Standard Time": [
        [
            "Europe/Berlin",
            "Europe/Andorra",
            "Europe/Vienna",
            "Europe/Zurich",
            "Europe/Busingen",
            "Europe/Gibraltar",
            "Europe/Rome",
            "Europe/Vaduz",
            "Europe/Luxembourg",
            "Europe/Monaco",
            "Europe/Malta",
            "Europe/Amsterdam",
            "Europe/Oslo",
            "Europe/Stockholm",
            "Arctic/Longyearbyen",
            "Europe/San_Marino",
            "Europe/Vatican"
        ],
        "(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna",
        "W. Europe Standard Time",
        "W. Europe Daylight Time",
        true,
        60
    ],
    "America/Montevideo": "Montevideo Standard Time",
    "America/St_Thomas": "SA Western Standard Time",
    "Africa/Monrovia": "Greenwich Standard Time",
    "Etc/GMT-8": "Singapore Standard Time",
    "Saint Pierre Standard Time": [
        [
            "America/Miquelon"
        ],
        "(UTC-03:00) Saint Pierre and Miquelon",
        "Saint Pierre Standard Time",
        "Saint Pierre Daylight Time",
        true,
        -180
    ],
    "America/Coral_Harbour": "SA Pacific Standard Time",
    "Africa/Djibouti": "E. Africa Standard Time",
    "Asia/Kabul": "Afghanistan Standard Time",
    "America/Port_of_Spain": "SA Western Standard Time",
    "Atlantic/Reykjavik": "Greenwich Standard Time",
    "Central Standard Time": [
        [
            "America/Chicago",
            "America/Winnipeg",
            "America/Rainy_River",
            "America/Rankin_Inlet",
            "America/Resolute",
            "America/Matamoros",
            "America/Indiana/Knox",
            "America/Indiana/Tell_City",
            "America/Menominee",
            "America/North_Dakota/Beulah",
            "America/North_Dakota/Center",
            "America/North_Dakota/New_Salem",
            "CST6CDT"
        ],
        "(UTC-06:00) Central Time (US &amp; Canada)",
        "Central Standard Time",
        "Central Daylight Time",
        true,
        -360
    ],
    "Australia/Melbourne": "AUS Eastern Standard Time",
    "Africa/Freetown": "Greenwich Standard Time",
    "Asia/Atyrau": "West Asia Standard Time",
    "Africa/Lagos": "W. Central Africa Standard Time",
    "Europe/Helsinki": "FLE Standard Time",
    "Asia/Karachi": "Pakistan Standard Time",
    "America/Regina": "Canada Central Standard Time",
    "Tocantins Standard Time": [
        [
            "America/Araguaina"
        ],
        "(UTC-03:00) Araguaina",
        "Tocantins Standard Time",
        "Tocantins Daylight Time",
        true,
        -180
    ],
    "Antarctica/Rothera": "SA Eastern Standard Time",
    "Etc/GMT+3": "SA Eastern Standard Time",
    "Dateline Standard Time": [
        [
            "Etc/GMT+12"
        ],
        "(UTC-12:00) International Date Line West",
        "Dateline Standard Time",
        "Dateline Daylight Time",
        false,
        -720
    ],
    "Australia/Sydney": "AUS Eastern Standard Time",
    "Etc/GMT+12": "Dateline Standard Time",
    "PST8PDT": "Pacific Standard Time",
    "Canada Central Standard Time": [
        [
            "America/Regina",
            "America/Swift_Current"
        ],
        "(UTC-06:00) Saskatchewan",
        "Canada Central Standard Time",
        "Canada Central Daylight Time",
        false,
        -360
    ],
    "Lord Howe Standard Time": [
        [
            "Australia/Lord_Howe"
        ],
        "(UTC+10:30) Lord Howe Island",
        "Lord Howe Standard Time",
        "Lord Howe Daylight Time",
        true,
        630
    ],
    "Europe/Busingen": "W. Europe Standard Time",
    "Turkey Standard Time": [
        [
            "Europe/Istanbul",
            "Asia/Famagusta"
        ],
        "(UTC+03:00) Istanbul",
        "Turkey Standard Time",
        "Turkey Daylight Time",
        true,
        180
    ],
    "Africa/Bamako": "Greenwich Standard Time",
    "America/Grenada": "SA Western Standard Time",
    "America/Kralendijk": "SA Western Standard Time",
    "America/Indiana/Petersburg": "Eastern Standard Time",
    "Etc/GMT+4": "SA Western Standard Time",
    "GTB Standard Time": [
        [
            "Europe/Bucharest",
            "Asia/Nicosia",
            "Europe/Athens"
        ],
        "(UTC+02:00) Athens, Bucharest",
        "GTB Standard Time",
        "GTB Daylight Time",
        true,
        120
    ],
    "Asia/Vientiane": "SE Asia Standard Time",
    "Africa/Lusaka": "South Africa Standard Time",
    "Europe/Oslo": "W. Europe Standard Time",
    "Australia/Hobart": "Tasmania Standard Time",
    "Central Asia Standard Time": [
        [
            "Asia/Almaty",
            "Antarctica/Vostok",
            "Asia/Urumqi",
            "Indian/Chagos",
            "Asia/Bishkek",
            "Asia/Qyzylorda",
            "Etc/GMT-6"
        ],
        "(UTC+06:00) Astana",
        "Central Asia Standard Time",
        "Central Asia Daylight Time",
        false,
        360
    ],
    "Etc/GMT+7": "US Mountain Standard Time",
    "Kaliningrad Standard Time": [
        [
            "Europe/Kaliningrad"
        ],
        "(UTC+02:00) Kaliningrad",
        "Russia TZ 1 Standard Time",
        "Russia TZ 1 Daylight Time",
        true,
        120
    ],
    "Yakutsk Standard Time": [
        [
            "Asia/Yakutsk",
            "Asia/Khandyga"
        ],
        "(UTC+09:00) Yakutsk",
        "Russia TZ 8 Standard Time",
        "Russia TZ 8 Daylight Time",
        true,
        540
    ],
    "Caucasus Standard Time": [
        [
            "Asia/Yerevan"
        ],
        "(UTC+04:00) Yerevan",
        "Caucasus Standard Time",
        "Caucasus Daylight Time",
        true,
        240
    ],
    "EST5EDT": "Eastern Standard Time",
    "Egypt Standard Time": [
        [
            "Africa/Cairo"
        ],
        "(UTC+02:00) Cairo",
        "Egypt Standard Time",
        "Egypt Daylight Time",
        true,
        120
    ],
    "Europe/Dublin": "GMT Standard Time",
    "Pacific/Norfolk": "Norfolk Standard Time",
    "Arabic Standard Time": [
        [
            "Asia/Baghdad"
        ],
        "(UTC+03:00) Baghdad",
        "Arabic Standard Time",
        "Arabic Daylight Time",
        true,
        180
    ],
    "Antarctica/Casey": "Central Pacific Standard Time",
    "America/Porto_Velho": "SA Western Standard Time",
    "Pakistan Standard Time": [
        [
            "Asia/Karachi"
        ],
        "(UTC+05:00) Islamabad, Karachi",
        "Pakistan Standard Time",
        "Pakistan Daylight Time",
        true,
        300
    ],
    "SE Asia Standard Time": [
        [
            "Asia/Bangkok",
            "Antarctica/Davis",
            "Indian/Christmas",
            "Asia/Jakarta",
            "Asia/Pontianak",
            "Asia/Phnom_Penh",
            "Asia/Vientiane",
            "Asia/Saigon",
            "Etc/GMT-7"
        ],
        "(UTC+07:00) Bangkok, Hanoi, Jakarta",
        "SE Asia Standard Time",
        "SE Asia Daylight Time",
        false,
        420
    ],
    "Asia/Hebron": "West Bank Standard Time",
    "Africa/Windhoek": "Namibia Standard Time",
    "SA Eastern Standard Time": [
        [
            "America/Cayenne",
            "Antarctica/Rothera",
            "Antarctica/Palmer",
            "America/Fortaleza",
            "America/Belem",
            "America/Maceio",
            "America/Recife",
            "America/Santarem",
            "America/Punta_Arenas",
            "Atlantic/Stanley",
            "America/Paramaribo",
            "Etc/GMT+3"
        ],
        "(UTC-03:00) Cayenne, Fortaleza",
        "SA Eastern Standard Time",
        "SA Eastern Daylight Time",
        false,
        -180
    ],
    "Asia/Tokyo": "Tokyo Standard Time",
    "Pacific/Honolulu": "Hawaiian Standard Time",
    "Asia/Magadan": "Magadan Standard Time",
    "Omsk Standard Time": [
        [
            "Asia/Omsk"
        ],
        "(UTC+06:00) Omsk",
        "Omsk Standard Time",
        "Omsk Daylight Time",
        true,
        360
    ],
    "America/New_York": "Eastern Standard Time",
    "Europe/Berlin": "W. Europe Standard Time",
    "Easter Island Standard Time": [
        [
            "Pacific/Easter"
        ],
        "(UTC-06:00) Easter Island",
        "Easter Island Standard Time",
        "Easter Island Daylight Time",
        true,
        -360
    ],
    "Central America Standard Time": [
        [
            "America/Guatemala",
            "America/Belize",
            "America/Costa_Rica",
            "Pacific/Galapagos",
            "America/Tegucigalpa",
            "America/Managua",
            "America/El_Salvador",
            "Etc/GMT+6"
        ],
        "(UTC-06:00) Central America",
        "Central America Standard Time",
        "Central America Daylight Time",
        false,
        -360
    ],
    "N. Central Asia Standard Time": [
        [
            "Asia/Novosibirsk"
        ],
        "(UTC+07:00) Novosibirsk",
        "Novosibirsk Standard Time",
        "Novosibirsk Daylight Time",
        true,
        420
    ],
    "Asia/Rangoon": "Myanmar Standard Time",
    "America/Argentina/La_Rioja": "Argentina Standard Time",
    "Myanmar Standard Time": [
        [
            "Asia/Rangoon",
            "Indian/Cocos"
        ],
        "(UTC+06:30) Yangon (Rangoon)",
        "Myanmar Standard Time",
        "Myanmar Daylight Time",
        false,
        390
    ],
    "Etc/GMT-12": "UTC+12",
    "Africa/Juba": "E. Africa Standard Time",
    "Etc/GMT-11": "Central Pacific Standard Time",
    "America/Yakutat": "Alaskan Standard Time",
    "Pacific/Port_Moresby": "West Pacific Standard Time",
    "Atlantic/South_Georgia": "UTC-02",
    "Australia/Darwin": "AUS Central Standard Time",
    "America/Nipigon": "Eastern Standard Time",
    "America/Panama": "SA Pacific Standard Time",
    "America/Cordoba": "Argentina Standard Time",
    "Europe/Stockholm": "W. Europe Standard Time",
    "America/Rio_Branco": "SA Pacific Standard Time",
    "Europe/Prague": "Central Europe Standard Time",
    "Antarctica/Palmer": "SA Eastern Standard Time",
    "America/Whitehorse": "Pacific Standard Time",
    "Pacific/Enderbury": "Tonga Standard Time",
    "UTC+12": [
        [
            "Etc/GMT-12",
            "Pacific/Tarawa",
            "Pacific/Majuro",
            "Pacific/Kwajalein",
            "Pacific/Nauru",
            "Pacific/Funafuti",
            "Pacific/Wake",
            "Pacific/Wallis"
        ],
        "(UTC+12:00) Coordinated Universal Time+12",
        "UTC+12",
        "UTC+12",
        false,
        720
    ],
    "UTC-09": [
        [
            "Etc/GMT+9",
            "Pacific/Gambier"
        ],
        "(UTC-09:00) Coordinated Universal Time-09",
        "UTC-09",
        "UTC-09",
        false,
        -540
    ],
    "AUS Central Standard Time": [
        [
            "Australia/Darwin"
        ],
        "(UTC+09:30) Darwin",
        "AUS Central Standard Time",
        "AUS Central Daylight Time",
        false,
        570
    ],
    "Line Islands Standard Time": [
        [
            "Pacific/Kiritimati",
            "Etc/GMT-14"
        ],
        "(UTC+14:00) Kiritimati Island",
        "Line Islands Standard Time",
        "Line Islands Daylight Time",
        false,
        840
    ],
    "Africa/Mbabane": "South Africa Standard Time",
    "Asia/Dushanbe": "West Asia Standard Time",
    "America/Indiana/Marengo": "US Eastern Standard Time",
    "America/Punta_Arenas": "SA Eastern Standard Time",
    "America/Maceio": "SA Eastern Standard Time",
    "America/Menominee": "Central Standard Time",
    "America/Anchorage": "Alaskan Standard Time",
    "Norfolk Standard Time": [
        [
            "Pacific/Norfolk"
        ],
        "(UTC+11:00) Norfolk Island",
        "Norfolk Standard Time",
        "Norfolk Daylight Time",
        true,
        660
    ],
    "America/Monterrey": "Central Standard Time (Mexico)",
    "America/Paramaribo": "SA Eastern Standard Time",
    "Africa/Gaborone": "South Africa Standard Time",
    "Morocco Standard Time": [
        [
            "Africa/Casablanca",
            "Africa/El_Aaiun"
        ],
        "(UTC+00:00) Casablanca",
        "Morocco Standard Time",
        "Morocco Daylight Time",
        true,
        0
    ],
    "Australia/Brisbane": "E. Australia Standard Time",
    "West Bank Standard Time": [
        [
            "Asia/Hebron",
            "Asia/Gaza"
        ],
        "(UTC+02:00) Gaza, Hebron",
        "West Bank Gaza Standard Time",
        "West Bank Gaza Daylight Time",
        true,
        120
    ],
    "America/St_Barthelemy": "SA Western Standard Time",
    "America/Montserrat": "SA Western Standard Time",
    "America/St_Vincent": "SA Western Standard Time",
    "America/Goose_Bay": "Atlantic Standard Time",
    "America/Argentina/Salta": "Argentina Standard Time",
    "Europe/Malta": "W. Europe Standard Time",
    "Australia/Perth": "W. Australia Standard Time",
    "Azerbaijan Standard Time": [
        [
            "Asia/Baku"
        ],
        "(UTC+04:00) Baku",
        "Azerbaijan Standard Time",
        "Azerbaijan Daylight Time",
        true,
        240
    ],
    "Asia/Katmandu": "Nepal Standard Time",
    "Pacific/Bougainville": "Bougainville Standard Time",
    "Asia/Phnom_Penh": "SE Asia Standard Time",
    "Africa/Porto-Novo": "W. Central Africa Standard Time",
    "America/Tortola": "SA Western Standard Time",
    "Tomsk Standard Time": [
        [
            "Asia/Tomsk"
        ],
        "(UTC+07:00) Tomsk",
        "Tomsk Standard Time",
        "Tomsk Daylight Time",
        true,
        420
    ],
    "Romance Standard Time": [
        [
            "Europe/Paris",
            "Europe/Brussels",
            "Europe/Copenhagen",
            "Europe/Madrid",
            "Africa/Ceuta"
        ],
        "(UTC+01:00) Brussels, Copenhagen, Madrid, Paris",
        "Romance Standard Time",
        "Romance Daylight Time",
        true,
        60
    ],
    "America/Matamoros": "Central Standard Time",
    "America/Bahia": "Bahia Standard Time",
    "Indian/Chagos": "Central Asia Standard Time",
    "America/Godthab": "Greenland Standard Time",
    "Africa/Luanda": "W. Central Africa Standard Time",
    "America/Resolute": "Central Standard Time",
    "Asia/Omsk": "Omsk Standard Time",
    "Indian/Christmas": "SE Asia Standard Time",
    "Africa/El_Aaiun": "Morocco Standard Time",
    "America/Metlakatla": "Alaskan Standard Time",
    "Europe/Athens": "GTB Standard Time",
    "Asia/Kuala_Lumpur": "Singapore Standard Time",
    "Europe/Zaporozhye": "FLE Standard Time",
    "Asia/Khandyga": "Yakutsk Standard Time",
    "Arab Standard Time": [
        [
            "Asia/Riyadh",
            "Asia/Bahrain",
            "Asia/Kuwait",
            "Asia/Qatar",
            "Asia/Aden"
        ],
        "(UTC+03:00) Kuwait, Riyadh",
        "Arab Standard Time",
        "Arab Daylight Time",
        false,
        180
    ],
    "America/Moncton": "Atlantic Standard Time",
    "Europe/Bratislava": "Central Europe Standard Time",
    "Etc/GMT-2": "South Africa Standard Time",
    "Antarctica/Syowa": "E. Africa Standard Time",
    "Etc/GMT+11": "UTC-11",
    "America/Argentina/San_Juan": "Argentina Standard Time",
    "Asia/Ashgabat": "West Asia Standard Time",
    "Indian/Comoro": "E. Africa Standard Time",
    "Asia/Shanghai": "China Standard Time",
    "Asia/Yakutsk": "Yakutsk Standard Time",
    "Aus Central W. Standard Time": [
        [
            "Australia/Eucla"
        ],
        "(UTC+08:45) Eucla",
        "Aus Central W. Standard Time",
        "Aus Central W. Daylight Time",
        false,
        525
    ],
    "America/Managua": "Central America Standard Time",
    "Africa/Nouakchott": "Greenwich Standard Time",
    "America/North_Dakota/Center": "Central Standard Time",
    "Africa/Algiers": "W. Central Africa Standard Time",
    "Europe/Rome": "W. Europe Standard Time",
    "Pacific/Wallis": "UTC+12",
    "Europe/Tallinn": "FLE Standard Time",
    "Australia/Broken_Hill": "Cen. Australia Standard Time",
    "Etc/GMT-14": "Line Islands Standard Time",
    "Africa/Casablanca": "Morocco Standard Time",
    "Pacific Standard Time": [
        [
            "America/Los_Angeles",
            "America/Vancouver",
            "America/Dawson",
            "America/Whitehorse",
            "PST8PDT"
        ],
        "(UTC-08:00) Pacific Time (US &amp; Canada)",
        "Pacific Standard Time",
        "Pacific Daylight Time",
        true,
        -480
    ],
    "Pacific/Galapagos": "Central America Standard Time",
    "Africa/Bissau": "Greenwich Standard Time",
    "Pacific/Fiji": "Fiji Standard Time",
    "Asia/Kuwait": "Arab Standard Time",
    "America/Cuiaba": "Central Brazilian Standard Time",
    "Pacific/Funafuti": "UTC+12",
    "Etc/GMT-7": "SE Asia Standard Time",
    "Africa/Kampala": "E. Africa Standard Time",
    "Europe/Istanbul": "Turkey Standard Time",
    "America/Thunder_Bay": "Eastern Standard Time",
    "America/Creston": "US Mountain Standard Time",
    "Pacific/Easter": "Easter Island Standard Time",
    "Middle East Standard Time": [
        [
            "Asia/Beirut"
        ],
        "(UTC+02:00) Beirut",
        "Middle East Standard Time",
        "Middle East Daylight Time",
        true,
        120
    ],
    "America/Detroit": "Eastern Standard Time",
    "America/Cancun": "Eastern Standard Time (Mexico)",
    "Asia/Macau": "China Standard Time",
    "Eastern Standard Time (Mexico)": [
        [
            "America/Cancun"
        ],
        "(UTC-05:00) Chetumal",
        "Eastern Standard Time (Mexico)",
        "Eastern Daylight Time (Mexico)",
        true,
        -300
    ],
    "America/Indiana/Vincennes": "Eastern Standard Time",
    "Asia/Bahrain": "Arab Standard Time",
    "Argentina Standard Time": [
        [
            "America/Buenos_Aires",
            "America/Argentina/La_Rioja",
            "America/Argentina/Rio_Gallegos",
            "America/Argentina/Salta",
            "America/Argentina/San_Juan",
            "America/Argentina/San_Luis",
            "America/Argentina/Tucuman",
            "America/Argentina/Ushuaia",
            "America/Catamarca",
            "America/Cordoba",
            "America/Jujuy",
            "America/Mendoza"
        ],
        "(UTC-03:00) City of Buenos Aires",
        "Argentina Standard Time",
        "Argentina Daylight Time",
        true,
        -180
    ],
    "Asia/Irkutsk": "North Asia East Standard Time",
    "Asia/Novosibirsk": "N. Central Asia Standard Time",
    "America/Noronha": "UTC-02",
    "Africa/Maputo": "South Africa Standard Time",
    "America/Sao_Paulo": "E. South America Standard Time",
    "Europe/Podgorica": "Central Europe Standard Time",
    "Etc/GMT+2": "UTC-02",
    "Pacific/Marquesas": "Marquesas Standard Time",
    "America/Blanc-Sablon": "SA Western Standard Time",
    "Asia/Yerevan": "Caucasus Standard Time",
    "Atlantic/Cape_Verde": "Cape Verde Standard Time",
    "Pacific/Auckland": "New Zealand Standard Time",
    "America/Phoenix": "US Mountain Standard Time",
    "Pacific/Truk": "West Pacific Standard Time",
    "Greenland Standard Time": [
        [
            "America/Godthab"
        ],
        "(UTC-03:00) Greenland",
        "Greenland Standard Time",
        "Greenland Daylight Time",
        true,
        -180
    ],
    "Africa/Mogadishu": "E. Africa Standard Time",
    "Pacific SA Standard Time": [
        [
            "America/Santiago"
        ],
        "(UTC-04:00) Santiago",
        "Pacific SA Standard Time",
        "Pacific SA Daylight Time",
        true,
        -240
    ],
    "Asia/Urumqi": "Central Asia Standard Time",
    "Asia/Chita": "Transbaikal Standard Time",
    "America/Lima": "SA Pacific Standard Time",
    "Australia/Eucla": "Aus Central W. Standard Time",
    "Asia/Damascus": "Syria Standard Time",
    "Europe/Minsk": "Belarus Standard Time",
    "Africa/Bujumbura": "South Africa Standard Time",
    "Asia/Makassar": "Singapore Standard Time",
    "Saratov Standard Time": [
        null,
        "(UTC+04:00) Saratov",
        "Saratov Standard Time",
        "Saratov Daylight Time",
        true,
        240
    ],
    "Ulaanbaatar Standard Time": [
        [
            "Asia/Ulaanbaatar",
            "Asia/Choibalsan"
        ],
        "(UTC+08:00) Ulaanbaatar",
        "Ulaanbaatar Standard Time",
        "Ulaanbaatar Daylight Time",
        true,
        480
    ],
    "Asia/Amman": "Jordan Standard Time",
    "Tonga Standard Time": [
        [
            "Pacific/Tongatapu",
            "Pacific/Enderbury",
            "Pacific/Fakaofo",
            "Etc/GMT-13"
        ],
        "(UTC+13:00) Nuku'alofa",
        "Tonga Standard Time",
        "Tonga Daylight Time",
        true,
        780
    ],
    "Atlantic/St_Helena": "Greenwich Standard Time",
    "America/Santiago": "Pacific SA Standard Time",
    "UTC-02": [
        [
            "Etc/GMT+2",
            "America/Noronha",
            "Atlantic/South_Georgia"
        ],
        "(UTC-02:00) Coordinated Universal Time-02",
        "UTC-02",
        "UTC-02",
        false,
        -120
    ],
    "Europe/Luxembourg": "W. Europe Standard Time",
    "Africa/Cairo": "Egypt Standard Time",
    "America/Recife": "SA Eastern Standard Time",
    "America/Indiana/Tell_City": "Central Standard Time",
    "Africa/Niamey": "W. Central Africa Standard Time",
    "America/Juneau": "Alaskan Standard Time",
    "Asia/Qyzylorda": "Central Asia Standard Time",
    "Asia/Bangkok": "SE Asia Standard Time",
    "Magadan Standard Time": [
        [
            "Asia/Magadan"
        ],
        "(UTC+11:00) Magadan",
        "Magadan Standard Time",
        "Magadan Daylight Time",
        true,
        660
    ],
    "Africa/Johannesburg": "South Africa Standard Time",
    "America/Santa_Isabel": "Pacific Standard Time (Mexico)",
    "Astrakhan Standard Time": [
        [
            "Europe/Astrakhan",
            "Europe/Saratov",
            "Europe/Ulyanovsk"
        ],
        "(UTC+04:00) Astrakhan, Ulyanovsk",
        "Astrakhan Standard Time",
        "Astrakhan Daylight Time",
        true,
        240
    ],
    "America/Cayenne": "SA Eastern Standard Time",
    "Africa/Tripoli": "Libya Standard Time",
    "Africa/Bangui": "W. Central Africa Standard Time",
    "Asia/Tomsk": "Tomsk Standard Time",
    "Central Brazilian Standard Time": [
        [
            "America/Cuiaba",
            "America/Campo_Grande"
        ],
        "(UTC-04:00) Cuiaba",
        "Central Brazilian Standard Time",
        "Central Brazilian Daylight Time",
        true,
        -240
    ],
    "Africa/Harare": "South Africa Standard Time",
    "Europe/Kaliningrad": "Kaliningrad Standard Time",
    "Israel Standard Time": [
        [
            "Asia/Jerusalem"
        ],
        "(UTC+02:00) Jerusalem",
        "Jerusalem Standard Time",
        "Jerusalem Daylight Time",
        true,
        120
    ],
    "E. Australia Standard Time": [
        [
            "Australia/Brisbane",
            "Australia/Lindeman"
        ],
        "(UTC+10:00) Brisbane",
        "E. Australia Standard Time",
        "E. Australia Daylight Time",
        false,
        600
    ],
    "America/Marigot": "SA Western Standard Time",
    "Asia/Dhaka": "Bangladesh Standard Time",
    "Etc/GMT-10": "West Pacific Standard Time",
    "Europe/Paris": "Romance Standard Time",
    "America/Nome": "Alaskan Standard Time",
    "America/Belem": "SA Eastern Standard Time",
    "Africa/Sao_Tome": "Greenwich Standard Time",
    "Asia/Taipei": "Taipei Standard Time",
    "Pacific/Chatham": "Chatham Islands Standard Time",
    "Asia/Vladivostok": "Vladivostok Standard Time",
    "Vladivostok Standard Time": [
        [
            "Asia/Vladivostok",
            "Asia/Ust-Nera"
        ],
        "(UTC+10:00) Vladivostok",
        "Russia TZ 9 Standard Time",
        "Russia TZ 9 Daylight Time",
        true,
        600
    ],
    "America/Tijuana": "Pacific Standard Time (Mexico)",
    "Etc/GMT-13": "Tonga Standard Time",
    "Pacific/Guadalcanal": "Central Pacific Standard Time",
    "Indian/Antananarivo": "E. Africa Standard Time",
    "Africa/Ceuta": "Romance Standard Time",
    "America/Jujuy": "Argentina Standard Time",
    "Cape Verde Standard Time": [
        [
            "Atlantic/Cape_Verde",
            "Etc/GMT+1"
        ],
        "(UTC-01:00) Cabo Verde Is.",
        "Cabo Verde Standard Time",
        "Cabo Verde Daylight Time",
        false,
        -60
    ],
    "GMT Standard Time": [
        [
            "Europe/London",
            "Atlantic/Canary",
            "Atlantic/Faeroe",
            "Europe/Guernsey",
            "Europe/Dublin",
            "Europe/Isle_of_Man",
            "Europe/Jersey",
            "Europe/Lisbon",
            "Atlantic/Madeira"
        ],
        "(UTC+00:00) Dublin, Edinburgh, Lisbon, London",
        "GMT Standard Time",
        "GMT Daylight Time",
        true,
        0
    ],
    "Bahia Standard Time": [
        [
            "America/Bahia"
        ],
        "(UTC-03:00) Salvador",
        "Bahia Standard Time",
        "Bahia Daylight Time",
        true,
        -180
    ]
};
exports.CustomTimeZoneMappingData = {
    'tzone://Microsoft/Utc': 'UTC'
};
/**
* TimeZoneInfo
*/
var TimeZoneInfo = (function () {
    function TimeZoneInfo(id, baseUtcOffset, displayName, standardDisplayName, daylightDisplayName, adjustmentRules, disableDaylightSavingTime) {
        this._ianaId = null;
        this._displayName = null;
        this._standardDisplayName = null;
        this._daylightDisplayName = null;
        this._supportsDaylightSavingTime = false;
        this._adjustmentRules = [];
        var adjustmentRulesSupportDst;
        //TimeZoneInfo.ValidateTimeZoneInfo(id, baseUtcOffset, adjustmentRules, adjustmentRulesSupportDst);
        this._id = id;
        this._baseUtcOffset = baseUtcOffset;
        this._displayName = displayName;
        this._standardDisplayName = standardDisplayName;
        this._daylightDisplayName = disableDaylightSavingTime ? null : daylightDisplayName;
        //this._supportsDaylightSavingTime = adjustmentRulesSupportDst && !disableDaylightSavingTime;
        this._adjustmentRules = adjustmentRules;
        var tzArray = exports.TimeZoneMappingData[id];
        if (ArrayHelper.isArray(tzArray)) {
            this._supportsDaylightSavingTime = tzArray[4] && !disableDaylightSavingTime;
        }
    }
    Object.defineProperty(TimeZoneInfo.prototype, "Id", {
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeZoneInfo.prototype, "IanaId", {
        get: function () {
            return this._ianaId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeZoneInfo.prototype, "DisplayName", {
        get: function () {
            return this._displayName || StringHelper.Empty;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeZoneInfo.prototype, "StandardName", {
        get: function () {
            return this._standardDisplayName || StringHelper.Empty;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeZoneInfo.prototype, "DaylightName", {
        get: function () {
            return this._daylightDisplayName || StringHelper.Empty;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeZoneInfo.prototype, "BaseUtcOffset", {
        get: function () {
            return this._baseUtcOffset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeZoneInfo.prototype, "SupportsDaylightSavingTime", {
        get: function () {
            return this._supportsDaylightSavingTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeZoneInfo, "Local", {
        get: function () {
            if (this._localTimeZone) {
                return this._localTimeZone;
            }
            return this.CreateLocal();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeZoneInfo, "Utc", {
        get: function () {
            return this.s_utcTimeZone;
        },
        enumerable: true,
        configurable: true
    });
    TimeZoneInfo.ConvertTime = function (dateTime, sourceTimeZone, destinationTimeZone) {
        if (sourceTimeZone == null) {
            throw new ArgumentNullException("sourceTimeZone");
        }
        if (destinationTimeZone == null) {
            throw new ArgumentNullException("destinationTimeZone");
        }
        var sourceKind = this.GetCorrespondingKind(sourceTimeZone);
        if (dateTime.Kind != DateTimeKind.Unspecified && dateTime.Kind != sourceKind) {
            throw new ArgumentException("DateTime Kind mismatch with source time", "sourceTimeZone");
        }
        var targetKind = this.GetCorrespondingKind(destinationTimeZone);
        // handle the special case of Loss-less Local->Local and UTC->UTC)
        if (dateTime.Kind != DateTimeKind.Unspecified && sourceKind != DateTimeKind.Unspecified && sourceKind == targetKind) {
            return dateTime;
        }
        var targetIanaId = destinationTimeZone._ianaId;
        if (StringHelper.IsNullOrEmpty(targetIanaId)) {
            if (StringHelper.IsNullOrEmpty(destinationTimeZone._id)) {
                throw new ArgumentException("Destination Timezone does not have valid identifier");
            }
            var targetTzData = exports.TimeZoneMappingData[destinationTimeZone._id];
            if (!ArrayHelper.isArray(targetTzData) || !ArrayHelper.isArray(targetTzData[0])) {
                throw new ArgumentException("Destination Timezone does not have valid identifier");
            }
            targetIanaId = targetTzData[0][0];
        }
        return new DateTime(dateTime.MomentDate.clone().tz(targetIanaId));
    };
    TimeZoneInfo.CreateLocal = function () {
        var tzGuess = moment.tz.guess();
        var offset = moment().utcOffset();
        if (StringHelper.IsNullOrEmpty(tzGuess) || StringHelper.IsNullOrEmpty(exports.TimeZoneMappingData[tzGuess])) {
            console.assert(false, "Unabele to guess timezone, switching to Utc");
            return this.Utc;
        }
        var tzArray = exports.TimeZoneMappingData[exports.TimeZoneMappingData[tzGuess]];
        if (ArrayHelper.isArray(tzArray)) {
            this._localTimeZone = new TimeZoneInfo(exports.TimeZoneMappingData[tzGuess], TimeSpan.FromMinutes(offset), tzArray[1], tzArray[2], tzArray[3], [], false);
        }
        else {
            this._localTimeZone = this.CreateCustomTimeZone(exports.TimeZoneMappingData[tzGuess], TimeSpan.FromMinutes(offset), exports.TimeZoneMappingData[tzGuess], exports.TimeZoneMappingData[tzGuess]);
        }
        this._localTimeZone._ianaId = tzGuess;
        return this._localTimeZone;
    };
    TimeZoneInfo.CreateCustomTimeZone = function (id, baseUtcOffset, displayName, standardDisplayName, daylightDisplayName, adjustmentRules, disableDaylightSavingTime) {
        if (daylightDisplayName === void 0) { daylightDisplayName = null; }
        if (adjustmentRules === void 0) { adjustmentRules = null; }
        if (disableDaylightSavingTime === void 0) { disableDaylightSavingTime = false; }
        if (!disableDaylightSavingTime && adjustmentRules && adjustmentRules.length > 0) {
            adjustmentRules = adjustmentRules.slice(0);
        }
        var tz = new TimeZoneInfo(id, baseUtcOffset, displayName, standardDisplayName, daylightDisplayName || standardDisplayName, adjustmentRules, disableDaylightSavingTime);
        if (id === this.UtcId) {
            tz._ianaId = id;
        }
        return tz;
    };
    TimeZoneInfo.AddTimeZoneMapping = function (source, mappedTz) {
        exports.CustomTimeZoneMappingData[source] = mappedTz;
    };
    TimeZoneInfo.FindSystemTimeZoneById = function (zoneName) {
        var ianaId = StringHelper.Empty;
        var winId = StringHelper.Empty;
        var mappedTz = exports.TimeZoneMappingData[zoneName];
        if (typeof mappedTz === 'undefined') {
            var zoneNameMapped = exports.CustomTimeZoneMappingData[zoneName];
            if (zoneNameMapped) {
                mappedTz = exports.TimeZoneMappingData[zoneNameMapped];
            }
            if (typeof mappedTz === 'undefined') {
                throw new Error("TimeZoneInfo->FromZoneName : Can not find zone name in mapped timezone data, try adding custom Map by calling TimeZoneInfo.AddTimeZoneMapping(sourceName, destinationName)");
            }
        }
        var tzArray = mappedTz;
        if (ArrayHelper.isArray(mappedTz)) {
            ianaId = mappedTz[0][0];
            winId = zoneName;
        }
        else {
            ianaId = zoneName;
            winId = mappedTz;
            tzArray = exports.TimeZoneMappingData[winId];
            if (!ArrayHelper.isArray(tzArray)) {
                throw new Error("TimeZoneInfo->FromZoneName : Invalid mapping data");
            }
        }
        var tzinfo = new TimeZoneInfo(winId, TimeSpan.FromMinutes(tzArray[5]), tzArray[1], tzArray[2], tzArray[3], [], !tzArray[4]);
        tzinfo._ianaId = ianaId;
        return tzinfo;
    };
    Object.defineProperty(TimeZoneInfo, "ListWindowsTimeZones", {
        get: function () {
            return function () { return Object.keys(exports.TimeZoneMappingData).filter(function (x) { return x.indexOf("/") < 0; }); };
        },
        enumerable: true,
        configurable: true
    });
    TimeZoneInfo.GetCorrespondingKind = function (timeZone) {
        if (timeZone === TimeZoneInfo.Utc)
            return DateTimeKind.Utc;
        if (timeZone === TimeZoneInfo.Local)
            return DateTimeKind.Local;
        return DateTimeKind.Unspecified;
    };
    TimeZoneInfo.GuessLocalTimeZone = function () {
        return moment.tz.guess();
    };
    TimeZoneInfo.prototype.HasSameRules = function (other) {
        if (other == null) {
            throw new ArgumentNullException("other");
        }
        // check the utcOffset and supportsDaylightSavingTime members
        return this._baseUtcOffset === other._baseUtcOffset && this._supportsDaylightSavingTime === other._supportsDaylightSavingTime;
    };
    // static get Utc(): TimeZoneInfo { return this.utc; }
    // private static utc: TimeZoneInfo = new TimeZoneInfo(0);
    // static get Local(): TimeZoneInfo { return this.local; }
    // private static local: TimeZoneInfo = new TimeZoneInfo(moment().local().utcOffset());
    // private offset: number;
    // constructor(offset: number) {
    //     this.offset = offset;
    // }
    // static IsLocalTimeZone(timeZone: TimeZoneInfo) {
    //     return timeZone.offset === this.local.offset;
    // }
    // get DisplayName(): string { return this.offset.toString(); }
    // static ConvertTime(dateTime: DateTime, sourceTZ: TimeZoneInfo, destinationTZ: TimeZoneInfo): DateTime {
    //     var returnDate = new DateTime(dateTime);
    //     //var offset = returnDate.currentUtcOffset + destinationTZ.offset - sourceTZ.offset 
    //     returnDate.utcOffset(destinationTZ.offset);
    //     return returnDate;
    // }
    TimeZoneInfo._localTimeZone = null;
    // constants for TimeZoneInfo.Local and TimeZoneInfo.Utc
    TimeZoneInfo.UtcId = "UTC";
    TimeZoneInfo.LocalId = "Local";
    TimeZoneInfo.s_utcTimeZone = TimeZoneInfo.CreateCustomTimeZone(TimeZoneInfo.UtcId, TimeSpan.Zero, TimeZoneInfo.UtcId, TimeZoneInfo.UtcId);
    // used by GetUtcOffsetFromUtc (DateTime.Now, DateTime.ToLocalTime) for max/min whole-day range checks
    TimeZoneInfo.s_maxDateOnly = new DateTime(9999, 12, 31);
    TimeZoneInfo.s_minDateOnly = new DateTime(1, 1, 2);
    return TimeZoneInfo;
}());
exports.TimeZoneInfo = TimeZoneInfo;
(function (TimeZoneInfo) {
    var TimeZoneInfoOptions;
    (function (TimeZoneInfoOptions) {
        TimeZoneInfoOptions[TimeZoneInfoOptions["None"] = 1] = "None";
        TimeZoneInfoOptions[TimeZoneInfoOptions["NoThrowOnInvalidTime"] = 2] = "NoThrowOnInvalidTime";
    })(TimeZoneInfoOptions = TimeZoneInfo.TimeZoneInfoOptions || (TimeZoneInfo.TimeZoneInfoOptions = {}));
    var TimeZoneInfoResult;
    (function (TimeZoneInfoResult) {
        TimeZoneInfoResult[TimeZoneInfoResult["Success"] = 0] = "Success";
        TimeZoneInfoResult[TimeZoneInfoResult["TimeZoneNotFoundException"] = 1] = "TimeZoneNotFoundException";
        TimeZoneInfoResult[TimeZoneInfoResult["InvalidTimeZoneException"] = 2] = "InvalidTimeZoneException";
        TimeZoneInfoResult[TimeZoneInfoResult["SecurityException"] = 3] = "SecurityException";
    })(TimeZoneInfoResult || (TimeZoneInfoResult = {}));
    ;
    var AdjustmentRule = (function () {
        function AdjustmentRule(dateStart, dateEnd, daylightDelta, daylightTransitionStart, daylightTransitionEnd, baseUtcOffsetDelta, noDaylightTransitions) {
            AdjustmentRule.ValidateAdjustmentRule(dateStart, dateEnd, daylightDelta, daylightTransitionStart, daylightTransitionEnd, noDaylightTransitions);
            this._dateStart = dateStart;
            this._dateEnd = dateEnd;
            this._daylightDelta = daylightDelta;
            this._daylightTransitionStart = daylightTransitionStart;
            this._daylightTransitionEnd = daylightTransitionEnd;
            this._baseUtcOffsetDelta = baseUtcOffsetDelta;
            this._noDaylightTransitions = noDaylightTransitions;
        }
        Object.defineProperty(AdjustmentRule.prototype, "DateStart", {
            get: function () {
                return this._dateStart;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AdjustmentRule.prototype, "DateEnd", {
            get: function () {
                return this._dateEnd;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AdjustmentRule.prototype, "DaylightDelta", {
            get: function () {
                return this._daylightDelta;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AdjustmentRule.prototype, "DaylightTransitionStart", {
            get: function () {
                return this._daylightTransitionStart;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AdjustmentRule.prototype, "DaylightTransitionEnd", {
            get: function () {
                return this._daylightTransitionEnd;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AdjustmentRule.prototype, "BaseUtcOffsetDelta", {
            /** @internal */
            get: function () {
                return this._baseUtcOffsetDelta;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AdjustmentRule.prototype, "NoDaylightTransitions", {
            /** @internal */
            get: function () {
                return this._noDaylightTransitions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AdjustmentRule.prototype, "HasDaylightSaving", {
            /** @internal */
            get: function () {
                return ((this.DaylightDelta != TimeSpan.Zero)
                    || ((this.DaylightTransitionStart.TimeOfDay != DateTime.MinValue)
                        || (this.DaylightTransitionEnd.TimeOfDay != DateTime.MinValue.AddMilliseconds(1))));
            },
            enumerable: true,
            configurable: true
        });
        // IEquatable<AdjustmentRule>
        AdjustmentRule.prototype.Equals = function (other) {
            var equals = ((other != null)
                && ((this._dateStart == other._dateStart)
                    && ((this._dateEnd == other._dateEnd)
                        && ((this._daylightDelta == other._daylightDelta)
                            && (this._baseUtcOffsetDelta == other._baseUtcOffsetDelta)))));
            equals = (equals
                && (this._daylightTransitionEnd.Equals(other._daylightTransitionEnd) && this._daylightTransitionStart.Equals(other._daylightTransitionStart)));
            return equals;
        };
        AdjustmentRule.CreateAdjustmentRule = function (dateStart, dateEnd, daylightDelta, daylightTransitionStart, daylightTransitionEnd, baseUtcOffsetDelta, noDaylightTransitions) {
            if (baseUtcOffsetDelta === void 0) { baseUtcOffsetDelta = TimeSpan.Zero; }
            if (noDaylightTransitions === void 0) { noDaylightTransitions = false; }
            return new AdjustmentRule(dateStart, dateEnd, daylightDelta, daylightTransitionStart, daylightTransitionEnd, baseUtcOffsetDelta, noDaylightTransitions);
        };
        // ----- SECTION: internal utility methods ----------------*
        //
        // When Windows sets the daylight transition start Jan 1st at 12:00 AM, it means the year starts with the daylight saving on. 
        // We have to special case this value and not adjust it when checking if any date is in the daylight saving period. 
        //
        /** @internal */
        AdjustmentRule.prototype.IsStartDateMarkerForBeginningOfYear = function () {
            return !this.NoDaylightTransitions &&
                this.DaylightTransitionStart.Month == 1 && this.DaylightTransitionStart.Day == 1 && this.DaylightTransitionStart.TimeOfDay.Hour == 0 &&
                this.DaylightTransitionStart.TimeOfDay.Minute == 0 && this.DaylightTransitionStart.TimeOfDay.Second == 0 &&
                this._dateStart.Year == this._dateEnd.Year;
        };
        //
        // When Windows sets the daylight transition end Jan 1st at 12:00 AM, it means the year ends with the daylight saving on. 
        // We have to special case this value and not adjust it when checking if any date is in the daylight saving period. 
        //
        /** @internal */
        AdjustmentRule.prototype.IsEndDateMarkerForEndOfYear = function () {
            return !this.NoDaylightTransitions &&
                this.DaylightTransitionEnd.Month == 1 && this.DaylightTransitionEnd.Day == 1 && this.DaylightTransitionEnd.TimeOfDay.Hour == 0 &&
                this.DaylightTransitionEnd.TimeOfDay.Minute == 0 && this.DaylightTransitionEnd.TimeOfDay.Second == 0 &&
                this._dateStart.Year == this._dateEnd.Year;
        };
        //
        // ValidateAdjustmentRule -
        //
        // Helper function that performs all of the validation checks for the 
        // factory methods and deserialization callback
        //
        AdjustmentRule.ValidateAdjustmentRule = function (dateStart, dateEnd, daylightDelta, daylightTransitionStart, daylightTransitionEnd, noDaylightTransitions) {
            if (dateStart.Kind != DateTimeKind.Unspecified && dateStart.Kind != DateTimeKind.Utc) {
                throw new ArgumentException("Argument_DateTimeKindMustBeUnspecifiedOrUtc", "dateStart");
            }
            if (dateEnd.Kind != DateTimeKind.Unspecified && dateEnd.Kind != DateTimeKind.Utc) {
                throw new ArgumentException("Argument_DateTimeKindMustBeUnspecifiedOrUtc", "dateEnd");
            }
            if (daylightTransitionStart.Equals(daylightTransitionEnd) && !noDaylightTransitions) {
                throw new ArgumentException("Argument_TransitionTimesAreIdentical", "daylightTransitionEnd");
            }
            if (dateStart > dateEnd) {
                throw new ArgumentException("Argument_OutOfOrderDateTimes", "dateStart");
            }
            // This cannot use UtcOffsetOutOfRange to account for the scenario where Samoa moved across the International Date Line,
            // which caused their current BaseUtcOffset to be +13. But on the other side of the line it was UTC-11 (+1 for daylight).
            // So when trying to describe DaylightDeltas for those times, the DaylightDelta needs
            // to be -23 (what it takes to go from UTC+13 to UTC-10)
            if (daylightDelta.TotalHours < -23.0 || daylightDelta.TotalHours > 14.0) {
                throw new ArgumentOutOfRangeException("daylightDelta", daylightDelta, "ArgumentOutOfRange_UtcOffset");
            }
            if (daylightDelta.TotalMilliseconds % TimeSpan.MillisPerMinute != 0) {
                throw new ArgumentException("Argument_TimeSpanHasSeconds", "daylightDelta");
            }
            if (dateStart != DateTime.MinValue && dateStart.Kind == DateTimeKind.Unspecified && dateStart.TimeOfDay != TimeSpan.Zero) {
                throw new ArgumentException("Argument_DateTimeHasTimeOfDay", "dateStart");
            }
            if (dateEnd != DateTime.MaxValue && dateEnd.Kind == DateTimeKind.Unspecified && dateEnd.TimeOfDay != TimeSpan.Zero) {
                throw new ArgumentException("Argument_DateTimeHasTimeOfDay", "dateEnd");
            }
        };
        return AdjustmentRule;
    }());
    TimeZoneInfo.AdjustmentRule = AdjustmentRule;
    var TransitionTime = (function () {
        function TransitionTime(timeOfDay, month, week, day, dayOfWeek, isFixedDateRule) {
            TransitionTime.ValidateTransitionTime(timeOfDay, month, week, day, dayOfWeek);
            this._timeOfDay = timeOfDay;
            this._month = month;
            this._week = week;
            this._day = day;
            this._dayOfWeek = dayOfWeek;
            this._isFixedDateRule = isFixedDateRule;
        }
        Object.defineProperty(TransitionTime.prototype, "TimeOfDay", {
            get: function () {
                return this._timeOfDay;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TransitionTime.prototype, "Month", {
            get: function () {
                return this._month;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TransitionTime.prototype, "Week", {
            get: function () {
                return this._week;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TransitionTime.prototype, "Day", {
            get: function () {
                return this._day;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TransitionTime.prototype, "DayOfWeek", {
            get: function () {
                return this._dayOfWeek;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TransitionTime.prototype, "IsFixedDateRule", {
            get: function () {
                return this._isFixedDateRule;
            },
            enumerable: true,
            configurable: true
        });
        // [Pure]
        // public override bool Equals(object obj) =>
        // obj is TransitionTime && Equals((TransitionTime)obj);
        // public static bool operator == (TransitionTime t1, TransitionTime t2) => t1.Equals(t2);
        // public static bool operator != (TransitionTime t1, TransitionTime t2) => !t1.Equals(t2);
        TransitionTime.prototype.Equals = function (other) {
            return;
            this._isFixedDateRule == other._isFixedDateRule &&
                this._timeOfDay == other._timeOfDay &&
                this._month == other._month &&
                (other._isFixedDateRule ?
                    this._day == other._day :
                    this._week == other._week &&
                        this._dayOfWeek == other._dayOfWeek);
        };
        TransitionTime.prototype.GetHashCode = function () {
            return (this._month ^ this._week << 8);
        };
        ;
        TransitionTime.CreateFixedDateRule = function (timeOfDay, month, day) {
            return new TransitionTime(timeOfDay, month, 1, day, DayOfWeek.Sunday, true);
        };
        TransitionTime.CreateFloatingDateRule = function (timeOfDay, month, week, dayOfWeek) {
            return new TransitionTime(timeOfDay, month, week, 1, dayOfWeek, false);
        };
        /// <summary>
        /// Helper function that validates a TransitionTime instance.
        /// </summary>
        TransitionTime.ValidateTransitionTime = function (timeOfDay, month, week, day, dayOfWeek) {
            if (timeOfDay.Kind != DateTimeKind.Unspecified) {
                throw new ArgumentException("Argument_DateTimeKindMustBeUnspecified", "timeOfDay");
            }
            // Month range 1-12
            if (month < 1 || month > 12) {
                throw new ArgumentOutOfRangeException("month", "ArgumentOutOfRange_MonthParam");
            }
            // Day range 1-31
            if (day < 1 || day > 31) {
                throw new ArgumentOutOfRangeException("day", "ArgumentOutOfRange_DayParam");
            }
            // Week range 1-5
            if (week < 1 || week > 5) {
                throw new ArgumentOutOfRangeException("week", "ArgumentOutOfRange_Week");
            }
            // DayOfWeek range 0-6
            if (dayOfWeek < 0 || dayOfWeek > 6) {
                throw new ArgumentOutOfRangeException("dayOfWeek", "ArgumentOutOfRange_DayOfWeek");
            }
            if (timeOfDay.Year != 1 || timeOfDay.Month != 1 || timeOfDay.Day != 1 || (timeOfDay.TotalMilliSeconds % 1 != 0)) {
                throw new ArgumentException("Argument_DateTimeHasTicks", "timeOfDay");
            }
        };
        return TransitionTime;
    }());
    TimeZoneInfo.TransitionTime = TransitionTime;
})(TimeZoneInfo = exports.TimeZoneInfo || (exports.TimeZoneInfo = {}));
exports.TimeZoneInfo = TimeZoneInfo;
/** @internal */
var TypeGuards;
(function (TypeGuards) {
    /**
     * check if the object implements EwsEnumInterface interface
     */
    function hasEwsEnumAttribute(arg) {
        return arg && typeof arg.FromEwsEnumString === 'function' && typeof arg.ToEwsEnumString === 'function';
    }
    TypeGuards.hasEwsEnumAttribute = hasEwsEnumAttribute;
    /**
     * check if the object implements EwsEnumInterface interface
     */
    function hasRequiredServerVersionAttribute(arg) {
        return arg && typeof arg.RequiredServerVersion === 'function';
    }
    TypeGuards.hasRequiredServerVersionAttribute = hasRequiredServerVersionAttribute;
    /**
     * check if the object implements ICalendarActionProvider interface
     */
    function isICalendarActionProvider(arg) {
        return arg && typeof arg.Accept === 'function' && typeof arg.CreateDeclineMessage === 'function';
    }
    TypeGuards.isICalendarActionProvider = isICalendarActionProvider;
    /**
     * check if the object implements ICustomUpdateSerializer interface
     */
    function isICustomUpdateSerializer(arg) {
        return arg && typeof arg.WriteSetUpdateToXml === 'function' && typeof arg.WriteDeleteUpdateToXml === 'function';
    }
    TypeGuards.isICustomUpdateSerializer = isICustomUpdateSerializer;
    /**
     * check if the object implements IFileAttachmentContentHandler interface
     */
    function isIFileAttachmentContentHandler(arg) {
        return arg && typeof arg.GetOutputStream === 'function';
    }
    TypeGuards.isIFileAttachmentContentHandler = isIFileAttachmentContentHandler;
    /**
     * check if the object implements IOwnedProperty interface
     */
    function isIOwnedProperty(arg) {
        return arg && typeof arg.Owner === 'object';
    }
    TypeGuards.isIOwnedProperty = isIOwnedProperty;
    /**
     * check if the object implements ISearchStringProvider interface
     */
    function isISearchStringProvider(arg) {
        return arg && typeof arg.GetSearchString === 'function';
    }
    TypeGuards.isISearchStringProvider = isISearchStringProvider;
    /**
     * check if the object implements ISelfValidate interface
     */
    function isISelfValidate(arg) {
        return arg && typeof arg.Validate === 'function';
    }
    TypeGuards.isISelfValidate = isISelfValidate;
    /**
     * check if the object implements ITraceListener interface
     */
    function isITraceListener(arg) {
        return arg && typeof arg.Trace === 'function';
    }
    TypeGuards.isITraceListener = isITraceListener;
    /** Not yet Used */
    // export function isIEwsHttpWebRequest(arg: IEwsHttpWebRequest): arg is IEwsHttpWebRequest {
    //     return arg && typeof arg === 'function';
    // }
    // export function isIEwsHttpWebRequestFactory(arg: IEwsHttpWebRequestFactory): arg is IEwsHttpWebRequestFactory {
    //     return arg && typeof arg === 'function';
    // }
    // export function isIEwsHttpWebResponse(arg: IEwsHttpWebResponse): arg is IEwsHttpWebResponse {
    //     return arg && typeof arg === 'function';
    // }
    // export function isIJsonCollectionDeserializer(arg: IJsonCollectionDeserializer): arg is IJsonCollectionDeserializer {
    //     return arg && typeof arg.CreateFromJsonCollection === 'function' && typeof arg.UpdateFromJsonCollection === 'function';
    // }
    // export function isIJsonSerializable(arg: IJsonSerializable): arg is IJsonSerializable {
    //     return arg && typeof arg.ToJson === 'function';
    // }
})(TypeGuards = exports.TypeGuards || (exports.TypeGuards = {}));
// import 'reflect-metadata';
// export var AttachableAttributeMetadata = "AttachableAttribute";
// export function AttachableAttribute(value: boolean = false) {
//     return function(target: Function) {
//         Reflect.defineMetadata("AttachableAttribute", value, target.prototype);
//     }
// }
// import 'reflect-metadata';
// export function EwsEnumAttribute(schemaName: string) {
//     return function(target: Function) {
//         Reflect.defineMetadata("EwsEnumAttribute", schemaName, target);
//     }
// }
// import 'reflect-metadata';
// export function RequiredServerVersionAttribute(version: ExchangeVersion) {
//     return function(target: Function) {
//         Reflect.defineMetadata("AttachableAttribute", version, target);
//     }
// }
//			
// class SchemaAttribute extends System.Attribute {
//}
//export = SchemaAttribute;
//------------modulename->Microsoft.Exchange.WebServices.Data------------
//			
// class ServiceObjectDefinitionAttribute extends System.Attribute {
//	XmlElementName: string;
//	ReturnedByServer: boolean;
//	private xmlElementName: string;
//	private returnedByServer: boolean;
//}
//export = ServiceObjectDefinitionAttribute;
//------------modulename->Microsoft.Exchange.WebServices.Data------------
/**
 * Indicates which occurrence of a recurring task should be deleted
 */
var AffectedTaskOccurrence;
(function (AffectedTaskOccurrence) {
    /**
     * All occurrences of the recurring task will be deleted.
     */
    AffectedTaskOccurrence[AffectedTaskOccurrence["AllOccurrences"] = 0] = "AllOccurrences";
    /**
     * Only the current occurrence of the recurring task will be deleted.
     */
    AffectedTaskOccurrence[AffectedTaskOccurrence["SpecifiedOccurrenceOnly"] = 1] = "SpecifiedOccurrenceOnly";
})(AffectedTaskOccurrence = exports.AffectedTaskOccurrence || (exports.AffectedTaskOccurrence = {}));
/**
 * Defines the type of aggregation to perform.
 */
var AggregateType;
(function (AggregateType) {
    /**
     * The maximum value is calculated.
     */
    AggregateType[AggregateType["Minimum"] = 0] = "Minimum";
    /**
     * The minimum value is calculated.
     */
    AggregateType[AggregateType["Maximum"] = 1] = "Maximum";
})(AggregateType = exports.AggregateType || (exports.AggregateType = {}));
/**
 * Defines the type of an appointment.
 */
var AppointmentType;
(function (AppointmentType) {
    /**
     * The appointment is non-recurring.
     */
    AppointmentType[AppointmentType["Single"] = 0] = "Single";
    /**
     * The appointment is an occurrence of a recurring appointment.
     */
    AppointmentType[AppointmentType["Occurrence"] = 1] = "Occurrence";
    /**
     * The appointment is an exception of a recurring appointment.
     */
    AppointmentType[AppointmentType["Exception"] = 2] = "Exception";
    /**
     * The appointment is the recurring master of a series.
     */
    AppointmentType[AppointmentType["RecurringMaster"] = 3] = "RecurringMaster";
})(AppointmentType = exports.AppointmentType || (exports.AppointmentType = {}));
/**
 * @internal Defines the types of Autodiscover endpoints that are available.
 *
 * [Flags]
 */
var AutodiscoverEndpoints;
(function (AutodiscoverEndpoints) {
    /**
     * No endpoints available.
     */
    AutodiscoverEndpoints[AutodiscoverEndpoints["None"] = 0] = "None";
    /**
     * The "legacy" Autodiscover endpoint.
     */
    AutodiscoverEndpoints[AutodiscoverEndpoints["Legacy"] = 1] = "Legacy";
    /**
     * The SOAP endpoint.
     */
    AutodiscoverEndpoints[AutodiscoverEndpoints["Soap"] = 2] = "Soap";
    /**
     * The WS-Security endpoint.
     */
    AutodiscoverEndpoints[AutodiscoverEndpoints["WsSecurity"] = 4] = "WsSecurity";
    /**
     * The WS-Security/SymmetricKey endpoint.
     */
    AutodiscoverEndpoints[AutodiscoverEndpoints["WSSecuritySymmetricKey"] = 8] = "WSSecuritySymmetricKey";
    /**
     * The WS-Security/X509Cert endpoint.
     */
    AutodiscoverEndpoints[AutodiscoverEndpoints["WSSecurityX509Cert"] = 16] = "WSSecurityX509Cert";
    /**
     * The OAuth endpoint
     */
    AutodiscoverEndpoints[AutodiscoverEndpoints["OAuth"] = 32] = "OAuth";
})(AutodiscoverEndpoints = exports.AutodiscoverEndpoints || (exports.AutodiscoverEndpoints = {}));
/**
 * Defines the error codes that can be returned by the Autodiscover service.
 */
var AutodiscoverErrorCode;
(function (AutodiscoverErrorCode) {
    /**
     * There was no Error.
     */
    AutodiscoverErrorCode[AutodiscoverErrorCode["NoError"] = 0] = "NoError";
    /**
     * The caller must follow the e-mail address redirection that was returned by Autodiscover.
     */
    AutodiscoverErrorCode[AutodiscoverErrorCode["RedirectAddress"] = 1] = "RedirectAddress";
    /**
     * The caller must follow the URL redirection that was returned by Autodiscover.
     */
    AutodiscoverErrorCode[AutodiscoverErrorCode["RedirectUrl"] = 2] = "RedirectUrl";
    /**
     * The user that was passed in the request is invalid.
     */
    AutodiscoverErrorCode[AutodiscoverErrorCode["InvalidUser"] = 3] = "InvalidUser";
    /**
     * The request is invalid.
     */
    AutodiscoverErrorCode[AutodiscoverErrorCode["InvalidRequest"] = 4] = "InvalidRequest";
    /**
     * A specified setting is invalid.
     */
    AutodiscoverErrorCode[AutodiscoverErrorCode["InvalidSetting"] = 5] = "InvalidSetting";
    /**
     * A specified setting is not available.
     */
    AutodiscoverErrorCode[AutodiscoverErrorCode["SettingIsNotAvailable"] = 6] = "SettingIsNotAvailable";
    /**
     * The server is too busy to process the request.
     */
    AutodiscoverErrorCode[AutodiscoverErrorCode["ServerBusy"] = 7] = "ServerBusy";
    /**
     * The requested domain is not valid.
     */
    AutodiscoverErrorCode[AutodiscoverErrorCode["InvalidDomain"] = 8] = "InvalidDomain";
    /**
     * The organization is not federated.
     */
    AutodiscoverErrorCode[AutodiscoverErrorCode["NotFederated"] = 9] = "NotFederated";
    /**
     * Internal server error.
     */
    AutodiscoverErrorCode[AutodiscoverErrorCode["InternalServerError"] = 10] = "InternalServerError";
})(AutodiscoverErrorCode = exports.AutodiscoverErrorCode || (exports.AutodiscoverErrorCode = {}));
/**
 * @internal Defines the types of response the Autodiscover service can return.
 */
var AutodiscoverResponseType;
(function (AutodiscoverResponseType) {
    /**
     * The request returned an error.
     */
    AutodiscoverResponseType[AutodiscoverResponseType["Error"] = 0] = "Error";
    /**
     * A URL redirection is necessary.
     */
    AutodiscoverResponseType[AutodiscoverResponseType["RedirectUrl"] = 1] = "RedirectUrl";
    /**
     * An address redirection is necessary.
     */
    AutodiscoverResponseType[AutodiscoverResponseType["RedirectAddress"] = 2] = "RedirectAddress";
    /**
     * The request succeeded.
     */
    AutodiscoverResponseType[AutodiscoverResponseType["Success"] = 3] = "Success";
})(AutodiscoverResponseType = exports.AutodiscoverResponseType || (exports.AutodiscoverResponseType = {}));
/**
 * Defines the type of data that can be requested via GetUserAvailability.
 */
var AvailabilityData;
(function (AvailabilityData) {
    /**
     * Only return free/busy data.
     */
    AvailabilityData[AvailabilityData["FreeBusy"] = 0] = "FreeBusy";
    /**
     * Only return suggestions.
     */
    AvailabilityData[AvailabilityData["Suggestions"] = 1] = "Suggestions";
    /**
     * Return both free/busy data and suggestions.
     */
    AvailabilityData[AvailabilityData["FreeBusyAndSuggestions"] = 2] = "FreeBusyAndSuggestions";
})(AvailabilityData = exports.AvailabilityData || (exports.AvailabilityData = {}));
/**
 * Defines base property sets that are used as the base for custom property sets.
 */
var BasePropertySet;
(function (BasePropertySet) {
    /**
     * Only includes the Id of items and folders.
     */
    BasePropertySet[BasePropertySet["IdOnly"] = 0] = "IdOnly";
    /**
     * Includes all the first class properties of items and folders.
     */
    BasePropertySet[BasePropertySet["FirstClassProperties"] = 1] = "FirstClassProperties";
})(BasePropertySet = exports.BasePropertySet || (exports.BasePropertySet = {}));
/**
 * Defines the type of body of an item.
 */
var BodyType;
(function (BodyType) {
    /**
     * The body is formatted in HTML.
     */
    BodyType[BodyType["HTML"] = 0] = "HTML";
    /**
     * The body is in plain text.
     */
    BodyType[BodyType["Text"] = 1] = "Text";
})(BodyType = exports.BodyType || (exports.BodyType = {}));
/**
 * Defines the type of change of a synchronization event.
 */
var ChangeType;
(function (ChangeType) {
    /**
     * An item or folder was created.
     */
    ChangeType[ChangeType["Create"] = 0] = "Create";
    /**
     * An item or folder was modified.
     */
    ChangeType[ChangeType["Update"] = 1] = "Update";
    /**
     * An item or folder was deleted.
     */
    ChangeType[ChangeType["Delete"] = 2] = "Delete";
    /**
     * An item's IsRead flag was changed.
     */
    ChangeType[ChangeType["ReadFlagChange"] = 3] = "ReadFlagChange";
})(ChangeType = exports.ChangeType || (exports.ChangeType = {}));
/**
 * Defines the type of ClientAccessTokenType
 */
var ClientAccessTokenType;
(function (ClientAccessTokenType) {
    /**
     * CallerIdentity
     */
    ClientAccessTokenType[ClientAccessTokenType["CallerIdentity"] = 0] = "CallerIdentity";
    /**
     * ExtensionCallback.
     */
    ClientAccessTokenType[ClientAccessTokenType["ExtensionCallback"] = 1] = "ExtensionCallback";
    /**
     * ScopedToken
     */
    ClientAccessTokenType[ClientAccessTokenType["ScopedToken"] = 2] = "ScopedToken";
})(ClientAccessTokenType = exports.ClientAccessTokenType || (exports.ClientAccessTokenType = {}));
/**
 * Defines the type of ClientExtensionProvidedTo.
 */
var ClientExtensionProvidedTo;
(function (ClientExtensionProvidedTo) {
    /**
     * Everyone
     */
    ClientExtensionProvidedTo[ClientExtensionProvidedTo["Everyone"] = 0] = "Everyone";
    /**
     * SpecificUsers
     */
    ClientExtensionProvidedTo[ClientExtensionProvidedTo["SpecificUsers"] = 1] = "SpecificUsers";
})(ClientExtensionProvidedTo = exports.ClientExtensionProvidedTo || (exports.ClientExtensionProvidedTo = {}));
/**
 * Defines the way values are compared in search filters.
 */
var ComparisonMode;
(function (ComparisonMode) {
    /**
     * The comparison is exact.
     */
    ComparisonMode[ComparisonMode["Exact"] = 0] = "Exact";
    /**
     * The comparison ignores casing.
     */
    ComparisonMode[ComparisonMode["IgnoreCase"] = 1] = "IgnoreCase";
    /**
     * The comparison ignores spacing characters.
     */
    ComparisonMode[ComparisonMode["IgnoreNonSpacingCharacters"] = 2] = "IgnoreNonSpacingCharacters";
    /**
     * The comparison ignores casing and spacing characters.
     */
    ComparisonMode[ComparisonMode["IgnoreCaseAndNonSpacingCharacters"] = 3] = "IgnoreCaseAndNonSpacingCharacters";
    // Although the following four values are defined in the EWS schema, they are useless
    // as they are all technically equivalent to Loose. We are not exposing those values
    // in this API. When we encounter one of these values on an existing search folder
    // restriction, we map it to IgnoreCaseAndNonSpacingCharacters.
    //
    // Loose,
    // LooseAndIgnoreCase,
    // LooseAndIgnoreNonSpace,
    // LooseAndIgnoreCaseAndIgnoreNonSpace
})(ComparisonMode = exports.ComparisonMode || (exports.ComparisonMode = {}));
/**
 * Defines how conflict resolutions are handled in update operations.
 */
var ConflictResolutionMode;
(function (ConflictResolutionMode) {
    /**
     * Local property changes are discarded.
     */
    ConflictResolutionMode[ConflictResolutionMode["NeverOverwrite"] = 0] = "NeverOverwrite";
    /**
     * Local property changes are applied to the server unless the server-side copy is more recent than the local copy.
     */
    ConflictResolutionMode[ConflictResolutionMode["AutoResolve"] = 1] = "AutoResolve";
    /**
     * Local property changes overwrite server-side changes.
     */
    ConflictResolutionMode[ConflictResolutionMode["AlwaysOverwrite"] = 2] = "AlwaysOverwrite";
})(ConflictResolutionMode = exports.ConflictResolutionMode || (exports.ConflictResolutionMode = {}));
/**
 * Defines the conflict types that can be returned in meeting time suggestions.
 */
var ConflictType;
(function (ConflictType) {
    /**
     * There is a conflict with an indicidual attendee.
     */
    ConflictType[ConflictType["IndividualAttendeeConflict"] = 0] = "IndividualAttendeeConflict";
    /**
     * There is a conflict with at least one member of a group.
     */
    ConflictType[ConflictType["GroupConflict"] = 1] = "GroupConflict";
    /**
     * There is a conflict with at least one member of a group, but the group was too big for detailed information to be returned.
     */
    ConflictType[ConflictType["GroupTooBigConflict"] = 2] = "GroupTooBigConflict";
    /**
     * There is a conflict with an unresolvable attendee or an attendee that is not a user, group, or contact.
     */
    ConflictType[ConflictType["UnknownAttendeeConflict"] = 3] = "UnknownAttendeeConflict";
})(ConflictType = exports.ConflictType || (exports.ConflictType = {}));
/**
 * Defines the type of Id of a ConnectingId object.
 */
var ConnectingIdType;
(function (ConnectingIdType) {
    /**
     * The connecting Id is a principal name.
     */
    ConnectingIdType[ConnectingIdType["PrincipalName"] = 0] = "PrincipalName";
    /**
     * The Id is an SID.
     */
    ConnectingIdType[ConnectingIdType["SID"] = 1] = "SID";
    /**
     * The Id is an SMTP address.
     */
    ConnectingIdType[ConnectingIdType["SmtpAddress"] = 2] = "SmtpAddress";
})(ConnectingIdType = exports.ConnectingIdType || (exports.ConnectingIdType = {}));
/**
 * The ConnectionFailureCause enumeration
 */
var ConnectionFailureCause;
(function (ConnectionFailureCause) {
    /**
     * None
     */
    ConnectionFailureCause[ConnectionFailureCause["None"] = 0] = "None";
    /**
     * UserBusy
     */
    ConnectionFailureCause[ConnectionFailureCause["UserBusy"] = 1] = "UserBusy";
    /**
     * NoAnswer
     */
    ConnectionFailureCause[ConnectionFailureCause["NoAnswer"] = 2] = "NoAnswer";
    /**
     * Unavailable
     */
    ConnectionFailureCause[ConnectionFailureCause["Unavailable"] = 3] = "Unavailable";
    /**
     * Other
     */
    ConnectionFailureCause[ConnectionFailureCause["Other"] = 4] = "Other";
})(ConnectionFailureCause = exports.ConnectionFailureCause || (exports.ConnectionFailureCause = {}));
//D:\dr\gh\ews-javascript-api_ForNewFeatures\build\temp\src\js\Enumerations\ConnectionStatus.ts
/**
 * The consent states enumeration
 */
var ConsentState;
(function (ConsentState) {
    /**
     * User has closed the consent page or has not responded yet.
     */
    ConsentState[ConsentState["NotResponded"] = 0] = "NotResponded";
    /**
     * User has requested to disable the extension.
     */
    ConsentState[ConsentState["NotConsented"] = 1] = "NotConsented";
    /**
     * User has requested to enable the extension.
     */
    ConsentState[ConsentState["Consented"] = 2] = "Consented";
})(ConsentState = exports.ConsentState || (exports.ConsentState = {}));
/**
 * Defines the source of a contact or group.
 */
var ContactSource;
(function (ContactSource) {
    /**
     * The contact or group is stored in the Global Address List
     */
    ContactSource[ContactSource["ActiveDirectory"] = 0] = "ActiveDirectory";
    /**
     * The contact or group is stored in Exchange.
     */
    ContactSource[ContactSource["Store"] = 1] = "Store";
})(ContactSource = exports.ContactSource || (exports.ContactSource = {}));
/**
 * Defines the containment mode for Contains search filters.
 */
var ContainmentMode;
(function (ContainmentMode) {
    /**
     * The comparison is between the full string and the constant. The property value and the supplied constant are precisely the same.
     */
    ContainmentMode[ContainmentMode["FullString"] = 0] = "FullString";
    /**
     * The comparison is between the string prefix and the constant.
     */
    ContainmentMode[ContainmentMode["Prefixed"] = 1] = "Prefixed";
    /**
     * The comparison is between a substring of the string and the constant.
     */
    ContainmentMode[ContainmentMode["Substring"] = 2] = "Substring";
    /**
     * The comparison is between a prefix on individual words in the string and the constant.
     */
    ContainmentMode[ContainmentMode["PrefixOnWords"] = 3] = "PrefixOnWords";
    /**
     * The comparison is between an exact phrase in the string and the constant.
     */
    ContainmentMode[ContainmentMode["ExactPhrase"] = 4] = "ExactPhrase";
})(ContainmentMode = exports.ContainmentMode || (exports.ContainmentMode = {}));
/**
 * @internal Defines actions applicable to Conversation.
 */
var ConversationActionType;
(function (ConversationActionType) {
    /**
     * Categorizes every current and future message in the conversation
     */
    ConversationActionType[ConversationActionType["AlwaysCategorize"] = 0] = "AlwaysCategorize";
    /**
     * Deletes every current and future message in the conversation
     */
    ConversationActionType[ConversationActionType["AlwaysDelete"] = 1] = "AlwaysDelete";
    /**
     * Moves every current and future message in the conversation
     */
    ConversationActionType[ConversationActionType["AlwaysMove"] = 2] = "AlwaysMove";
    /**
     * Deletes current item in context folder in the conversation
     */
    ConversationActionType[ConversationActionType["Delete"] = 3] = "Delete";
    /**
     * Moves current item in context folder in the conversation
     */
    ConversationActionType[ConversationActionType["Move"] = 4] = "Move";
    /**
     * Copies current item in context folder in the conversation
     */
    ConversationActionType[ConversationActionType["Copy"] = 5] = "Copy";
    /**
     * Marks current item in context folder in the conversation with provided read state
     */
    ConversationActionType[ConversationActionType["SetReadState"] = 6] = "SetReadState";
    /**
     * Set retention policy.
     */
    ConversationActionType[ConversationActionType["SetRetentionPolicy"] = 7] = "SetRetentionPolicy";
    /**
     * Flag current items in context folder in the conversation with provided flag state.
     */
    ConversationActionType[ConversationActionType["Flag"] = 8] = "Flag";
})(ConversationActionType = exports.ConversationActionType || (exports.ConversationActionType = {}));
/**
 * Defines the flag status of a Conversation.
 */
var ConversationFlagStatus;
(function (ConversationFlagStatus) {
    /**
     * Not Flagged
     */
    ConversationFlagStatus[ConversationFlagStatus["NotFlagged"] = 0] = "NotFlagged";
    /**
     * Flagged
     */
    ConversationFlagStatus[ConversationFlagStatus["Flagged"] = 1] = "Flagged";
    /**
     * Complete
     */
    ConversationFlagStatus[ConversationFlagStatus["Complete"] = 2] = "Complete";
})(ConversationFlagStatus = exports.ConversationFlagStatus || (exports.ConversationFlagStatus = {}));
/**
 * Defines the folder traversal depth in queries.
 */
var ConversationQueryTraversal;
(function (ConversationQueryTraversal) {
    /**
     * Shallow traversal
     */
    ConversationQueryTraversal[ConversationQueryTraversal["Shallow"] = 0] = "Shallow";
    /**
     * Deep traversal
     */
    ConversationQueryTraversal[ConversationQueryTraversal["Deep"] = 1] = "Deep";
})(ConversationQueryTraversal = exports.ConversationQueryTraversal || (exports.ConversationQueryTraversal = {}));
(function (ConversationQueryTraversal) {
    /**RequiredServerVersionAttribute */
    function RequiredServerVersion(value) {
        if (value <= 1)
            return ExchangeVersion.Exchange2013;
        return ExchangeVersion.Exchange_Version_Not_Updated;
    }
    ConversationQueryTraversal.RequiredServerVersion = RequiredServerVersion;
})(ConversationQueryTraversal = exports.ConversationQueryTraversal || (exports.ConversationQueryTraversal = {}));
/**
 * Defines the order in which conversation nodes should be returned by GetConversationItems.
 */
var ConversationSortOrder;
(function (ConversationSortOrder) {
    /**
     * Tree order, ascending
     */
    ConversationSortOrder[ConversationSortOrder["TreeOrderAscending"] = 0] = "TreeOrderAscending";
    /**
     * Tree order, descending.
     */
    ConversationSortOrder[ConversationSortOrder["TreeOrderDescending"] = 1] = "TreeOrderDescending";
    /**
     * Chronological order, ascending.
     */
    ConversationSortOrder[ConversationSortOrder["DateOrderAscending"] = 2] = "DateOrderAscending";
    /**
     * Chronological order, descending.
     */
    ConversationSortOrder[ConversationSortOrder["DateOrderDescending"] = 3] = "DateOrderDescending";
})(ConversationSortOrder = exports.ConversationSortOrder || (exports.ConversationSortOrder = {}));
/**
 * Defines the precision for returned DateTime values
 */
var DateTimePrecision;
(function (DateTimePrecision) {
    /**
     * Default value.  No SOAP header emitted.
     */
    DateTimePrecision[DateTimePrecision["Default"] = 0] = "Default";
    /**
     * Seconds
     */
    DateTimePrecision[DateTimePrecision["Seconds"] = 1] = "Seconds";
    /**
     * Milliseconds
     */
    DateTimePrecision[DateTimePrecision["Milliseconds"] = 2] = "Milliseconds";
})(DateTimePrecision = exports.DateTimePrecision || (exports.DateTimePrecision = {}));
/**
 * Specifies the day of the week.
 *
 * /remarks/    For the standard days of the week (Sunday, Monday...) the DayOfTheWeek enum value is the same as the System.DayOfWeek enum type.
 * These values can be safely cast between the two enum types. The special days of the week (Day, Weekday and WeekendDay) are used for monthly and yearly recurrences and cannot be cast to System.DayOfWeek values.
 */
var DayOfTheWeek;
(function (DayOfTheWeek) {
    /**
     * Sunday
     */
    DayOfTheWeek[DayOfTheWeek["Sunday"] = 0] = "Sunday";
    /**
     * Monday
     */
    DayOfTheWeek[DayOfTheWeek["Monday"] = 1] = "Monday";
    /**
     * Tuesday
     */
    DayOfTheWeek[DayOfTheWeek["Tuesday"] = 2] = "Tuesday";
    /**
     * Wednesday
     */
    DayOfTheWeek[DayOfTheWeek["Wednesday"] = 3] = "Wednesday";
    /**
     * Thursday
     */
    DayOfTheWeek[DayOfTheWeek["Thursday"] = 4] = "Thursday";
    /**
     * Friday
     */
    DayOfTheWeek[DayOfTheWeek["Friday"] = 5] = "Friday";
    /**
     * Saturday
     */
    DayOfTheWeek[DayOfTheWeek["Saturday"] = 6] = "Saturday";
    /**
     * Any day of the week
     */
    DayOfTheWeek[DayOfTheWeek["Day"] = 7] = "Day";
    /**
     * Any day of the usual business week (Monday-Friday)
     */
    DayOfTheWeek[DayOfTheWeek["Weekday"] = 8] = "Weekday";
    /**
     * Any weekend day (Saturday or Sunday)
     */
    DayOfTheWeek[DayOfTheWeek["WeekendDay"] = 9] = "WeekendDay";
})(DayOfTheWeek = exports.DayOfTheWeek || (exports.DayOfTheWeek = {}));
/**
 * Defines the index of a week day within a month.
 */
var DayOfTheWeekIndex;
(function (DayOfTheWeekIndex) {
    /**
     * The first specific day of the week in the month. For example, the first Tuesday of the month.
     */
    DayOfTheWeekIndex[DayOfTheWeekIndex["First"] = 0] = "First";
    /**
     * The second specific day of the week in the month. For example, the second Tuesday of the month.
     */
    DayOfTheWeekIndex[DayOfTheWeekIndex["Second"] = 1] = "Second";
    /**
     * The third specific day of the week in the month. For example, the third Tuesday of the month.
     */
    DayOfTheWeekIndex[DayOfTheWeekIndex["Third"] = 2] = "Third";
    /**
     * The fourth specific day of the week in the month. For example, the fourth Tuesday of the month.
     */
    DayOfTheWeekIndex[DayOfTheWeekIndex["Fourth"] = 3] = "Fourth";
    /**
     * The last specific day of the week in the month. For example, the last Tuesday of the month.
     */
    DayOfTheWeekIndex[DayOfTheWeekIndex["Last"] = 4] = "Last";
})(DayOfTheWeekIndex = exports.DayOfTheWeekIndex || (exports.DayOfTheWeekIndex = {}));
/**
 * Enum for the day of the week.
 * System.DayOfWeek
 */
var DayOfWeek;
(function (DayOfWeek) {
    /**
     * Sunday
     */
    DayOfWeek[DayOfWeek["Sunday"] = 0] = "Sunday";
    /**
     * Monday
     */
    DayOfWeek[DayOfWeek["Monday"] = 1] = "Monday";
    /**
     * Tuesday
     */
    DayOfWeek[DayOfWeek["Tuesday"] = 2] = "Tuesday";
    /**
     * Wednesday
     */
    DayOfWeek[DayOfWeek["Wednesday"] = 3] = "Wednesday";
    /**
     * Thursday
     */
    DayOfWeek[DayOfWeek["Thursday"] = 4] = "Thursday";
    /**
     * Friday
     */
    DayOfWeek[DayOfWeek["Friday"] = 5] = "Friday";
    /**
     * Saturday
     */
    DayOfWeek[DayOfWeek["Saturday"] = 6] = "Saturday";
})(DayOfWeek = exports.DayOfWeek || (exports.DayOfWeek = {}));
/**
 * Defines the default sets of extended properties.
 */
var DefaultExtendedPropertySet;
(function (DefaultExtendedPropertySet) {
    /**
     * The Meeting extended property set.
     */
    DefaultExtendedPropertySet[DefaultExtendedPropertySet["Meeting"] = 0] = "Meeting";
    /**
     * The Appointment extended property set.
     */
    DefaultExtendedPropertySet[DefaultExtendedPropertySet["Appointment"] = 1] = "Appointment";
    /**
     * The Common extended property set.
     */
    DefaultExtendedPropertySet[DefaultExtendedPropertySet["Common"] = 2] = "Common";
    /**
     * The PublicStrings extended property set.
     */
    DefaultExtendedPropertySet[DefaultExtendedPropertySet["PublicStrings"] = 3] = "PublicStrings";
    /**
     * The Address extended property set.
     */
    DefaultExtendedPropertySet[DefaultExtendedPropertySet["Address"] = 4] = "Address";
    /**
     * The InternetHeaders extended property set.
     */
    DefaultExtendedPropertySet[DefaultExtendedPropertySet["InternetHeaders"] = 5] = "InternetHeaders";
    /**
     * The CalendarAssistant extended property set.
     */
    DefaultExtendedPropertySet[DefaultExtendedPropertySet["CalendarAssistant"] = 6] = "CalendarAssistant";
    /**
     * The UnifiedMessaging extended property set.
     */
    DefaultExtendedPropertySet[DefaultExtendedPropertySet["UnifiedMessaging"] = 7] = "UnifiedMessaging";
    /**
     * The Task extended property set.
     */
    DefaultExtendedPropertySet[DefaultExtendedPropertySet["Task"] = 8] = "Task";
})(DefaultExtendedPropertySet = exports.DefaultExtendedPropertySet || (exports.DefaultExtendedPropertySet = {}));
/**
 *
 */
var DelegateFolderPermissionLevel;
(function (DelegateFolderPermissionLevel) {
    /**
     * The delegate has no permissions.
     */
    DelegateFolderPermissionLevel[DelegateFolderPermissionLevel["None"] = 0] = "None";
    /**
     * The delegate has Editor permissions.
     */
    DelegateFolderPermissionLevel[DelegateFolderPermissionLevel["Editor"] = 1] = "Editor";
    /**
     * The delegate has Reviewer permissions.
     */
    DelegateFolderPermissionLevel[DelegateFolderPermissionLevel["Reviewer"] = 2] = "Reviewer";
    /**
     * The delegate has Author permissions.
     */
    DelegateFolderPermissionLevel[DelegateFolderPermissionLevel["Author"] = 3] = "Author";
    /**
     * The delegate has Custom permissions.
     */
    DelegateFolderPermissionLevel[DelegateFolderPermissionLevel["Custom"] = 4] = "Custom";
})(DelegateFolderPermissionLevel = exports.DelegateFolderPermissionLevel || (exports.DelegateFolderPermissionLevel = {}));
/**
 * Represents deletion modes.
 */
var DeleteMode;
(function (DeleteMode) {
    /**
     * The item or folder will be permanently deleted.
     */
    DeleteMode[DeleteMode["HardDelete"] = 0] = "HardDelete";
    /**
     * The item or folder will be moved to the dumpster. Items and folders in the dumpster can be recovered.
     */
    DeleteMode[DeleteMode["SoftDelete"] = 1] = "SoftDelete";
    /**
     * The item or folder will be moved to the mailbox' Deleted Items folder.
     */
    DeleteMode[DeleteMode["MoveToDeletedItems"] = 2] = "MoveToDeletedItems";
})(DeleteMode = exports.DeleteMode || (exports.DeleteMode = {}));
var DictionaryKeyType;
(function (DictionaryKeyType) {
    DictionaryKeyType[DictionaryKeyType["EmailAddressKey"] = 0] = "EmailAddressKey";
    DictionaryKeyType[DictionaryKeyType["ImAddressKey"] = 1] = "ImAddressKey";
    DictionaryKeyType[DictionaryKeyType["PhoneNumberKey"] = 2] = "PhoneNumberKey";
    DictionaryKeyType[DictionaryKeyType["PhysicalAddressKey"] = 3] = "PhysicalAddressKey";
})(DictionaryKeyType = exports.DictionaryKeyType || (exports.DictionaryKeyType = {}));
/**
 * Disable reason type
 */
var DisableReasonType;
(function (DisableReasonType) {
    /**
     * Extension is being disabled with no reason
     */
    DisableReasonType[DisableReasonType["NoReason"] = 0] = "NoReason";
    /**
     * Extension is being disabled from Outlook due to performance reasons
     */
    DisableReasonType[DisableReasonType["OutlookClientPerformance"] = 1] = "OutlookClientPerformance";
    /**
     * Extension is being disabled from OWA due to performance reasons
     */
    DisableReasonType[DisableReasonType["OWAClientPerformance"] = 2] = "OWAClientPerformance";
    /**
     * Extension is being disabled from MOWA due to performance reasons
     */
    DisableReasonType[DisableReasonType["MobileClientPerformance"] = 3] = "MobileClientPerformance";
})(DisableReasonType = exports.DisableReasonType || (exports.DisableReasonType = {}));
// //todo - move to file where class Microsoft.Exchange.WebServices.Dns.DnsNativeMethods is located
// module Microsoft.Exchange.WebServices.Dns.DnsNativeMethods {
//     export enum DnsQueryOptions {
//         DNS_QUERY_STANDARD = 0
//     }
// }
/**
 * @internal DNS record types.
 */
var DnsRecordType;
(function (DnsRecordType) {
    /**
     * RFC 1034/1035 Address Record
     */
    DnsRecordType[DnsRecordType["A"] = 1] = "A";
    /**
     * Canonical Name Record
     */
    DnsRecordType[DnsRecordType["CNAME"] = 5] = "CNAME";
    /**
     * Start of Authority Record
     */
    DnsRecordType[DnsRecordType["SOA"] = 6] = "SOA";
    /**
     * Pointer Record
     */
    DnsRecordType[DnsRecordType["PTR"] = 12] = "PTR";
    /**
     * Mail Exchange Record
     */
    DnsRecordType[DnsRecordType["MX"] = 15] = "MX";
    /**
     * Text Record
     */
    DnsRecordType[DnsRecordType["TXT"] = 16] = "TXT";
    /**
     * RFC 1886 (IPv6 Address)
     */
    DnsRecordType[DnsRecordType["AAAA"] = 28] = "AAAA";
    /**
     * Service location - RFC 2052
     */
    DnsRecordType[DnsRecordType["SRV"] = 33] = "SRV";
})(DnsRecordType = exports.DnsRecordType || (exports.DnsRecordType = {}));
/**
 * Domain setting names.
 */
var DomainSettingName;
(function (DomainSettingName) {
    /**
     * The external URL of the Exchange Web Services.
     */
    DomainSettingName[DomainSettingName["ExternalEwsUrl"] = 0] = "ExternalEwsUrl";
    /**
     * The version of the Exchange server hosting the URL of the Exchange Web Services.
     */
    DomainSettingName[DomainSettingName["ExternalEwsVersion"] = 1] = "ExternalEwsVersion";
})(DomainSettingName = exports.DomainSettingName || (exports.DomainSettingName = {}));
/**
 * Defines the effective user rights associated with an item or folder.
 *
 * [Flags]
 */
var EffectiveRights;
(function (EffectiveRights) {
    /**
     * The user has no acces right on the item or folder.
     */
    EffectiveRights[EffectiveRights["None"] = 0] = "None";
    /**
     * The user can create associated items (FAI)
     */
    EffectiveRights[EffectiveRights["CreateAssociated"] = 1] = "CreateAssociated";
    /**
     * The user can create items.
     */
    EffectiveRights[EffectiveRights["CreateContents"] = 2] = "CreateContents";
    /**
     * The user can create sub-folders.
     */
    EffectiveRights[EffectiveRights["CreateHierarchy"] = 4] = "CreateHierarchy";
    /**
     * The user can delete items and/or folders.
     */
    EffectiveRights[EffectiveRights["Delete"] = 8] = "Delete";
    /**
     * The user can modify the properties of items and/or folders.
     */
    EffectiveRights[EffectiveRights["Modify"] = 16] = "Modify";
    /**
     * The user can read the contents of items.
     */
    EffectiveRights[EffectiveRights["Read"] = 32] = "Read";
    /**
     * The user can view private items.
     */
    EffectiveRights[EffectiveRights["ViewPrivateItems"] = 64] = "ViewPrivateItems";
})(EffectiveRights = exports.EffectiveRights || (exports.EffectiveRights = {}));
/**
 * Defines the folder type of a retention policy tag.
 */
var ElcFolderType;
(function (ElcFolderType) {
    /**
     * Calendar folder.
     */
    ElcFolderType[ElcFolderType["Calendar"] = 1] = "Calendar";
    /**
     * Contacts folder.
     */
    ElcFolderType[ElcFolderType["Contacts"] = 2] = "Contacts";
    /**
     * Deleted Items.
     */
    ElcFolderType[ElcFolderType["DeletedItems"] = 3] = "DeletedItems";
    /**
     * Drafts folder.
     */
    ElcFolderType[ElcFolderType["Drafts"] = 4] = "Drafts";
    /**
     * Inbox.
     */
    ElcFolderType[ElcFolderType["Inbox"] = 5] = "Inbox";
    /**
     * Junk mail
     */
    ElcFolderType[ElcFolderType["JunkEmail"] = 6] = "JunkEmail";
    /**
     * Journal.
     */
    ElcFolderType[ElcFolderType["Journal"] = 7] = "Journal";
    /**
     * Notes.
     */
    ElcFolderType[ElcFolderType["Notes"] = 8] = "Notes";
    /**
     * Outbox.
     */
    ElcFolderType[ElcFolderType["Outbox"] = 9] = "Outbox";
    /**
     * Sent Items.
     */
    ElcFolderType[ElcFolderType["SentItems"] = 10] = "SentItems";
    /**
     * Tasks folder.
     */
    ElcFolderType[ElcFolderType["Tasks"] = 11] = "Tasks";
    /**
     * Policy applies to all folders that do not have a policy.
     */
    ElcFolderType[ElcFolderType["All"] = 12] = "All";
    /**
     * Policy is for an organizational policy.
     */
    ElcFolderType[ElcFolderType["ManagedCustomFolder"] = 13] = "ManagedCustomFolder";
    /**
     * Policy is for the RSS Subscription (default) folder.
     */
    ElcFolderType[ElcFolderType["RssSubscriptions"] = 14] = "RssSubscriptions";
    /**
     * Policy is for the Sync Issues (default) folder.
     */
    ElcFolderType[ElcFolderType["SyncIssues"] = 15] = "SyncIssues";
    /**
     * Policy is for the Conversation History (default) folder.
     * This folder is used by the Office Communicator to archive IM conversations.
     */
    ElcFolderType[ElcFolderType["ConversationHistory"] = 16] = "ConversationHistory";
    /**
     * Policy is for the personal folders.
     */
    ElcFolderType[ElcFolderType["Personal"] = 17] = "Personal";
    /**
     * Policy is for Dumpster 2.0.
     */
    ElcFolderType[ElcFolderType["RecoverableItems"] = 18] = "RecoverableItems";
    /**
     * Non IPM Subtree root.
     */
    ElcFolderType[ElcFolderType["NonIpmRoot"] = 19] = "NonIpmRoot";
})(ElcFolderType = exports.ElcFolderType || (exports.ElcFolderType = {}));
/**
 * Defines e-mail address entries for a contact.
 */
var EmailAddressKey;
(function (EmailAddressKey) {
    /**
     * The first e-mail address.
     */
    EmailAddressKey[EmailAddressKey["EmailAddress1"] = 0] = "EmailAddress1";
    /**
     * The second e-mail address.
     */
    EmailAddressKey[EmailAddressKey["EmailAddress2"] = 1] = "EmailAddress2";
    /**
     * The third e-mail address.
     */
    EmailAddressKey[EmailAddressKey["EmailAddress3"] = 2] = "EmailAddress3";
})(EmailAddressKey = exports.EmailAddressKey || (exports.EmailAddressKey = {}));
/**
 * Defines the email position of an extracted entity.
 */
var EmailPosition;
(function (EmailPosition) {
    /**
     * The position is in the latest reply.
     */
    EmailPosition[EmailPosition["LatestReply"] = 0] = "LatestReply";
    /**
     * The position is not in the latest reply.
     */
    EmailPosition[EmailPosition["Other"] = 1] = "Other";
    /**
     * The position is in the subject.
     */
    EmailPosition[EmailPosition["Subject"] = 2] = "Subject";
    /**
     * The position is in the signature.
     */
    EmailPosition[EmailPosition["Signature"] = 3] = "Signature";
})(EmailPosition = exports.EmailPosition || (exports.EmailPosition = {}));
//D:\dr\gh\ews-javascript-api_ForNewFeatures\build\temp\src\js\Enumerations\EnumToExchangeVersionMappingHelper.ts
/**custom created to simplify creation of above Enum(s) to ExchangeVersion mapping in EwsUtil, There is no c# like Attribute typesystem and reflection available */
var EnumToSchemaMappingHelper;
(function (EnumToSchemaMappingHelper) {
    EnumToSchemaMappingHelper[EnumToSchemaMappingHelper["WellKnownFolderName"] = 0] = "WellKnownFolderName";
    /**Item Traversal */
    EnumToSchemaMappingHelper[EnumToSchemaMappingHelper["ItemTraversal"] = 1] = "ItemTraversal";
    EnumToSchemaMappingHelper[EnumToSchemaMappingHelper["ConversationQueryTraversal"] = 2] = "ConversationQueryTraversal";
    EnumToSchemaMappingHelper[EnumToSchemaMappingHelper["FileAsMapping"] = 3] = "FileAsMapping";
    EnumToSchemaMappingHelper[EnumToSchemaMappingHelper["EventType"] = 4] = "EventType";
    EnumToSchemaMappingHelper[EnumToSchemaMappingHelper["MeetingRequestsDeliveryScope"] = 5] = "MeetingRequestsDeliveryScope";
    EnumToSchemaMappingHelper[EnumToSchemaMappingHelper["ViewFilter"] = 6] = "ViewFilter";
    EnumToSchemaMappingHelper[EnumToSchemaMappingHelper["MailboxType"] = 7] = "MailboxType";
})(EnumToSchemaMappingHelper = exports.EnumToSchemaMappingHelper || (exports.EnumToSchemaMappingHelper = {}));
/**
 * Defines the types of event that can occur in a folder.
 */
var EventType;
(function (EventType) {
    /**
     * This event is sent to a client application by push notifications to indicate that the subscription is still alive.
     */
    EventType[EventType["Status"] = 0] = "Status";
    /**
     * This event indicates that a new e-mail message was received.
     */
    EventType[EventType["NewMail"] = 1] = "NewMail";
    /**
     * This event indicates that an item or folder has been deleted.
     */
    EventType[EventType["Deleted"] = 2] = "Deleted";
    /**
     * This event indicates that an item or folder has been modified.
     */
    EventType[EventType["Modified"] = 3] = "Modified";
    /**
     * This event indicates that an item or folder has been moved to another folder.
     */
    EventType[EventType["Moved"] = 4] = "Moved";
    /**
     * This event indicates that an item or folder has been copied to another folder.
     */
    EventType[EventType["Copied"] = 5] = "Copied";
    /**
     * This event indicates that a new item or folder has been created.
     */
    EventType[EventType["Created"] = 6] = "Created";
    /**
     * This event indicates that free/busy has changed. This is only supported in 2010 SP1 or later
     */
    EventType[EventType["FreeBusyChanged"] = 7] = "FreeBusyChanged";
})(EventType = exports.EventType || (exports.EventType = {}));
(function (EventType) {
    /**RequiredServerVersionAttribute */
    function RequiredServerVersion(value) {
        if (value <= 6)
            return ExchangeVersion.Exchange2007_SP1;
        if (value == 7)
            return ExchangeVersion.Exchange2010_SP1;
        return ExchangeVersion.Exchange_Version_Not_Updated;
    }
    EventType.RequiredServerVersion = RequiredServerVersion;
    /**EwsEnumAttribute */
    function FromEwsEnumString(value) {
        return EventType[value.replace("Event", "")];
    }
    EventType.FromEwsEnumString = FromEwsEnumString;
    /**EwsEnumAttribute */
    function ToEwsEnumString(value) {
        return EventType[value] + "Event";
    }
    EventType.ToEwsEnumString = ToEwsEnumString;
})(EventType = exports.EventType || (exports.EventType = {}));
/**
 * Defines the each available Exchange release version
 */
var ExchangeVersion;
(function (ExchangeVersion) {
    /**
     * Microsoft Exchange 2007, Service Pack 1
     */
    ExchangeVersion[ExchangeVersion["Exchange2007_SP1"] = 0] = "Exchange2007_SP1";
    /**
     * Microsoft Exchange 2010
     */
    ExchangeVersion[ExchangeVersion["Exchange2010"] = 1] = "Exchange2010";
    /**
     * Microsoft Exchange 2010, Service Pack 1
     */
    ExchangeVersion[ExchangeVersion["Exchange2010_SP1"] = 2] = "Exchange2010_SP1";
    /**
     * Microsoft Exchange 2010, Service Pack 2
     */
    ExchangeVersion[ExchangeVersion["Exchange2010_SP2"] = 3] = "Exchange2010_SP2";
    /**
     * Microsoft Exchange 2013
     */
    ExchangeVersion[ExchangeVersion["Exchange2013"] = 4] = "Exchange2013";
    /**
     * Microsoft Exchange 2013 SP1
     */
    ExchangeVersion[ExchangeVersion["Exchange2013_SP1"] = 5] = "Exchange2013_SP1";
    /**
     * Microsoft Exchange 2015 (aka Exchange 2016)
     */
    ExchangeVersion[ExchangeVersion["Exchange2015"] = 6] = "Exchange2015";
    /**
     * Microsoft Exchange 2016
     */
    ExchangeVersion[ExchangeVersion["Exchange2016"] = 7] = "Exchange2016";
    /**
     * Functionality starting 10/05/2015
     */
    ExchangeVersion[ExchangeVersion["V2015_10_05"] = 8] = "V2015_10_05";
    /** internal tracking of any version not updated in **ews-javascript-api** */
    ExchangeVersion[ExchangeVersion["Exchange_Version_Not_Updated"] = 15000] = "Exchange_Version_Not_Updated";
})(ExchangeVersion = exports.ExchangeVersion || (exports.ExchangeVersion = {}));
/**
 * Defines the type of ExtensionInstallScope.
 */
var ExtensionInstallScope;
(function (ExtensionInstallScope) {
    /**
     * None
     */
    ExtensionInstallScope[ExtensionInstallScope["None"] = 0] = "None";
    /**
     * User
     */
    ExtensionInstallScope[ExtensionInstallScope["User"] = 1] = "User";
    /**
     * Organization
     */
    ExtensionInstallScope[ExtensionInstallScope["Organization"] = 2] = "Organization";
    /**
     * Exchange Default
     */
    ExtensionInstallScope[ExtensionInstallScope["Default"] = 3] = "Default";
})(ExtensionInstallScope = exports.ExtensionInstallScope || (exports.ExtensionInstallScope = {}));
/**
 * Defines the type of ExtensionType.
 */
var ExtensionType;
(function (ExtensionType) {
    /**
     * Default
     */
    ExtensionType[ExtensionType["Default"] = 0] = "Default";
    /**
     * Private
     */
    ExtensionType[ExtensionType["Private"] = 1] = "Private";
    /**
     * MarketPlace
     */
    ExtensionType[ExtensionType["MarketPlace"] = 2] = "MarketPlace";
})(ExtensionType = exports.ExtensionType || (exports.ExtensionType = {}));
/**
 * Defines the way the FileAs property of a contact is automatically formatted.
 */
var FileAsMapping;
(function (FileAsMapping) {
    /**
     * No automatic formatting is used.
     */
    FileAsMapping[FileAsMapping["None"] = 0] = "None";
    /**
     * Surname, GivenName
     */
    FileAsMapping[FileAsMapping["SurnameCommaGivenName"] = 1] = "SurnameCommaGivenName";
    /**
     * GivenName Surname
     */
    FileAsMapping[FileAsMapping["GivenNameSpaceSurname"] = 2] = "GivenNameSpaceSurname";
    /**
     * Company
     */
    FileAsMapping[FileAsMapping["Company"] = 3] = "Company";
    /**
     * Surname, GivenName (Company)
     */
    FileAsMapping[FileAsMapping["SurnameCommaGivenNameCompany"] = 4] = "SurnameCommaGivenNameCompany";
    /**
     * Company (SurnameGivenName)
     */
    FileAsMapping[FileAsMapping["CompanySurnameGivenName"] = 5] = "CompanySurnameGivenName";
    /**
     * SurnameGivenName
     */
    FileAsMapping[FileAsMapping["SurnameGivenName"] = 6] = "SurnameGivenName";
    /**
     * SurnameGivenName (Company)
     */
    FileAsMapping[FileAsMapping["SurnameGivenNameCompany"] = 7] = "SurnameGivenNameCompany";
    /**
     * Company (Surname, GivenName)
     */
    FileAsMapping[FileAsMapping["CompanySurnameCommaGivenName"] = 8] = "CompanySurnameCommaGivenName";
    /**
     * SurnameGivenName Suffix
     */
    FileAsMapping[FileAsMapping["SurnameGivenNameSuffix"] = 9] = "SurnameGivenNameSuffix";
    /**
     * Surname GivenName (Company)
     */
    FileAsMapping[FileAsMapping["SurnameSpaceGivenNameCompany"] = 10] = "SurnameSpaceGivenNameCompany";
    /**
     * Company (Surname GivenName)
     */
    FileAsMapping[FileAsMapping["CompanySurnameSpaceGivenName"] = 11] = "CompanySurnameSpaceGivenName";
    /**
     * Surname GivenName
     */
    FileAsMapping[FileAsMapping["SurnameSpaceGivenName"] = 12] = "SurnameSpaceGivenName";
    /**
     * Display Name (Exchange 2010 or later).
     */
    FileAsMapping[FileAsMapping["DisplayName"] = 13] = "DisplayName";
    /**
     * GivenName (Exchange 2010 or later).
     */
    FileAsMapping[FileAsMapping["GivenName"] = 14] = "GivenName";
    /**
     * Surname GivenName Middle Suffix (Exchange 2010 or later).
     */
    FileAsMapping[FileAsMapping["SurnameGivenNameMiddleSuffix"] = 15] = "SurnameGivenNameMiddleSuffix";
    /**
     * Surname (Exchange 2010 or later).
     */
    FileAsMapping[FileAsMapping["Surname"] = 16] = "Surname";
    /**
     * Empty (Exchange 2010 or later).
     */
    FileAsMapping[FileAsMapping["Empty"] = 17] = "Empty";
})(FileAsMapping = exports.FileAsMapping || (exports.FileAsMapping = {}));
(function (FileAsMapping) {
    /**RequiredServerVersionAttribute */
    function RequiredServerVersion(value) {
        if (value <= 12)
            return ExchangeVersion.Exchange2007_SP1;
        if (value <= 17)
            return ExchangeVersion.Exchange2010;
        return ExchangeVersion.Exchange_Version_Not_Updated;
    }
    FileAsMapping.RequiredServerVersion = RequiredServerVersion;
    // create map for EwsEnumAttribute, this can be parsed without issue
    var EwsEnumStringMap = {};
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.SurnameCommaGivenName] = "LastCommaFirst"] = FileAsMapping.SurnameCommaGivenName;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.GivenNameSpaceSurname] = "FirstSpaceLast"] = FileAsMapping.GivenNameSpaceSurname;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.SurnameCommaGivenNameCompany] = "LastCommaFirstCompany"] = FileAsMapping.SurnameCommaGivenNameCompany;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.CompanySurnameGivenName] = "CompanyLastFirst"] = FileAsMapping.CompanySurnameGivenName;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.SurnameGivenName] = "LastFirst"] = FileAsMapping.SurnameGivenName;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.SurnameGivenNameCompany] = "LastFirstCompany"] = FileAsMapping.SurnameGivenNameCompany;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.CompanySurnameCommaGivenName] = "CompanyLastCommaFirst"] = FileAsMapping.CompanySurnameCommaGivenName;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.SurnameGivenNameSuffix] = "LastFirstSuffix"] = FileAsMapping.SurnameGivenNameSuffix;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.SurnameSpaceGivenNameCompany] = "LastSpaceFirstCompany"] = FileAsMapping.SurnameSpaceGivenNameCompany;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.CompanySurnameSpaceGivenName] = "CompanyLastSpaceFirst"] = FileAsMapping.CompanySurnameSpaceGivenName;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.SurnameSpaceGivenName] = "LastSpaceFirst"] = FileAsMapping.SurnameSpaceGivenName;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.GivenName] = "FirstName"] = FileAsMapping.GivenName;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.SurnameGivenNameMiddleSuffix] = "LastFirstMiddleSuffix"] = FileAsMapping.SurnameGivenNameMiddleSuffix;
    EwsEnumStringMap[EwsEnumStringMap[FileAsMapping.Surname] = "LastName"] = FileAsMapping.Surname;
    /**EwsEnumAttribute */
    function FromEwsEnumString(value) {
        return EwsEnumStringMap[value] || FileAsMapping[value];
    }
    FileAsMapping.FromEwsEnumString = FromEwsEnumString;
    /**EwsEnumAttribute */
    function ToEwsEnumString(value) {
        return EwsEnumStringMap[value] || FileAsMapping[value];
    }
    FileAsMapping.ToEwsEnumString = ToEwsEnumString;
})(FileAsMapping = exports.FileAsMapping || (exports.FileAsMapping = {}));
/**
 * Defines the follow-up actions that may be stamped on a message.
 */
var FlaggedForAction;
(function (FlaggedForAction) {
    /**
     * The message is flagged with any action.
     */
    FlaggedForAction[FlaggedForAction["Any"] = 0] = "Any";
    /**
     * The recipient is requested to call the sender.
     */
    FlaggedForAction[FlaggedForAction["Call"] = 1] = "Call";
    /**
     * The recipient is requested not to forward the message.
     */
    FlaggedForAction[FlaggedForAction["DoNotForward"] = 2] = "DoNotForward";
    /**
     * The recipient is requested to follow up on the message.
     */
    FlaggedForAction[FlaggedForAction["FollowUp"] = 3] = "FollowUp";
    /**
     * The recipient received the message for information.
     */
    FlaggedForAction[FlaggedForAction["FYI"] = 4] = "FYI";
    /**
     * The recipient is requested to forward the message.
     */
    FlaggedForAction[FlaggedForAction["Forward"] = 5] = "Forward";
    /**
     * The recipient is informed that a response to the message is not required.
     */
    FlaggedForAction[FlaggedForAction["NoResponseNecessary"] = 6] = "NoResponseNecessary";
    /**
     * The recipient is requested to read the message.
     */
    FlaggedForAction[FlaggedForAction["Read"] = 7] = "Read";
    /**
     * The recipient is requested to reply to the sender of the message.
     */
    FlaggedForAction[FlaggedForAction["Reply"] = 8] = "Reply";
    /**
     * The recipient is requested to reply to everyone the message was sent to.
     */
    FlaggedForAction[FlaggedForAction["ReplyToAll"] = 9] = "ReplyToAll";
    /**
     * The recipient is requested to review the message.
     */
    FlaggedForAction[FlaggedForAction["Review"] = 10] = "Review";
})(FlaggedForAction = exports.FlaggedForAction || (exports.FlaggedForAction = {}));
/**
 * Defines permission levels for calendar folders.
 */
var FolderPermissionLevel;
(function (FolderPermissionLevel) {
    /**
     * No permission is granted.
     */
    FolderPermissionLevel[FolderPermissionLevel["None"] = 0] = "None";
    /**
     * The Owner level.
     */
    FolderPermissionLevel[FolderPermissionLevel["Owner"] = 1] = "Owner";
    /**
     * The Publishing Editor level.
     */
    FolderPermissionLevel[FolderPermissionLevel["PublishingEditor"] = 2] = "PublishingEditor";
    /**
     * The Editor level.
     */
    FolderPermissionLevel[FolderPermissionLevel["Editor"] = 3] = "Editor";
    /**
     * The Publishing Author level.
     */
    FolderPermissionLevel[FolderPermissionLevel["PublishingAuthor"] = 4] = "PublishingAuthor";
    /**
     * The Author level.
     */
    FolderPermissionLevel[FolderPermissionLevel["Author"] = 5] = "Author";
    /**
     * The Nonediting Author level.
     */
    FolderPermissionLevel[FolderPermissionLevel["NoneditingAuthor"] = 6] = "NoneditingAuthor";
    /**
     * The Reviewer level.
     */
    FolderPermissionLevel[FolderPermissionLevel["Reviewer"] = 7] = "Reviewer";
    /**
     * The Contributor level.
     */
    FolderPermissionLevel[FolderPermissionLevel["Contributor"] = 8] = "Contributor";
    /**
     * The Free/busy Time Only level. (Can only be applied to Calendar folders).
     */
    FolderPermissionLevel[FolderPermissionLevel["FreeBusyTimeOnly"] = 9] = "FreeBusyTimeOnly";
    /**
     * The Free/busy Time, Subject and Location level. (Can only be applied to Calendar folders).
     */
    FolderPermissionLevel[FolderPermissionLevel["FreeBusyTimeAndSubjectAndLocation"] = 10] = "FreeBusyTimeAndSubjectAndLocation";
    /**
     * The Custom level.
     */
    FolderPermissionLevel[FolderPermissionLevel["Custom"] = 11] = "Custom";
})(FolderPermissionLevel = exports.FolderPermissionLevel || (exports.FolderPermissionLevel = {}));
/**
 * Defines a user's read access permission on items in a non-calendar folder.
 */
var FolderPermissionReadAccess;
(function (FolderPermissionReadAccess) {
    /**
     * The user has no read access on the items in the folder.
     */
    FolderPermissionReadAccess[FolderPermissionReadAccess["None"] = 0] = "None";
    /**
     * The user can read the start and end date and time of appointments. (Can only be applied to Calendar folders).
     */
    FolderPermissionReadAccess[FolderPermissionReadAccess["TimeOnly"] = 1] = "TimeOnly";
    /**
     * The user can read the start and end date and time, subject and location of appointments. (Can only be applied to Calendar folders).
     */
    FolderPermissionReadAccess[FolderPermissionReadAccess["TimeAndSubjectAndLocation"] = 2] = "TimeAndSubjectAndLocation";
    /**
     * The user has access to the full details of items.
     */
    FolderPermissionReadAccess[FolderPermissionReadAccess["FullDetails"] = 3] = "FullDetails";
})(FolderPermissionReadAccess = exports.FolderPermissionReadAccess || (exports.FolderPermissionReadAccess = {}));
/**
 * Defines the scope of FindFolders operations.
 */
var FolderTraversal;
(function (FolderTraversal) {
    /**
     * Only direct sub-folders are retrieved.
     */
    FolderTraversal[FolderTraversal["Shallow"] = 0] = "Shallow";
    /**
     * The entire hierarchy of sub-folders is retrieved.
     */
    FolderTraversal[FolderTraversal["Deep"] = 1] = "Deep";
    /**
     * Only soft deleted folders are retrieved.
     */
    FolderTraversal[FolderTraversal["SoftDeleted"] = 2] = "SoftDeleted";
})(FolderTraversal = exports.FolderTraversal || (exports.FolderTraversal = {}));
/**
 * Defines the type of free/busy information returned by a GetUserAvailability operation.
 */
var FreeBusyViewType;
(function (FreeBusyViewType) {
    /**
     * No view could be returned. This value cannot be specified in a call to GetUserAvailability.
     */
    FreeBusyViewType[FreeBusyViewType["None"] = 0] = "None";
    /**
     * Represents an aggregated free/busy stream. In cross-forest scenarios in which the target user in one forest does not have an Availability service configured, the Availability service of the requestor retrieves the target user's free/busy information from the free/busy public folder.
     * Because public folders only store free/busy information in merged form, MergedOnly is the only available information.
     */
    FreeBusyViewType[FreeBusyViewType["MergedOnly"] = 1] = "MergedOnly";
    /**
     * Represents the legacy status information: free, busy, tentative, and OOF. This also includes the start/end times of the appointments. This view is richer than the legacy free/busy view because individual meeting start and end times are provided instead of an aggregated free/busy stream.
     */
    FreeBusyViewType[FreeBusyViewType["FreeBusy"] = 2] = "FreeBusy";
    /**
     * Represents all the properties in FreeBusy with a stream of merged free/busy availability information.
     */
    FreeBusyViewType[FreeBusyViewType["FreeBusyMerged"] = 3] = "FreeBusyMerged";
    /**
     * Represents the legacy status information: free, busy, tentative, and OOF; the start/end times of the appointments; and various properties of the appointment such as subject, location, and importance.
     * This requested view will return the maximum amount of information for which the requesting user is privileged.
     * If merged free/busy information only is available, as with requesting information for users in a Microsoft Exchange Server 2003 forest, MergedOnly will be returned.
     * Otherwise, FreeBusy or Detailed will be returned.
     */
    FreeBusyViewType[FreeBusyViewType["Detailed"] = 4] = "Detailed";
    /**
     * Represents all the properties in Detailed with a stream of merged free/busy availability information.
     * If only merged free/busy information is available, for example if the mailbox exists on a computer running Exchange 2003, MergedOnly will be returned.
     * Otherwise, FreeBusyMerged or DetailedMerged will be returned.
     */
    FreeBusyViewType[FreeBusyViewType["DetailedMerged"] = 5] = "DetailedMerged";
})(FreeBusyViewType = exports.FreeBusyViewType || (exports.FreeBusyViewType = {}));
//todo - move to file where class Microsoft.Exchange.WebServices.Dns.DnsNativeMethods is located
// module Microsoft.Exchange.WebServices.Dns.DnsNativeMethods {
//     export enum FreeType {
//         RecordList = 1
//     }
// }
// import _export = Microsoft.Exchange.WebServices.Dns.DnsNativeMethods.FreeType;
// export = _export;
/**
 * Defines the response types from a GetUserPhoto request
 */
var GetUserPhotoStatus;
(function (GetUserPhotoStatus) {
    /**
     * The photo was successfully returned
     */
    GetUserPhotoStatus[GetUserPhotoStatus["PhotoReturned"] = 0] = "PhotoReturned";
    /**
     * The photo has not changed since it was last obtained
     */
    GetUserPhotoStatus[GetUserPhotoStatus["PhotoUnchanged"] = 1] = "PhotoUnchanged";
    /**
     * The photo or user was not found on the server
     */
    GetUserPhotoStatus[GetUserPhotoStatus["PhotoOrUserNotFound"] = 2] = "PhotoOrUserNotFound";
})(GetUserPhotoStatus = exports.GetUserPhotoStatus || (exports.GetUserPhotoStatus = {}));
//todo - move to file where class Microsoft.Exchange.WebServices.Data.HangingServiceRequestBase is located
// - cant move - this is needed by shared eventargs type member
/**
 * @internal Enumeration of reasons that a hanging request may disconnect.
 */
var HangingRequestDisconnectReason;
(function (HangingRequestDisconnectReason) {
    /**
     * The server cleanly closed the connection.
     */
    HangingRequestDisconnectReason[HangingRequestDisconnectReason["Clean"] = 0] = "Clean";
    /**
     * The client closed the connection.
     */
    HangingRequestDisconnectReason[HangingRequestDisconnectReason["UserInitiated"] = 1] = "UserInitiated";
    /**
     * The connection timed out do to a lack of a heartbeat received.
     */
    HangingRequestDisconnectReason[HangingRequestDisconnectReason["Timeout"] = 2] = "Timeout";
    /**
     * An exception occurred on the connection.
     */
    HangingRequestDisconnectReason[HangingRequestDisconnectReason["Exception"] = 3] = "Exception";
})(HangingRequestDisconnectReason = exports.HangingRequestDisconnectReason || (exports.HangingRequestDisconnectReason = {}));
/**
 * Defines the hold action.
 */
var HoldAction;
(function (HoldAction) {
    /**
     * Create new hold
     */
    HoldAction[HoldAction["Create"] = 0] = "Create";
    /**
     * Update query associated with a hold
     */
    HoldAction[HoldAction["Update"] = 1] = "Update";
    /**
     * Release the hold
     */
    HoldAction[HoldAction["Remove"] = 2] = "Remove";
})(HoldAction = exports.HoldAction || (exports.HoldAction = {}));
/**
 * Defines the hold status.
 */
var HoldStatus;
(function (HoldStatus) {
    /**
     * Not on hold
     */
    HoldStatus[HoldStatus["NotOnHold"] = 0] = "NotOnHold";
    /**
     * Placing/removing hold is in-progress
     */
    HoldStatus[HoldStatus["Pending"] = 1] = "Pending";
    /**
     * On hold
     */
    HoldStatus[HoldStatus["OnHold"] = 2] = "OnHold";
    /**
     * Some mailboxes are on hold and some are not
     */
    HoldStatus[HoldStatus["PartialHold"] = 3] = "PartialHold";
    /**
     * The hold operation failed
     */
    HoldStatus[HoldStatus["Failed"] = 4] = "Failed";
})(HoldStatus = exports.HoldStatus || (exports.HoldStatus = {}));
/**
 * The values indicate the types of item icons to display.
 */
var IconIndex;
(function (IconIndex) {
    /**
     * A default icon.
     */
    IconIndex[IconIndex["Default"] = 0] = "Default";
    /**
     * Post Item
     */
    IconIndex[IconIndex["PostItem"] = 1] = "PostItem";
    /**
     * Icon read
     */
    IconIndex[IconIndex["MailRead"] = 2] = "MailRead";
    /**
     * Icon unread
     */
    IconIndex[IconIndex["MailUnread"] = 3] = "MailUnread";
    /**
     * Icon replied
     */
    IconIndex[IconIndex["MailReplied"] = 4] = "MailReplied";
    /**
     * Icon forwarded
     */
    IconIndex[IconIndex["MailForwarded"] = 5] = "MailForwarded";
    /**
     * Icon encrypted
     */
    IconIndex[IconIndex["MailEncrypted"] = 6] = "MailEncrypted";
    /**
     * Icon S/MIME signed
     */
    IconIndex[IconIndex["MailSmimeSigned"] = 7] = "MailSmimeSigned";
    /**
     * Icon encrypted replied
     */
    IconIndex[IconIndex["MailEncryptedReplied"] = 8] = "MailEncryptedReplied";
    /**
     * Icon S/MIME signed replied
     */
    IconIndex[IconIndex["MailSmimeSignedReplied"] = 9] = "MailSmimeSignedReplied";
    /**
     * Icon encrypted forwarded
     */
    IconIndex[IconIndex["MailEncryptedForwarded"] = 10] = "MailEncryptedForwarded";
    /**
     * Icon S/MIME signed forwarded
     */
    IconIndex[IconIndex["MailSmimeSignedForwarded"] = 11] = "MailSmimeSignedForwarded";
    /**
     * Icon encrypted read
     */
    IconIndex[IconIndex["MailEncryptedRead"] = 12] = "MailEncryptedRead";
    /**
     * Icon S/MIME signed read
     */
    IconIndex[IconIndex["MailSmimeSignedRead"] = 13] = "MailSmimeSignedRead";
    /**
     * IRM-protected mail
     */
    IconIndex[IconIndex["MailIrm"] = 14] = "MailIrm";
    /**
     * IRM-protected mail forwarded
     */
    IconIndex[IconIndex["MailIrmForwarded"] = 15] = "MailIrmForwarded";
    /**
     * IRM-protected mail replied
     */
    IconIndex[IconIndex["MailIrmReplied"] = 16] = "MailIrmReplied";
    /**
     * Icon sms routed to external messaging system
     */
    IconIndex[IconIndex["SmsSubmitted"] = 17] = "SmsSubmitted";
    /**
     * Icon sms routed to external messaging system
     */
    IconIndex[IconIndex["SmsRoutedToDeliveryPoint"] = 18] = "SmsRoutedToDeliveryPoint";
    /**
     * Icon sms routed to external messaging system
     */
    IconIndex[IconIndex["SmsRoutedToExternalMessagingSystem"] = 19] = "SmsRoutedToExternalMessagingSystem";
    /**
     * Icon sms routed to external messaging system
     */
    IconIndex[IconIndex["SmsDelivered"] = 20] = "SmsDelivered";
    /**
     * Outlook Default for Contacts
     */
    IconIndex[IconIndex["OutlookDefaultForContacts"] = 21] = "OutlookDefaultForContacts";
    /**
     * Icon appointment item
     */
    IconIndex[IconIndex["AppointmentItem"] = 22] = "AppointmentItem";
    /**
     * Icon appointment recur
     */
    IconIndex[IconIndex["AppointmentRecur"] = 23] = "AppointmentRecur";
    /**
     * Icon appointment meet
     */
    IconIndex[IconIndex["AppointmentMeet"] = 24] = "AppointmentMeet";
    /**
     * Icon appointment meet recur
     */
    IconIndex[IconIndex["AppointmentMeetRecur"] = 25] = "AppointmentMeetRecur";
    /**
     * Icon appointment meet NY
     */
    IconIndex[IconIndex["AppointmentMeetNY"] = 26] = "AppointmentMeetNY";
    /**
     * Icon appointment meet yes
     */
    IconIndex[IconIndex["AppointmentMeetYes"] = 27] = "AppointmentMeetYes";
    /**
     * Icon appointment meet no
     */
    IconIndex[IconIndex["AppointmentMeetNo"] = 28] = "AppointmentMeetNo";
    /**
     * Icon appointment meet maybe
     */
    IconIndex[IconIndex["AppointmentMeetMaybe"] = 29] = "AppointmentMeetMaybe";
    /**
     * Icon appointment meet cancel
     */
    IconIndex[IconIndex["AppointmentMeetCancel"] = 30] = "AppointmentMeetCancel";
    /**
     * Icon appointment meet info
     */
    IconIndex[IconIndex["AppointmentMeetInfo"] = 31] = "AppointmentMeetInfo";
    /**
     * Icon task item
     */
    IconIndex[IconIndex["TaskItem"] = 32] = "TaskItem";
    /**
     * Icon task recur
     */
    IconIndex[IconIndex["TaskRecur"] = 33] = "TaskRecur";
    /**
     * Icon task owned
     */
    IconIndex[IconIndex["TaskOwned"] = 34] = "TaskOwned";
    /**
     * Icon task delegated
     */
    IconIndex[IconIndex["TaskDelegated"] = 35] = "TaskDelegated";
})(IconIndex = exports.IconIndex || (exports.IconIndex = {}));
/**
 * Defines supported Id formats in ConvertId operations.
 */
var IdFormat;
(function (IdFormat) {
    /**
     * The EWS Id format used in Exchange 2007 RTM.
     */
    IdFormat[IdFormat["EwsLegacyId"] = 0] = "EwsLegacyId";
    /**
     * The EWS Id format used in Exchange 2007 SP1 and above.
     */
    IdFormat[IdFormat["EwsId"] = 1] = "EwsId";
    /**
     * The base64-encoded PR_ENTRYID property.
     */
    IdFormat[IdFormat["EntryId"] = 2] = "EntryId";
    /**
     * The hexadecimal representation  of the PR_ENTRYID property.
     */
    IdFormat[IdFormat["HexEntryId"] = 3] = "HexEntryId";
    /**
     * The Store Id format.
     */
    IdFormat[IdFormat["StoreId"] = 4] = "StoreId";
    /**
     * The Outlook Web Access Id format.
     */
    IdFormat[IdFormat["OwaId"] = 5] = "OwaId";
})(IdFormat = exports.IdFormat || (exports.IdFormat = {}));
// //todo - move to file where class Microsoft.Exchange.WebServices.Strings is located
// module Microsoft.Exchange.WebServices.Strings {
//     export enum IDs {
//         CannotRemoveSubscriptionFromLiveConnection = 1631423810,
//         ReadAccessInvalidForNonCalendarFolder = 3355844483,
//         PropertyDefinitionPropertyMustBeSet = 1413133863,
//         ArgumentIsBlankString = 2808916828,
//         InvalidAutodiscoverDomainsCount = 2110564001,
//         MinutesMustBeBetween0And1439 = 3846446647,
//         DeleteInvalidForUnsavedUserConfiguration = 3725066606,
//         PeriodNotFound = 732877372,
//         InvalidAutodiscoverSmtpAddress = 742945049,
//         InvalidOAuthToken = 2371807741,
//         MaxScpHopsExceeded = 540781291,
//         ContactGroupMemberCannotBeUpdatedWithoutBeingLoadedFirst = 412932664,
//         CurrentPositionNotElementStart = 3932722495,
//         CannotConvertBetweenTimeZones = 1762296216,
//         FrequencyMustBeBetween1And1440 = 2947629837,
//         CannotSetDelegateFolderPermissionLevelToCustom = 4255072555,
//         PartnerTokenIncompatibleWithRequestVersion = 231532733,
//         InvalidAutodiscoverRequest = 216906786,
//         InvalidAsyncResult = 2795977038,
//         InvalidMailboxType = 1875536889,
//         AttachmentCollectionNotLoaded = 368467777,
//         ParameterIncompatibleWithRequestVersion = 1937216341,
//         DayOfWeekIndexMustBeSpecifiedForRecurrencePattern = 814325722,
//         WLIDCredentialsCannotBeUsedWithLegacyAutodiscover = 365885070,
//         PropertyCannotBeUpdated = 2534953608,
//         IncompatibleTypeForArray = 3820761979,
//         PercentCompleteMustBeBetween0And100 = 3936886128,
//         AutodiscoverServiceIncompatibleWithRequestVersion = 460414997,
//         InvalidAutodiscoverSmtpAddressesCount = 1774410042,
//         ServiceUrlMustBeSet = 1922401890,
//         ItemTypeNotCompatible = 4181025268,
//         AttachmentItemTypeMismatch = 1516841384,
//         UnsupportedWebProtocol = 3620572079,
//         EnumValueIncompatibleWithRequestVersion = 777131942,
//         UnexpectedElement = 2080190431,
//         InvalidOrderBy = 162617974,
//         NoAppropriateConstructorForItemClass = 3730786468,
//         SearchFilterAtIndexIsInvalid = 1334400254,
//         DeletingThisObjectTypeNotAuthorized = 3957228737,
//         PropertyCannotBeDeleted = 2011990502,
//         ValuePropertyMustBeSet = 49538054,
//         TagValueIsOutOfRange = 4177209255,
//         ItemToUpdateCannotBeNullOrNew = 893972063,
//         SearchParametersRootFolderIdsEmpty = 2492696699,
//         MailboxQueriesParameterIsNotSpecified = 2182404464,
//         FolderPermissionHasInvalidUserId = 3079787672,
//         InvalidAutodiscoverDomain = 95137117,
//         MailboxesParameterIsNotSpecified = 1274908260,
//         ParentFolderDoesNotHaveId = 3207115397,
//         DayOfMonthMustBeSpecifiedForRecurrencePattern = 190140884,
//         ClassIncompatibleWithRequestVersion = 886236812,
//         CertificateHasNoPrivateKey = 956539910,
//         InvalidOrUnsupportedTimeZoneDefinition = 2660350763,
//         HourMustBeBetween0And23 = 980862610,
//         TimeoutMustBeBetween1And1440 = 1864811546,
//         CredentialsRequired = 107509017,
//         MustLoadOrAssignPropertyBeforeAccess = 1301287431,
//         InvalidAutodiscoverServiceResponse = 2421645987,
//         CannotCallConnectDuringLiveConnection = 3637880390,
//         ObjectDoesNotHaveId = 1990317298,
//         CannotAddSubscriptionToLiveConnection = 2374077290,
//         MaxChangesMustBeBetween1And512 = 3989266019,
//         AttributeValueCannotBeSerialized = 3745271395,
//         SearchFilterMustBeSet = 2182989540,
//         EndDateMustBeGreaterThanStartDate = 2696927076,
//         InvalidDateTime = 3410810540,
//         UpdateItemsDoesNotAllowAttachments = 2505974152,
//         TimeoutMustBeGreaterThanZero = 3210574608,
//         AutodiscoverInvalidSettingForOutlookProvider = 81925120,
//         InvalidRedirectionResponseReturned = 706868687,
//         ExpectedStartElement = 3728006586,
//         DaysOfTheWeekNotSpecified = 2925351706,
//         FolderToUpdateCannotBeNullOrNew = 2887145506,
//         PartnerTokenRequestRequiresUrl = 1709653493,
//         NumberOfOccurrencesMustBeGreaterThanZero = 4020293177,
//         JsonSerializationNotImplemented = 537341821,
//         StartTimeZoneRequired = 263088904,
//         PropertyAlreadyExistsInOrderByCollection = 2291792901,
//         ItemAttachmentMustBeNamed = 2209938519,
//         InvalidAutodiscoverSettingsCount = 2688936715,
//         LoadingThisObjectTypeNotSupported = 1313605428,
//         UserIdForDelegateUserNotSpecified = 3460610998,
//         PhoneCallAlreadyDisconnected = 2720737469,
//         OperationDoesNotSupportAttachments = 1464025756,
//         UnsupportedTimeZonePeriodTransitionTarget = 98512741,
//         IEnumerableDoesNotContainThatManyObject = 474853648,
//         UpdateItemsDoesNotSupportNewOrUnchangedItems = 953072612,
//         ValidationFailed = 1341796948,
//         InvalidRecurrencePattern = 3636462697,
//         TimeWindowStartTimeMustBeGreaterThanEndTime = 4170253059,
//         InvalidAttributeValue = 369811396,
//         FileAttachmentContentIsNotSet = 2449142619,
//         AutodiscoverDidNotReturnEwsUrl = 628121484,
//         RecurrencePatternMustHaveStartDate = 423461609,
//         OccurrenceIndexMustBeGreaterThanZero = 1396112272,
//         ServiceResponseDoesNotContainXml = 1981959699,
//         ItemIsOutOfDate = 2560682386,
//         MinuteMustBeBetween0And59 = 3637133283,
//         NoSoapOrWsSecurityEndpointAvailable = 3954825173,
//         ElementNotFound = 3189440097,
//         IndexIsOutOfRange = 4223767916,
//         PropertyIsReadOnly = 869119007,
//         AttachmentCreationFailed = 2817837707,
//         DayOfMonthMustBeBetween1And31 = 3133762315,
//         ServiceRequestFailed = 2091738407,
//         DelegateUserHasInvalidUserId = 129422921,
//         SearchFilterComparisonValueTypeIsNotSupported = 1069581653,
//         ElementValueCannotBeSerialized = 4258284629,
//         PropertyValueMustBeSpecifiedForRecurrencePattern = 2924950297,
//         NonSummaryPropertyCannotBeUsed = 2436895661,
//         HoldIdParameterIsNotSpecified = 134310332,
//         TransitionGroupNotFound = 21384399,
//         ObjectTypeNotSupported = 4144876524,
//         InvalidTimeoutValue = 3454211069,
//         AutodiscoverRedirectBlocked = 3339063014,
//         PropertySetCannotBeModified = 3717641032,
//         DayOfTheWeekMustBeSpecifiedForRecurrencePattern = 3877446129,
//         ServiceObjectAlreadyHasId = 3918321785,
//         MethodIncompatibleWithRequestVersion = 4274338115,
//         OperationNotSupportedForPropertyDefinitionType = 2727810523,
//         InvalidElementStringValue = 3934659801,
//         CollectionIsEmpty = 500353177,
//         InvalidFrequencyValue = 885177846,
//         UnexpectedEndOfXmlDocument = 546825189,
//         FolderTypeNotCompatible = 3578997681,
//         RequestIncompatibleWithRequestVersion = 3451337077,
//         PropertyTypeIncompatibleWhenUpdatingCollection = 4148083232,
//         ServerVersionNotSupported = 603284986,
//         DurationMustBeSpecifiedWhenScheduled = 666454105,
//         NoError = 1005127777,
//         CannotUpdateNewUserConfiguration = 3972010693,
//         ObjectTypeIncompatibleWithRequestVersion = 2438108153,
//         NullStringArrayElementInvalid = 3604837092,
//         HttpsIsRequired = 333950754,
//         MergedFreeBusyIntervalMustBeSmallerThanTimeWindow = 2480357954,
//         SecondMustBeBetween0And59 = 328519365,
//         AtLeastOneAttachmentCouldNotBeDeleted = 3596957401,
//         IdAlreadyInList = 1233804470,
//         BothSearchFilterAndQueryStringCannotBeSpecified = 3295662635,
//         AdditionalPropertyIsNull = 3383788511,
//         InvalidEmailAddress = 2316486059,
//         MaximumRedirectionHopsExceeded = 1588497945,
//         AutodiscoverCouldNotBeLocated = 3097538091,
//         NoSubscriptionsOnConnection = 2715578908,
//         PermissionLevelInvalidForNonCalendarFolder = 1063351272,
//         InvalidAuthScheme = 2845550636,
//         JsonDeserializationNotImplemented = 311071154,
//         ValuePropertyNotLoaded = 2743202310,
//         PropertyIncompatibleWithRequestVersion = 843308875,
//         OffsetMustBeGreaterThanZero = 2437116628,
//         CreateItemsDoesNotAllowAttachments = 690508625,
//         PropertyDefinitionTypeMismatch = 2445370550,
//         IntervalMustBeGreaterOrEqualToOne = 2129318611,
//         CannotSetPermissionLevelToCustom = 961741172,
//         CannotAddRequestHeader = 2921139860,
//         ArrayMustHaveAtLeastOneElement = 4264880578,
//         MonthMustBeSpecifiedForRecurrencePattern = 567828041,
//         ValueOfTypeCannotBeConverted = 3869807514,
//         ValueCannotBeConverted = 788051255,
//         ServerErrorAndStackTraceDetails = 1481761255,
//         FolderPermissionLevelMustBeSet = 2586079185,
//         AutodiscoverError = 4003396996,
//         ArrayMustHaveSingleDimension = 3066801652,
//         InvalidPropertyValueNotInRange = 2233059550,
//         RegenerationPatternsOnlyValidForTasks = 1453973661,
//         ItemAttachmentCannotBeUpdated = 914733855,
//         EqualityComparisonFilterIsInvalid = 1467147488,
//         AutodiscoverServiceRequestRequiresDomainOrUrl = 2950491364,
//         InvalidUser = 3929050450,
//         AccountIsLocked = 2901788841,
//         InvalidDomainName = 2762661174,
//         TooFewServiceReponsesReturned = 710118117,
//         CannotSubscribeToStatusEvents = 463464377,
//         InvalidSortByPropertyForMailboxSearch = 1066736932,
//         UnexpectedElementType = 2100812591,
//         ValueMustBeGreaterThanZero = 691200302,
//         AttachmentCannotBeUpdated = 2292458752,
//         CreateItemsDoesNotHandleExistingItems = 3912371609,
//         MultipleContactPhotosInAttachment = 2967125165,
//         InvalidRecurrenceRange = 3387532664,
//         CannotSetBothImpersonatedAndPrivilegedUser = 4210899574,
//         NewMessagesWithAttachmentsCannotBeSentDirectly = 1565629292,
//         CannotCallDisconnectWithNoLiveConnection = 3633425214,
//         IdPropertyMustBeSet = 3940556486,
//         ValuePropertyNotAssigned = 1562822901,
//         ZeroLengthArrayInvalid = 4061174908,
//         HoldMailboxesParameterIsNotSpecified = 3345946933,
//         CannotSaveNotNewUserConfiguration = 2270311116,
//         ServiceObjectDoesNotHaveId = 2111195463,
//         PropertyCollectionSizeMismatch = 491519754,
//         XsDurationCouldNotBeParsed = 2861470707,
//         UnknownTimeZonePeriodTransitionType = 2279096081
//     }
// }
// import _export = Microsoft.Exchange.WebServices.Strings.IDs;
// export = _export;
/**
 * Defines Instant Messaging address entries for a contact.
 */
var ImAddressKey;
(function (ImAddressKey) {
    /**
     * The first Instant Messaging address.
     */
    ImAddressKey[ImAddressKey["ImAddress1"] = 0] = "ImAddress1";
    /**
     * The second Instant Messaging address.
     */
    ImAddressKey[ImAddressKey["ImAddress2"] = 1] = "ImAddress2";
    /**
     * The third Instant Messaging address.
     */
    ImAddressKey[ImAddressKey["ImAddress3"] = 2] = "ImAddress3";
})(ImAddressKey = exports.ImAddressKey || (exports.ImAddressKey = {}));
/**
 * Defines the importance of an item.
 */
var Importance;
(function (Importance) {
    /**
     * Low importance.
     */
    Importance[Importance["Low"] = 0] = "Low";
    /**
     * Normal importance.
     */
    Importance[Importance["Normal"] = 1] = "Normal";
    /**
     * High importance.
     */
    Importance[Importance["High"] = 2] = "High";
})(Importance = exports.Importance || (exports.Importance = {}));
/**
 * Defines the flag status of an Item.
 */
var ItemFlagStatus;
(function (ItemFlagStatus) {
    /**
     * Not Flagged.
     */
    ItemFlagStatus[ItemFlagStatus["NotFlagged"] = 0] = "NotFlagged";
    /**
     * Flagged.
     */
    ItemFlagStatus[ItemFlagStatus["Flagged"] = 1] = "Flagged";
    /**
     * Complete.
     */
    ItemFlagStatus[ItemFlagStatus["Complete"] = 2] = "Complete";
})(ItemFlagStatus = exports.ItemFlagStatus || (exports.ItemFlagStatus = {}));
//todo - move to file where class Microsoft.Exchange.WebServices.Data.NonIndexableItem is located
/**
 * Item index error
 */
var ItemIndexError;
(function (ItemIndexError) {
    /**
     * None
     */
    ItemIndexError[ItemIndexError["None"] = 0] = "None";
    /**
     * Generic Error
     */
    ItemIndexError[ItemIndexError["GenericError"] = 1] = "GenericError";
    /**
     * Timeout
     */
    ItemIndexError[ItemIndexError["Timeout"] = 2] = "Timeout";
    /**
     * Stale Event
     */
    ItemIndexError[ItemIndexError["StaleEvent"] = 3] = "StaleEvent";
    /**
     * Mailbox Offline
     */
    ItemIndexError[ItemIndexError["MailboxOffline"] = 4] = "MailboxOffline";
    /**
     * Too many attachments to index
     */
    ItemIndexError[ItemIndexError["AttachmentLimitReached"] = 5] = "AttachmentLimitReached";
    /**
     * Data is truncated
     */
    ItemIndexError[ItemIndexError["MarsWriterTruncation"] = 6] = "MarsWriterTruncation";
})(ItemIndexError = exports.ItemIndexError || (exports.ItemIndexError = {}));
/**
 * Defines the scope of FindItems operations.
 */
var ItemTraversal;
(function (ItemTraversal) {
    /**
     * All non deleted items in the specified folder are retrieved.
     */
    ItemTraversal[ItemTraversal["Shallow"] = 0] = "Shallow";
    /**
     * Only soft-deleted items are retrieved.
     */
    ItemTraversal[ItemTraversal["SoftDeleted"] = 1] = "SoftDeleted";
    /**
     * Only associated items are retrieved (Exchange 2010 or later).
     */
    ItemTraversal[ItemTraversal["Associated"] = 2] = "Associated";
})(ItemTraversal = exports.ItemTraversal || (exports.ItemTraversal = {}));
(function (ItemTraversal) {
    /**RequiredServerVersionAttribute */
    function RequiredServerVersion(value) {
        if (value <= 1)
            return ExchangeVersion.Exchange2007_SP1;
        if (value == 2)
            return ExchangeVersion.Exchange2010;
        return ExchangeVersion.Exchange_Version_Not_Updated;
    }
    ItemTraversal.RequiredServerVersion = RequiredServerVersion;
})(ItemTraversal = exports.ItemTraversal || (exports.ItemTraversal = {}));
//todo - move to file where class Microsoft.Exchange.WebServices.Data.JsonTokenizer is located
var JsonTokenType;
(function (JsonTokenType) {
    JsonTokenType[JsonTokenType["String"] = 0] = "String";
    JsonTokenType[JsonTokenType["Number"] = 1] = "Number";
    JsonTokenType[JsonTokenType["Boolean"] = 2] = "Boolean";
    JsonTokenType[JsonTokenType["Null"] = 3] = "Null";
    JsonTokenType[JsonTokenType["ObjectOpen"] = 4] = "ObjectOpen";
    JsonTokenType[JsonTokenType["ObjectClose"] = 5] = "ObjectClose";
    JsonTokenType[JsonTokenType["ArrayOpen"] = 6] = "ArrayOpen";
    JsonTokenType[JsonTokenType["ArrayClose"] = 7] = "ArrayClose";
    JsonTokenType[JsonTokenType["Colon"] = 8] = "Colon";
    JsonTokenType[JsonTokenType["Comma"] = 9] = "Comma";
    JsonTokenType[JsonTokenType["EndOfFile"] = 10] = "EndOfFile";
})(JsonTokenType = exports.JsonTokenType || (exports.JsonTokenType = {}));
/**
 * Defines the legacy free/busy status associated with an appointment.
 */
var LegacyFreeBusyStatus;
(function (LegacyFreeBusyStatus) {
    /**
     * The time slot associated with the appointment appears as free.
     */
    LegacyFreeBusyStatus[LegacyFreeBusyStatus["Free"] = 0] = "Free";
    /**
     * The time slot associated with the appointment appears as tentative.
     */
    LegacyFreeBusyStatus[LegacyFreeBusyStatus["Tentative"] = 1] = "Tentative";
    /**
     * The time slot associated with the appointment appears as busy.
     */
    LegacyFreeBusyStatus[LegacyFreeBusyStatus["Busy"] = 2] = "Busy";
    /**
     * The time slot associated with the appointment appears as Out of Office.
     */
    LegacyFreeBusyStatus[LegacyFreeBusyStatus["OOF"] = 3] = "OOF";
    /**
     * The time slot associated with the appointment appears as working else where.
     */
    LegacyFreeBusyStatus[LegacyFreeBusyStatus["WorkingElsewhere"] = 4] = "WorkingElsewhere";
    /**
     * No free/busy status is associated with the appointment.
     */
    LegacyFreeBusyStatus[LegacyFreeBusyStatus["NoData"] = 5] = "NoData";
})(LegacyFreeBusyStatus = exports.LegacyFreeBusyStatus || (exports.LegacyFreeBusyStatus = {}));
//todo - move to file where class Microsoft.Exchange.WebServices.Data.OnlineMeetingSettings is located
/**
 * Online Meeting Lobby Bypass options.
 */
var LobbyBypass;
(function (LobbyBypass) {
    /**
     * Disabled.
     */
    LobbyBypass[LobbyBypass["Disabled"] = 0] = "Disabled";
    /**
     * Enabled for gateway participants.
     */
    LobbyBypass[LobbyBypass["EnabledForGatewayParticipants"] = 1] = "EnabledForGatewayParticipants";
})(LobbyBypass = exports.LobbyBypass || (exports.LobbyBypass = {}));
/**
 * Source of resolution.
 */
var LocationSource;
(function (LocationSource) {
    /**
     * Unresolved
     */
    LocationSource[LocationSource["None"] = 0] = "None";
    /**
     * Resolved by external location services (such as Bing, Google, etc)
     */
    LocationSource[LocationSource["LocationServices"] = 1] = "LocationServices";
    /**
     * Resolved by external phonebook services (such as Bing, Google, etc)
     */
    LocationSource[LocationSource["PhonebookServices"] = 2] = "PhonebookServices";
    /**
     * Revolved by a GPS enabled device (such as cellphone)
     */
    LocationSource[LocationSource["Device"] = 3] = "Device";
    /**
     * Sourced from a contact card
     */
    LocationSource[LocationSource["Contact"] = 4] = "Contact";
    /**
     * Sourced from a resource (such as a conference room)
     */
    LocationSource[LocationSource["Resource"] = 5] = "Resource";
})(LocationSource = exports.LocationSource || (exports.LocationSource = {}));
/**
 * Defines a logical operator as used by search filter collections.
 */
var LogicalOperator;
(function (LogicalOperator) {
    /**
     * The AND operator.
     */
    LogicalOperator[LogicalOperator["And"] = 0] = "And";
    /**
     * The OR operator.
     */
    LogicalOperator[LogicalOperator["Or"] = 1] = "Or";
})(LogicalOperator = exports.LogicalOperator || (exports.LogicalOperator = {}));
/**
 * Defines the location for mailbox search.
 */
var MailboxSearchLocation;
(function (MailboxSearchLocation) {
    /**
     * Primary only (Exchange 2013 or later).
     */
    MailboxSearchLocation[MailboxSearchLocation["PrimaryOnly"] = 0] = "PrimaryOnly";
    /**
     * Archive only (Exchange 2013 or later).
     */
    MailboxSearchLocation[MailboxSearchLocation["ArchiveOnly"] = 1] = "ArchiveOnly";
    /**
     * Both Primary and Archive (Exchange 2013 or later).
     */
    MailboxSearchLocation[MailboxSearchLocation["All"] = 2] = "All";
})(MailboxSearchLocation = exports.MailboxSearchLocation || (exports.MailboxSearchLocation = {}));
(function (MailboxSearchLocation) {
    /**RequiredServerVersionAttribute */
    function RequiredServerVersion(value) {
        if (value <= 2)
            return ExchangeVersion.Exchange2013;
        return ExchangeVersion.Exchange_Version_Not_Updated;
    }
    MailboxSearchLocation.RequiredServerVersion = RequiredServerVersion;
})(MailboxSearchLocation = exports.MailboxSearchLocation || (exports.MailboxSearchLocation = {}));
/**
 * @internal Enum MailboxSearchScopeType
 */
var MailboxSearchScopeType;
(function (MailboxSearchScopeType) {
    /**
     * The legacy exchange DN
     */
    MailboxSearchScopeType[MailboxSearchScopeType["LegacyExchangeDN"] = 0] = "LegacyExchangeDN";
    /**
     * The public folder
     */
    MailboxSearchScopeType[MailboxSearchScopeType["PublicFolder"] = 1] = "PublicFolder";
    /**
     * The recipient
     */
    MailboxSearchScopeType[MailboxSearchScopeType["Recipient"] = 2] = "Recipient";
    /**
     * The mailbox GUID
     */
    MailboxSearchScopeType[MailboxSearchScopeType["MailboxGuid"] = 3] = "MailboxGuid";
    /**
     * All public folders
     */
    MailboxSearchScopeType[MailboxSearchScopeType["AllPublicFolders"] = 4] = "AllPublicFolders";
    /**
     * All mailboxes
     */
    MailboxSearchScopeType[MailboxSearchScopeType["AllMailboxes"] = 5] = "AllMailboxes";
    /**
     * The saved search id
     */
    MailboxSearchScopeType[MailboxSearchScopeType["SavedSearchId"] = 6] = "SavedSearchId";
    /**
     * The auto detect
     */
    MailboxSearchScopeType[MailboxSearchScopeType["AutoDetect"] = 7] = "AutoDetect";
})(MailboxSearchScopeType = exports.MailboxSearchScopeType || (exports.MailboxSearchScopeType = {}));
/**
 * Defines the type of an EmailAddress object.
 */
var MailboxType;
(function (MailboxType) {
    /**
     * Unknown mailbox type (Exchange 2010 or later).
     */
    MailboxType[MailboxType["Unknown"] = 0] = "Unknown";
    /**
     * The EmailAddress represents a one-off contact (Exchange 2010 or later).
     */
    MailboxType[MailboxType["OneOff"] = 1] = "OneOff";
    /**
     * The EmailAddress represents a mailbox.
     */
    MailboxType[MailboxType["Mailbox"] = 2] = "Mailbox";
    /**
     * The EmailAddress represents a public folder.
     */
    MailboxType[MailboxType["PublicFolder"] = 3] = "PublicFolder";
    /**
     * The EmailAddress represents a Public Group.
     */
    MailboxType[MailboxType["PublicGroup"] = 4] = "PublicGroup";
    /**
     * The EmailAddress represents a Contact Group.
     */
    MailboxType[MailboxType["ContactGroup"] = 5] = "ContactGroup";
    /**
     * The EmailAddress represents a store contact or AD mail contact.
     */
    MailboxType[MailboxType["Contact"] = 6] = "Contact";
    /**
     * The EmailAddress represents a GroupMailbox (Exchange 2015/2016 or later).
     */
    MailboxType[MailboxType["GroupMailbox"] = 7] = "GroupMailbox";
})(MailboxType = exports.MailboxType || (exports.MailboxType = {}));
(function (MailboxType) {
    /**RequiredServerVersionAttribute */
    function RequiredServerVersion(value) {
        if (value <= 1)
            return ExchangeVersion.Exchange2010;
        if (value <= 6)
            return ExchangeVersion.Exchange2007_SP1;
        if (value <= 7)
            return ExchangeVersion.Exchange2015;
        return ExchangeVersion.Exchange_Version_Not_Updated;
    }
    MailboxType.RequiredServerVersion = RequiredServerVersion;
    /**EwsEnumAttribute */
    function FromEwsEnumString(value) {
        switch (value) {
            case "PublicDL":
                return MailboxType.PublicGroup;
            case "PrivateDL":
                return MailboxType.ContactGroup;
            default:
                return MailboxType[value];
        }
    }
    MailboxType.FromEwsEnumString = FromEwsEnumString;
    /**EwsEnumAttribute */
    function ToEwsEnumString(value) {
        switch (value) {
            case MailboxType.PublicGroup:
                return "PublicDL";
            case MailboxType.ContactGroup:
                return "PrivateDL";
            default:
                return MailboxType[value];
        }
    }
    MailboxType.ToEwsEnumString = ToEwsEnumString;
})(MailboxType = exports.MailboxType || (exports.MailboxType = {}));
/**
 * Defines the MAPI type of an extended property.
 */
var MapiPropertyType;
(function (MapiPropertyType) {
    /**
     * The property is of type ApplicationTime.
     */
    MapiPropertyType[MapiPropertyType["ApplicationTime"] = 0] = "ApplicationTime";
    /**
     * The property is of type ApplicationTimeArray.
     */
    MapiPropertyType[MapiPropertyType["ApplicationTimeArray"] = 1] = "ApplicationTimeArray";
    /**
     * The property is of type Binary.
     */
    MapiPropertyType[MapiPropertyType["Binary"] = 2] = "Binary";
    /**
     * The property is of type BinaryArray.
     */
    MapiPropertyType[MapiPropertyType["BinaryArray"] = 3] = "BinaryArray";
    /**
     * The property is of type Boolean.
     */
    MapiPropertyType[MapiPropertyType["Boolean"] = 4] = "Boolean";
    /**
     * The property is of type CLSID.
     */
    MapiPropertyType[MapiPropertyType["CLSID"] = 5] = "CLSID";
    /**
     * The property is of type CLSIDArray.
     */
    MapiPropertyType[MapiPropertyType["CLSIDArray"] = 6] = "CLSIDArray";
    /**
     * The property is of type Currency.
     */
    MapiPropertyType[MapiPropertyType["Currency"] = 7] = "Currency";
    /**
     * The property is of type CurrencyArray.
     */
    MapiPropertyType[MapiPropertyType["CurrencyArray"] = 8] = "CurrencyArray";
    /**
     * The property is of type Double.
     */
    MapiPropertyType[MapiPropertyType["Double"] = 9] = "Double";
    /**
     * The property is of type DoubleArray.
     */
    MapiPropertyType[MapiPropertyType["DoubleArray"] = 10] = "DoubleArray";
    /**
     * The property is of type Error.
     */
    MapiPropertyType[MapiPropertyType["Error"] = 11] = "Error";
    /**
     * The property is of type Float.
     */
    MapiPropertyType[MapiPropertyType["Float"] = 12] = "Float";
    /**
     * The property is of type FloatArray.
     */
    MapiPropertyType[MapiPropertyType["FloatArray"] = 13] = "FloatArray";
    /**
     * The property is of type Integer.
     */
    MapiPropertyType[MapiPropertyType["Integer"] = 14] = "Integer";
    /**
     * The property is of type IntegerArray.
     */
    MapiPropertyType[MapiPropertyType["IntegerArray"] = 15] = "IntegerArray";
    /**
     * The property is of type Long.
     */
    MapiPropertyType[MapiPropertyType["Long"] = 16] = "Long";
    /**
     * The property is of type LongArray.
     */
    MapiPropertyType[MapiPropertyType["LongArray"] = 17] = "LongArray";
    /**
     * The property is of type Null.
     */
    MapiPropertyType[MapiPropertyType["Null"] = 18] = "Null";
    /**
     * The property is of type Object.
     */
    MapiPropertyType[MapiPropertyType["Object"] = 19] = "Object";
    /**
     * The property is of type ObjectArray.
     */
    MapiPropertyType[MapiPropertyType["ObjectArray"] = 20] = "ObjectArray";
    /**
     * The property is of type Short.
     */
    MapiPropertyType[MapiPropertyType["Short"] = 21] = "Short";
    /**
     * The property is of type ShortArray.
     */
    MapiPropertyType[MapiPropertyType["ShortArray"] = 22] = "ShortArray";
    /**
     * The property is of type SystemTime.
     */
    MapiPropertyType[MapiPropertyType["SystemTime"] = 23] = "SystemTime";
    /**
     * The property is of type SystemTimeArray.
     */
    MapiPropertyType[MapiPropertyType["SystemTimeArray"] = 24] = "SystemTimeArray";
    /**
     * The property is of type String.
     */
    MapiPropertyType[MapiPropertyType["String"] = 25] = "String";
    /**
     * The property is of type StringArray.
     */
    MapiPropertyType[MapiPropertyType["StringArray"] = 26] = "StringArray";
})(MapiPropertyType = exports.MapiPropertyType || (exports.MapiPropertyType = {}));
/** shim to store type of data in MapiTypeConverterMapEntry */
var MapiTypeConverterTypeSystem;
(function (MapiTypeConverterTypeSystem) {
    MapiTypeConverterTypeSystem[MapiTypeConverterTypeSystem["boolean"] = 0] = "boolean";
    MapiTypeConverterTypeSystem[MapiTypeConverterTypeSystem["string"] = 1] = "string";
    MapiTypeConverterTypeSystem[MapiTypeConverterTypeSystem["number"] = 2] = "number";
    MapiTypeConverterTypeSystem[MapiTypeConverterTypeSystem["DateTime"] = 3] = "DateTime";
    MapiTypeConverterTypeSystem[MapiTypeConverterTypeSystem["guid"] = 4] = "guid";
    MapiTypeConverterTypeSystem[MapiTypeConverterTypeSystem["byteArray"] = 5] = "byteArray";
})(MapiTypeConverterTypeSystem = exports.MapiTypeConverterTypeSystem || (exports.MapiTypeConverterTypeSystem = {}));
/**
 * The attendee is the organizer of the meeting.
 */
var MeetingAttendeeType;
(function (MeetingAttendeeType) {
    /**
     * The attendee is the organizer of the meeting.
     */
    MeetingAttendeeType[MeetingAttendeeType["Organizer"] = 0] = "Organizer";
    /**
     * The attendee is required.
     */
    MeetingAttendeeType[MeetingAttendeeType["Required"] = 1] = "Required";
    /**
     * The attendee is optional.
     */
    MeetingAttendeeType[MeetingAttendeeType["Optional"] = 2] = "Optional";
    /**
     * The attendee is a room.
     */
    MeetingAttendeeType[MeetingAttendeeType["Room"] = 3] = "Room";
    /**
     * The attendee is a resource.
     */
    MeetingAttendeeType[MeetingAttendeeType["Resource"] = 4] = "Resource";
})(MeetingAttendeeType = exports.MeetingAttendeeType || (exports.MeetingAttendeeType = {}));
/**
 * Defines how meeting requests are sent to delegates.
 */
var MeetingRequestsDeliveryScope;
(function (MeetingRequestsDeliveryScope) {
    /**
     * Meeting requests are sent to delegates only.
     */
    MeetingRequestsDeliveryScope[MeetingRequestsDeliveryScope["DelegatesOnly"] = 0] = "DelegatesOnly";
    /**
     * Meeting requests are sent to delegates and to the owner of the mailbox.
     */
    MeetingRequestsDeliveryScope[MeetingRequestsDeliveryScope["DelegatesAndMe"] = 1] = "DelegatesAndMe";
    /**
     * Meeting requests are sent to delegates and informational messages are sent to the owner of the mailbox.
     */
    MeetingRequestsDeliveryScope[MeetingRequestsDeliveryScope["DelegatesAndSendInformationToMe"] = 2] = "DelegatesAndSendInformationToMe";
    /**
     * Meeting requests are not sent to delegates.  This value is supported only for Exchange 2010 SP1 or later server versions.
     */
    MeetingRequestsDeliveryScope[MeetingRequestsDeliveryScope["NoForward"] = 3] = "NoForward";
})(MeetingRequestsDeliveryScope = exports.MeetingRequestsDeliveryScope || (exports.MeetingRequestsDeliveryScope = {}));
(function (MeetingRequestsDeliveryScope) {
    /**RequiredServerVersionAttribute */
    function RequiredServerVersion(value) {
        if (value <= 2)
            return ExchangeVersion.Exchange2007_SP1;
        else if (value == 3)
            return ExchangeVersion.Exchange2010_SP1;
        return ExchangeVersion.Exchange_Version_Not_Updated;
    }
    MeetingRequestsDeliveryScope.RequiredServerVersion = RequiredServerVersion;
})(MeetingRequestsDeliveryScope = exports.MeetingRequestsDeliveryScope || (exports.MeetingRequestsDeliveryScope = {}));
/**
 * Defines the type of a meeting request.
 */
var MeetingRequestType;
(function (MeetingRequestType) {
    /**
     * Undefined meeting request type.
     */
    MeetingRequestType[MeetingRequestType["None"] = 0] = "None";
    /**
     * The meeting request is an update to the original meeting.
     */
    MeetingRequestType[MeetingRequestType["FullUpdate"] = 1] = "FullUpdate";
    /**
     * The meeting request is an information update.
     */
    MeetingRequestType[MeetingRequestType["InformationalUpdate"] = 2] = "InformationalUpdate";
    /**
     * The meeting request is for a new meeting.
     */
    MeetingRequestType[MeetingRequestType["NewMeetingRequest"] = 3] = "NewMeetingRequest";
    /**
     * The meeting request is outdated.
     */
    MeetingRequestType[MeetingRequestType["Outdated"] = 4] = "Outdated";
    /**
     * The meeting update is a silent update to an existing meeting.
     */
    MeetingRequestType[MeetingRequestType["SilentUpdate"] = 5] = "SilentUpdate";
    /**
     * The meeting update was forwarded to a delegate, and this copy is informational.
     */
    MeetingRequestType[MeetingRequestType["PrincipalWantsCopy"] = 6] = "PrincipalWantsCopy";
})(MeetingRequestType = exports.MeetingRequestType || (exports.MeetingRequestType = {}));
/**
 * Defines the types of response given to a meeting request.
 */
var MeetingResponseType;
(function (MeetingResponseType) {
    /**
     * The response type is unknown.
     */
    MeetingResponseType[MeetingResponseType["Unknown"] = 0] = "Unknown";
    /**
     * There was no response. The authenticated is the organizer of the meeting.
     */
    MeetingResponseType[MeetingResponseType["Organizer"] = 1] = "Organizer";
    /**
     * The meeting was tentatively accepted.
     */
    MeetingResponseType[MeetingResponseType["Tentative"] = 2] = "Tentative";
    /**
     * The meeting was accepted.
     */
    MeetingResponseType[MeetingResponseType["Accept"] = 3] = "Accept";
    /**
     * The meeting was declined.
     */
    MeetingResponseType[MeetingResponseType["Decline"] = 4] = "Decline";
    /**
     * No response was received for the meeting.
     */
    MeetingResponseType[MeetingResponseType["NoResponseReceived"] = 5] = "NoResponseReceived";
})(MeetingResponseType = exports.MeetingResponseType || (exports.MeetingResponseType = {}));
/**
 * Defines the status of group members.
 */
var MemberStatus;
(function (MemberStatus) {
    /**
     * The member is unrecognized.
     */
    MemberStatus[MemberStatus["Unrecognized"] = 0] = "Unrecognized";
    /**
     * The member is normal.
     */
    MemberStatus[MemberStatus["Normal"] = 1] = "Normal";
    /**
     * The member is demoted.
     */
    MemberStatus[MemberStatus["Demoted"] = 2] = "Demoted";
})(MemberStatus = exports.MemberStatus || (exports.MemberStatus = {}));
/**
 * Defines how messages are disposed of in CreateItem and UpdateItem operations.
 */
var MessageDisposition;
(function (MessageDisposition) {
    /**
     * Messages are saved but not sent.
     */
    MessageDisposition[MessageDisposition["SaveOnly"] = 0] = "SaveOnly";
    /**
     * Messages are sent and a copy is saved.
     */
    MessageDisposition[MessageDisposition["SendAndSaveCopy"] = 1] = "SendAndSaveCopy";
    /**
     * Messages are sent but no copy is saved.
     */
    MessageDisposition[MessageDisposition["SendOnly"] = 2] = "SendOnly";
})(MessageDisposition = exports.MessageDisposition || (exports.MessageDisposition = {}));
/**
 * Defines months of the year.
 */
var Month;
(function (Month) {
    /**
     * January.
     */
    Month[Month["January"] = 1] = "January";
    /**
     * February.
     */
    Month[Month["February"] = 2] = "February";
    /**
     * March.
     */
    Month[Month["March"] = 3] = "March";
    /**
     * April.
     */
    Month[Month["April"] = 4] = "April";
    /**
     * May.
     */
    Month[Month["May"] = 5] = "May";
    /**
     * June.
     */
    Month[Month["June"] = 6] = "June";
    /**
     * July.
     */
    Month[Month["July"] = 7] = "July";
    /**
     * August.
     */
    Month[Month["August"] = 8] = "August";
    /**
     * September.
     */
    Month[Month["September"] = 9] = "September";
    /**
     * October.
     */
    Month[Month["October"] = 10] = "October";
    /**
     * November.
     */
    Month[Month["November"] = 11] = "November";
    /**
     * December.
     */
    Month[Month["December"] = 12] = "December";
})(Month = exports.Month || (exports.Month = {}));
/**
 * Defines the offset's base point in a paged view.
 */
var OffsetBasePoint;
(function (OffsetBasePoint) {
    /**
     * The offset is from the beginning of the view.
     */
    OffsetBasePoint[OffsetBasePoint["Beginning"] = 0] = "Beginning";
    /**
     * The offset is from the end of the view.
     */
    OffsetBasePoint[OffsetBasePoint["End"] = 1] = "End";
})(OffsetBasePoint = exports.OffsetBasePoint || (exports.OffsetBasePoint = {}));
//todo - move to file where class Microsoft.Exchange.WebServices.Data.OnlineMeetingSettings is located
/**
 * Online Meeting Access Level options.
 */
var OnlineMeetingAccessLevel;
(function (OnlineMeetingAccessLevel) {
    /**
     * Locked.
     */
    OnlineMeetingAccessLevel[OnlineMeetingAccessLevel["Locked"] = 0] = "Locked";
    /**
     * Invited.
     */
    OnlineMeetingAccessLevel[OnlineMeetingAccessLevel["Invited"] = 1] = "Invited";
    /**
     * Internal.
     */
    OnlineMeetingAccessLevel[OnlineMeetingAccessLevel["Internal"] = 2] = "Internal";
    /**
     * Everyone.
     */
    OnlineMeetingAccessLevel[OnlineMeetingAccessLevel["Everyone"] = 3] = "Everyone";
})(OnlineMeetingAccessLevel = exports.OnlineMeetingAccessLevel || (exports.OnlineMeetingAccessLevel = {}));
/**
 * Defines the external audience of an Out of Office notification.
 */
var OofExternalAudience;
(function (OofExternalAudience) {
    /**
     * No external recipients should receive Out of Office notifications.
     */
    OofExternalAudience[OofExternalAudience["None"] = 0] = "None";
    /**
     * Only recipients that are in the user's Contacts frolder should receive Out of Office notifications.
     */
    OofExternalAudience[OofExternalAudience["Known"] = 1] = "Known";
    /**
     * All recipients should receive Out of Office notifications.
     */
    OofExternalAudience[OofExternalAudience["All"] = 2] = "All";
})(OofExternalAudience = exports.OofExternalAudience || (exports.OofExternalAudience = {}));
/**
 * Defines a user's Out of Office Assistant status.
 */
var OofState;
(function (OofState) {
    /**
     * The assistant is diabled.
     */
    OofState[OofState["Disabled"] = 0] = "Disabled";
    /**
     * The assistant is enabled.
     */
    OofState[OofState["Enabled"] = 1] = "Enabled";
    /**
     * The assistant is scheduled.
     */
    OofState[OofState["Scheduled"] = 2] = "Scheduled";
})(OofState = exports.OofState || (exports.OofState = {}));
/**
 * @internal Defines supported Outlook protocls.
 */
var OutlookProtocolType;
(function (OutlookProtocolType) {
    /**
     * The Remote Procedure Call (RPC) protocol.
     */
    OutlookProtocolType[OutlookProtocolType["Rpc"] = 0] = "Rpc";
    /**
     * The Remote Procedure Call (RPC) over HTTP protocol.
     */
    OutlookProtocolType[OutlookProtocolType["RpcOverHttp"] = 1] = "RpcOverHttp";
    /**
     * The Web protocol.
     */
    OutlookProtocolType[OutlookProtocolType["Web"] = 2] = "Web";
    /**
     * The protocol is unknown.
     */
    OutlookProtocolType[OutlookProtocolType["Unknown"] = 3] = "Unknown";
})(OutlookProtocolType = exports.OutlookProtocolType || (exports.OutlookProtocolType = {}));
/**
 * Defines the scope of a user's permission on a folders.
 */
var PermissionScope;
(function (PermissionScope) {
    /**
     * The user does not have the associated permission.
     */
    PermissionScope[PermissionScope["None"] = 0] = "None";
    /**
     * The user has the associated permission on items that it owns.
     */
    PermissionScope[PermissionScope["Owned"] = 1] = "Owned";
    /**
     * The user has the associated permission on all items.
     */
    PermissionScope[PermissionScope["All"] = 2] = "All";
})(PermissionScope = exports.PermissionScope || (exports.PermissionScope = {}));
/**
 * The PhoneCallState enumeration
 */
var PhoneCallState;
(function (PhoneCallState) {
    /**
     * Idle.
     */
    PhoneCallState[PhoneCallState["Idle"] = 0] = "Idle";
    /**
     * Connecting.
     */
    PhoneCallState[PhoneCallState["Connecting"] = 1] = "Connecting";
    /**
     * Alerted.
     */
    PhoneCallState[PhoneCallState["Alerted"] = 2] = "Alerted";
    /**
     * Connected.
     */
    PhoneCallState[PhoneCallState["Connected"] = 3] = "Connected";
    /**
     * Disconnected.
     */
    PhoneCallState[PhoneCallState["Disconnected"] = 4] = "Disconnected";
    /**
     * Incoming.
     */
    PhoneCallState[PhoneCallState["Incoming"] = 5] = "Incoming";
    /**
     * Transferring.
     */
    PhoneCallState[PhoneCallState["Transferring"] = 6] = "Transferring";
    /**
     * Forwarding.
     */
    PhoneCallState[PhoneCallState["Forwarding"] = 7] = "Forwarding";
})(PhoneCallState = exports.PhoneCallState || (exports.PhoneCallState = {}));
/**
 * Defines phone number entries for a contact.
 */
var PhoneNumberKey;
(function (PhoneNumberKey) {
    /**
     * The assistant's phone number.
     */
    PhoneNumberKey[PhoneNumberKey["AssistantPhone"] = 0] = "AssistantPhone";
    /**
     * The business fax number.
     */
    PhoneNumberKey[PhoneNumberKey["BusinessFax"] = 1] = "BusinessFax";
    /**
     * The business phone number.
     */
    PhoneNumberKey[PhoneNumberKey["BusinessPhone"] = 2] = "BusinessPhone";
    /**
     * The second business phone number.
     */
    PhoneNumberKey[PhoneNumberKey["BusinessPhone2"] = 3] = "BusinessPhone2";
    /**
     * The callback number.
     */
    PhoneNumberKey[PhoneNumberKey["Callback"] = 4] = "Callback";
    /**
     * The car phone number.
     */
    PhoneNumberKey[PhoneNumberKey["CarPhone"] = 5] = "CarPhone";
    /**
     * The company's main phone number.
     */
    PhoneNumberKey[PhoneNumberKey["CompanyMainPhone"] = 6] = "CompanyMainPhone";
    /**
     * The home fax number.
     */
    PhoneNumberKey[PhoneNumberKey["HomeFax"] = 7] = "HomeFax";
    /**
     * The home phone number.
     */
    PhoneNumberKey[PhoneNumberKey["HomePhone"] = 8] = "HomePhone";
    /**
     * The second home phone number.
     */
    PhoneNumberKey[PhoneNumberKey["HomePhone2"] = 9] = "HomePhone2";
    /**
     * The ISDN number.
     */
    PhoneNumberKey[PhoneNumberKey["Isdn"] = 10] = "Isdn";
    /**
     * The mobile phone number.
     */
    PhoneNumberKey[PhoneNumberKey["MobilePhone"] = 11] = "MobilePhone";
    /**
     * An alternate fax number.
     */
    PhoneNumberKey[PhoneNumberKey["OtherFax"] = 12] = "OtherFax";
    /**
     * An alternate phone number.
     */
    PhoneNumberKey[PhoneNumberKey["OtherTelephone"] = 13] = "OtherTelephone";
    /**
     * The pager number.
     */
    PhoneNumberKey[PhoneNumberKey["Pager"] = 14] = "Pager";
    /**
     * The primary phone number.
     */
    PhoneNumberKey[PhoneNumberKey["PrimaryPhone"] = 15] = "PrimaryPhone";
    /**
     * The radio phone number.
     */
    PhoneNumberKey[PhoneNumberKey["RadioPhone"] = 16] = "RadioPhone";
    /**
     * The Telex number
     */
    PhoneNumberKey[PhoneNumberKey["Telex"] = 17] = "Telex";
    /**
     * The TTY/TTD phone number.
     */
    PhoneNumberKey[PhoneNumberKey["TtyTddPhone"] = 18] = "TtyTddPhone";
})(PhoneNumberKey = exports.PhoneNumberKey || (exports.PhoneNumberKey = {}));
/**
 * Defines a physical address index.
 */
var PhysicalAddressIndex;
(function (PhysicalAddressIndex) {
    /**
     * None.
     */
    PhysicalAddressIndex[PhysicalAddressIndex["None"] = 0] = "None";
    /**
     * The business address.
     */
    PhysicalAddressIndex[PhysicalAddressIndex["Business"] = 1] = "Business";
    /**
     * The home address.
     */
    PhysicalAddressIndex[PhysicalAddressIndex["Home"] = 2] = "Home";
    /**
     * The alternate address.
     */
    PhysicalAddressIndex[PhysicalAddressIndex["Other"] = 3] = "Other";
})(PhysicalAddressIndex = exports.PhysicalAddressIndex || (exports.PhysicalAddressIndex = {}));
/**
 * Defines physical address entries for a contact.
 */
var PhysicalAddressKey;
(function (PhysicalAddressKey) {
    /**
     * The business address.
     */
    PhysicalAddressKey[PhysicalAddressKey["Business"] = 0] = "Business";
    /**
     * The home address.
     */
    PhysicalAddressKey[PhysicalAddressKey["Home"] = 1] = "Home";
    /**
     * An alternate address.
     */
    PhysicalAddressKey[PhysicalAddressKey["Other"] = 2] = "Other";
})(PhysicalAddressKey = exports.PhysicalAddressKey || (exports.PhysicalAddressKey = {}));
//todo - move to file where class Microsoft.Exchange.WebServices.Data.OnlineMeetingSettings is located
/**
 * Online Meeting Presenters options.
 */
var Presenters;
(function (Presenters) {
    /**
     * Disabled.
     */
    Presenters[Presenters["Disabled"] = 0] = "Disabled";
    /**
     * Internal.
     */
    Presenters[Presenters["Internal"] = 1] = "Internal";
    /**
     * Everyone.
     */
    Presenters[Presenters["Everyone"] = 2] = "Everyone";
})(Presenters = exports.Presenters || (exports.Presenters = {}));
/**
 * Preview item base shape
 */
var PreviewItemBaseShape;
(function (PreviewItemBaseShape) {
    /**
     * Default (all properties required for showing preview by default)
     */
    PreviewItemBaseShape[PreviewItemBaseShape["Default"] = 0] = "Default";
    /**
     * Compact (only a set of core properties)
     */
    PreviewItemBaseShape[PreviewItemBaseShape["Compact"] = 1] = "Compact";
})(PreviewItemBaseShape = exports.PreviewItemBaseShape || (exports.PreviewItemBaseShape = {}));
/**
 * @internal Defines the type of PrivilegedLogonType.
 */
var PrivilegedLogonType;
(function (PrivilegedLogonType) {
    /**
     * Logon as Admin
     */
    PrivilegedLogonType[PrivilegedLogonType["Admin"] = 0] = "Admin";
    /**
     * Logon as SystemService
     */
    PrivilegedLogonType[PrivilegedLogonType["SystemService"] = 1] = "SystemService";
})(PrivilegedLogonType = exports.PrivilegedLogonType || (exports.PrivilegedLogonType = {}));
//todo - move to file where class Microsoft.Exchange.WebServices.Dns.PrivilegedUserId is located
/**
 * @internal Interactive, charge against a copy of target mailbox budget.
 */
var PrivilegedUserIdBudgetType;
(function (PrivilegedUserIdBudgetType) {
    /**
     * Interactive, charge against a copy of target mailbox budget.
     */
    PrivilegedUserIdBudgetType[PrivilegedUserIdBudgetType["Default"] = 0] = "Default";
    /**
     * Running as background load
     */
    PrivilegedUserIdBudgetType[PrivilegedUserIdBudgetType["RunningAsBackgroundLoad"] = 1] = "RunningAsBackgroundLoad";
    /**
     * Unthrottled budget.
     */
    PrivilegedUserIdBudgetType[PrivilegedUserIdBudgetType["Unthrottled"] = 2] = "Unthrottled";
})(PrivilegedUserIdBudgetType = exports.PrivilegedUserIdBudgetType || (exports.PrivilegedUserIdBudgetType = {}));
/**
 * @internal Defines how a complex property behaves.
 *
 * [Flags]
 */
var PropertyDefinitionFlags;
(function (PropertyDefinitionFlags) {
    /**
     * No specific behavior.
     */
    PropertyDefinitionFlags[PropertyDefinitionFlags["None"] = 0] = "None";
    /**
     * The property is automatically instantiated when it is read.
     */
    PropertyDefinitionFlags[PropertyDefinitionFlags["AutoInstantiateOnRead"] = 1] = "AutoInstantiateOnRead";
    /**
     * The existing instance of the property is reusable.
     */
    PropertyDefinitionFlags[PropertyDefinitionFlags["ReuseInstance"] = 2] = "ReuseInstance";
    /**
     * The property can be set.
     */
    PropertyDefinitionFlags[PropertyDefinitionFlags["CanSet"] = 4] = "CanSet";
    /**
     * The property can be updated.
     */
    PropertyDefinitionFlags[PropertyDefinitionFlags["CanUpdate"] = 8] = "CanUpdate";
    /**
     * The property can be deleted.
     */
    PropertyDefinitionFlags[PropertyDefinitionFlags["CanDelete"] = 16] = "CanDelete";
    /**
     * The property can be searched.
     */
    PropertyDefinitionFlags[PropertyDefinitionFlags["CanFind"] = 32] = "CanFind";
    /**
     * The property must be loaded explicitly
     */
    PropertyDefinitionFlags[PropertyDefinitionFlags["MustBeExplicitlyLoaded"] = 64] = "MustBeExplicitlyLoaded";
    /**
     * Only meaningful for "collection" property.
     * With this flag, the item in the collection gets updated, instead of creating and adding new items to the collection.
     * Should be used together with the ReuseInstance flag.
     */
    PropertyDefinitionFlags[PropertyDefinitionFlags["UpdateCollectionItems"] = 128] = "UpdateCollectionItems";
})(PropertyDefinitionFlags = exports.PropertyDefinitionFlags || (exports.PropertyDefinitionFlags = {}));
/**
 * The rendering method.
 */
var RenderingMode;
(function (RenderingMode) {
    /**
     * XML
     */
    RenderingMode[RenderingMode["Xml"] = 0] = "Xml";
    /**
     * Javascript Object Notation
     */
    RenderingMode[RenderingMode["JSON"] = 1] = "JSON";
})(RenderingMode = exports.RenderingMode || (exports.RenderingMode = {}));
/**
 * Defines the location where a ResolveName operation searches for contacts.
 */
var ResolveNameSearchLocation;
(function (ResolveNameSearchLocation) {
    /**
     * The name is resolved against the Global Address List.
     */
    ResolveNameSearchLocation[ResolveNameSearchLocation["DirectoryOnly"] = 0] = "DirectoryOnly";
    /**
     * The name is resolved against the Global Address List and then against the Contacts folder if no match was found.
     */
    ResolveNameSearchLocation[ResolveNameSearchLocation["DirectoryThenContacts"] = 1] = "DirectoryThenContacts";
    /**
     * The name is resolved against the Contacts folder.
     */
    ResolveNameSearchLocation[ResolveNameSearchLocation["ContactsOnly"] = 2] = "ContactsOnly";
    /**
     * The name is resolved against the Contacts folder and then against the Global Address List if no match was found.
     */
    ResolveNameSearchLocation[ResolveNameSearchLocation["ContactsThenDirectory"] = 3] = "ContactsThenDirectory";
})(ResolveNameSearchLocation = exports.ResolveNameSearchLocation || (exports.ResolveNameSearchLocation = {}));
/**
 * Defines the response actions that can be taken on an item.
 *
 * [Flags]
 */
var ResponseActions;
(function (ResponseActions) {
    /**
     * No action can be taken.
     */
    ResponseActions[ResponseActions["None"] = 0] = "None";
    /**
     * The item can be accepted.
     */
    ResponseActions[ResponseActions["Accept"] = 1] = "Accept";
    /**
     * The item can be tentatively accepted.
     */
    ResponseActions[ResponseActions["TentativelyAccept"] = 2] = "TentativelyAccept";
    /**
     * The item can be declined.
     */
    ResponseActions[ResponseActions["Decline"] = 4] = "Decline";
    /**
     * The item can be replied to.
     */
    ResponseActions[ResponseActions["Reply"] = 8] = "Reply";
    /**
     * The item can be replied to all.
     */
    ResponseActions[ResponseActions["ReplyAll"] = 16] = "ReplyAll";
    /**
     * The item can be forwarded.
     */
    ResponseActions[ResponseActions["Forward"] = 32] = "Forward";
    /**
     * The item can be cancelled.
     */
    ResponseActions[ResponseActions["Cancel"] = 64] = "Cancel";
    /**
     * The item can be removed from the calendar.
     */
    ResponseActions[ResponseActions["RemoveFromCalendar"] = 128] = "RemoveFromCalendar";
    /**
     * The item's read receipt can be suppressed.
     */
    ResponseActions[ResponseActions["SuppressReadReceipt"] = 256] = "SuppressReadReceipt";
    /**
     * A reply to the item can be posted.
     */
    ResponseActions[ResponseActions["PostReply"] = 512] = "PostReply";
})(ResponseActions = exports.ResponseActions || (exports.ResponseActions = {}));
/**
 * Defines the type of a ResponseMessage object.
 */
var ResponseMessageType;
(function (ResponseMessageType) {
    /**
     * The ResponseMessage is a reply to the sender of a message.
     */
    ResponseMessageType[ResponseMessageType["Reply"] = 0] = "Reply";
    /**
     * The ResponseMessage is a reply to the sender and all the recipients of a message.
     */
    ResponseMessageType[ResponseMessageType["ReplyAll"] = 1] = "ReplyAll";
    /**
     * The ResponseMessage is a forward.
     */
    ResponseMessageType[ResponseMessageType["Forward"] = 2] = "Forward";
})(ResponseMessageType = exports.ResponseMessageType || (exports.ResponseMessageType = {}));
/**
 * Defines the action of a retention policy tag.
 */
var RetentionActionType;
(function (RetentionActionType) {
    /**
     * Never tags (RetentionEnabled = false) do not have retention action in the FAI.
     */
    RetentionActionType[RetentionActionType["None"] = 0] = "None";
    /**
     * Expired items will be moved to the Deleted Items folder.
     */
    RetentionActionType[RetentionActionType["MoveToDeletedItems"] = 1] = "MoveToDeletedItems";
    /**
     * Expired items will be moved to the organizational folder specified in the ExpirationDestination field.
     */
    RetentionActionType[RetentionActionType["MoveToFolder"] = 2] = "MoveToFolder";
    /**
     * Expired items will be soft deleted.
     */
    RetentionActionType[RetentionActionType["DeleteAndAllowRecovery"] = 3] = "DeleteAndAllowRecovery";
    /**
     * Expired items will be hard deleted.
     */
    RetentionActionType[RetentionActionType["PermanentlyDelete"] = 4] = "PermanentlyDelete";
    /**
     * Expired items will be tagged as expired.
     */
    RetentionActionType[RetentionActionType["MarkAsPastRetentionLimit"] = 5] = "MarkAsPastRetentionLimit";
    /**
     * Expired items will be moved to the archive.
     */
    RetentionActionType[RetentionActionType["MoveToArchive"] = 6] = "MoveToArchive";
})(RetentionActionType = exports.RetentionActionType || (exports.RetentionActionType = {}));
/**
 * Defines the retention type.
 */
var RetentionType;
(function (RetentionType) {
    /**
     * Delete retention.
     */
    RetentionType[RetentionType["Delete"] = 0] = "Delete";
    /**
     * Archive retention.
     */
    RetentionType[RetentionType["Archive"] = 1] = "Archive";
})(RetentionType = exports.RetentionType || (exports.RetentionType = {}));
/**
 * Defines the error codes identifying why a rule failed validation.
 */
var RuleErrorCode;
(function (RuleErrorCode) {
    /**
     * Active Directory operation failed.
     */
    RuleErrorCode[RuleErrorCode["ADOperationFailure"] = 0] = "ADOperationFailure";
    /**
     * The e-mail account specified in the FromConnectedAccounts predicate was not found.
     */
    RuleErrorCode[RuleErrorCode["ConnectedAccountNotFound"] = 1] = "ConnectedAccountNotFound";
    /**
     * The Rule object in a CreateInboxRuleOperation has an Id.
     * The Ids of new  rules are generated server side and should not be provided by the client.
     */
    RuleErrorCode[RuleErrorCode["CreateWithRuleId"] = 2] = "CreateWithRuleId";
    /**
     * The value is empty. An empty value is not allowed for the property.
     */
    RuleErrorCode[RuleErrorCode["EmptyValueFound"] = 3] = "EmptyValueFound";
    /**
     * There already is a rule with the same priority.
     */
    RuleErrorCode[RuleErrorCode["DuplicatedPriority"] = 4] = "DuplicatedPriority";
    /**
     * There are multiple operations against the same rule.
     * Only one operation per rule is allowed.
     */
    RuleErrorCode[RuleErrorCode["DuplicatedOperationOnTheSameRule"] = 5] = "DuplicatedOperationOnTheSameRule";
    /**
     * The folder does not exist in the user's mailbox.
     */
    RuleErrorCode[RuleErrorCode["FolderDoesNotExist"] = 6] = "FolderDoesNotExist";
    /**
     * The e-mail address is invalid.
     */
    RuleErrorCode[RuleErrorCode["InvalidAddress"] = 7] = "InvalidAddress";
    /**
     * The date range is invalid.
     */
    RuleErrorCode[RuleErrorCode["InvalidDateRange"] = 8] = "InvalidDateRange";
    /**
     * The folder Id is invalid.
     */
    RuleErrorCode[RuleErrorCode["InvalidFolderId"] = 9] = "InvalidFolderId";
    /**
     * The size range is invalid.
     */
    RuleErrorCode[RuleErrorCode["InvalidSizeRange"] = 10] = "InvalidSizeRange";
    /**
     * The value is invalid.
     */
    RuleErrorCode[RuleErrorCode["InvalidValue"] = 11] = "InvalidValue";
    /**
     * The message classification was not found.
     */
    RuleErrorCode[RuleErrorCode["MessageClassificationNotFound"] = 12] = "MessageClassificationNotFound";
    /**
     * No action was specified. At least one action must be specified.
     */
    RuleErrorCode[RuleErrorCode["MissingAction"] = 13] = "MissingAction";
    /**
     * The required parameter is missing.
     */
    RuleErrorCode[RuleErrorCode["MissingParameter"] = 14] = "MissingParameter";
    /**
     * The range value is missing.
     */
    RuleErrorCode[RuleErrorCode["MissingRangeValue"] = 15] = "MissingRangeValue";
    /**
     * The property cannot be modified.
     */
    RuleErrorCode[RuleErrorCode["NotSettable"] = 16] = "NotSettable";
    /**
     * The recipient does not exist.
     */
    RuleErrorCode[RuleErrorCode["RecipientDoesNotExist"] = 17] = "RecipientDoesNotExist";
    /**
     * The rule was not found.
     */
    RuleErrorCode[RuleErrorCode["RuleNotFound"] = 18] = "RuleNotFound";
    /**
     * The size is less than zero.
     */
    RuleErrorCode[RuleErrorCode["SizeLessThanZero"] = 19] = "SizeLessThanZero";
    /**
     * The string value is too big.
     */
    RuleErrorCode[RuleErrorCode["StringValueTooBig"] = 20] = "StringValueTooBig";
    /**
     * The address is unsupported.
     */
    RuleErrorCode[RuleErrorCode["UnsupportedAddress"] = 21] = "UnsupportedAddress";
    /**
     * An unexpected error occured.
     */
    RuleErrorCode[RuleErrorCode["UnexpectedError"] = 22] = "UnexpectedError";
    /**
     * The rule is not supported.
     */
    RuleErrorCode[RuleErrorCode["UnsupportedRule"] = 23] = "UnsupportedRule";
})(RuleErrorCode = exports.RuleErrorCode || (exports.RuleErrorCode = {}));
/**
 * Defines the available properties of a rule.
 */
var RuleProperty;
(function (RuleProperty) {
    /**
     * The RuleId property of a rule.
     */
    RuleProperty[RuleProperty["RuleId"] = 0] = "RuleId";
    /**
     * The DisplayName property of a rule.
     */
    RuleProperty[RuleProperty["DisplayName"] = 1] = "DisplayName";
    /**
     * The Priority property of a rule.
     */
    RuleProperty[RuleProperty["Priority"] = 2] = "Priority";
    /**
     * The IsNotSupported property of a rule.
     */
    RuleProperty[RuleProperty["IsNotSupported"] = 3] = "IsNotSupported";
    /**
     * The Actions property of a rule.
     */
    RuleProperty[RuleProperty["Actions"] = 4] = "Actions";
    /**
     * The Categories property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionCategories"] = 5] = "ConditionCategories";
    /**
     * The ContainsBodyStrings property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionContainsBodyStrings"] = 6] = "ConditionContainsBodyStrings";
    /**
     * The ContainsHeaderStrings property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionContainsHeaderStrings"] = 7] = "ConditionContainsHeaderStrings";
    /**
     * The ContainsRecipientStrings property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionContainsRecipientStrings"] = 8] = "ConditionContainsRecipientStrings";
    /**
     * The ContainsSenderStrings property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionContainsSenderStrings"] = 9] = "ConditionContainsSenderStrings";
    /**
     * The ContainsSubjectOrBodyStrings property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionContainsSubjectOrBodyStrings"] = 10] = "ConditionContainsSubjectOrBodyStrings";
    /**
     * The ContainsSubjectStrings property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionContainsSubjectStrings"] = 11] = "ConditionContainsSubjectStrings";
    /**
     * The FlaggedForAction property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionFlaggedForAction"] = 12] = "ConditionFlaggedForAction";
    /**
     * The FromAddresses property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionFromAddresses"] = 13] = "ConditionFromAddresses";
    /**
     * The FromConnectedAccounts property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionFromConnectedAccounts"] = 14] = "ConditionFromConnectedAccounts";
    /**
     * The HasAttachments property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionHasAttachments"] = 15] = "ConditionHasAttachments";
    /**
     * The Importance property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionImportance"] = 16] = "ConditionImportance";
    /**
     * The IsApprovalRequest property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionIsApprovalRequest"] = 17] = "ConditionIsApprovalRequest";
    /**
     * The IsAutomaticForward property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionIsAutomaticForward"] = 18] = "ConditionIsAutomaticForward";
    /**
     * The IsAutomaticReply property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionIsAutomaticReply"] = 19] = "ConditionIsAutomaticReply";
    /**
     * The IsEncrypted property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionIsEncrypted"] = 20] = "ConditionIsEncrypted";
    /**
     * The IsMeetingRequest property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionIsMeetingRequest"] = 21] = "ConditionIsMeetingRequest";
    /**
     * The IsMeetingResponse property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionIsMeetingResponse"] = 22] = "ConditionIsMeetingResponse";
    /**
     * The IsNonDeliveryReport property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionIsNonDeliveryReport"] = 23] = "ConditionIsNonDeliveryReport";
    /**
     * The IsPermissionControlled property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionIsPermissionControlled"] = 24] = "ConditionIsPermissionControlled";
    /**
     * The IsRead property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionIsRead"] = 25] = "ConditionIsRead";
    /**
     * The IsSigned property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionIsSigned"] = 26] = "ConditionIsSigned";
    /**
     * The IsVoicemail property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionIsVoicemail"] = 27] = "ConditionIsVoicemail";
    /**
     * The IsReadReceipt property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionIsReadReceipt"] = 28] = "ConditionIsReadReceipt";
    /**
     * The ItemClasses property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionItemClasses"] = 29] = "ConditionItemClasses";
    /**
     * The MessageClassifications property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionMessageClassifications"] = 30] = "ConditionMessageClassifications";
    /**
     * The NotSentToMe property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionNotSentToMe"] = 31] = "ConditionNotSentToMe";
    /**
     * The SentCcMe property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionSentCcMe"] = 32] = "ConditionSentCcMe";
    /**
     * The SentOnlyToMe property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionSentOnlyToMe"] = 33] = "ConditionSentOnlyToMe";
    /**
     * The SentToAddresses property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionSentToAddresses"] = 34] = "ConditionSentToAddresses";
    /**
     * The SentToMe property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionSentToMe"] = 35] = "ConditionSentToMe";
    /**
     * The SentToOrCcMe property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionSentToOrCcMe"] = 36] = "ConditionSentToOrCcMe";
    /**
     * The Sensitivity property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionSensitivity"] = 37] = "ConditionSensitivity";
    /**
     * The WithinDateRange property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionWithinDateRange"] = 38] = "ConditionWithinDateRange";
    /**
     * The WithinSizeRange property of a rule's set of conditions.
     */
    RuleProperty[RuleProperty["ConditionWithinSizeRange"] = 39] = "ConditionWithinSizeRange";
    /**
     * The Categories property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionCategories"] = 40] = "ExceptionCategories";
    /**
     * The ContainsBodyStrings property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionContainsBodyStrings"] = 41] = "ExceptionContainsBodyStrings";
    /**
     * The ContainsHeaderStrings property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionContainsHeaderStrings"] = 42] = "ExceptionContainsHeaderStrings";
    /**
     * The ContainsRecipientStrings property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionContainsRecipientStrings"] = 43] = "ExceptionContainsRecipientStrings";
    /**
     * The ContainsSenderStrings property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionContainsSenderStrings"] = 44] = "ExceptionContainsSenderStrings";
    /**
     * The ContainsSubjectOrBodyStrings property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionContainsSubjectOrBodyStrings"] = 45] = "ExceptionContainsSubjectOrBodyStrings";
    /**
     * The ContainsSubjectStrings property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionContainsSubjectStrings"] = 46] = "ExceptionContainsSubjectStrings";
    /**
     * The FlaggedForAction property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionFlaggedForAction"] = 47] = "ExceptionFlaggedForAction";
    /**
     * The FromAddresses property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionFromAddresses"] = 48] = "ExceptionFromAddresses";
    /**
     * The FromConnectedAccounts property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionFromConnectedAccounts"] = 49] = "ExceptionFromConnectedAccounts";
    /**
     * The HasAttachments property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionHasAttachments"] = 50] = "ExceptionHasAttachments";
    /**
     * The Importance property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionImportance"] = 51] = "ExceptionImportance";
    /**
     * The IsApprovalRequest property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionIsApprovalRequest"] = 52] = "ExceptionIsApprovalRequest";
    /**
     * The IsAutomaticForward property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionIsAutomaticForward"] = 53] = "ExceptionIsAutomaticForward";
    /**
     * The IsAutomaticReply property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionIsAutomaticReply"] = 54] = "ExceptionIsAutomaticReply";
    /**
     * The IsEncrypted property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionIsEncrypted"] = 55] = "ExceptionIsEncrypted";
    /**
     * The IsMeetingRequest property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionIsMeetingRequest"] = 56] = "ExceptionIsMeetingRequest";
    /**
     * The IsMeetingResponse property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionIsMeetingResponse"] = 57] = "ExceptionIsMeetingResponse";
    /**
     * The IsNonDeliveryReport property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionIsNonDeliveryReport"] = 58] = "ExceptionIsNonDeliveryReport";
    /**
     * The IsPermissionControlled property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionIsPermissionControlled"] = 59] = "ExceptionIsPermissionControlled";
    /**
     * The IsRead property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionIsRead"] = 60] = "ExceptionIsRead";
    /**
     * The IsSigned property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionIsSigned"] = 61] = "ExceptionIsSigned";
    /**
     * The IsVoicemail property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionIsVoicemail"] = 62] = "ExceptionIsVoicemail";
    /**
     * The ItemClasses property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionItemClasses"] = 63] = "ExceptionItemClasses";
    /**
     * The MessageClassifications property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionMessageClassifications"] = 64] = "ExceptionMessageClassifications";
    /**
     * The NotSentToMe property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionNotSentToMe"] = 65] = "ExceptionNotSentToMe";
    /**
     * The SentCcMe property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionSentCcMe"] = 66] = "ExceptionSentCcMe";
    /**
     * The SentOnlyToMe property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionSentOnlyToMe"] = 67] = "ExceptionSentOnlyToMe";
    /**
     * The SentToAddresses property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionSentToAddresses"] = 68] = "ExceptionSentToAddresses";
    /**
     * The SentToMe property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionSentToMe"] = 69] = "ExceptionSentToMe";
    /**
     * The SentToOrCcMe property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionSentToOrCcMe"] = 70] = "ExceptionSentToOrCcMe";
    /**
     * The Sensitivity property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionSensitivity"] = 71] = "ExceptionSensitivity";
    /**
     * The WithinDateRange property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionWithinDateRange"] = 72] = "ExceptionWithinDateRange";
    /**
     * The WithinSizeRange property of a rule's set of exceptions.
     */
    RuleProperty[RuleProperty["ExceptionWithinSizeRange"] = 73] = "ExceptionWithinSizeRange";
    /**
     * The Categories property in a rule's set of actions.
     */
    RuleProperty[RuleProperty["ActionCategories"] = 74] = "ActionCategories";
    /**
     * The CopyToFolder property in a rule's set of actions.
     */
    RuleProperty[RuleProperty["ActionCopyToFolder"] = 75] = "ActionCopyToFolder";
    /**
     * The Delete property in a rule's set of actions.
     */
    RuleProperty[RuleProperty["ActionDelete"] = 76] = "ActionDelete";
    /**
     * The ForwardAsAttachmentToRecipients property in a rule's set of actions.
     */
    RuleProperty[RuleProperty["ActionForwardAsAttachmentToRecipients"] = 77] = "ActionForwardAsAttachmentToRecipients";
    /**
     * The ForwardToRecipients property in a rule's set of actions.
     */
    RuleProperty[RuleProperty["ActionForwardToRecipients"] = 78] = "ActionForwardToRecipients";
    /**
     * The Importance property in a rule's set of actions.
     */
    RuleProperty[RuleProperty["ActionImportance"] = 79] = "ActionImportance";
    /**
     * The MarkAsRead property in a rule's set of actions.
     */
    RuleProperty[RuleProperty["ActionMarkAsRead"] = 80] = "ActionMarkAsRead";
    /**
     * The MoveToFolder property in a rule's set of actions.
     */
    RuleProperty[RuleProperty["ActionMoveToFolder"] = 81] = "ActionMoveToFolder";
    /**
     * The PermanentDelete property in a rule's set of actions.
     */
    RuleProperty[RuleProperty["ActionPermanentDelete"] = 82] = "ActionPermanentDelete";
    /**
     * The RedirectToRecipients property in a rule's set of actions.
     */
    RuleProperty[RuleProperty["ActionRedirectToRecipients"] = 83] = "ActionRedirectToRecipients";
    /**
     * The SendSMSAlertToRecipients property in a rule's set of actions.
     */
    RuleProperty[RuleProperty["ActionSendSMSAlertToRecipients"] = 84] = "ActionSendSMSAlertToRecipients";
    /**
     * The ServerReplyWithMessage property in a rule's set of actions.
     */
    RuleProperty[RuleProperty["ActionServerReplyWithMessage"] = 85] = "ActionServerReplyWithMessage";
    /**
     * The StopProcessingRules property in a rule's set of actions.
     */
    RuleProperty[RuleProperty["ActionStopProcessingRules"] = 86] = "ActionStopProcessingRules";
    /**
     * The IsEnabled property of a rule, indicating if the rule is enabled.
     */
    RuleProperty[RuleProperty["IsEnabled"] = 87] = "IsEnabled";
    /**
     * The IsInError property of a rule, indicating if the rule is in error.
     */
    RuleProperty[RuleProperty["IsInError"] = 88] = "IsInError";
    /**
     * The Conditions property of a rule, contains all conditions of the rule.
     */
    RuleProperty[RuleProperty["Conditions"] = 89] = "Conditions";
    /**
     * The Exceptions property of a rule, contains all exceptions of the rule.
     */
    RuleProperty[RuleProperty["Exceptions"] = 90] = "Exceptions";
})(RuleProperty = exports.RuleProperty || (exports.RuleProperty = {}));
(function (RuleProperty) {
    /**EwsEnumAttribute */
    function FromEwsEnumString(value) {
        return RuleProperty[value.replace(":", "")];
    }
    RuleProperty.FromEwsEnumString = FromEwsEnumString;
    /**EwsEnumAttribute */
    function ToEwsEnumString(value) {
        var startsWith = ["Condition", "Exception", "Action"];
        var str2 = null;
        startsWith.map(function (str) {
            if (RuleProperty[value].indexOf(str) === 0) {
                str2 = RuleProperty[value].replace(str, str + ":");
            }
        });
        return str2 || RuleProperty[value];
    }
    RuleProperty.ToEwsEnumString = ToEwsEnumString;
})(RuleProperty = exports.RuleProperty || (exports.RuleProperty = {}));
/**
 * Defines the scope of a search folder.
 */
var SearchFolderTraversal;
(function (SearchFolderTraversal) {
    /**
     * Items belonging to the root folder are retrieved.
     */
    SearchFolderTraversal[SearchFolderTraversal["Shallow"] = 0] = "Shallow";
    /**
     * Items belonging to the root folder and its sub-folders are retrieved.
     */
    SearchFolderTraversal[SearchFolderTraversal["Deep"] = 1] = "Deep";
})(SearchFolderTraversal = exports.SearchFolderTraversal || (exports.SearchFolderTraversal = {}));
/**
 * Defines the page direction for mailbox search.
 */
var SearchPageDirection;
(function (SearchPageDirection) {
    /**
     * Navigate to next page.
     */
    SearchPageDirection[SearchPageDirection["Next"] = 0] = "Next";
    /**
     * Navigate to previous page.
     */
    SearchPageDirection[SearchPageDirection["Previous"] = 1] = "Previous";
})(SearchPageDirection = exports.SearchPageDirection || (exports.SearchPageDirection = {}));
/**
 * Defines the type of search result.
 */
var SearchResultType;
(function (SearchResultType) {
    /**
     * Keyword statistics only.
     */
    SearchResultType[SearchResultType["StatisticsOnly"] = 0] = "StatisticsOnly";
    /**
     * Preview only.
     */
    SearchResultType[SearchResultType["PreviewOnly"] = 1] = "PreviewOnly";
})(SearchResultType = exports.SearchResultType || (exports.SearchResultType = {}));
/**
 * Defines how meeting cancellations should be sent to attendees when an appointment is deleted.
 */
var SendCancellationsMode;
(function (SendCancellationsMode) {
    /**
     * No meeting cancellation is sent.
     */
    SendCancellationsMode[SendCancellationsMode["SendToNone"] = 0] = "SendToNone";
    /**
     * Meeting cancellations are sent to all attendees.
     */
    SendCancellationsMode[SendCancellationsMode["SendOnlyToAll"] = 1] = "SendOnlyToAll";
    /**
     * Meeting cancellations are sent to all attendees and a copy of the cancellation message is saved in the organizer's Sent Items folder.
     */
    SendCancellationsMode[SendCancellationsMode["SendToAllAndSaveCopy"] = 2] = "SendToAllAndSaveCopy";
})(SendCancellationsMode = exports.SendCancellationsMode || (exports.SendCancellationsMode = {}));
/**
 * Defines if/how meeting invitations are sent.
 */
var SendInvitationsMode;
(function (SendInvitationsMode) {
    /**
     * No meeting invitation is sent.
     */
    SendInvitationsMode[SendInvitationsMode["SendToNone"] = 0] = "SendToNone";
    /**
     * Meeting invitations are sent to all attendees.
     */
    SendInvitationsMode[SendInvitationsMode["SendOnlyToAll"] = 1] = "SendOnlyToAll";
    /**
     * Meeting invitations are sent to all attendees and a copy of the invitation message is saved.
     */
    SendInvitationsMode[SendInvitationsMode["SendToAllAndSaveCopy"] = 2] = "SendToAllAndSaveCopy";
})(SendInvitationsMode = exports.SendInvitationsMode || (exports.SendInvitationsMode = {}));
/**
 * Defines if/how meeting invitations or cancellations should be sent to attendees when an appointment is updated.
 */
var SendInvitationsOrCancellationsMode;
(function (SendInvitationsOrCancellationsMode) {
    /**
     * No meeting invitation/cancellation is sent.
     */
    SendInvitationsOrCancellationsMode[SendInvitationsOrCancellationsMode["SendToNone"] = 0] = "SendToNone";
    /**
     * Meeting invitations/cancellations are sent to all attendees.
     */
    SendInvitationsOrCancellationsMode[SendInvitationsOrCancellationsMode["SendOnlyToAll"] = 1] = "SendOnlyToAll";
    /**
     * Meeting invitations/cancellations are sent only to attendees that have been added or modified.
     */
    SendInvitationsOrCancellationsMode[SendInvitationsOrCancellationsMode["SendOnlyToChanged"] = 2] = "SendOnlyToChanged";
    /**
     * Meeting invitations/cancellations are sent to all attendees and a copy is saved in the organizer's Sent Items folder.
     */
    SendInvitationsOrCancellationsMode[SendInvitationsOrCancellationsMode["SendToAllAndSaveCopy"] = 3] = "SendToAllAndSaveCopy";
    /**
     * Meeting invitations/cancellations are sent only to attendees that have been added or modified and a copy is saved in the organizer's Sent Items folder.
     */
    SendInvitationsOrCancellationsMode[SendInvitationsOrCancellationsMode["SendToChangedAndSaveCopy"] = 4] = "SendToChangedAndSaveCopy";
})(SendInvitationsOrCancellationsMode = exports.SendInvitationsOrCancellationsMode || (exports.SendInvitationsOrCancellationsMode = {}));
/**
 * The values indicate the types of item icons to display.
 */
var SendPrompt;
(function (SendPrompt) {
    /**
     * None
     */
    SendPrompt[SendPrompt["None"] = 0] = "None";
    /**
     * Send
     */
    SendPrompt[SendPrompt["Send"] = 1] = "Send";
    /**
     * VotingOption
     */
    SendPrompt[SendPrompt["VotingOption"] = 2] = "VotingOption";
})(SendPrompt = exports.SendPrompt || (exports.SendPrompt = {}));
/**
 * Defines the sensitivity of an item.
 */
var Sensitivity;
(function (Sensitivity) {
    /**
     * The item has a normal sensitivity.
     */
    Sensitivity[Sensitivity["Normal"] = 0] = "Normal";
    /**
     * The item is personal.
     */
    Sensitivity[Sensitivity["Personal"] = 1] = "Personal";
    /**
     * The item is private.
     */
    Sensitivity[Sensitivity["Private"] = 2] = "Private";
    /**
     * The item is confidential.
     */
    Sensitivity[Sensitivity["Confidential"] = 3] = "Confidential";
})(Sensitivity = exports.Sensitivity || (exports.Sensitivity = {}));
/**
 * Defines the error codes that can be returned by the Exchange Web Services.
 */
var ServiceError;
(function (ServiceError) {
    /**
     * NoError. Indicates that an error has not occurred.
     */
    ServiceError[ServiceError["NoError"] = 0] = "NoError";
    /**
     * Access is denied. Check credentials and try again.
     */
    ServiceError[ServiceError["ErrorAccessDenied"] = 1] = "ErrorAccessDenied";
    /**
     * The impersonation authentication header should not be included.
     */
    ServiceError[ServiceError["ErrorAccessModeSpecified"] = 2] = "ErrorAccessModeSpecified";
    /**
     * Account is disabled. Contact the account administrator.
     */
    ServiceError[ServiceError["ErrorAccountDisabled"] = 3] = "ErrorAccountDisabled";
    /**
     * Failed to add one or more delegates.
     */
    ServiceError[ServiceError["ErrorAddDelegatesFailed"] = 4] = "ErrorAddDelegatesFailed";
    /**
     * ErrorAddressSpaceNotFound
     */
    ServiceError[ServiceError["ErrorAddressSpaceNotFound"] = 5] = "ErrorAddressSpaceNotFound";
    /**
     * Active Directory operation did not succeed. Try again later.
     */
    ServiceError[ServiceError["ErrorADOperation"] = 6] = "ErrorADOperation";
    /**
     * Invalid search criteria.
     */
    ServiceError[ServiceError["ErrorADSessionFilter"] = 7] = "ErrorADSessionFilter";
    /**
     * Active Directory is unavailable. Try again later.
     */
    ServiceError[ServiceError["ErrorADUnavailable"] = 8] = "ErrorADUnavailable";
    /**
     * AffectedTaskOccurrences attribute is required for Task items.
     */
    ServiceError[ServiceError["ErrorAffectedTaskOccurrencesRequired"] = 9] = "ErrorAffectedTaskOccurrencesRequired";
    /**
     * The conversation action alwayscategorize or alwaysmove or alwaysdelete has failed.
     */
    ServiceError[ServiceError["ErrorApplyConversationActionFailed"] = 10] = "ErrorApplyConversationActionFailed";
    /**
     * Archive mailbox not enabled
     */
    ServiceError[ServiceError["ErrorArchiveMailboxNotEnabled"] = 11] = "ErrorArchiveMailboxNotEnabled";
    /**
     * Unable to create the folder in archive mailbox to which the items will be archived
     */
    ServiceError[ServiceError["ErrorArchiveFolderPathCreation"] = 12] = "ErrorArchiveFolderPathCreation";
    /**
     * Unable to discover archive mailbox
     */
    ServiceError[ServiceError["ErrorArchiveMailboxServiceDiscoveryFailed"] = 13] = "ErrorArchiveMailboxServiceDiscoveryFailed";
    /**
     * The item has attachment at more than the maximum supported nest level.
     */
    ServiceError[ServiceError["ErrorAttachmentNestLevelLimitExceeded"] = 14] = "ErrorAttachmentNestLevelLimitExceeded";
    /**
     * The file attachment exceeds the maximum supported size.
     */
    ServiceError[ServiceError["ErrorAttachmentSizeLimitExceeded"] = 15] = "ErrorAttachmentSizeLimitExceeded";
    /**
     * ErrorAutoDiscoverFailed
     */
    ServiceError[ServiceError["ErrorAutoDiscoverFailed"] = 16] = "ErrorAutoDiscoverFailed";
    /**
     * ErrorAvailabilityConfigNotFound
     */
    ServiceError[ServiceError["ErrorAvailabilityConfigNotFound"] = 17] = "ErrorAvailabilityConfigNotFound";
    /**
     * Item was not processed as a result of a previous error.
     */
    ServiceError[ServiceError["ErrorBatchProcessingStopped"] = 18] = "ErrorBatchProcessingStopped";
    /**
     * Can not move or copy a calendar occurrence.
     */
    ServiceError[ServiceError["ErrorCalendarCannotMoveOrCopyOccurrence"] = 19] = "ErrorCalendarCannotMoveOrCopyOccurrence";
    /**
     * Cannot update calendar item that has already been deleted.
     */
    ServiceError[ServiceError["ErrorCalendarCannotUpdateDeletedItem"] = 20] = "ErrorCalendarCannotUpdateDeletedItem";
    /**
     * The Id specified does not represent an occurrence.
     */
    ServiceError[ServiceError["ErrorCalendarCannotUseIdForOccurrenceId"] = 21] = "ErrorCalendarCannotUseIdForOccurrenceId";
    /**
     * The specified Id does not represent a recurring master item.
     */
    ServiceError[ServiceError["ErrorCalendarCannotUseIdForRecurringMasterId"] = 22] = "ErrorCalendarCannotUseIdForRecurringMasterId";
    /**
     * Calendar item duration is too long.
     */
    ServiceError[ServiceError["ErrorCalendarDurationIsTooLong"] = 23] = "ErrorCalendarDurationIsTooLong";
    /**
     * EndDate is earlier than StartDate
     */
    ServiceError[ServiceError["ErrorCalendarEndDateIsEarlierThanStartDate"] = 24] = "ErrorCalendarEndDateIsEarlierThanStartDate";
    /**
     * Cannot request CalendarView for the folder.
     */
    ServiceError[ServiceError["ErrorCalendarFolderIsInvalidForCalendarView"] = 25] = "ErrorCalendarFolderIsInvalidForCalendarView";
    /**
     * Attribute has an invalid value.
     */
    ServiceError[ServiceError["ErrorCalendarInvalidAttributeValue"] = 26] = "ErrorCalendarInvalidAttributeValue";
    /**
     * The value of the DaysOfWeek property is not valid for time change pattern of time zone.
     */
    ServiceError[ServiceError["ErrorCalendarInvalidDayForTimeChangePattern"] = 27] = "ErrorCalendarInvalidDayForTimeChangePattern";
    /**
     * The value of the DaysOfWeek property is invalid for a weekly recurrence.
     */
    ServiceError[ServiceError["ErrorCalendarInvalidDayForWeeklyRecurrence"] = 28] = "ErrorCalendarInvalidDayForWeeklyRecurrence";
    /**
     * The property has invalid state.
     */
    ServiceError[ServiceError["ErrorCalendarInvalidPropertyState"] = 29] = "ErrorCalendarInvalidPropertyState";
    /**
     * The property has an invalid value.
     */
    ServiceError[ServiceError["ErrorCalendarInvalidPropertyValue"] = 30] = "ErrorCalendarInvalidPropertyValue";
    /**
     * The recurrence is invalid.
     */
    ServiceError[ServiceError["ErrorCalendarInvalidRecurrence"] = 31] = "ErrorCalendarInvalidRecurrence";
    /**
     * TimeZone is invalid.
     */
    ServiceError[ServiceError["ErrorCalendarInvalidTimeZone"] = 32] = "ErrorCalendarInvalidTimeZone";
    /**
     * A meeting that's been canceled can't be accepted.
     */
    ServiceError[ServiceError["ErrorCalendarIsCancelledForAccept"] = 33] = "ErrorCalendarIsCancelledForAccept";
    /**
     * A canceled meeting can't be declined.
     */
    ServiceError[ServiceError["ErrorCalendarIsCancelledForDecline"] = 34] = "ErrorCalendarIsCancelledForDecline";
    /**
     * A canceled meeting can't be removed.
     */
    ServiceError[ServiceError["ErrorCalendarIsCancelledForRemove"] = 35] = "ErrorCalendarIsCancelledForRemove";
    /**
     * A canceled meeting can't be accepted tentatively.
     */
    ServiceError[ServiceError["ErrorCalendarIsCancelledForTentative"] = 36] = "ErrorCalendarIsCancelledForTentative";
    /**
     * AcceptItem action is invalid for a delegated meeting message.
     */
    ServiceError[ServiceError["ErrorCalendarIsDelegatedForAccept"] = 37] = "ErrorCalendarIsDelegatedForAccept";
    /**
     * DeclineItem operation is invalid for a delegated meeting message.
     */
    ServiceError[ServiceError["ErrorCalendarIsDelegatedForDecline"] = 38] = "ErrorCalendarIsDelegatedForDecline";
    /**
     * RemoveItem action is invalid for a delegated meeting message.
     */
    ServiceError[ServiceError["ErrorCalendarIsDelegatedForRemove"] = 39] = "ErrorCalendarIsDelegatedForRemove";
    /**
     * The TentativelyAcceptItem action isn't valid for a delegated meeting message.
     */
    ServiceError[ServiceError["ErrorCalendarIsDelegatedForTentative"] = 40] = "ErrorCalendarIsDelegatedForTentative";
    /**
     * User must be an organizer for CancelCalendarItem action.
     */
    ServiceError[ServiceError["ErrorCalendarIsNotOrganizer"] = 41] = "ErrorCalendarIsNotOrganizer";
    /**
     * The user is the organizer of this meeting, and cannot, therefore, accept it.
     */
    ServiceError[ServiceError["ErrorCalendarIsOrganizerForAccept"] = 42] = "ErrorCalendarIsOrganizerForAccept";
    /**
     * The user is the organizer of this meeting, and cannot, therefore, decline it.
     */
    ServiceError[ServiceError["ErrorCalendarIsOrganizerForDecline"] = 43] = "ErrorCalendarIsOrganizerForDecline";
    /**
     * The user is the organizer of this meeting, and cannot, therefore, remove it.
     */
    ServiceError[ServiceError["ErrorCalendarIsOrganizerForRemove"] = 44] = "ErrorCalendarIsOrganizerForRemove";
    /**
     * The user is the organizer of this meeting, and therefore can't tentatively accept it.
     */
    ServiceError[ServiceError["ErrorCalendarIsOrganizerForTentative"] = 45] = "ErrorCalendarIsOrganizerForTentative";
    /**
     * The meeting request is out of date. The calendar couldn't be updated.
     */
    ServiceError[ServiceError["ErrorCalendarMeetingRequestIsOutOfDate"] = 46] = "ErrorCalendarMeetingRequestIsOutOfDate";
    /**
     * Occurrence index is out of recurrence range.
     */
    ServiceError[ServiceError["ErrorCalendarOccurrenceIndexIsOutOfRecurrenceRange"] = 47] = "ErrorCalendarOccurrenceIndexIsOutOfRecurrenceRange";
    /**
     * Occurrence with this index was previously deleted from the recurrence.
     */
    ServiceError[ServiceError["ErrorCalendarOccurrenceIsDeletedFromRecurrence"] = 48] = "ErrorCalendarOccurrenceIsDeletedFromRecurrence";
    /**
     * The calendar property falls out of valid range.
     */
    ServiceError[ServiceError["ErrorCalendarOutOfRange"] = 49] = "ErrorCalendarOutOfRange";
    /**
     * The specified view range exceeds the maximum range of two years.
     */
    ServiceError[ServiceError["ErrorCalendarViewRangeTooBig"] = 50] = "ErrorCalendarViewRangeTooBig";
    /**
     * Failed to get valid Active Directory information for the calling account. Confirm that it
     * is a valid Active Directory account.
     */
    ServiceError[ServiceError["ErrorCallerIsInvalidADAccount"] = 51] = "ErrorCallerIsInvalidADAccount";
    /**
     * Cannot archive items in Calendar, contact to task folders
     */
    ServiceError[ServiceError["ErrorCannotArchiveCalendarContactTaskFolderException"] = 52] = "ErrorCannotArchiveCalendarContactTaskFolderException";
    /**
     * Cannot archive items in archive mailboxes
     */
    ServiceError[ServiceError["ErrorCannotArchiveItemsInArchiveMailbox"] = 53] = "ErrorCannotArchiveItemsInArchiveMailbox";
    /**
     * Cannot archive items in public folders
     */
    ServiceError[ServiceError["ErrorCannotArchiveItemsInPublicFolders"] = 54] = "ErrorCannotArchiveItemsInPublicFolders";
    /**
     * Cannot create a calendar item in a non-calendar folder.
     */
    ServiceError[ServiceError["ErrorCannotCreateCalendarItemInNonCalendarFolder"] = 55] = "ErrorCannotCreateCalendarItemInNonCalendarFolder";
    /**
     * Cannot create a contact in a non-contact folder.
     */
    ServiceError[ServiceError["ErrorCannotCreateContactInNonContactFolder"] = 56] = "ErrorCannotCreateContactInNonContactFolder";
    /**
     * Cannot create a post item in a folder that is not a mail folder.
     */
    ServiceError[ServiceError["ErrorCannotCreatePostItemInNonMailFolder"] = 57] = "ErrorCannotCreatePostItemInNonMailFolder";
    /**
     * Cannot create a task in a non-task Folder.
     */
    ServiceError[ServiceError["ErrorCannotCreateTaskInNonTaskFolder"] = 58] = "ErrorCannotCreateTaskInNonTaskFolder";
    /**
     * Object cannot be deleted.
     */
    ServiceError[ServiceError["ErrorCannotDeleteObject"] = 59] = "ErrorCannotDeleteObject";
    /**
     * Deleting a task occurrence is not permitted on non-recurring tasks, on the last
     * occurrence of a recurring task or on a regenerating task.
     */
    ServiceError[ServiceError["ErrorCannotDeleteTaskOccurrence"] = 60] = "ErrorCannotDeleteTaskOccurrence";
    /**
     * Mandatory extensions cannot be disabled by end users
     */
    ServiceError[ServiceError["ErrorCannotDisableMandatoryExtension"] = 61] = "ErrorCannotDisableMandatoryExtension";
    /**
     * Folder cannot be emptied.
     */
    ServiceError[ServiceError["ErrorCannotEmptyFolder"] = 62] = "ErrorCannotEmptyFolder";
    /**
     * Cannot get external ECP URL. This might happen if external ECP URL isn't configured
     */
    ServiceError[ServiceError["ErrorCannotGetExternalEcpUrl"] = 63] = "ErrorCannotGetExternalEcpUrl";
    /**
     * Unable to read the folder path for the source folder while archiving items
     */
    ServiceError[ServiceError["ErrorCannotGetSourceFolderPath"] = 64] = "ErrorCannotGetSourceFolderPath";
    /**
     * The attachment could not be opened.
     */
    ServiceError[ServiceError["ErrorCannotOpenFileAttachment"] = 65] = "ErrorCannotOpenFileAttachment";
    /**
     * Expected a PermissionSet but received a CalendarPermissionSet.
     */
    ServiceError[ServiceError["ErrorCannotSetCalendarPermissionOnNonCalendarFolder"] = 66] = "ErrorCannotSetCalendarPermissionOnNonCalendarFolder";
    /**
     * Expected a CalendarPermissionSet but received a PermissionSet.
     */
    ServiceError[ServiceError["ErrorCannotSetNonCalendarPermissionOnCalendarFolder"] = 67] = "ErrorCannotSetNonCalendarPermissionOnCalendarFolder";
    /**
     * Cannot set UnknownEntries on a PermissionSet or CalendarPermissionSet.
     */
    ServiceError[ServiceError["ErrorCannotSetPermissionUnknownEntries"] = 68] = "ErrorCannotSetPermissionUnknownEntries";
    /**
     * Cannot specify search folders as source folders while archiving items
     */
    ServiceError[ServiceError["ErrorCannotSpecifySearchFolderAsSourceFolder"] = 69] = "ErrorCannotSpecifySearchFolderAsSourceFolder";
    /**
     * Expected an item Id but received a folder Id.
     */
    ServiceError[ServiceError["ErrorCannotUseFolderIdForItemId"] = 70] = "ErrorCannotUseFolderIdForItemId";
    /**
     * Expected a folder Id but received an item Id.
     */
    ServiceError[ServiceError["ErrorCannotUseItemIdForFolderId"] = 71] = "ErrorCannotUseItemIdForFolderId";
    /**
     * ChangeKey is required if overriding automatic conflict resolution.
     */
    ServiceError[ServiceError["ErrorChangeKeyRequired"] = 72] = "ErrorChangeKeyRequired";
    /**
     * ChangeKey is required for this operation.
     */
    ServiceError[ServiceError["ErrorChangeKeyRequiredForWriteOperations"] = 73] = "ErrorChangeKeyRequiredForWriteOperations";
    /**
     * ErrorClientDisconnected
     */
    ServiceError[ServiceError["ErrorClientDisconnected"] = 74] = "ErrorClientDisconnected";
    /**
     * Connection did not succeed. Try again later.
     */
    ServiceError[ServiceError["ErrorConnectionFailed"] = 75] = "ErrorConnectionFailed";
    /**
     * The Contains filter can only be used for string properties.
     */
    ServiceError[ServiceError["ErrorContainsFilterWrongType"] = 76] = "ErrorContainsFilterWrongType";
    /**
     * Content conversion failed.
     */
    ServiceError[ServiceError["ErrorContentConversionFailed"] = 77] = "ErrorContentConversionFailed";
    /**
     * Data is corrupt.
     */
    ServiceError[ServiceError["ErrorCorruptData"] = 78] = "ErrorCorruptData";
    /**
     * Unable to create item. The user account does not have the right to create items.
     */
    ServiceError[ServiceError["ErrorCreateItemAccessDenied"] = 79] = "ErrorCreateItemAccessDenied";
    /**
     * Failed to create one or more of the specified managed folders.
     */
    ServiceError[ServiceError["ErrorCreateManagedFolderPartialCompletion"] = 80] = "ErrorCreateManagedFolderPartialCompletion";
    /**
     * Unable to create subfolder. The user account does not have the right to create
     * subfolders.
     */
    ServiceError[ServiceError["ErrorCreateSubfolderAccessDenied"] = 81] = "ErrorCreateSubfolderAccessDenied";
    /**
     * Move and Copy operations across mailbox boundaries are not permitted.
     */
    ServiceError[ServiceError["ErrorCrossMailboxMoveCopy"] = 82] = "ErrorCrossMailboxMoveCopy";
    /**
     * This request isn't allowed because the Client Access server that's servicing the request
     * is in a different site than the requested resource. Use Autodiscover to find the correct
     * URL for accessing the specified resource.
     */
    ServiceError[ServiceError["ErrorCrossSiteRequest"] = 83] = "ErrorCrossSiteRequest";
    /**
     * Property exceeds the maximum supported size.
     */
    ServiceError[ServiceError["ErrorDataSizeLimitExceeded"] = 84] = "ErrorDataSizeLimitExceeded";
    /**
     * Invalid data source operation.
     */
    ServiceError[ServiceError["ErrorDataSourceOperation"] = 85] = "ErrorDataSourceOperation";
    /**
     * The user is already a delegate for the mailbox.
     */
    ServiceError[ServiceError["ErrorDelegateAlreadyExists"] = 86] = "ErrorDelegateAlreadyExists";
    /**
     * This is an invalid operation. Cannot add owner as delegate.
     */
    ServiceError[ServiceError["ErrorDelegateCannotAddOwner"] = 87] = "ErrorDelegateCannotAddOwner";
    /**
     * Delegate is not configured properly.
     */
    ServiceError[ServiceError["ErrorDelegateMissingConfiguration"] = 88] = "ErrorDelegateMissingConfiguration";
    /**
     * The delegate does not map to a user in the Active Directory.
     */
    ServiceError[ServiceError["ErrorDelegateNoUser"] = 89] = "ErrorDelegateNoUser";
    /**
     * Cannot add the delegate user. Failed to validate the changes.
     */
    ServiceError[ServiceError["ErrorDelegateValidationFailed"] = 90] = "ErrorDelegateValidationFailed";
    /**
     * Distinguished folders cannot be deleted.
     */
    ServiceError[ServiceError["ErrorDeleteDistinguishedFolder"] = 91] = "ErrorDeleteDistinguishedFolder";
    /**
     * The deletion failed.
     */
    ServiceError[ServiceError["ErrorDeleteItemsFailed"] = 92] = "ErrorDeleteItemsFailed";
    /**
     * DistinguishedUser should not be specified for a Delegate User.
     */
    ServiceError[ServiceError["ErrorDistinguishedUserNotSupported"] = 93] = "ErrorDistinguishedUserNotSupported";
    /**
     * The group member doesn't exist.
     */
    ServiceError[ServiceError["ErrorDistributionListMemberNotExist"] = 94] = "ErrorDistributionListMemberNotExist";
    /**
     * The specified list of managed folder names contains duplicate entries.
     */
    ServiceError[ServiceError["ErrorDuplicateInputFolderNames"] = 95] = "ErrorDuplicateInputFolderNames";
    /**
     * A duplicate exchange legacy DN.
     */
    ServiceError[ServiceError["ErrorDuplicateLegacyDistinguishedName"] = 96] = "ErrorDuplicateLegacyDistinguishedName";
    /**
     * A duplicate SOAP header was received.
     */
    ServiceError[ServiceError["ErrorDuplicateSOAPHeader"] = 97] = "ErrorDuplicateSOAPHeader";
    /**
     * The specified permission set contains duplicate UserIds.
     */
    ServiceError[ServiceError["ErrorDuplicateUserIdsSpecified"] = 98] = "ErrorDuplicateUserIdsSpecified";
    /**
     * The email address associated with a folder Id does not match the mailbox you are
     * operating on.
     */
    ServiceError[ServiceError["ErrorEmailAddressMismatch"] = 99] = "ErrorEmailAddressMismatch";
    /**
     * The watermark used for creating this subscription was not found.
     */
    ServiceError[ServiceError["ErrorEventNotFound"] = 100] = "ErrorEventNotFound";
    /**
     * You have exceeded the available concurrent connections for your account.  Try again once
     * your other requests have completed.
     */
    ServiceError[ServiceError["ErrorExceededConnectionCount"] = 101] = "ErrorExceededConnectionCount";
    /**
     * You have exceeded the maximum number of objects that can be returned for the find
     * operation. Use paging to reduce the result size and try your request again.
     */
    ServiceError[ServiceError["ErrorExceededFindCountLimit"] = 102] = "ErrorExceededFindCountLimit";
    /**
     * You have exceeded the available subscriptions for your account.  Remove unnecessary
     * subscriptions and try your request again.
     */
    ServiceError[ServiceError["ErrorExceededSubscriptionCount"] = 103] = "ErrorExceededSubscriptionCount";
    /**
     * Subscription information is not available. Subscription is expired.
     */
    ServiceError[ServiceError["ErrorExpiredSubscription"] = 104] = "ErrorExpiredSubscription";
    /**
     * Extension with id specified was not found
     */
    ServiceError[ServiceError["ErrorExtensionNotFound"] = 105] = "ErrorExtensionNotFound";
    /**
     * The folder is corrupt.
     */
    ServiceError[ServiceError["ErrorFolderCorrupt"] = 106] = "ErrorFolderCorrupt";
    /**
     * A folder with the specified name already exists.
     */
    ServiceError[ServiceError["ErrorFolderExists"] = 107] = "ErrorFolderExists";
    /**
     * The specified folder could not be found in the store.
     */
    ServiceError[ServiceError["ErrorFolderNotFound"] = 108] = "ErrorFolderNotFound";
    /**
     * ErrorFolderPropertRequestFailed
     */
    ServiceError[ServiceError["ErrorFolderPropertRequestFailed"] = 109] = "ErrorFolderPropertRequestFailed";
    /**
     * The folder save operation did not succeed.
     */
    ServiceError[ServiceError["ErrorFolderSave"] = 110] = "ErrorFolderSave";
    /**
     * The save operation failed or partially succeeded.
     */
    ServiceError[ServiceError["ErrorFolderSaveFailed"] = 111] = "ErrorFolderSaveFailed";
    /**
     * The folder save operation failed due to invalid property values.
     */
    ServiceError[ServiceError["ErrorFolderSavePropertyError"] = 112] = "ErrorFolderSavePropertyError";
    /**
     * ErrorFreeBusyDLLimitReached
     */
    ServiceError[ServiceError["ErrorFreeBusyDLLimitReached"] = 113] = "ErrorFreeBusyDLLimitReached";
    /**
     * ErrorFreeBusyGenerationFailed
     */
    ServiceError[ServiceError["ErrorFreeBusyGenerationFailed"] = 114] = "ErrorFreeBusyGenerationFailed";
    /**
     * ErrorGetServerSecurityDescriptorFailed
     */
    ServiceError[ServiceError["ErrorGetServerSecurityDescriptorFailed"] = 115] = "ErrorGetServerSecurityDescriptorFailed";
    /**
     * ErrorImContactLimitReached
     */
    ServiceError[ServiceError["ErrorImContactLimitReached"] = 116] = "ErrorImContactLimitReached";
    /**
     * ErrorImGroupDisplayNameAlreadyExists
     */
    ServiceError[ServiceError["ErrorImGroupDisplayNameAlreadyExists"] = 117] = "ErrorImGroupDisplayNameAlreadyExists";
    /**
     * ErrorImGroupLimitReached
     */
    ServiceError[ServiceError["ErrorImGroupLimitReached"] = 118] = "ErrorImGroupLimitReached";
    /**
     * The account does not have permission to impersonate the requested user.
     */
    ServiceError[ServiceError["ErrorImpersonateUserDenied"] = 119] = "ErrorImpersonateUserDenied";
    /**
     * ErrorImpersonationDenied
     */
    ServiceError[ServiceError["ErrorImpersonationDenied"] = 120] = "ErrorImpersonationDenied";
    /**
     * Impersonation failed.
     */
    ServiceError[ServiceError["ErrorImpersonationFailed"] = 121] = "ErrorImpersonationFailed";
    /**
     * ErrorInboxRulesValidationError
     */
    ServiceError[ServiceError["ErrorInboxRulesValidationError"] = 122] = "ErrorInboxRulesValidationError";
    /**
     * The request is valid but does not specify the correct server version in the
     * RequestServerVersion SOAP header.  Ensure that the RequestServerVersion SOAP header is
     * set with the correct RequestServerVersionValue.
     */
    ServiceError[ServiceError["ErrorIncorrectSchemaVersion"] = 123] = "ErrorIncorrectSchemaVersion";
    /**
     * An object within a change description must contain one and only one property to modify.
     */
    ServiceError[ServiceError["ErrorIncorrectUpdatePropertyCount"] = 124] = "ErrorIncorrectUpdatePropertyCount";
    /**
     * ErrorIndividualMailboxLimitReached
     */
    ServiceError[ServiceError["ErrorIndividualMailboxLimitReached"] = 125] = "ErrorIndividualMailboxLimitReached";
    /**
     * Resources are unavailable. Try again later.
     */
    ServiceError[ServiceError["ErrorInsufficientResources"] = 126] = "ErrorInsufficientResources";
    /**
     * An internal server error occurred. The operation failed.
     */
    ServiceError[ServiceError["ErrorInternalServerError"] = 127] = "ErrorInternalServerError";
    /**
     * An internal server error occurred. Try again later.
     */
    ServiceError[ServiceError["ErrorInternalServerTransientError"] = 128] = "ErrorInternalServerTransientError";
    /**
     * ErrorInvalidAccessLevel
     */
    ServiceError[ServiceError["ErrorInvalidAccessLevel"] = 129] = "ErrorInvalidAccessLevel";
    /**
     * ErrorInvalidArgument
     */
    ServiceError[ServiceError["ErrorInvalidArgument"] = 130] = "ErrorInvalidArgument";
    /**
     * The specified attachment Id is invalid.
     */
    ServiceError[ServiceError["ErrorInvalidAttachmentId"] = 131] = "ErrorInvalidAttachmentId";
    /**
     * Attachment subfilters must have a single TextFilter therein.
     */
    ServiceError[ServiceError["ErrorInvalidAttachmentSubfilter"] = 132] = "ErrorInvalidAttachmentSubfilter";
    /**
     * Attachment subfilters must have a single TextFilter on the display name only.
     */
    ServiceError[ServiceError["ErrorInvalidAttachmentSubfilterTextFilter"] = 133] = "ErrorInvalidAttachmentSubfilterTextFilter";
    /**
     * ErrorInvalidAuthorizationContext
     */
    ServiceError[ServiceError["ErrorInvalidAuthorizationContext"] = 134] = "ErrorInvalidAuthorizationContext";
    /**
     * The change key is invalid.
     */
    ServiceError[ServiceError["ErrorInvalidChangeKey"] = 135] = "ErrorInvalidChangeKey";
    /**
     * ErrorInvalidClientSecurityContext
     */
    ServiceError[ServiceError["ErrorInvalidClientSecurityContext"] = 136] = "ErrorInvalidClientSecurityContext";
    /**
     * CompleteDate cannot be set to a date in the future.
     */
    ServiceError[ServiceError["ErrorInvalidCompleteDate"] = 137] = "ErrorInvalidCompleteDate";
    /**
     * The e-mail address that was supplied isn't valid.
     */
    ServiceError[ServiceError["ErrorInvalidContactEmailAddress"] = 138] = "ErrorInvalidContactEmailAddress";
    /**
     * The e-mail index supplied isn't valid.
     */
    ServiceError[ServiceError["ErrorInvalidContactEmailIndex"] = 139] = "ErrorInvalidContactEmailIndex";
    /**
     * ErrorInvalidCrossForestCredentials
     */
    ServiceError[ServiceError["ErrorInvalidCrossForestCredentials"] = 140] = "ErrorInvalidCrossForestCredentials";
    /**
     * Invalid Delegate Folder Permission.
     */
    ServiceError[ServiceError["ErrorInvalidDelegatePermission"] = 141] = "ErrorInvalidDelegatePermission";
    /**
     * One or more UserId parameters are invalid. Make sure that the PrimarySmtpAddress, Sid and
     * DisplayName properties refer to the same user when specified.
     */
    ServiceError[ServiceError["ErrorInvalidDelegateUserId"] = 142] = "ErrorInvalidDelegateUserId";
    /**
     * An ExchangeImpersonation SOAP header must contain a user principal name, user SID, or
     * primary SMTP address.
     */
    ServiceError[ServiceError["ErrorInvalidExchangeImpersonationHeaderData"] = 143] = "ErrorInvalidExchangeImpersonationHeaderData";
    /**
     * Second operand in Excludes expression must be uint compatible.
     */
    ServiceError[ServiceError["ErrorInvalidExcludesRestriction"] = 144] = "ErrorInvalidExcludesRestriction";
    /**
     * FieldURI can only be used in Contains expressions.
     */
    ServiceError[ServiceError["ErrorInvalidExpressionTypeForSubFilter"] = 145] = "ErrorInvalidExpressionTypeForSubFilter";
    /**
     * The extended property attribute combination is invalid.
     */
    ServiceError[ServiceError["ErrorInvalidExtendedProperty"] = 146] = "ErrorInvalidExtendedProperty";
    /**
     * The extended property value is inconsistent with its type.
     */
    ServiceError[ServiceError["ErrorInvalidExtendedPropertyValue"] = 147] = "ErrorInvalidExtendedPropertyValue";
    /**
     * The original sender of the message (initiator field in the sharing metadata) is not
     * valid.
     */
    ServiceError[ServiceError["ErrorInvalidExternalSharingInitiator"] = 148] = "ErrorInvalidExternalSharingInitiator";
    /**
     * The sharing message is not intended for this caller.
     */
    ServiceError[ServiceError["ErrorInvalidExternalSharingSubscriber"] = 149] = "ErrorInvalidExternalSharingSubscriber";
    /**
     * The organization is either not federated, or it's configured incorrectly.
     */
    ServiceError[ServiceError["ErrorInvalidFederatedOrganizationId"] = 150] = "ErrorInvalidFederatedOrganizationId";
    /**
     * Folder Id is invalid.
     */
    ServiceError[ServiceError["ErrorInvalidFolderId"] = 151] = "ErrorInvalidFolderId";
    /**
     * ErrorInvalidFolderTypeForOperation
     */
    ServiceError[ServiceError["ErrorInvalidFolderTypeForOperation"] = 152] = "ErrorInvalidFolderTypeForOperation";
    /**
     * Invalid fractional paging offset values.
     */
    ServiceError[ServiceError["ErrorInvalidFractionalPagingParameters"] = 153] = "ErrorInvalidFractionalPagingParameters";
    /**
     * ErrorInvalidFreeBusyViewType
     */
    ServiceError[ServiceError["ErrorInvalidFreeBusyViewType"] = 154] = "ErrorInvalidFreeBusyViewType";
    /**
     * Either DataType or SharedFolderId must be specified, but not both.
     */
    ServiceError[ServiceError["ErrorInvalidGetSharingFolderRequest"] = 155] = "ErrorInvalidGetSharingFolderRequest";
    /**
     * The Id is invalid.
     */
    ServiceError[ServiceError["ErrorInvalidId"] = 156] = "ErrorInvalidId";
    /**
     * The Im Contact id was invalid.
     */
    ServiceError[ServiceError["ErrorInvalidImContactId"] = 157] = "ErrorInvalidImContactId";
    /**
     * The Im Distribution Group Smtp Address was invalid.
     */
    ServiceError[ServiceError["ErrorInvalidImDistributionGroupSmtpAddress"] = 158] = "ErrorInvalidImDistributionGroupSmtpAddress";
    /**
     * The Im Contact id was invalid.
     */
    ServiceError[ServiceError["ErrorInvalidImGroupId"] = 159] = "ErrorInvalidImGroupId";
    /**
     * Id must be non-empty.
     */
    ServiceError[ServiceError["ErrorInvalidIdEmpty"] = 160] = "ErrorInvalidIdEmpty";
    /**
     * Id is malformed.
     */
    ServiceError[ServiceError["ErrorInvalidIdMalformed"] = 161] = "ErrorInvalidIdMalformed";
    /**
     * The EWS Id is in EwsLegacyId format which is not supported by the Exchange version
     * specified by your request. Please use the ConvertId method to convert from EwsLegacyId
     * to EwsId format.
     */
    ServiceError[ServiceError["ErrorInvalidIdMalformedEwsLegacyIdFormat"] = 162] = "ErrorInvalidIdMalformedEwsLegacyIdFormat";
    /**
     * Moniker exceeded allowable length.
     */
    ServiceError[ServiceError["ErrorInvalidIdMonikerTooLong"] = 163] = "ErrorInvalidIdMonikerTooLong";
    /**
     * The Id does not represent an item attachment.
     */
    ServiceError[ServiceError["ErrorInvalidIdNotAnItemAttachmentId"] = 164] = "ErrorInvalidIdNotAnItemAttachmentId";
    /**
     * ResolveNames returned an invalid Id.
     */
    ServiceError[ServiceError["ErrorInvalidIdReturnedByResolveNames"] = 165] = "ErrorInvalidIdReturnedByResolveNames";
    /**
     * Id exceeded allowable length.
     */
    ServiceError[ServiceError["ErrorInvalidIdStoreObjectIdTooLong"] = 166] = "ErrorInvalidIdStoreObjectIdTooLong";
    /**
     * Too many attachment levels.
     */
    ServiceError[ServiceError["ErrorInvalidIdTooManyAttachmentLevels"] = 167] = "ErrorInvalidIdTooManyAttachmentLevels";
    /**
     * The Id Xml is invalid.
     */
    ServiceError[ServiceError["ErrorInvalidIdXml"] = 168] = "ErrorInvalidIdXml";
    /**
     * The specified indexed paging values are invalid.
     */
    ServiceError[ServiceError["ErrorInvalidIndexedPagingParameters"] = 169] = "ErrorInvalidIndexedPagingParameters";
    /**
     * Only one child node is allowed when setting an Internet Message Header.
     */
    ServiceError[ServiceError["ErrorInvalidInternetHeaderChildNodes"] = 170] = "ErrorInvalidInternetHeaderChildNodes";
    /**
     * Item type is invalid for AcceptItem action.
     */
    ServiceError[ServiceError["ErrorInvalidItemForOperationAcceptItem"] = 171] = "ErrorInvalidItemForOperationAcceptItem";
    /**
     * Item type is invalid for ArchiveItem action.
     */
    ServiceError[ServiceError["ErrorInvalidItemForOperationArchiveItem"] = 172] = "ErrorInvalidItemForOperationArchiveItem";
    /**
     * Item type is invalid for CancelCalendarItem action.
     */
    ServiceError[ServiceError["ErrorInvalidItemForOperationCancelItem"] = 173] = "ErrorInvalidItemForOperationCancelItem";
    /**
     * Item type is invalid for CreateItem operation.
     */
    ServiceError[ServiceError["ErrorInvalidItemForOperationCreateItem"] = 174] = "ErrorInvalidItemForOperationCreateItem";
    /**
     * Item type is invalid for CreateItemAttachment operation.
     */
    ServiceError[ServiceError["ErrorInvalidItemForOperationCreateItemAttachment"] = 175] = "ErrorInvalidItemForOperationCreateItemAttachment";
    /**
     * Item type is invalid for DeclineItem operation.
     */
    ServiceError[ServiceError["ErrorInvalidItemForOperationDeclineItem"] = 176] = "ErrorInvalidItemForOperationDeclineItem";
    /**
     * ExpandDL operation does not support this item type.
     */
    ServiceError[ServiceError["ErrorInvalidItemForOperationExpandDL"] = 177] = "ErrorInvalidItemForOperationExpandDL";
    /**
     * Item type is invalid for RemoveItem operation.
     */
    ServiceError[ServiceError["ErrorInvalidItemForOperationRemoveItem"] = 178] = "ErrorInvalidItemForOperationRemoveItem";
    /**
     * Item type is invalid for SendItem operation.
     */
    ServiceError[ServiceError["ErrorInvalidItemForOperationSendItem"] = 179] = "ErrorInvalidItemForOperationSendItem";
    /**
     * The item of this type is invalid for TentativelyAcceptItem action.
     */
    ServiceError[ServiceError["ErrorInvalidItemForOperationTentative"] = 180] = "ErrorInvalidItemForOperationTentative";
    /**
     * The logon type isn't valid.
     */
    ServiceError[ServiceError["ErrorInvalidLogonType"] = 181] = "ErrorInvalidLogonType";
    /**
     * Mailbox is invalid. Verify the specified Mailbox property.
     */
    ServiceError[ServiceError["ErrorInvalidMailbox"] = 182] = "ErrorInvalidMailbox";
    /**
     * The Managed Folder property is corrupt or otherwise invalid.
     */
    ServiceError[ServiceError["ErrorInvalidManagedFolderProperty"] = 183] = "ErrorInvalidManagedFolderProperty";
    /**
     * The managed folder has an invalid quota.
     */
    ServiceError[ServiceError["ErrorInvalidManagedFolderQuota"] = 184] = "ErrorInvalidManagedFolderQuota";
    /**
     * The managed folder has an invalid storage limit value.
     */
    ServiceError[ServiceError["ErrorInvalidManagedFolderSize"] = 185] = "ErrorInvalidManagedFolderSize";
    /**
     * ErrorInvalidMergedFreeBusyInterval
     */
    ServiceError[ServiceError["ErrorInvalidMergedFreeBusyInterval"] = 186] = "ErrorInvalidMergedFreeBusyInterval";
    /**
     * The specified value is not a valid name for name resolution.
     */
    ServiceError[ServiceError["ErrorInvalidNameForNameResolution"] = 187] = "ErrorInvalidNameForNameResolution";
    /**
     * ErrorInvalidNetworkServiceContext
     */
    ServiceError[ServiceError["ErrorInvalidNetworkServiceContext"] = 188] = "ErrorInvalidNetworkServiceContext";
    /**
     * ErrorInvalidOofParameter
     */
    ServiceError[ServiceError["ErrorInvalidOofParameter"] = 189] = "ErrorInvalidOofParameter";
    /**
     * ErrorInvalidOperation
     */
    ServiceError[ServiceError["ErrorInvalidOperation"] = 190] = "ErrorInvalidOperation";
    /**
     * ErrorInvalidOrganizationRelationshipForFreeBusy
     */
    ServiceError[ServiceError["ErrorInvalidOrganizationRelationshipForFreeBusy"] = 191] = "ErrorInvalidOrganizationRelationshipForFreeBusy";
    /**
     * MaxEntriesReturned must be greater than zero.
     */
    ServiceError[ServiceError["ErrorInvalidPagingMaxRows"] = 192] = "ErrorInvalidPagingMaxRows";
    /**
     * Cannot create a subfolder within a SearchFolder.
     */
    ServiceError[ServiceError["ErrorInvalidParentFolder"] = 193] = "ErrorInvalidParentFolder";
    /**
     * PercentComplete must be an integer between 0 and 100.
     */
    ServiceError[ServiceError["ErrorInvalidPercentCompleteValue"] = 194] = "ErrorInvalidPercentCompleteValue";
    /**
     * The permission settings were not valid.
     */
    ServiceError[ServiceError["ErrorInvalidPermissionSettings"] = 195] = "ErrorInvalidPermissionSettings";
    /**
     * The phone call ID isn't valid.
     */
    ServiceError[ServiceError["ErrorInvalidPhoneCallId"] = 196] = "ErrorInvalidPhoneCallId";
    /**
     * The phone number isn't valid.
     */
    ServiceError[ServiceError["ErrorInvalidPhoneNumber"] = 197] = "ErrorInvalidPhoneNumber";
    /**
     * The append action is not supported for this property.
     */
    ServiceError[ServiceError["ErrorInvalidPropertyAppend"] = 198] = "ErrorInvalidPropertyAppend";
    /**
     * The delete action is not supported for this property.
     */
    ServiceError[ServiceError["ErrorInvalidPropertyDelete"] = 199] = "ErrorInvalidPropertyDelete";
    /**
     * Property cannot be used in Exists expression.  Use IsEqualTo instead.
     */
    ServiceError[ServiceError["ErrorInvalidPropertyForExists"] = 200] = "ErrorInvalidPropertyForExists";
    /**
     * Property is not valid for this operation.
     */
    ServiceError[ServiceError["ErrorInvalidPropertyForOperation"] = 201] = "ErrorInvalidPropertyForOperation";
    /**
     * Property is not valid for this object type.
     */
    ServiceError[ServiceError["ErrorInvalidPropertyRequest"] = 202] = "ErrorInvalidPropertyRequest";
    /**
     * Set action is invalid for property.
     */
    ServiceError[ServiceError["ErrorInvalidPropertySet"] = 203] = "ErrorInvalidPropertySet";
    /**
     * Update operation is invalid for property of a sent message.
     */
    ServiceError[ServiceError["ErrorInvalidPropertyUpdateSentMessage"] = 204] = "ErrorInvalidPropertyUpdateSentMessage";
    /**
     * The proxy security context is invalid.
     */
    ServiceError[ServiceError["ErrorInvalidProxySecurityContext"] = 205] = "ErrorInvalidProxySecurityContext";
    /**
     * SubscriptionId is invalid. Subscription is not a pull subscription.
     */
    ServiceError[ServiceError["ErrorInvalidPullSubscriptionId"] = 206] = "ErrorInvalidPullSubscriptionId";
    /**
     * URL specified for push subscription is invalid.
     */
    ServiceError[ServiceError["ErrorInvalidPushSubscriptionUrl"] = 207] = "ErrorInvalidPushSubscriptionUrl";
    /**
     * One or more recipients are invalid.
     */
    ServiceError[ServiceError["ErrorInvalidRecipients"] = 208] = "ErrorInvalidRecipients";
    /**
     * Recipient subfilters are only supported when there are two expressions within a single
     * AND filter.
     */
    ServiceError[ServiceError["ErrorInvalidRecipientSubfilter"] = 209] = "ErrorInvalidRecipientSubfilter";
    /**
     * Recipient subfilter must have a comparison filter that tests equality to recipient type
     * or attendee type.
     */
    ServiceError[ServiceError["ErrorInvalidRecipientSubfilterComparison"] = 210] = "ErrorInvalidRecipientSubfilterComparison";
    /**
     * Recipient subfilters must have a text filter and a comparison filter in that order.
     */
    ServiceError[ServiceError["ErrorInvalidRecipientSubfilterOrder"] = 211] = "ErrorInvalidRecipientSubfilterOrder";
    /**
     * Recipient subfilter must have a TextFilter on the SMTP address only.
     */
    ServiceError[ServiceError["ErrorInvalidRecipientSubfilterTextFilter"] = 212] = "ErrorInvalidRecipientSubfilterTextFilter";
    /**
     * The reference item does not support the requested operation.
     */
    ServiceError[ServiceError["ErrorInvalidReferenceItem"] = 213] = "ErrorInvalidReferenceItem";
    /**
     * The request is invalid.
     */
    ServiceError[ServiceError["ErrorInvalidRequest"] = 214] = "ErrorInvalidRequest";
    /**
     * The restriction is invalid.
     */
    ServiceError[ServiceError["ErrorInvalidRestriction"] = 215] = "ErrorInvalidRestriction";
    /**
     * ErrorInvalidRetentionIdTagTypeMismatch.
     */
    ServiceError[ServiceError["ErrorInvalidRetentionTagTypeMismatch"] = 216] = "ErrorInvalidRetentionTagTypeMismatch";
    /**
     * ErrorInvalidRetentionTagInvisible.
     */
    ServiceError[ServiceError["ErrorInvalidRetentionTagInvisible"] = 217] = "ErrorInvalidRetentionTagInvisible";
    /**
     * ErrorInvalidRetentionTagInheritance.
     */
    ServiceError[ServiceError["ErrorInvalidRetentionTagInheritance"] = 218] = "ErrorInvalidRetentionTagInheritance";
    /**
     * ErrorInvalidRetentionTagIdGuid.
     */
    ServiceError[ServiceError["ErrorInvalidRetentionTagIdGuid"] = 219] = "ErrorInvalidRetentionTagIdGuid";
    /**
     * The routing type format is invalid.
     */
    ServiceError[ServiceError["ErrorInvalidRoutingType"] = 220] = "ErrorInvalidRoutingType";
    /**
     * ErrorInvalidScheduledOofDuration
     */
    ServiceError[ServiceError["ErrorInvalidScheduledOofDuration"] = 221] = "ErrorInvalidScheduledOofDuration";
    /**
     * The mailbox that was requested doesn't support the specified RequestServerVersion.
     */
    ServiceError[ServiceError["ErrorInvalidSchemaVersionForMailboxVersion"] = 222] = "ErrorInvalidSchemaVersionForMailboxVersion";
    /**
     * ErrorInvalidSecurityDescriptor
     */
    ServiceError[ServiceError["ErrorInvalidSecurityDescriptor"] = 223] = "ErrorInvalidSecurityDescriptor";
    /**
     * Invalid combination of SaveItemToFolder attribute and SavedItemFolderId element.
     */
    ServiceError[ServiceError["ErrorInvalidSendItemSaveSettings"] = 224] = "ErrorInvalidSendItemSaveSettings";
    /**
     * Invalid serialized access token.
     */
    ServiceError[ServiceError["ErrorInvalidSerializedAccessToken"] = 225] = "ErrorInvalidSerializedAccessToken";
    /**
     * The specified server version is invalid.
     */
    ServiceError[ServiceError["ErrorInvalidServerVersion"] = 226] = "ErrorInvalidServerVersion";
    /**
     * The sharing message metadata is not valid.
     */
    ServiceError[ServiceError["ErrorInvalidSharingData"] = 227] = "ErrorInvalidSharingData";
    /**
     * The sharing message is not valid.
     */
    ServiceError[ServiceError["ErrorInvalidSharingMessage"] = 228] = "ErrorInvalidSharingMessage";
    /**
     * A SID with an invalid format was encountered.
     */
    ServiceError[ServiceError["ErrorInvalidSid"] = 229] = "ErrorInvalidSid";
    /**
     * The SIP address isn't valid.
     */
    ServiceError[ServiceError["ErrorInvalidSIPUri"] = 230] = "ErrorInvalidSIPUri";
    /**
     * The SMTP address format is invalid.
     */
    ServiceError[ServiceError["ErrorInvalidSmtpAddress"] = 231] = "ErrorInvalidSmtpAddress";
    /**
     * Invalid subFilterType.
     */
    ServiceError[ServiceError["ErrorInvalidSubfilterType"] = 232] = "ErrorInvalidSubfilterType";
    /**
     * SubFilterType is not attendee type.
     */
    ServiceError[ServiceError["ErrorInvalidSubfilterTypeNotAttendeeType"] = 233] = "ErrorInvalidSubfilterTypeNotAttendeeType";
    /**
     * SubFilterType is not recipient type.
     */
    ServiceError[ServiceError["ErrorInvalidSubfilterTypeNotRecipientType"] = 234] = "ErrorInvalidSubfilterTypeNotRecipientType";
    /**
     * Subscription is invalid.
     */
    ServiceError[ServiceError["ErrorInvalidSubscription"] = 235] = "ErrorInvalidSubscription";
    /**
     * A subscription can only be established on a single public folder or on folders from a
     * single mailbox.
     */
    ServiceError[ServiceError["ErrorInvalidSubscriptionRequest"] = 236] = "ErrorInvalidSubscriptionRequest";
    /**
     * Synchronization state data is corrupt or otherwise invalid.
     */
    ServiceError[ServiceError["ErrorInvalidSyncStateData"] = 237] = "ErrorInvalidSyncStateData";
    /**
     * ErrorInvalidTimeInterval
     */
    ServiceError[ServiceError["ErrorInvalidTimeInterval"] = 238] = "ErrorInvalidTimeInterval";
    /**
     * A UserId was not valid.
     */
    ServiceError[ServiceError["ErrorInvalidUserInfo"] = 239] = "ErrorInvalidUserInfo";
    /**
     * ErrorInvalidUserOofSettings
     */
    ServiceError[ServiceError["ErrorInvalidUserOofSettings"] = 240] = "ErrorInvalidUserOofSettings";
    /**
     * The impersonation principal name is invalid.
     */
    ServiceError[ServiceError["ErrorInvalidUserPrincipalName"] = 241] = "ErrorInvalidUserPrincipalName";
    /**
     * The user SID is invalid or does not map to a user in the Active Directory.
     */
    ServiceError[ServiceError["ErrorInvalidUserSid"] = 242] = "ErrorInvalidUserSid";
    /**
     * ErrorInvalidUserSidMissingUPN
     */
    ServiceError[ServiceError["ErrorInvalidUserSidMissingUPN"] = 243] = "ErrorInvalidUserSidMissingUPN";
    /**
     * The specified value is invalid for property.
     */
    ServiceError[ServiceError["ErrorInvalidValueForProperty"] = 244] = "ErrorInvalidValueForProperty";
    /**
     * The watermark is invalid.
     */
    ServiceError[ServiceError["ErrorInvalidWatermark"] = 245] = "ErrorInvalidWatermark";
    /**
     * A valid IP gateway couldn't be found.
     */
    ServiceError[ServiceError["ErrorIPGatewayNotFound"] = 246] = "ErrorIPGatewayNotFound";
    /**
     * The send or update operation could not be performed because the change key passed in the
     * request does not match the current change key for the item.
     */
    ServiceError[ServiceError["ErrorIrresolvableConflict"] = 247] = "ErrorIrresolvableConflict";
    /**
     * The item is corrupt.
     */
    ServiceError[ServiceError["ErrorItemCorrupt"] = 248] = "ErrorItemCorrupt";
    /**
     * The specified object was not found in the store.
     */
    ServiceError[ServiceError["ErrorItemNotFound"] = 249] = "ErrorItemNotFound";
    /**
     * One or more of the properties requested for this item could not be retrieved.
     */
    ServiceError[ServiceError["ErrorItemPropertyRequestFailed"] = 250] = "ErrorItemPropertyRequestFailed";
    /**
     * The item save operation did not succeed.
     */
    ServiceError[ServiceError["ErrorItemSave"] = 251] = "ErrorItemSave";
    /**
     * Item save operation did not succeed.
     */
    ServiceError[ServiceError["ErrorItemSavePropertyError"] = 252] = "ErrorItemSavePropertyError";
    /**
     * ErrorLegacyMailboxFreeBusyViewTypeNotMerged
     */
    ServiceError[ServiceError["ErrorLegacyMailboxFreeBusyViewTypeNotMerged"] = 253] = "ErrorLegacyMailboxFreeBusyViewTypeNotMerged";
    /**
     * ErrorLocalServerObjectNotFound
     */
    ServiceError[ServiceError["ErrorLocalServerObjectNotFound"] = 254] = "ErrorLocalServerObjectNotFound";
    /**
     * ErrorLogonAsNetworkServiceFailed
     */
    ServiceError[ServiceError["ErrorLogonAsNetworkServiceFailed"] = 255] = "ErrorLogonAsNetworkServiceFailed";
    /**
     * Unable to access an account or mailbox.
     */
    ServiceError[ServiceError["ErrorMailboxConfiguration"] = 256] = "ErrorMailboxConfiguration";
    /**
     * ErrorMailboxDataArrayEmpty
     */
    ServiceError[ServiceError["ErrorMailboxDataArrayEmpty"] = 257] = "ErrorMailboxDataArrayEmpty";
    /**
     * ErrorMailboxDataArrayTooBig
     */
    ServiceError[ServiceError["ErrorMailboxDataArrayTooBig"] = 258] = "ErrorMailboxDataArrayTooBig";
    /**
     * ErrorMailboxFailover
     */
    ServiceError[ServiceError["ErrorMailboxFailover"] = 259] = "ErrorMailboxFailover";
    /**
     * The specific mailbox hold is not found.
     */
    ServiceError[ServiceError["ErrorMailboxHoldNotFound"] = 260] = "ErrorMailboxHoldNotFound";
    /**
     * ErrorMailboxLogonFailed
     */
    ServiceError[ServiceError["ErrorMailboxLogonFailed"] = 261] = "ErrorMailboxLogonFailed";
    /**
     * Mailbox move in progress. Try again later.
     */
    ServiceError[ServiceError["ErrorMailboxMoveInProgress"] = 262] = "ErrorMailboxMoveInProgress";
    /**
     * The mailbox database is temporarily unavailable.
     */
    ServiceError[ServiceError["ErrorMailboxStoreUnavailable"] = 263] = "ErrorMailboxStoreUnavailable";
    /**
     * ErrorMailRecipientNotFound
     */
    ServiceError[ServiceError["ErrorMailRecipientNotFound"] = 264] = "ErrorMailRecipientNotFound";
    /**
     * MailTips aren't available for your organization.
     */
    ServiceError[ServiceError["ErrorMailTipsDisabled"] = 265] = "ErrorMailTipsDisabled";
    /**
     * The specified Managed Folder already exists in the mailbox.
     */
    ServiceError[ServiceError["ErrorManagedFolderAlreadyExists"] = 266] = "ErrorManagedFolderAlreadyExists";
    /**
     * Unable to find the specified managed folder in the Active Directory.
     */
    ServiceError[ServiceError["ErrorManagedFolderNotFound"] = 267] = "ErrorManagedFolderNotFound";
    /**
     * Failed to create or bind to the folder: Managed Folders
     */
    ServiceError[ServiceError["ErrorManagedFoldersRootFailure"] = 268] = "ErrorManagedFoldersRootFailure";
    /**
     * ErrorMeetingSuggestionGenerationFailed
     */
    ServiceError[ServiceError["ErrorMeetingSuggestionGenerationFailed"] = 269] = "ErrorMeetingSuggestionGenerationFailed";
    /**
     * MessageDisposition attribute is required.
     */
    ServiceError[ServiceError["ErrorMessageDispositionRequired"] = 270] = "ErrorMessageDispositionRequired";
    /**
     * The message exceeds the maximum supported size.
     */
    ServiceError[ServiceError["ErrorMessageSizeExceeded"] = 271] = "ErrorMessageSizeExceeded";
    /**
     * The domain specified in the tracking request doesn't exist.
     */
    ServiceError[ServiceError["ErrorMessageTrackingNoSuchDomain"] = 272] = "ErrorMessageTrackingNoSuchDomain";
    /**
     * The log search service can't track this message.
     */
    ServiceError[ServiceError["ErrorMessageTrackingPermanentError"] = 273] = "ErrorMessageTrackingPermanentError";
    /**
     * The log search service isn't currently available. Please try again later.
     */
    ServiceError[ServiceError["ErrorMessageTrackingTransientError"] = 274] = "ErrorMessageTrackingTransientError";
    /**
     * MIME content conversion failed.
     */
    ServiceError[ServiceError["ErrorMimeContentConversionFailed"] = 275] = "ErrorMimeContentConversionFailed";
    /**
     * Invalid MIME content.
     */
    ServiceError[ServiceError["ErrorMimeContentInvalid"] = 276] = "ErrorMimeContentInvalid";
    /**
     * Invalid base64 string for MIME content.
     */
    ServiceError[ServiceError["ErrorMimeContentInvalidBase64String"] = 277] = "ErrorMimeContentInvalidBase64String";
    /**
     * The subscription has missed events, but will continue service on this connection.
     */
    ServiceError[ServiceError["ErrorMissedNotificationEvents"] = 278] = "ErrorMissedNotificationEvents";
    /**
     * ErrorMissingArgument
     */
    ServiceError[ServiceError["ErrorMissingArgument"] = 279] = "ErrorMissingArgument";
    /**
     * When making a request as an account that does not have a mailbox, you must specify the
     * mailbox primary SMTP address for any distinguished folder Ids.
     */
    ServiceError[ServiceError["ErrorMissingEmailAddress"] = 280] = "ErrorMissingEmailAddress";
    /**
     * When making a request with an account that does not have a mailbox, you must specify the
     * primary SMTP address for an existing mailbox.
     */
    ServiceError[ServiceError["ErrorMissingEmailAddressForManagedFolder"] = 281] = "ErrorMissingEmailAddressForManagedFolder";
    /**
     * EmailAddress or ItemId must be included in the request.
     */
    ServiceError[ServiceError["ErrorMissingInformationEmailAddress"] = 282] = "ErrorMissingInformationEmailAddress";
    /**
     * ReferenceItemId must be included in the request.
     */
    ServiceError[ServiceError["ErrorMissingInformationReferenceItemId"] = 283] = "ErrorMissingInformationReferenceItemId";
    /**
     * SharingFolderId must be included in the request.
     */
    ServiceError[ServiceError["ErrorMissingInformationSharingFolderId"] = 284] = "ErrorMissingInformationSharingFolderId";
    /**
     * An item must be specified when creating an item attachment.
     */
    ServiceError[ServiceError["ErrorMissingItemForCreateItemAttachment"] = 285] = "ErrorMissingItemForCreateItemAttachment";
    /**
     * The managed folder Id is missing.
     */
    ServiceError[ServiceError["ErrorMissingManagedFolderId"] = 286] = "ErrorMissingManagedFolderId";
    /**
     * A message needs to have at least one recipient.
     */
    ServiceError[ServiceError["ErrorMissingRecipients"] = 287] = "ErrorMissingRecipients";
    /**
     * Missing information for delegate user. You must either specify a valid SMTP address or
     * SID.
     */
    ServiceError[ServiceError["ErrorMissingUserIdInformation"] = 288] = "ErrorMissingUserIdInformation";
    /**
     * Only one access mode header may be specified.
     */
    ServiceError[ServiceError["ErrorMoreThanOneAccessModeSpecified"] = 289] = "ErrorMoreThanOneAccessModeSpecified";
    /**
     * The move or copy operation failed.
     */
    ServiceError[ServiceError["ErrorMoveCopyFailed"] = 290] = "ErrorMoveCopyFailed";
    /**
     * Cannot move distinguished folder.
     */
    ServiceError[ServiceError["ErrorMoveDistinguishedFolder"] = 291] = "ErrorMoveDistinguishedFolder";
    /**
     * ErrorMultiLegacyMailboxAccess
     */
    ServiceError[ServiceError["ErrorMultiLegacyMailboxAccess"] = 292] = "ErrorMultiLegacyMailboxAccess";
    /**
     * Multiple results were found.
     */
    ServiceError[ServiceError["ErrorNameResolutionMultipleResults"] = 293] = "ErrorNameResolutionMultipleResults";
    /**
     * User must have a mailbox for name resolution operations.
     */
    ServiceError[ServiceError["ErrorNameResolutionNoMailbox"] = 294] = "ErrorNameResolutionNoMailbox";
    /**
     * No results were found.
     */
    ServiceError[ServiceError["ErrorNameResolutionNoResults"] = 295] = "ErrorNameResolutionNoResults";
    /**
     * Another connection was opened against this subscription.
     */
    ServiceError[ServiceError["ErrorNewEventStreamConnectionOpened"] = 296] = "ErrorNewEventStreamConnectionOpened";
    /**
     * Exchange Web Services are not currently available for this request because there are no
     * available Client Access Services Servers in the target AD Site.
     */
    ServiceError[ServiceError["ErrorNoApplicableProxyCASServersAvailable"] = 297] = "ErrorNoApplicableProxyCASServersAvailable";
    /**
     * ErrorNoCalendar
     */
    ServiceError[ServiceError["ErrorNoCalendar"] = 298] = "ErrorNoCalendar";
    /**
     * Exchange Web Services aren't available for this request because there is no Client Access
     * server with the necessary configuration in the Active Directory site where the mailbox is
     * stored. If the problem continues, click Help.
     */
    ServiceError[ServiceError["ErrorNoDestinationCASDueToKerberosRequirements"] = 299] = "ErrorNoDestinationCASDueToKerberosRequirements";
    /**
     * Exchange Web Services aren't currently available for this request because an SSL
     * connection couldn't be established to the Client Access server that should be used for
     * mailbox access. If the problem continues, click Help.
     */
    ServiceError[ServiceError["ErrorNoDestinationCASDueToSSLRequirements"] = 300] = "ErrorNoDestinationCASDueToSSLRequirements";
    /**
     * Exchange Web Services aren't currently available for this request because the Client
     * Access server used for proxying has an older version of Exchange installed than the
     * Client Access server in the mailbox Active Directory site.
     */
    ServiceError[ServiceError["ErrorNoDestinationCASDueToVersionMismatch"] = 301] = "ErrorNoDestinationCASDueToVersionMismatch";
    /**
     * You cannot specify the FolderClass when creating a non-generic folder.
     */
    ServiceError[ServiceError["ErrorNoFolderClassOverride"] = 302] = "ErrorNoFolderClassOverride";
    /**
     * ErrorNoFreeBusyAccess
     */
    ServiceError[ServiceError["ErrorNoFreeBusyAccess"] = 303] = "ErrorNoFreeBusyAccess";
    /**
     * Mailbox does not exist.
     */
    ServiceError[ServiceError["ErrorNonExistentMailbox"] = 304] = "ErrorNonExistentMailbox";
    /**
     * The primary SMTP address must be specified when referencing a mailbox.
     */
    ServiceError[ServiceError["ErrorNonPrimarySmtpAddress"] = 305] = "ErrorNonPrimarySmtpAddress";
    /**
     * Custom properties cannot be specified using property tags.  The GUID and Id/Name
     * combination must be used instead.
     */
    ServiceError[ServiceError["ErrorNoPropertyTagForCustomProperties"] = 306] = "ErrorNoPropertyTagForCustomProperties";
    /**
     * ErrorNoPublicFolderReplicaAvailable
     */
    ServiceError[ServiceError["ErrorNoPublicFolderReplicaAvailable"] = 307] = "ErrorNoPublicFolderReplicaAvailable";
    /**
     * There are no public folder servers available.
     */
    ServiceError[ServiceError["ErrorNoPublicFolderServerAvailable"] = 308] = "ErrorNoPublicFolderServerAvailable";
    /**
     * Exchange Web Services are not currently available for this request because none of the
     * Client Access Servers in the destination site could process the request.
     */
    ServiceError[ServiceError["ErrorNoRespondingCASInDestinationSite"] = 309] = "ErrorNoRespondingCASInDestinationSite";
    /**
     * Policy does not allow granting of permissions to external users.
     */
    ServiceError[ServiceError["ErrorNotAllowedExternalSharingByPolicy"] = 310] = "ErrorNotAllowedExternalSharingByPolicy";
    /**
     * The user is not a delegate for the mailbox.
     */
    ServiceError[ServiceError["ErrorNotDelegate"] = 311] = "ErrorNotDelegate";
    /**
     * There was not enough memory to complete the request.
     */
    ServiceError[ServiceError["ErrorNotEnoughMemory"] = 312] = "ErrorNotEnoughMemory";
    /**
     * The sharing message is not supported.
     */
    ServiceError[ServiceError["ErrorNotSupportedSharingMessage"] = 313] = "ErrorNotSupportedSharingMessage";
    /**
     * Operation would change object type, which is not permitted.
     */
    ServiceError[ServiceError["ErrorObjectTypeChanged"] = 314] = "ErrorObjectTypeChanged";
    /**
     * Modified occurrence is crossing or overlapping adjacent occurrence.
     */
    ServiceError[ServiceError["ErrorOccurrenceCrossingBoundary"] = 315] = "ErrorOccurrenceCrossingBoundary";
    /**
     * One occurrence of the recurring calendar item overlaps with another occurrence of the
     * same calendar item.
     */
    ServiceError[ServiceError["ErrorOccurrenceTimeSpanTooBig"] = 316] = "ErrorOccurrenceTimeSpanTooBig";
    /**
     * Operation not allowed with public folder root.
     */
    ServiceError[ServiceError["ErrorOperationNotAllowedWithPublicFolderRoot"] = 317] = "ErrorOperationNotAllowedWithPublicFolderRoot";
    /**
     * Organization is not federated.
     */
    ServiceError[ServiceError["ErrorOrganizationNotFederated"] = 318] = "ErrorOrganizationNotFederated";
    /**
     * ErrorOutlookRuleBlobExists
     */
    ServiceError[ServiceError["ErrorOutlookRuleBlobExists"] = 319] = "ErrorOutlookRuleBlobExists";
    /**
     * You must specify the parent folder Id for this operation.
     */
    ServiceError[ServiceError["ErrorParentFolderIdRequired"] = 320] = "ErrorParentFolderIdRequired";
    /**
     * The specified parent folder could not be found.
     */
    ServiceError[ServiceError["ErrorParentFolderNotFound"] = 321] = "ErrorParentFolderNotFound";
    /**
     * Password change is required.
     */
    ServiceError[ServiceError["ErrorPasswordChangeRequired"] = 322] = "ErrorPasswordChangeRequired";
    /**
     * Password has expired. Change password.
     */
    ServiceError[ServiceError["ErrorPasswordExpired"] = 323] = "ErrorPasswordExpired";
    /**
     * Policy does not allow granting permission level to user.
     */
    ServiceError[ServiceError["ErrorPermissionNotAllowedByPolicy"] = 324] = "ErrorPermissionNotAllowedByPolicy";
    /**
     * Dialing restrictions are preventing the phone number that was entered from being dialed.
     */
    ServiceError[ServiceError["ErrorPhoneNumberNotDialable"] = 325] = "ErrorPhoneNumberNotDialable";
    /**
     * Property update did not succeed.
     */
    ServiceError[ServiceError["ErrorPropertyUpdate"] = 326] = "ErrorPropertyUpdate";
    /**
     * At least one property failed validation.
     */
    ServiceError[ServiceError["ErrorPropertyValidationFailure"] = 327] = "ErrorPropertyValidationFailure";
    /**
     * Subscription related request failed because EWS could not contact the appropriate CAS
     * server for this request.  If this problem persists, recreate the subscription.
     */
    ServiceError[ServiceError["ErrorProxiedSubscriptionCallFailure"] = 328] = "ErrorProxiedSubscriptionCallFailure";
    /**
     * Request failed because EWS could not contact the appropriate CAS server for this request.
     */
    ServiceError[ServiceError["ErrorProxyCallFailed"] = 329] = "ErrorProxyCallFailed";
    /**
     * Exchange Web Services (EWS) is not available for this mailbox because the user account
     * associated with the mailbox is a member of too many groups. EWS limits the group
     * membership it can proxy between Client Access Service Servers to 3000.
     */
    ServiceError[ServiceError["ErrorProxyGroupSidLimitExceeded"] = 330] = "ErrorProxyGroupSidLimitExceeded";
    /**
     * ErrorProxyRequestNotAllowed
     */
    ServiceError[ServiceError["ErrorProxyRequestNotAllowed"] = 331] = "ErrorProxyRequestNotAllowed";
    /**
     * ErrorProxyRequestProcessingFailed
     */
    ServiceError[ServiceError["ErrorProxyRequestProcessingFailed"] = 332] = "ErrorProxyRequestProcessingFailed";
    /**
     * Exchange Web Services are not currently available for this mailbox because it could not
     * determine the Client Access Services Server to use for the mailbox.
     */
    ServiceError[ServiceError["ErrorProxyServiceDiscoveryFailed"] = 333] = "ErrorProxyServiceDiscoveryFailed";
    /**
     * Proxy token has expired.
     */
    ServiceError[ServiceError["ErrorProxyTokenExpired"] = 334] = "ErrorProxyTokenExpired";
    /**
     * ErrorPublicFolderRequestProcessingFailed
     */
    ServiceError[ServiceError["ErrorPublicFolderRequestProcessingFailed"] = 335] = "ErrorPublicFolderRequestProcessingFailed";
    /**
     * ErrorPublicFolderServerNotFound
     */
    ServiceError[ServiceError["ErrorPublicFolderServerNotFound"] = 336] = "ErrorPublicFolderServerNotFound";
    /**
     * The search folder has a restriction that is too long to return.
     */
    ServiceError[ServiceError["ErrorQueryFilterTooLong"] = 337] = "ErrorQueryFilterTooLong";
    /**
     * Mailbox has exceeded maximum mailbox size.
     */
    ServiceError[ServiceError["ErrorQuotaExceeded"] = 338] = "ErrorQuotaExceeded";
    /**
     * Unable to retrieve events for this subscription.  The subscription must be recreated.
     */
    ServiceError[ServiceError["ErrorReadEventsFailed"] = 339] = "ErrorReadEventsFailed";
    /**
     * Unable to suppress read receipt. Read receipts are not pending.
     */
    ServiceError[ServiceError["ErrorReadReceiptNotPending"] = 340] = "ErrorReadReceiptNotPending";
    /**
     * Recurrence end date can not exceed Sep 1, 4500 00:00:00.
     */
    ServiceError[ServiceError["ErrorRecurrenceEndDateTooBig"] = 341] = "ErrorRecurrenceEndDateTooBig";
    /**
     * Recurrence has no occurrences in the specified range.
     */
    ServiceError[ServiceError["ErrorRecurrenceHasNoOccurrence"] = 342] = "ErrorRecurrenceHasNoOccurrence";
    /**
     * Failed to remove one or more delegates.
     */
    ServiceError[ServiceError["ErrorRemoveDelegatesFailed"] = 343] = "ErrorRemoveDelegatesFailed";
    /**
     * ErrorRequestAborted
     */
    ServiceError[ServiceError["ErrorRequestAborted"] = 344] = "ErrorRequestAborted";
    /**
     * ErrorRequestStreamTooBig
     */
    ServiceError[ServiceError["ErrorRequestStreamTooBig"] = 345] = "ErrorRequestStreamTooBig";
    /**
     * Required property is missing.
     */
    ServiceError[ServiceError["ErrorRequiredPropertyMissing"] = 346] = "ErrorRequiredPropertyMissing";
    /**
     * Cannot perform ResolveNames for non-contact folder.
     */
    ServiceError[ServiceError["ErrorResolveNamesInvalidFolderType"] = 347] = "ErrorResolveNamesInvalidFolderType";
    /**
     * Only one contacts folder can be specified in request.
     */
    ServiceError[ServiceError["ErrorResolveNamesOnlyOneContactsFolderAllowed"] = 348] = "ErrorResolveNamesOnlyOneContactsFolderAllowed";
    /**
     * The response failed schema validation.
     */
    ServiceError[ServiceError["ErrorResponseSchemaValidation"] = 349] = "ErrorResponseSchemaValidation";
    /**
     * The restriction or sort order is too complex for this operation.
     */
    ServiceError[ServiceError["ErrorRestrictionTooComplex"] = 350] = "ErrorRestrictionTooComplex";
    /**
     * Restriction contained too many elements.
     */
    ServiceError[ServiceError["ErrorRestrictionTooLong"] = 351] = "ErrorRestrictionTooLong";
    /**
     * ErrorResultSetTooBig
     */
    ServiceError[ServiceError["ErrorResultSetTooBig"] = 352] = "ErrorResultSetTooBig";
    /**
     * ErrorRulesOverQuota
     */
    ServiceError[ServiceError["ErrorRulesOverQuota"] = 353] = "ErrorRulesOverQuota";
    /**
     * The folder in which items were to be saved could not be found.
     */
    ServiceError[ServiceError["ErrorSavedItemFolderNotFound"] = 354] = "ErrorSavedItemFolderNotFound";
    /**
     * The request failed schema validation.
     */
    ServiceError[ServiceError["ErrorSchemaValidation"] = 355] = "ErrorSchemaValidation";
    /**
     * The search folder is not initialized.
     */
    ServiceError[ServiceError["ErrorSearchFolderNotInitialized"] = 356] = "ErrorSearchFolderNotInitialized";
    /**
     * The user account which was used to submit this request does not have the right to send
     * mail on behalf of the specified sending account.
     */
    ServiceError[ServiceError["ErrorSendAsDenied"] = 357] = "ErrorSendAsDenied";
    /**
     * SendMeetingCancellations attribute is required for Calendar items.
     */
    ServiceError[ServiceError["ErrorSendMeetingCancellationsRequired"] = 358] = "ErrorSendMeetingCancellationsRequired";
    /**
     * The SendMeetingInvitationsOrCancellations attribute is required for calendar items.
     */
    ServiceError[ServiceError["ErrorSendMeetingInvitationsOrCancellationsRequired"] = 359] = "ErrorSendMeetingInvitationsOrCancellationsRequired";
    /**
     * The SendMeetingInvitations attribute is required for calendar items.
     */
    ServiceError[ServiceError["ErrorSendMeetingInvitationsRequired"] = 360] = "ErrorSendMeetingInvitationsRequired";
    /**
     * The meeting request has already been sent and might not be updated.
     */
    ServiceError[ServiceError["ErrorSentMeetingRequestUpdate"] = 361] = "ErrorSentMeetingRequestUpdate";
    /**
     * The task request has already been sent and may not be updated.
     */
    ServiceError[ServiceError["ErrorSentTaskRequestUpdate"] = 362] = "ErrorSentTaskRequestUpdate";
    /**
     * The server cannot service this request right now. Try again later.
     */
    ServiceError[ServiceError["ErrorServerBusy"] = 363] = "ErrorServerBusy";
    /**
     * ErrorServiceDiscoveryFailed
     */
    ServiceError[ServiceError["ErrorServiceDiscoveryFailed"] = 364] = "ErrorServiceDiscoveryFailed";
    /**
     * No external Exchange Web Service URL available.
     */
    ServiceError[ServiceError["ErrorSharingNoExternalEwsAvailable"] = 365] = "ErrorSharingNoExternalEwsAvailable";
    /**
     * Failed to synchronize the sharing folder.
     */
    ServiceError[ServiceError["ErrorSharingSynchronizationFailed"] = 366] = "ErrorSharingSynchronizationFailed";
    /**
     * The current ChangeKey is required for this operation.
     */
    ServiceError[ServiceError["ErrorStaleObject"] = 367] = "ErrorStaleObject";
    /**
     * The message couldn't be sent because the sender's submission quota was exceeded. Please
     * try again later.
     */
    ServiceError[ServiceError["ErrorSubmissionQuotaExceeded"] = 368] = "ErrorSubmissionQuotaExceeded";
    /**
     * Access is denied. Only the subscription owner may access the subscription.
     */
    ServiceError[ServiceError["ErrorSubscriptionAccessDenied"] = 369] = "ErrorSubscriptionAccessDenied";
    /**
     * Subscriptions are not supported for delegate user access.
     */
    ServiceError[ServiceError["ErrorSubscriptionDelegateAccessNotSupported"] = 370] = "ErrorSubscriptionDelegateAccessNotSupported";
    /**
     * The specified subscription was not found.
     */
    ServiceError[ServiceError["ErrorSubscriptionNotFound"] = 371] = "ErrorSubscriptionNotFound";
    /**
     * The StreamingSubscription was unsubscribed while the current connection was servicing it.
     */
    ServiceError[ServiceError["ErrorSubscriptionUnsubscribed"] = 372] = "ErrorSubscriptionUnsubscribed";
    /**
     * The folder to be synchronized could not be found.
     */
    ServiceError[ServiceError["ErrorSyncFolderNotFound"] = 373] = "ErrorSyncFolderNotFound";
    /**
     * ErrorTeamMailboxNotFound
     */
    ServiceError[ServiceError["ErrorTeamMailboxNotFound"] = 374] = "ErrorTeamMailboxNotFound";
    /**
     * ErrorTeamMailboxNotLinkedToSharePoint
     */
    ServiceError[ServiceError["ErrorTeamMailboxNotLinkedToSharePoint"] = 375] = "ErrorTeamMailboxNotLinkedToSharePoint";
    /**
     * ErrorTeamMailboxUrlValidationFailed
     */
    ServiceError[ServiceError["ErrorTeamMailboxUrlValidationFailed"] = 376] = "ErrorTeamMailboxUrlValidationFailed";
    /**
     * ErrorTeamMailboxNotAuthorizedOwner
     */
    ServiceError[ServiceError["ErrorTeamMailboxNotAuthorizedOwner"] = 377] = "ErrorTeamMailboxNotAuthorizedOwner";
    /**
     * ErrorTeamMailboxActiveToPendingDelete
     */
    ServiceError[ServiceError["ErrorTeamMailboxActiveToPendingDelete"] = 378] = "ErrorTeamMailboxActiveToPendingDelete";
    /**
     * ErrorTeamMailboxFailedSendingNotifications
     */
    ServiceError[ServiceError["ErrorTeamMailboxFailedSendingNotifications"] = 379] = "ErrorTeamMailboxFailedSendingNotifications";
    /**
     * ErrorTeamMailboxErrorUnknown
     */
    ServiceError[ServiceError["ErrorTeamMailboxErrorUnknown"] = 380] = "ErrorTeamMailboxErrorUnknown";
    /**
     * ErrorTimeIntervalTooBig
     */
    ServiceError[ServiceError["ErrorTimeIntervalTooBig"] = 381] = "ErrorTimeIntervalTooBig";
    /**
     * ErrorTimeoutExpired
     */
    ServiceError[ServiceError["ErrorTimeoutExpired"] = 382] = "ErrorTimeoutExpired";
    /**
     * The time zone isn't valid.
     */
    ServiceError[ServiceError["ErrorTimeZone"] = 383] = "ErrorTimeZone";
    /**
     * The specified target folder could not be found.
     */
    ServiceError[ServiceError["ErrorToFolderNotFound"] = 384] = "ErrorToFolderNotFound";
    /**
     * The requesting account does not have permission to serialize tokens.
     */
    ServiceError[ServiceError["ErrorTokenSerializationDenied"] = 385] = "ErrorTokenSerializationDenied";
    /**
     * ErrorUnableToGetUserOofSettings
     */
    ServiceError[ServiceError["ErrorUnableToGetUserOofSettings"] = 386] = "ErrorUnableToGetUserOofSettings";
    /**
     * ErrorUnableToRemoveImContactFromGroup
     */
    ServiceError[ServiceError["ErrorUnableToRemoveImContactFromGroup"] = 387] = "ErrorUnableToRemoveImContactFromGroup";
    /**
     * A dial plan could not be found.
     */
    ServiceError[ServiceError["ErrorUnifiedMessagingDialPlanNotFound"] = 388] = "ErrorUnifiedMessagingDialPlanNotFound";
    /**
     * The UnifiedMessaging request failed.
     */
    ServiceError[ServiceError["ErrorUnifiedMessagingRequestFailed"] = 389] = "ErrorUnifiedMessagingRequestFailed";
    /**
     * A connection couldn't be made to the Unified Messaging server.
     */
    ServiceError[ServiceError["ErrorUnifiedMessagingServerNotFound"] = 390] = "ErrorUnifiedMessagingServerNotFound";
    /**
     * The specified item culture is not supported on this server.
     */
    ServiceError[ServiceError["ErrorUnsupportedCulture"] = 391] = "ErrorUnsupportedCulture";
    /**
     * The MAPI property type is not supported.
     */
    ServiceError[ServiceError["ErrorUnsupportedMapiPropertyType"] = 392] = "ErrorUnsupportedMapiPropertyType";
    /**
     * MIME conversion is not supported for this item type.
     */
    ServiceError[ServiceError["ErrorUnsupportedMimeConversion"] = 393] = "ErrorUnsupportedMimeConversion";
    /**
     * The property can not be used with this type of restriction.
     */
    ServiceError[ServiceError["ErrorUnsupportedPathForQuery"] = 394] = "ErrorUnsupportedPathForQuery";
    /**
     * The property can not be used for sorting or grouping results.
     */
    ServiceError[ServiceError["ErrorUnsupportedPathForSortGroup"] = 395] = "ErrorUnsupportedPathForSortGroup";
    /**
     * PropertyDefinition is not supported in searches.
     */
    ServiceError[ServiceError["ErrorUnsupportedPropertyDefinition"] = 396] = "ErrorUnsupportedPropertyDefinition";
    /**
     * QueryFilter type is not supported.
     */
    ServiceError[ServiceError["ErrorUnsupportedQueryFilter"] = 397] = "ErrorUnsupportedQueryFilter";
    /**
     * The specified recurrence is not supported.
     */
    ServiceError[ServiceError["ErrorUnsupportedRecurrence"] = 398] = "ErrorUnsupportedRecurrence";
    /**
     * Unsupported subfilter type.
     */
    ServiceError[ServiceError["ErrorUnsupportedSubFilter"] = 399] = "ErrorUnsupportedSubFilter";
    /**
     * Unsupported type for restriction conversion.
     */
    ServiceError[ServiceError["ErrorUnsupportedTypeForConversion"] = 400] = "ErrorUnsupportedTypeForConversion";
    /**
     * Failed to update one or more delegates.
     */
    ServiceError[ServiceError["ErrorUpdateDelegatesFailed"] = 401] = "ErrorUpdateDelegatesFailed";
    /**
     * Property for update does not match property in object.
     */
    ServiceError[ServiceError["ErrorUpdatePropertyMismatch"] = 402] = "ErrorUpdatePropertyMismatch";
    /**
     * Policy does not allow granting permissions to user.
     */
    ServiceError[ServiceError["ErrorUserNotAllowedByPolicy"] = 403] = "ErrorUserNotAllowedByPolicy";
    /**
     * The user isn't enabled for Unified Messaging
     */
    ServiceError[ServiceError["ErrorUserNotUnifiedMessagingEnabled"] = 404] = "ErrorUserNotUnifiedMessagingEnabled";
    /**
     * The user doesn't have an SMTP proxy address from a federated domain.
     */
    ServiceError[ServiceError["ErrorUserWithoutFederatedProxyAddress"] = 405] = "ErrorUserWithoutFederatedProxyAddress";
    /**
     * The value is out of range.
     */
    ServiceError[ServiceError["ErrorValueOutOfRange"] = 406] = "ErrorValueOutOfRange";
    /**
     * Virus detected in the message.
     */
    ServiceError[ServiceError["ErrorVirusDetected"] = 407] = "ErrorVirusDetected";
    /**
     * The item has been deleted as a result of a virus scan.
     */
    ServiceError[ServiceError["ErrorVirusMessageDeleted"] = 408] = "ErrorVirusMessageDeleted";
    /**
     * The Voice Mail distinguished folder is not implemented.
     */
    ServiceError[ServiceError["ErrorVoiceMailNotImplemented"] = 409] = "ErrorVoiceMailNotImplemented";
    /**
     * ErrorWebRequestInInvalidState
     */
    ServiceError[ServiceError["ErrorWebRequestInInvalidState"] = 410] = "ErrorWebRequestInInvalidState";
    /**
     * ErrorWin32InteropError
     */
    ServiceError[ServiceError["ErrorWin32InteropError"] = 411] = "ErrorWin32InteropError";
    /**
     * ErrorWorkingHoursSaveFailed
     */
    ServiceError[ServiceError["ErrorWorkingHoursSaveFailed"] = 412] = "ErrorWorkingHoursSaveFailed";
    /**
     * ErrorWorkingHoursXmlMalformed
     */
    ServiceError[ServiceError["ErrorWorkingHoursXmlMalformed"] = 413] = "ErrorWorkingHoursXmlMalformed";
    /**
     * The Client Access server version doesn't match the Mailbox server version of the resource
     * that was being accessed. To determine the correct URL to use to access the resource, use
     * Autodiscover with the address of the resource.
     */
    ServiceError[ServiceError["ErrorWrongServerVersion"] = 414] = "ErrorWrongServerVersion";
    /**
     * The mailbox of the authenticating user and the mailbox of the resource being accessed
     * must have the same Mailbox server version.
     */
    ServiceError[ServiceError["ErrorWrongServerVersionDelegate"] = 415] = "ErrorWrongServerVersionDelegate";
    /**
     * The client access token request is invalid.
     */
    ServiceError[ServiceError["ErrorInvalidClientAccessTokenRequest"] = 416] = "ErrorInvalidClientAccessTokenRequest";
    /**
     * invalid managementrole header value or usage.
     */
    ServiceError[ServiceError["ErrorInvalidManagementRoleHeader"] = 417] = "ErrorInvalidManagementRoleHeader";
    /**
     * SearchMailboxes query has too many keywords.
     */
    ServiceError[ServiceError["ErrorSearchQueryHasTooManyKeywords"] = 418] = "ErrorSearchQueryHasTooManyKeywords";
    /**
     * SearchMailboxes on too many mailboxes.
     */
    ServiceError[ServiceError["ErrorSearchTooManyMailboxes"] = 419] = "ErrorSearchTooManyMailboxes";
    /**
     * There are no retention tags.
     */
    ServiceError[ServiceError["ErrorInvalidRetentionTagNone"] = 420] = "ErrorInvalidRetentionTagNone";
    /**
     * Discovery Searches are disabled.
     */
    ServiceError[ServiceError["ErrorDiscoverySearchesDisabled"] = 421] = "ErrorDiscoverySearchesDisabled";
    /**
     * SeekToConditionPageView not supported for calendar items.
     */
    ServiceError[ServiceError["ErrorCalendarSeekToConditionNotSupported"] = 422] = "ErrorCalendarSeekToConditionNotSupported";
    /**
     * Archive mailbox search operation failed.
     */
    ServiceError[ServiceError["ErrorArchiveMailboxSearchFailed"] = 423] = "ErrorArchiveMailboxSearchFailed";
    /**
     * Get remote archive mailbox folder failed.
     */
    ServiceError[ServiceError["ErrorGetRemoteArchiveFolderFailed"] = 424] = "ErrorGetRemoteArchiveFolderFailed";
    /**
     * Find remote archive mailbox folder failed.
     */
    ServiceError[ServiceError["ErrorFindRemoteArchiveFolderFailed"] = 425] = "ErrorFindRemoteArchiveFolderFailed";
    /**
     * Get remote archive mailbox item failed.
     */
    ServiceError[ServiceError["ErrorGetRemoteArchiveItemFailed"] = 426] = "ErrorGetRemoteArchiveItemFailed";
    /**
     * Export remote archive mailbox items failed.
     */
    ServiceError[ServiceError["ErrorExportRemoteArchiveItemsFailed"] = 427] = "ErrorExportRemoteArchiveItemsFailed";
    /**
     * Invalid state definition.
     */
    ServiceError[ServiceError["ErrorClientIntentInvalidStateDefinition"] = 428] = "ErrorClientIntentInvalidStateDefinition";
    /**
     * Client intent not found.
     */
    ServiceError[ServiceError["ErrorClientIntentNotFound"] = 429] = "ErrorClientIntentNotFound";
    /**
     * The Content Indexing service is required to perform this search, but it's not enabled.
     */
    ServiceError[ServiceError["ErrorContentIndexingNotEnabled"] = 430] = "ErrorContentIndexingNotEnabled";
    /**
     * The custom prompt files you specified couldn't be removed.
     */
    ServiceError[ServiceError["ErrorDeleteUnifiedMessagingPromptFailed"] = 431] = "ErrorDeleteUnifiedMessagingPromptFailed";
    /**
     * The location service is disabled.
     */
    ServiceError[ServiceError["ErrorLocationServicesDisabled"] = 432] = "ErrorLocationServicesDisabled";
    /**
     * Invalid location service request.
     */
    ServiceError[ServiceError["ErrorLocationServicesInvalidRequest"] = 433] = "ErrorLocationServicesInvalidRequest";
    /**
     * The request for location information failed.
     */
    ServiceError[ServiceError["ErrorLocationServicesRequestFailed"] = 434] = "ErrorLocationServicesRequestFailed";
    /**
     * The request for location information timed out.
     */
    ServiceError[ServiceError["ErrorLocationServicesRequestTimedOut"] = 435] = "ErrorLocationServicesRequestTimedOut";
    /**
     * Weather service is disabled.
     */
    ServiceError[ServiceError["ErrorWeatherServiceDisabled"] = 436] = "ErrorWeatherServiceDisabled";
    /**
     * Mailbox scope not allowed without a query string.
     */
    ServiceError[ServiceError["ErrorMailboxScopeNotAllowedWithoutQueryString"] = 437] = "ErrorMailboxScopeNotAllowedWithoutQueryString";
    /**
     * No speech detected.
     */
    ServiceError[ServiceError["ErrorNoSpeechDetected"] = 438] = "ErrorNoSpeechDetected";
    /**
     * An error occurred while accessing the custom prompt publishing point.
     */
    ServiceError[ServiceError["ErrorPromptPublishingOperationFailed"] = 439] = "ErrorPromptPublishingOperationFailed";
    /**
     * Unable to discover the URL of the public folder mailbox.
     */
    ServiceError[ServiceError["ErrorPublicFolderMailboxDiscoveryFailed"] = 440] = "ErrorPublicFolderMailboxDiscoveryFailed";
    /**
     * Public folder operation failed.
     */
    ServiceError[ServiceError["ErrorPublicFolderOperationFailed"] = 441] = "ErrorPublicFolderOperationFailed";
    /**
     * The operation succeeded on the primary public folder mailbox, but failed to sync to the secondary public folder mailbox.
     */
    ServiceError[ServiceError["ErrorPublicFolderSyncException"] = 442] = "ErrorPublicFolderSyncException";
    /**
     * Discovery Searches are disabled.
     */
    ServiceError[ServiceError["ErrorRecipientNotFound"] = 443] = "ErrorRecipientNotFound";
    /**
     * Recognizer not installed.
     */
    ServiceError[ServiceError["ErrorRecognizerNotInstalled"] = 444] = "ErrorRecognizerNotInstalled";
    /**
     * Speech grammar error.
     */
    ServiceError[ServiceError["ErrorSpeechGrammarError"] = 445] = "ErrorSpeechGrammarError";
    /**
     * Too many concurrent connections opened.
     */
    ServiceError[ServiceError["ErrorTooManyObjectsOpened"] = 446] = "ErrorTooManyObjectsOpened";
    /**
     * Unified Messaging server unavailable.
     */
    ServiceError[ServiceError["ErrorUMServerUnavailable"] = 447] = "ErrorUMServerUnavailable";
    /**
     * The Unified Messaging custom prompt file you specified couldn't be found.
     */
    ServiceError[ServiceError["ErrorUnifiedMessagingPromptNotFound"] = 448] = "ErrorUnifiedMessagingPromptNotFound";
    /**
     * Report data for the UM call summary couldn't be found.
     */
    ServiceError[ServiceError["ErrorUnifiedMessagingReportDataNotFound"] = 449] = "ErrorUnifiedMessagingReportDataNotFound";
    /**
     * The requested size is invalid.
     */
    ServiceError[ServiceError["ErrorInvalidPhotoSize"] = 450] = "ErrorInvalidPhotoSize";
    /**
     * AcceptItem action is invalid for a meeting message in group mailbox.
     */
    ServiceError[ServiceError["ErrorCalendarIsGroupMailboxForAccept"] = 451] = "ErrorCalendarIsGroupMailboxForAccept";
    /**
     * DeclineItem operation is invalid for a meeting message in group mailbox.
     */
    ServiceError[ServiceError["ErrorCalendarIsGroupMailboxForDecline"] = 452] = "ErrorCalendarIsGroupMailboxForDecline";
    /**
     * TentativelyAcceptItem action isn't valid for a meeting message in group mailbox.
     */
    ServiceError[ServiceError["ErrorCalendarIsGroupMailboxForTentative"] = 453] = "ErrorCalendarIsGroupMailboxForTentative";
    /**
     * SuppressReadReceipt action isn't valid for a meeting message in group mailbox.
     */
    ServiceError[ServiceError["ErrorCalendarIsGroupMailboxForSuppressReadReceipt"] = 454] = "ErrorCalendarIsGroupMailboxForSuppressReadReceipt";
    /**
     * The Organization is marked for removal.
     */
    ServiceError[ServiceError["ErrorOrganizationAccessBlocked"] = 455] = "ErrorOrganizationAccessBlocked";
    /**
     * User doesn't have a valid license.
     */
    ServiceError[ServiceError["ErrorInvalidLicense"] = 456] = "ErrorInvalidLicense";
    /**
     * Receive quota message per folder is exceeded.
     */
    ServiceError[ServiceError["ErrorMessagePerFolderCountReceiveQuotaExceeded"] = 457] = "ErrorMessagePerFolderCountReceiveQuotaExceeded";
    /**
     * Unified group was not found.
     */
    ServiceError[ServiceError["ErrorUnifiedGroupMailboxNotFound"] = 458] = "ErrorUnifiedGroupMailboxNotFound";
    /**
     * Invalid channel id.
     */
    ServiceError[ServiceError["ErrorInvalidChannelId"] = 459] = "ErrorInvalidChannelId";
    /**
     * Another connection is opened on the same channel.
     */
    ServiceError[ServiceError["ErrorNewChannelConnectionOpened"] = 460] = "ErrorNewChannelConnectionOpened";
    /**
     * The channel subscription cannot be found.
     */
    ServiceError[ServiceError["ErrorChannelSubscriptionNotFound"] = 461] = "ErrorChannelSubscriptionNotFound";
    /**
     * The channel contains too many subscriptions.
     */
    ServiceError[ServiceError["ErrorExceededChannelSubscriptionCount"] = 462] = "ErrorExceededChannelSubscriptionCount";
    /**
     * The channel subscription already exists.
     */
    ServiceError[ServiceError["ErrorChannelSubscriptionAlreadyExists"] = 463] = "ErrorChannelSubscriptionAlreadyExists";
    /**
     * The given channel subscription id is invalid.
     */
    ServiceError[ServiceError["ErrorInvalidChannelSubscriptionId"] = 464] = "ErrorInvalidChannelSubscriptionId";
    /* #region Error codes to map WASCL errors */
    /**
     * Error indicating that message submission blocked by WASCL for a consumer mailboxes
     */
    ServiceError[ServiceError["ErrorMessageSubmissionBlocked"] = 465] = "ErrorMessageSubmissionBlocked";
    /**
     * Error indicating that number of submitted messages exceeded the limit and message submission is blocked by WASCL
     */
    ServiceError[ServiceError["ErrorExceededMessageLimit"] = 466] = "ErrorExceededMessageLimit";
    /**
     * Error indicating that recipients number for a consumer mailbox has exceeded the limit defined by WASCL
     */
    ServiceError[ServiceError["ErrorExceededMaxRecipientLimitBlock"] = 467] = "ErrorExceededMaxRecipientLimitBlock";
    /**
     * Error indicating that access to the consumer mailbox is suspended by WASCL
     */
    ServiceError[ServiceError["ErrorAccountSuspend"] = 468] = "ErrorAccountSuspend";
    /**
     * Error indicating that recipients number for a consumer mailbox has exceeded the limit defined by WASCL
     */
    ServiceError[ServiceError["ErrorExceededMaxRecipientLimit"] = 469] = "ErrorExceededMaxRecipientLimit";
    /**
     * Error indicating that particular message cannot be sent for a consumer mailbox as it is considered as SPAM by WASCL
     */
    ServiceError[ServiceError["ErrorMessageBlocked"] = 470] = "ErrorMessageBlocked";
    /**
     * Error indicating that access to the consumer mailbox is suspended by WASCL
     */
    ServiceError[ServiceError["ErrorAccountSuspendShowTierUpgrade"] = 471] = "ErrorAccountSuspendShowTierUpgrade";
    /**
     * Error indicating that message sent from a consumer mailbox has exceeded the limit defined by WASCL
     */
    ServiceError[ServiceError["ErrorExceededMessageLimitShowTierUpgrade"] = 472] = "ErrorExceededMessageLimitShowTierUpgrade";
    /**
     * Error indicating that recipients number for a consumer mailbox has exceeded the limit defined by WASCL
     */
    ServiceError[ServiceError["ErrorExceededMaxRecipientLimitShowTierUpgrade"] = 473] = "ErrorExceededMaxRecipientLimitShowTierUpgrade";
    /* #endregion */
})(ServiceError = exports.ServiceError || (exports.ServiceError = {}));
/**
 * @internal Defines the type of error handling used for service method calls.
 */
var ServiceErrorHandling;
(function (ServiceErrorHandling) {
    /**
     * Service method should return the error(s).
     */
    ServiceErrorHandling[ServiceErrorHandling["ReturnErrors"] = 0] = "ReturnErrors";
    /**
     * Service method should throw exception when error occurs.
     */
    ServiceErrorHandling[ServiceErrorHandling["ThrowOnError"] = 1] = "ThrowOnError";
})(ServiceErrorHandling = exports.ServiceErrorHandling || (exports.ServiceErrorHandling = {}));
/**
 * Defines the type of a service object.
 */
var ServiceObjectType;
(function (ServiceObjectType) {
    /**
     * The object is a folder.
     */
    ServiceObjectType[ServiceObjectType["Folder"] = 0] = "Folder";
    /**
     * The object is an item.
     */
    ServiceObjectType[ServiceObjectType["Item"] = 1] = "Item";
    /**
     * Data represents a conversation
     */
    ServiceObjectType[ServiceObjectType["Conversation"] = 2] = "Conversation";
    /**
     * Data represents a persona
     */
    ServiceObjectType[ServiceObjectType["Persona"] = 3] = "Persona";
})(ServiceObjectType = exports.ServiceObjectType || (exports.ServiceObjectType = {}));
/**
 * Defines the result of a call to an EWS method.
 * Values in this enumeration have to be ordered from lowest to highest severity.
 */
var ServiceResult;
(function (ServiceResult) {
    /**
     * The call was successful
     */
    ServiceResult[ServiceResult["Success"] = 0] = "Success";
    /**
     * The call triggered at least one warning
     */
    ServiceResult[ServiceResult["Warning"] = 1] = "Warning";
    /**
     * The call triggered at least one error
     */
    ServiceResult[ServiceResult["Error"] = 2] = "Error";
})(ServiceResult = exports.ServiceResult || (exports.ServiceResult = {}));
/**
 * Defines the type of SetClientExtensionActionId.
 */
var SetClientExtensionActionId;
(function (SetClientExtensionActionId) {
    /**
     * Install
     */
    SetClientExtensionActionId[SetClientExtensionActionId["Install"] = 0] = "Install";
    /**
     * Uninstall
     */
    SetClientExtensionActionId[SetClientExtensionActionId["Uninstall"] = 1] = "Uninstall";
    /**
     * Configure
     */
    SetClientExtensionActionId[SetClientExtensionActionId["Configure"] = 2] = "Configure";
})(SetClientExtensionActionId = exports.SetClientExtensionActionId || (exports.SetClientExtensionActionId = {}));
/**
 * Defines a sort direction
 */
var SortDirection;
(function (SortDirection) {
    /**
     * The sort is performed in ascending order.
     */
    SortDirection[SortDirection["Ascending"] = 0] = "Ascending";
    /**
     * The sort is performed in descending order.
     */
    SortDirection[SortDirection["Descending"] = 1] = "Descending";
})(SortDirection = exports.SortDirection || (exports.SortDirection = {}));
/**
 * Defines a standard delegate user.
 */
var StandardUser;
(function (StandardUser) {
    /**
     * The Default delegate user, used to define default delegation permissions.
     */
    StandardUser[StandardUser["Default"] = 0] = "Default";
    /**
     * The Anonymous delegate user, used to define delegate permissions for unauthenticated users.
     */
    StandardUser[StandardUser["Anonymous"] = 1] = "Anonymous";
})(StandardUser = exports.StandardUser || (exports.StandardUser = {}));
/**
 * Defines the quality of an availability suggestion.
 */
var SuggestionQuality;
(function (SuggestionQuality) {
    /**
     * The suggestion is excellent.
     */
    SuggestionQuality[SuggestionQuality["Excellent"] = 0] = "Excellent";
    /**
     * The suggestion is good.
     */
    SuggestionQuality[SuggestionQuality["Good"] = 1] = "Good";
    /**
     * The suggestion is fair.
     */
    SuggestionQuality[SuggestionQuality["Fair"] = 2] = "Fair";
    /**
     * The suggestion is poor.
     */
    SuggestionQuality[SuggestionQuality["Poor"] = 3] = "Poor";
})(SuggestionQuality = exports.SuggestionQuality || (exports.SuggestionQuality = {}));
/**
 * Determines items to be included in a SyncFolderItems response.
 */
var SyncFolderItemsScope;
(function (SyncFolderItemsScope) {
    /**
     * Include only normal items in the response.
     */
    SyncFolderItemsScope[SyncFolderItemsScope["NormalItems"] = 0] = "NormalItems";
    /**
     * Include normal and associated items in the response.
     */
    SyncFolderItemsScope[SyncFolderItemsScope["NormalAndAssociatedItems"] = 1] = "NormalAndAssociatedItems";
})(SyncFolderItemsScope = exports.SyncFolderItemsScope || (exports.SyncFolderItemsScope = {}));
/**
 * This maps to the bogus TaskDelegationState in the EWS schema.
 * The schema enum has 6 values, but EWS should never return anything but values between 0 and 3, so we should be safe without mappings for EWS's Declined and Max values
 */
var TaskDelegationState;
(function (TaskDelegationState) {
    /**
     * The task is not delegated
     */
    TaskDelegationState[TaskDelegationState["NoDelegation"] = 0] = "NoDelegation";
    /**
     * The task's delegation state is unknown.
     */
    TaskDelegationState[TaskDelegationState["Unknown"] = 1] = "Unknown";
    /**
     * The task was delegated and the delegation was accepted.
     */
    TaskDelegationState[TaskDelegationState["Accepted"] = 2] = "Accepted";
    /**
     * The task was delegated but the delegation was declined.
     */
    TaskDelegationState[TaskDelegationState["Declined"] = 3] = "Declined"; // Maps to Accepted
    // The original Declined value has no mapping
    // The original Max value has no mapping
})(TaskDelegationState = exports.TaskDelegationState || (exports.TaskDelegationState = {}));
/**
 * Defines the modes of a Task.
 */
var TaskMode;
(function (TaskMode) {
    /**
     * The task is normal
     */
    TaskMode[TaskMode["Normal"] = 0] = "Normal";
    /**
     * The task is a task assignment request
     */
    TaskMode[TaskMode["Request"] = 1] = "Request";
    /**
     * The task assignment request was accepted
     */
    TaskMode[TaskMode["RequestAccepted"] = 2] = "RequestAccepted";
    /**
     * The task assignment request was declined
     */
    TaskMode[TaskMode["RequestDeclined"] = 3] = "RequestDeclined";
    /**
     * The task has been updated
     */
    TaskMode[TaskMode["Update"] = 4] = "Update";
    /**
     * The task is self delegated
     */
    TaskMode[TaskMode["SelfDelegated"] = 5] = "SelfDelegated";
})(TaskMode = exports.TaskMode || (exports.TaskMode = {}));
/**
 * Defines the execution status of a task.
 */
var TaskStatus;
(function (TaskStatus) {
    /**
     * The execution of the task is not started.
     */
    TaskStatus[TaskStatus["NotStarted"] = 0] = "NotStarted";
    /**
     * The execution of the task is in progress.
     */
    TaskStatus[TaskStatus["InProgress"] = 1] = "InProgress";
    /**
     * The execution of the task is completed.
     */
    TaskStatus[TaskStatus["Completed"] = 2] = "Completed";
    /**
     * The execution of the task is waiting on others.
     */
    TaskStatus[TaskStatus["WaitingOnOthers"] = 3] = "WaitingOnOthers";
    /**
     * The execution of the task is deferred.
     */
    TaskStatus[TaskStatus["Deferred"] = 4] = "Deferred";
})(TaskStatus = exports.TaskStatus || (exports.TaskStatus = {}));
/**
 * TeamMailbox lifecycle state
 */
var TeamMailboxLifecycleState;
(function (TeamMailboxLifecycleState) {
    /**
     * Active
     */
    TeamMailboxLifecycleState[TeamMailboxLifecycleState["Active"] = 0] = "Active";
    /**
     * Closed
     */
    TeamMailboxLifecycleState[TeamMailboxLifecycleState["Closed"] = 1] = "Closed";
    /**
     * Unlinked
     */
    TeamMailboxLifecycleState[TeamMailboxLifecycleState["Unlinked"] = 2] = "Unlinked";
    /**
     * PendingDelete
     */
    TeamMailboxLifecycleState[TeamMailboxLifecycleState["PendingDelete"] = 3] = "PendingDelete";
})(TeamMailboxLifecycleState = exports.TeamMailboxLifecycleState || (exports.TeamMailboxLifecycleState = {}));
(function (TeamMailboxLifecycleState) {
    /**EwsEnumAttribute */
    function FromEwsEnumString(value) {
        return TeamMailboxLifecycleState[value];
    }
    TeamMailboxLifecycleState.FromEwsEnumString = FromEwsEnumString;
    /**EwsEnumAttribute */
    function ToEwsEnumString(value) {
        return TeamMailboxLifecycleState[value];
    }
    TeamMailboxLifecycleState.ToEwsEnumString = ToEwsEnumString;
})(TeamMailboxLifecycleState = exports.TeamMailboxLifecycleState || (exports.TeamMailboxLifecycleState = {}));
/**
 * Defines flags to control tracing details
 *
 * [Flags]
 */
var TraceFlags;
(function (TraceFlags) {
    /**
     * No tracing.
     */
    TraceFlags[TraceFlags["None"] = 0] = "None";
    /**
     * Trace EWS request messages.
     */
    TraceFlags[TraceFlags["EwsRequest"] = 1] = "EwsRequest";
    /**
     * Trace EWS response messages.
     */
    TraceFlags[TraceFlags["EwsResponse"] = 2] = "EwsResponse";
    /**
     * Trace EWS response HTTP headers.
     */
    TraceFlags[TraceFlags["EwsResponseHttpHeaders"] = 4] = "EwsResponseHttpHeaders";
    /**
     * Trace Autodiscover request messages.
     */
    TraceFlags[TraceFlags["AutodiscoverRequest"] = 8] = "AutodiscoverRequest";
    /**
     * Trace Autodiscover response messages.
     */
    TraceFlags[TraceFlags["AutodiscoverResponse"] = 16] = "AutodiscoverResponse";
    /**
     * Trace Autodiscover response HTTP headers.
     */
    TraceFlags[TraceFlags["AutodiscoverResponseHttpHeaders"] = 32] = "AutodiscoverResponseHttpHeaders";
    /**
     * Trace Autodiscover configuration logic.
     */
    TraceFlags[TraceFlags["AutodiscoverConfiguration"] = 64] = "AutodiscoverConfiguration";
    /**
     * Trace messages used in debugging the Exchange Web Services Managed API
     */
    TraceFlags[TraceFlags["DebugMessage"] = 128] = "DebugMessage";
    /**
     * Trace EWS request HTTP headers.
     */
    TraceFlags[TraceFlags["EwsRequestHttpHeaders"] = 256] = "EwsRequestHttpHeaders";
    /**
     * Trace Autodiscover request HTTP headers.
     */
    TraceFlags[TraceFlags["AutodiscoverRequestHttpHeaders"] = 512] = "AutodiscoverRequestHttpHeaders";
    /**
     * Trace EWS timezone related logic.
     */
    TraceFlags[TraceFlags["EwsTimeZones"] = 1024] = "EwsTimeZones";
    /**
     * All trace types enabled.
     */
    TraceFlags[TraceFlags["All"] = 9223372036854776000] = "All";
})(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));
/**
 * Identifies the user configuration dictionary key and value types.
 */
var UserConfigurationDictionaryObjectType;
(function (UserConfigurationDictionaryObjectType) {
    /**
     * DateTime type.
     */
    UserConfigurationDictionaryObjectType[UserConfigurationDictionaryObjectType["DateTime"] = 0] = "DateTime";
    /**
     * Boolean type.
     */
    UserConfigurationDictionaryObjectType[UserConfigurationDictionaryObjectType["Boolean"] = 1] = "Boolean";
    /**
     * Byte type.
     */
    UserConfigurationDictionaryObjectType[UserConfigurationDictionaryObjectType["Byte"] = 2] = "Byte";
    /**
     * String type.
     */
    UserConfigurationDictionaryObjectType[UserConfigurationDictionaryObjectType["String"] = 3] = "String";
    /**
     * 32-bit integer type.
     */
    UserConfigurationDictionaryObjectType[UserConfigurationDictionaryObjectType["Integer32"] = 4] = "Integer32";
    /**
     * 32-bit unsigned integer type.
     */
    UserConfigurationDictionaryObjectType[UserConfigurationDictionaryObjectType["UnsignedInteger32"] = 5] = "UnsignedInteger32";
    /**
     * 64-bit integer type.
     */
    UserConfigurationDictionaryObjectType[UserConfigurationDictionaryObjectType["Integer64"] = 6] = "Integer64";
    /**
     * 64-bit unsigned integer type.
     */
    UserConfigurationDictionaryObjectType[UserConfigurationDictionaryObjectType["UnsignedInteger64"] = 7] = "UnsignedInteger64";
    /**
     * String array type.
     */
    UserConfigurationDictionaryObjectType[UserConfigurationDictionaryObjectType["StringArray"] = 8] = "StringArray";
    /**
     * Byte array type
     */
    UserConfigurationDictionaryObjectType[UserConfigurationDictionaryObjectType["ByteArray"] = 9] = "ByteArray";
})(UserConfigurationDictionaryObjectType = exports.UserConfigurationDictionaryObjectType || (exports.UserConfigurationDictionaryObjectType = {}));
/**
 * Identifies the user configuration properties to retrieve.
 *
 * [Flags]
 */
var UserConfigurationProperties;
(function (UserConfigurationProperties) {
    /**
     * Retrieve the Id property.
     */
    UserConfigurationProperties[UserConfigurationProperties["Id"] = 1] = "Id";
    /**
     * Retrieve the Dictionary property.
     */
    UserConfigurationProperties[UserConfigurationProperties["Dictionary"] = 2] = "Dictionary";
    /**
     * Retrieve the XmlData property.
     */
    UserConfigurationProperties[UserConfigurationProperties["XmlData"] = 4] = "XmlData";
    /**
     * Retrieve the BinaryData property.
     */
    UserConfigurationProperties[UserConfigurationProperties["BinaryData"] = 8] = "BinaryData";
    /**
     * Retrieve all properties.
     */
    UserConfigurationProperties[UserConfigurationProperties["All"] = 15] = "All";
})(UserConfigurationProperties = exports.UserConfigurationProperties || (exports.UserConfigurationProperties = {}));
/**
 * User settings that can be requested using GetUserSettings.
 *
 * /remarks/  Add new values to the end and keep in sync with Microsoft.Exchange.Autodiscover.ConfigurationSettings.UserConfigurationSettingName.
 */
var UserSettingName;
(function (UserSettingName) {
    /**
     * The display name of the user.
     */
    UserSettingName[UserSettingName["UserDisplayName"] = 0] = "UserDisplayName";
    /**
     * The legacy distinguished name of the user.
     */
    UserSettingName[UserSettingName["UserDN"] = 1] = "UserDN";
    /**
     * The deployment Id of the user.
     */
    UserSettingName[UserSettingName["UserDeploymentId"] = 2] = "UserDeploymentId";
    /**
     * The fully qualified domain name of the mailbox server.
     */
    UserSettingName[UserSettingName["InternalMailboxServer"] = 3] = "InternalMailboxServer";
    /**
     * The fully qualified domain name of the RPC client server.
     */
    UserSettingName[UserSettingName["InternalRpcClientServer"] = 4] = "InternalRpcClientServer";
    /**
     * The legacy distinguished name of the mailbox server.
     */
    UserSettingName[UserSettingName["InternalMailboxServerDN"] = 5] = "InternalMailboxServerDN";
    /**
     * The internal URL of the Exchange Control Panel.
     */
    UserSettingName[UserSettingName["InternalEcpUrl"] = 6] = "InternalEcpUrl";
    /**
     * The internal URL of the Exchange Control Panel for VoiceMail Customization.
     */
    UserSettingName[UserSettingName["InternalEcpVoicemailUrl"] = 7] = "InternalEcpVoicemailUrl";
    /**
     * The internal URL of the Exchange Control Panel for Email Subscriptions.
     */
    UserSettingName[UserSettingName["InternalEcpEmailSubscriptionsUrl"] = 8] = "InternalEcpEmailSubscriptionsUrl";
    /**
     * The internal URL of the Exchange Control Panel for Text Messaging.
     */
    UserSettingName[UserSettingName["InternalEcpTextMessagingUrl"] = 9] = "InternalEcpTextMessagingUrl";
    /**
     * The internal URL of the Exchange Control Panel for Delivery Reports.
     */
    UserSettingName[UserSettingName["InternalEcpDeliveryReportUrl"] = 10] = "InternalEcpDeliveryReportUrl";
    /**
     * The internal URL of the Exchange Control Panel for RetentionPolicy Tags.
     */
    UserSettingName[UserSettingName["InternalEcpRetentionPolicyTagsUrl"] = 11] = "InternalEcpRetentionPolicyTagsUrl";
    /**
     * The internal URL of the Exchange Control Panel for Publishing.
     */
    UserSettingName[UserSettingName["InternalEcpPublishingUrl"] = 12] = "InternalEcpPublishingUrl";
    /**
     * The internal URL of the Exchange Control Panel for photos.
     */
    UserSettingName[UserSettingName["InternalEcpPhotoUrl"] = 13] = "InternalEcpPhotoUrl";
    /**
     * The internal URL of the Exchange Control Panel for People Connect subscriptions.
     */
    UserSettingName[UserSettingName["InternalEcpConnectUrl"] = 14] = "InternalEcpConnectUrl";
    /**
     * The internal URL of the Exchange Control Panel for Team Mailbox.
     */
    UserSettingName[UserSettingName["InternalEcpTeamMailboxUrl"] = 15] = "InternalEcpTeamMailboxUrl";
    /**
     * The internal URL of the Exchange Control Panel for creating Team Mailbox.
     */
    UserSettingName[UserSettingName["InternalEcpTeamMailboxCreatingUrl"] = 16] = "InternalEcpTeamMailboxCreatingUrl";
    /**
     * The internal URL of the Exchange Control Panel for editing Team Mailbox.
     */
    UserSettingName[UserSettingName["InternalEcpTeamMailboxEditingUrl"] = 17] = "InternalEcpTeamMailboxEditingUrl";
    /**
     * The internal URL of the Exchange Control Panel for hiding Team Mailbox.
     */
    UserSettingName[UserSettingName["InternalEcpTeamMailboxHidingUrl"] = 18] = "InternalEcpTeamMailboxHidingUrl";
    /**
     * The internal URL of the Exchange Control Panel for the extension installation.
     */
    UserSettingName[UserSettingName["InternalEcpExtensionInstallationUrl"] = 19] = "InternalEcpExtensionInstallationUrl";
    /**
     * The internal URL of the Exchange Web Services.
     */
    UserSettingName[UserSettingName["InternalEwsUrl"] = 20] = "InternalEwsUrl";
    /**
     * The internal URL of the Exchange Management Web Services.
     */
    UserSettingName[UserSettingName["InternalEmwsUrl"] = 21] = "InternalEmwsUrl";
    /**
     * The internal URL of the Offline Address Book.
     */
    UserSettingName[UserSettingName["InternalOABUrl"] = 22] = "InternalOABUrl";
    /**
     * The internal URL of the Photos service.
     */
    UserSettingName[UserSettingName["InternalPhotosUrl"] = 23] = "InternalPhotosUrl";
    /**
     * The internal URL of the Unified Messaging services.
     */
    UserSettingName[UserSettingName["InternalUMUrl"] = 24] = "InternalUMUrl";
    /**
     * The internal URLs of the Exchange web client.
     */
    UserSettingName[UserSettingName["InternalWebClientUrls"] = 25] = "InternalWebClientUrls";
    /**
     * The distinguished name of the mailbox database of the user's mailbox.
     */
    UserSettingName[UserSettingName["MailboxDN"] = 26] = "MailboxDN";
    /**
     * The name of the Public Folders server.
     */
    UserSettingName[UserSettingName["PublicFolderServer"] = 27] = "PublicFolderServer";
    /**
     * The name of the Active Directory server.
     */
    UserSettingName[UserSettingName["ActiveDirectoryServer"] = 28] = "ActiveDirectoryServer";
    /**
     * The name of the RPC over HTTP server.
     */
    UserSettingName[UserSettingName["ExternalMailboxServer"] = 29] = "ExternalMailboxServer";
    /**
     * Indicates whether the RPC over HTTP server requires SSL.
     */
    UserSettingName[UserSettingName["ExternalMailboxServerRequiresSSL"] = 30] = "ExternalMailboxServerRequiresSSL";
    /**
     * The authentication methods supported by the RPC over HTTP server.
     */
    UserSettingName[UserSettingName["ExternalMailboxServerAuthenticationMethods"] = 31] = "ExternalMailboxServerAuthenticationMethods";
    /**
     * The URL fragment of the Exchange Control Panel for VoiceMail Customization.
     */
    UserSettingName[UserSettingName["EcpVoicemailUrlFragment"] = 32] = "EcpVoicemailUrlFragment";
    /**
     * The URL fragment of the Exchange Control Panel for Email Subscriptions.
     */
    UserSettingName[UserSettingName["EcpEmailSubscriptionsUrlFragment"] = 33] = "EcpEmailSubscriptionsUrlFragment";
    /**
     * The URL fragment of the Exchange Control Panel for Text Messaging.
     */
    UserSettingName[UserSettingName["EcpTextMessagingUrlFragment"] = 34] = "EcpTextMessagingUrlFragment";
    /**
     * The URL fragment of the Exchange Control Panel for Delivery Reports.
     */
    UserSettingName[UserSettingName["EcpDeliveryReportUrlFragment"] = 35] = "EcpDeliveryReportUrlFragment";
    /**
     * The URL fragment of the Exchange Control Panel for RetentionPolicy Tags.
     */
    UserSettingName[UserSettingName["EcpRetentionPolicyTagsUrlFragment"] = 36] = "EcpRetentionPolicyTagsUrlFragment";
    /**
     * The URL fragment of the Exchange Control Panel for Publishing.
     */
    UserSettingName[UserSettingName["EcpPublishingUrlFragment"] = 37] = "EcpPublishingUrlFragment";
    /**
     * The URL fragment of the Exchange Control Panel for photos.
     */
    UserSettingName[UserSettingName["EcpPhotoUrlFragment"] = 38] = "EcpPhotoUrlFragment";
    /**
     * The URL fragment of the Exchange Control Panel for People Connect.
     */
    UserSettingName[UserSettingName["EcpConnectUrlFragment"] = 39] = "EcpConnectUrlFragment";
    /**
     * The URL fragment of the Exchange Control Panel for Team Mailbox.
     */
    UserSettingName[UserSettingName["EcpTeamMailboxUrlFragment"] = 40] = "EcpTeamMailboxUrlFragment";
    /**
     * The URL fragment of the Exchange Control Panel for creating Team Mailbox.
     */
    UserSettingName[UserSettingName["EcpTeamMailboxCreatingUrlFragment"] = 41] = "EcpTeamMailboxCreatingUrlFragment";
    /**
     * The URL fragment of the Exchange Control Panel for editing Team Mailbox.
     */
    UserSettingName[UserSettingName["EcpTeamMailboxEditingUrlFragment"] = 42] = "EcpTeamMailboxEditingUrlFragment";
    /**
     * The URL fragment of the Exchange Control Panel for installing extension.
     */
    UserSettingName[UserSettingName["EcpExtensionInstallationUrlFragment"] = 43] = "EcpExtensionInstallationUrlFragment";
    /**
     * The external URL of the Exchange Control Panel.
     */
    UserSettingName[UserSettingName["ExternalEcpUrl"] = 44] = "ExternalEcpUrl";
    /**
     * The external URL of the Exchange Control Panel for VoiceMail Customization.
     */
    UserSettingName[UserSettingName["ExternalEcpVoicemailUrl"] = 45] = "ExternalEcpVoicemailUrl";
    /**
     * The external URL of the Exchange Control Panel for Email Subscriptions.
     */
    UserSettingName[UserSettingName["ExternalEcpEmailSubscriptionsUrl"] = 46] = "ExternalEcpEmailSubscriptionsUrl";
    /**
     * The external URL of the Exchange Control Panel for Text Messaging.
     */
    UserSettingName[UserSettingName["ExternalEcpTextMessagingUrl"] = 47] = "ExternalEcpTextMessagingUrl";
    /**
     * The external URL of the Exchange Control Panel for Delivery Reports.
     */
    UserSettingName[UserSettingName["ExternalEcpDeliveryReportUrl"] = 48] = "ExternalEcpDeliveryReportUrl";
    /**
     * The external URL of the Exchange Control Panel for RetentionPolicy Tags.
     */
    UserSettingName[UserSettingName["ExternalEcpRetentionPolicyTagsUrl"] = 49] = "ExternalEcpRetentionPolicyTagsUrl";
    /**
     * The external URL of the Exchange Control Panel for Publishing.
     */
    UserSettingName[UserSettingName["ExternalEcpPublishingUrl"] = 50] = "ExternalEcpPublishingUrl";
    /**
     * The external URL of the Exchange Control Panel for photos.
     */
    UserSettingName[UserSettingName["ExternalEcpPhotoUrl"] = 51] = "ExternalEcpPhotoUrl";
    /**
     * The external URL of the Exchange Control Panel for People Connect subscriptions.
     */
    UserSettingName[UserSettingName["ExternalEcpConnectUrl"] = 52] = "ExternalEcpConnectUrl";
    /**
     * The external URL of the Exchange Control Panel for Team Mailbox.
     */
    UserSettingName[UserSettingName["ExternalEcpTeamMailboxUrl"] = 53] = "ExternalEcpTeamMailboxUrl";
    /**
     * The external URL of the Exchange Control Panel for creating Team Mailbox.
     */
    UserSettingName[UserSettingName["ExternalEcpTeamMailboxCreatingUrl"] = 54] = "ExternalEcpTeamMailboxCreatingUrl";
    /**
     * The external URL of the Exchange Control Panel for editing Team Mailbox.
     */
    UserSettingName[UserSettingName["ExternalEcpTeamMailboxEditingUrl"] = 55] = "ExternalEcpTeamMailboxEditingUrl";
    /**
     * The external URL of the Exchange Control Panel for hiding Team Mailbox.
     */
    UserSettingName[UserSettingName["ExternalEcpTeamMailboxHidingUrl"] = 56] = "ExternalEcpTeamMailboxHidingUrl";
    /**
     * The external URL of the Exchange Control Panel for the extension installation.
     */
    UserSettingName[UserSettingName["ExternalEcpExtensionInstallationUrl"] = 57] = "ExternalEcpExtensionInstallationUrl";
    /**
     * The external URL of the Exchange Web Services.
     */
    UserSettingName[UserSettingName["ExternalEwsUrl"] = 58] = "ExternalEwsUrl";
    /**
     * The external URL of the Exchange Management Web Services.
     */
    UserSettingName[UserSettingName["ExternalEmwsUrl"] = 59] = "ExternalEmwsUrl";
    /**
     * The external URL of the Offline Address Book.
     */
    UserSettingName[UserSettingName["ExternalOABUrl"] = 60] = "ExternalOABUrl";
    /**
     * The external URL of the Photos service.
     */
    UserSettingName[UserSettingName["ExternalPhotosUrl"] = 61] = "ExternalPhotosUrl";
    /**
     * The external URL of the Unified Messaging services.
     */
    UserSettingName[UserSettingName["ExternalUMUrl"] = 62] = "ExternalUMUrl";
    /**
     * The external URLs of the Exchange web client.
     */
    UserSettingName[UserSettingName["ExternalWebClientUrls"] = 63] = "ExternalWebClientUrls";
    /**
     * Indicates that cross-organization sharing is enabled.
     */
    UserSettingName[UserSettingName["CrossOrganizationSharingEnabled"] = 64] = "CrossOrganizationSharingEnabled";
    /**
     * Collection of alternate mailboxes.
     */
    UserSettingName[UserSettingName["AlternateMailboxes"] = 65] = "AlternateMailboxes";
    /**
     * The version of the Client Access Server serving the request (e.g. 14.XX.YYY.ZZZ)
     */
    UserSettingName[UserSettingName["CasVersion"] = 66] = "CasVersion";
    /**
     * Comma-separated list of schema versions supported by Exchange Web Services. The schema version values  /// will be the same as the values of the ExchangeServerVersion enumeration.
     */
    UserSettingName[UserSettingName["EwsSupportedSchemas"] = 67] = "EwsSupportedSchemas";
    /**
     * The internal connection settings list for pop protocol
     */
    UserSettingName[UserSettingName["InternalPop3Connections"] = 68] = "InternalPop3Connections";
    /**
     * The external connection settings list for pop protocol
     */
    UserSettingName[UserSettingName["ExternalPop3Connections"] = 69] = "ExternalPop3Connections";
    /**
     * The internal connection settings list for imap4 protocol
     */
    UserSettingName[UserSettingName["InternalImap4Connections"] = 70] = "InternalImap4Connections";
    /**
     * The external connection settings list for imap4 protocol
     */
    UserSettingName[UserSettingName["ExternalImap4Connections"] = 71] = "ExternalImap4Connections";
    /**
     * The internal connection settings list for smtp protocol
     */
    UserSettingName[UserSettingName["InternalSmtpConnections"] = 72] = "InternalSmtpConnections";
    /**
     * The external connection settings list for smtp protocol
     */
    UserSettingName[UserSettingName["ExternalSmtpConnections"] = 73] = "ExternalSmtpConnections";
    /**
     * If set to "Off" then clients should not connect via this protocol.  /// The protocol contents are for informational purposes only.
     */
    UserSettingName[UserSettingName["InternalServerExclusiveConnect"] = 74] = "InternalServerExclusiveConnect";
    /**
     * The version of the Exchange Web Services server ExternalEwsUrl is pointing to.
     */
    UserSettingName[UserSettingName["ExternalEwsVersion"] = 75] = "ExternalEwsVersion";
    /**
     * Mobile Mailbox policy settings.
     */
    UserSettingName[UserSettingName["MobileMailboxPolicy"] = 76] = "MobileMailboxPolicy";
    /**
     * Document sharing locations and their settings.
     */
    UserSettingName[UserSettingName["DocumentSharingLocations"] = 77] = "DocumentSharingLocations";
    /**
     * Whether the user account is an MSOnline account.
     */
    UserSettingName[UserSettingName["UserMSOnline"] = 78] = "UserMSOnline";
    /**
     * The authentication methods supported by the RPC client server.
     */
    UserSettingName[UserSettingName["InternalMailboxServerAuthenticationMethods"] = 79] = "InternalMailboxServerAuthenticationMethods";
    /**
     * Version of the server hosting the user's mailbox.
     */
    UserSettingName[UserSettingName["MailboxVersion"] = 80] = "MailboxVersion";
    /**
     * Sharepoint MySite Host URL.
     */
    UserSettingName[UserSettingName["SPMySiteHostURL"] = 81] = "SPMySiteHostURL";
    /**
     * Site mailbox creation URL in SharePoint.
     */
    /// </summary>
    UserSettingName[UserSettingName["SiteMailboxCreationURL"] = 82] = "SiteMailboxCreationURL";
    /**
     * The FQDN of the server used for internal RPC/HTTP connectivity.
     */
    UserSettingName[UserSettingName["InternalRpcHttpServer"] = 83] = "InternalRpcHttpServer";
    /**
     * Indicates whether SSL is required for internal RPC/HTTP connectivity.
     */
    UserSettingName[UserSettingName["InternalRpcHttpConnectivityRequiresSsl"] = 84] = "InternalRpcHttpConnectivityRequiresSsl";
    /**
     * The authentication method used for internal RPC/HTTP connectivity.
     */
    UserSettingName[UserSettingName["InternalRpcHttpAuthenticationMethod"] = 85] = "InternalRpcHttpAuthenticationMethod";
    /**
     * If set to "On" then clients should only connect via this protocol.
     */
    UserSettingName[UserSettingName["ExternalServerExclusiveConnect"] = 86] = "ExternalServerExclusiveConnect";
    /**
     * If set, then clients can call the server via XTC
     */
    UserSettingName[UserSettingName["ExchangeRpcUrl"] = 87] = "ExchangeRpcUrl";
    /**
     * If set to false then clients should not show the GAL by default, but show the contact list.
     */
    UserSettingName[UserSettingName["ShowGalAsDefaultView"] = 88] = "ShowGalAsDefaultView";
    /**
     * AutoDiscover Primary SMTP Address for the user.
     */
    UserSettingName[UserSettingName["AutoDiscoverSMTPAddress"] = 89] = "AutoDiscoverSMTPAddress";
    /**
     * The 'interop' external URL of the Exchange Web Services.  /// By interop it means a URL to E14 (or later) server that can serve mailboxes  /// that are hosted in downlevel server (E2K3 and earlier).
     */
    UserSettingName[UserSettingName["InteropExternalEwsUrl"] = 90] = "InteropExternalEwsUrl";
    /**
     * Version of server InteropExternalEwsUrl is pointing to.
     */
    UserSettingName[UserSettingName["InteropExternalEwsVersion"] = 91] = "InteropExternalEwsVersion";
    /**
     * Public Folder (Hierarchy) information
     */
    UserSettingName[UserSettingName["PublicFolderInformation"] = 92] = "PublicFolderInformation";
    /**
     * The version appropriate URL of the AutoDiscover service that should answer this query.
     */
    UserSettingName[UserSettingName["RedirectUrl"] = 93] = "RedirectUrl";
    /**
     * The URL of the Exchange Web Services for Office365 partners.
     */
    UserSettingName[UserSettingName["EwsPartnerUrl"] = 94] = "EwsPartnerUrl";
    /**
     * SSL certificate name
     */
    UserSettingName[UserSettingName["CertPrincipalName"] = 95] = "CertPrincipalName";
    /**
     * The grouping hint for certain clients.
     */
    UserSettingName[UserSettingName["GroupingInformation"] = 96] = "GroupingInformation";
    /**
     * MapiHttpEnabled ///todo: not available any more in official repo
     */
    UserSettingName[UserSettingName["MapiHttpEnabled"] = 97] = "MapiHttpEnabled";
    /**
     * Internal OutlookService URL
     */
    UserSettingName[UserSettingName["InternalOutlookServiceUrl"] = 98] = "InternalOutlookServiceUrl";
    /**
     * External OutlookService URL
     */
    UserSettingName[UserSettingName["ExternalOutlookServiceUrl"] = 99] = "ExternalOutlookServiceUrl";
})(UserSettingName = exports.UserSettingName || (exports.UserSettingName = {}));
/**
 * Defines the view filter for queries.
 */
var ViewFilter;
(function (ViewFilter) {
    /**
     * Show all item (no filter)
     */
    ViewFilter[ViewFilter["All"] = 0] = "All";
    /**
     * Item has flag
     */
    ViewFilter[ViewFilter["Flagged"] = 1] = "Flagged";
    /**
     * Item has attachment
     */
    ViewFilter[ViewFilter["HasAttachment"] = 2] = "HasAttachment";
    /**
     * Item is to or cc me
     */
    ViewFilter[ViewFilter["ToOrCcMe"] = 3] = "ToOrCcMe";
    /**
     * Item is unread
     */
    ViewFilter[ViewFilter["Unread"] = 4] = "Unread";
    /**
     * Active task items
     */
    ViewFilter[ViewFilter["TaskActive"] = 5] = "TaskActive";
    /**
     * Overdue task items
     */
    ViewFilter[ViewFilter["TaskOverdue"] = 6] = "TaskOverdue";
    /**
     * Completed task items
     */
    ViewFilter[ViewFilter["TaskCompleted"] = 7] = "TaskCompleted";
    /**
     * Suggestions (aka Predicted Actions) from the Inference engine
     */
    ViewFilter[ViewFilter["Suggestions"] = 8] = "Suggestions";
    /**
     * Respond suggestions
     */
    ViewFilter[ViewFilter["SuggestionsRespond"] = 9] = "SuggestionsRespond";
    /**
     * Delete suggestions
     */
    ViewFilter[ViewFilter["SuggestionsDelete"] = 10] = "SuggestionsDelete";
})(ViewFilter = exports.ViewFilter || (exports.ViewFilter = {}));
(function (ViewFilter) {
    /**RequiredServerVersionAttribute */
    function RequiredServerVersion(value) {
        if (value <= 10)
            return ExchangeVersion.Exchange2013;
        return ExchangeVersion.Exchange_Version_Not_Updated;
    }
    ViewFilter.RequiredServerVersion = RequiredServerVersion;
})(ViewFilter = exports.ViewFilter || (exports.ViewFilter = {}));
/**
 * The values in this enumeration must match the values of the DistinguishedFolderIdNameType type in the schema.
 */
var WellKnownFolderName;
(function (WellKnownFolderName) {
    /**
     * The Calendar folder.
     */
    WellKnownFolderName[WellKnownFolderName["Calendar"] = 0] = "Calendar";
    /**
     * The Contacts folder.
     */
    WellKnownFolderName[WellKnownFolderName["Contacts"] = 1] = "Contacts";
    /**
     * The Deleted Items folder
     */
    WellKnownFolderName[WellKnownFolderName["DeletedItems"] = 2] = "DeletedItems";
    /**
     * The Drafts folder.
     */
    WellKnownFolderName[WellKnownFolderName["Drafts"] = 3] = "Drafts";
    /**
     * The Inbox folder.
     */
    WellKnownFolderName[WellKnownFolderName["Inbox"] = 4] = "Inbox";
    /**
     * The Journal folder.
     */
    WellKnownFolderName[WellKnownFolderName["Journal"] = 5] = "Journal";
    /**
     * The Notes folder.
     */
    WellKnownFolderName[WellKnownFolderName["Notes"] = 6] = "Notes";
    /**
     * The Outbox folder.
     */
    WellKnownFolderName[WellKnownFolderName["Outbox"] = 7] = "Outbox";
    /**
     * The Sent Items folder.
     */
    WellKnownFolderName[WellKnownFolderName["SentItems"] = 8] = "SentItems";
    /**
     * The Tasks folder.
     */
    WellKnownFolderName[WellKnownFolderName["Tasks"] = 9] = "Tasks";
    /**
     * The message folder root.
     */
    WellKnownFolderName[WellKnownFolderName["MsgFolderRoot"] = 10] = "MsgFolderRoot";
    /**
     * The root of the Public Folders hierarchy.
     */
    WellKnownFolderName[WellKnownFolderName["PublicFoldersRoot"] = 11] = "PublicFoldersRoot";
    /**
     * The root of the mailbox.
     */
    WellKnownFolderName[WellKnownFolderName["Root"] = 12] = "Root";
    /**
     * The Junk E-mail folder.
     */
    WellKnownFolderName[WellKnownFolderName["JunkEmail"] = 13] = "JunkEmail";
    /**
     * The Search Folders folder, also known as the Finder folder.
     */
    WellKnownFolderName[WellKnownFolderName["SearchFolders"] = 14] = "SearchFolders";
    /**
     * The Voicemail folder.
     */
    WellKnownFolderName[WellKnownFolderName["VoiceMail"] = 15] = "VoiceMail";
    /**
     * The Dumpster 2.0 root folder.
     */
    WellKnownFolderName[WellKnownFolderName["RecoverableItemsRoot"] = 16] = "RecoverableItemsRoot";
    /**
     * The Dumpster 2.0 soft deletions folder.
     */
    WellKnownFolderName[WellKnownFolderName["RecoverableItemsDeletions"] = 17] = "RecoverableItemsDeletions";
    /**
     * The Dumpster 2.0 versions folder.
     */
    WellKnownFolderName[WellKnownFolderName["RecoverableItemsVersions"] = 18] = "RecoverableItemsVersions";
    /**
     * The Dumpster 2.0 hard deletions folder.
     */
    WellKnownFolderName[WellKnownFolderName["RecoverableItemsPurges"] = 19] = "RecoverableItemsPurges";
    /**
     * The Dumpster 2.0 discovery hold folder
     */
    WellKnownFolderName[WellKnownFolderName["RecoverableItemsDiscoveryHolds"] = 20] = "RecoverableItemsDiscoveryHolds";
    /**
     * The root of the archive mailbox.
     */
    WellKnownFolderName[WellKnownFolderName["ArchiveRoot"] = 21] = "ArchiveRoot";
    /**
     * The root of the archive mailbox.
     */
    WellKnownFolderName[WellKnownFolderName["ArchiveInbox"] = 22] = "ArchiveInbox";
    /**
     * The message folder root in the archive mailbox.
     */
    WellKnownFolderName[WellKnownFolderName["ArchiveMsgFolderRoot"] = 23] = "ArchiveMsgFolderRoot";
    /**
     * The Deleted Items folder in the archive mailbox
     */
    WellKnownFolderName[WellKnownFolderName["ArchiveDeletedItems"] = 24] = "ArchiveDeletedItems";
    /**
     * The Dumpster 2.0 root folder in the archive mailbox.
     */
    WellKnownFolderName[WellKnownFolderName["ArchiveRecoverableItemsRoot"] = 25] = "ArchiveRecoverableItemsRoot";
    /**
     * The Dumpster 2.0 soft deletions folder in the archive mailbox.
     */
    WellKnownFolderName[WellKnownFolderName["ArchiveRecoverableItemsDeletions"] = 26] = "ArchiveRecoverableItemsDeletions";
    /**
     * The Dumpster 2.0 versions folder in the archive mailbox.
     */
    WellKnownFolderName[WellKnownFolderName["ArchiveRecoverableItemsVersions"] = 27] = "ArchiveRecoverableItemsVersions";
    /**
     * The Dumpster 2.0 hard deletions folder in the archive mailbox.
     */
    WellKnownFolderName[WellKnownFolderName["ArchiveRecoverableItemsPurges"] = 28] = "ArchiveRecoverableItemsPurges";
    /**
     * The Dumpster 2.0 discovery hold folder in the archive mailbox.
     */
    WellKnownFolderName[WellKnownFolderName["ArchiveRecoverableItemsDiscoveryHolds"] = 29] = "ArchiveRecoverableItemsDiscoveryHolds";
    /**
     * The Sync Issues folder.
     */
    WellKnownFolderName[WellKnownFolderName["SyncIssues"] = 30] = "SyncIssues";
    /**
     * The Conflicts folder
     */
    WellKnownFolderName[WellKnownFolderName["Conflicts"] = 31] = "Conflicts";
    /**
     * The Local failures folder
     */
    WellKnownFolderName[WellKnownFolderName["LocalFailures"] = 32] = "LocalFailures";
    /**
     * The Server failures folder
     */
    WellKnownFolderName[WellKnownFolderName["ServerFailures"] = 33] = "ServerFailures";
    /**
     * The Recipient Cache folder
     */
    WellKnownFolderName[WellKnownFolderName["RecipientCache"] = 34] = "RecipientCache";
    /**
     * The Quick Contacts folder
     */
    WellKnownFolderName[WellKnownFolderName["QuickContacts"] = 35] = "QuickContacts";
    /**
     * Conversation history folder
     */
    WellKnownFolderName[WellKnownFolderName["ConversationHistory"] = 36] = "ConversationHistory";
    /**
     * AdminAuditLogs folder
     */
    WellKnownFolderName[WellKnownFolderName["AdminAuditLogs"] = 37] = "AdminAuditLogs";
    /**
     * ToDo search folder
     */
    WellKnownFolderName[WellKnownFolderName["ToDoSearch"] = 38] = "ToDoSearch";
    /**
     * MyContacts folder
     */
    WellKnownFolderName[WellKnownFolderName["MyContacts"] = 39] = "MyContacts";
    /**
     * Directory (GAL)
     * It is not a mailbox folder. It only indicates any GAL operation.
     */
    WellKnownFolderName[WellKnownFolderName["Directory"] = 40] = "Directory";
    /**
     * IMContactList folder
     */
    WellKnownFolderName[WellKnownFolderName["IMContactList"] = 41] = "IMContactList";
    /**
     * PeopleConnect folder
     */
    WellKnownFolderName[WellKnownFolderName["PeopleConnect"] = 42] = "PeopleConnect";
    /**
     * Favorites folder
     */
    WellKnownFolderName[WellKnownFolderName["Favorites"] = 43] = "Favorites";
})(WellKnownFolderName = exports.WellKnownFolderName || (exports.WellKnownFolderName = {}));
(function (WellKnownFolderName) {
    /**RequiredServerVersionAttribute */
    function RequiredServerVersion(value) {
        if (value <= 15)
            return ExchangeVersion.Exchange2007_SP1;
        if (value <= 28 && [20, 22].indexOf(value) < 0)
            return ExchangeVersion.Exchange2010_SP1;
        if (value >= 27 && value <= 43)
            return ExchangeVersion.Exchange2013;
        if ([20, 22, 29, 40].indexOf(value) >= 0)
            return ExchangeVersion.Exchange2013_SP1;
        return ExchangeVersion.Exchange_Version_Not_Updated;
    }
    WellKnownFolderName.RequiredServerVersion = RequiredServerVersion;
})(WellKnownFolderName = exports.WellKnownFolderName || (exports.WellKnownFolderName = {}));
/**
 * @internal Defines the namespaces as used by the EwsXmlReader, EwsServiceXmlReader, and EwsServiceXmlWriter classes.
 */
var XmlNamespace;
(function (XmlNamespace) {
    /**
     * The namespace is not specified.
     */
    XmlNamespace[XmlNamespace["NotSpecified"] = 0] = "NotSpecified";
    /**
     * The EWS Messages namespace.
     */
    XmlNamespace[XmlNamespace["Messages"] = 1] = "Messages";
    /**
     * The EWS Types namespace.
     */
    XmlNamespace[XmlNamespace["Types"] = 2] = "Types";
    /**
     * The EWS Errors namespace.
     */
    XmlNamespace[XmlNamespace["Errors"] = 3] = "Errors";
    /**
     * The SOAP 1.1 namespace.
     */
    XmlNamespace[XmlNamespace["Soap"] = 4] = "Soap";
    /**
     * The SOAP 1.2 namespace.
     */
    XmlNamespace[XmlNamespace["Soap12"] = 5] = "Soap12";
    /**
     * XmlSchema-Instance namespace.
     */
    XmlNamespace[XmlNamespace["XmlSchemaInstance"] = 6] = "XmlSchemaInstance";
    /**
     * The Passport SOAP services SOAP fault namespace.
     */
    XmlNamespace[XmlNamespace["PassportSoapFault"] = 7] = "PassportSoapFault";
    /**
     * The WS-Trust February 2005 namespace.
     */
    XmlNamespace[XmlNamespace["WSTrustFebruary2005"] = 8] = "WSTrustFebruary2005";
    /**
     * The WS Addressing 1.0 namespace.
     */
    XmlNamespace[XmlNamespace["WSAddressing"] = 9] = "WSAddressing";
    /**
     * The Autodiscover SOAP service namespace.
     */
    XmlNamespace[XmlNamespace["Autodiscover"] = 10] = "Autodiscover";
})(XmlNamespace = exports.XmlNamespace || (exports.XmlNamespace = {}));
var LazyMember = (function () {
    /// <summary>
    /// Constructor
    /// </summary>
    /// <param name="initializationDelegate">The initialization delegate to call for the item on first access
    /// </param>
    function LazyMember(initializationDelegate) {
        this.initialized = false;
        this.initializationDelegate = initializationDelegate;
    }
    Object.defineProperty(LazyMember.prototype, "Member", {
        get: function () {
            if (!this.initialized) {
                //lock(this.lockObject)
                //{
                if (!this.initialized) {
                    this.lazyMember = this.initializationDelegate();
                }
                this.initialized = true;
                //}
            }
            return this.lazyMember;
        },
        enumerable: true,
        configurable: true
    });
    return LazyMember;
}());
exports.LazyMember = LazyMember;
/*@Updated <from SourceTree description>
 * Commit: 154dbc66ac018d861c73ce489839cd9f58a1b0cd [154dbc6]
 * Parents: 67756e1846, a9a3297c0f
 * Author: David Claux <dclaux@users.noreply.github.com>
 * Date: Friday, December 4, 2015 3:14:27 AM
 * Labels: upstream/master, origin/master, master
 * Merge pull request #71 from ysanghi/master
 *
 * Publishing Latest Updates from Microsoft
 */
/**
 * XML attribute names.
 */
var XmlAttributeNames;
(function (XmlAttributeNames) {
    XmlAttributeNames.XmlNs = "xmlns";
    XmlAttributeNames.Id = "Id";
    XmlAttributeNames.ChangeKey = "ChangeKey";
    XmlAttributeNames.RecurringMasterId = "RecurringMasterId";
    XmlAttributeNames.InstanceIndex = "InstanceIndex";
    XmlAttributeNames.OccurrenceId = "OccurrenceId";
    XmlAttributeNames.Traversal = "Traversal";
    XmlAttributeNames.ViewFilter = "ViewFilter";
    XmlAttributeNames.Offset = "Offset";
    XmlAttributeNames.MaxEntriesReturned = "MaxEntriesReturned";
    XmlAttributeNames.BasePoint = "BasePoint";
    XmlAttributeNames.ResponseClass = "ResponseClass";
    XmlAttributeNames.IndexedPagingOffset = "IndexedPagingOffset";
    XmlAttributeNames.TotalItemsInView = "TotalItemsInView";
    XmlAttributeNames.IncludesLastItemInRange = "IncludesLastItemInRange";
    XmlAttributeNames.BodyType = "BodyType";
    XmlAttributeNames.MessageDisposition = "MessageDisposition";
    XmlAttributeNames.SaveItemToFolder = "SaveItemToFolder";
    XmlAttributeNames.RootItemChangeKey = "RootItemChangeKey";
    XmlAttributeNames.DeleteType = "DeleteType";
    XmlAttributeNames.DeleteSubFolders = "DeleteSubFolders";
    XmlAttributeNames.AffectedTaskOccurrences = "AffectedTaskOccurrences";
    XmlAttributeNames.SendMeetingCancellations = "SendMeetingCancellations";
    XmlAttributeNames.SuppressReadReceipts = "SuppressReadReceipts"; //XmlElementNames.SuppressReadReceipts;
    XmlAttributeNames.FieldURI = "FieldURI";
    XmlAttributeNames.FieldIndex = "FieldIndex";
    XmlAttributeNames.ConflictResolution = "ConflictResolution";
    XmlAttributeNames.SendMeetingInvitationsOrCancellations = "SendMeetingInvitationsOrCancellations";
    XmlAttributeNames.CharacterSet = "CharacterSet";
    XmlAttributeNames.HeaderName = "HeaderName";
    XmlAttributeNames.SendMeetingInvitations = "SendMeetingInvitations";
    XmlAttributeNames.Key = "Key";
    XmlAttributeNames.RoutingType = "RoutingType";
    XmlAttributeNames.MailboxType = "MailboxType";
    XmlAttributeNames.DistinguishedPropertySetId = "DistinguishedPropertySetId";
    XmlAttributeNames.PropertySetId = "PropertySetId";
    XmlAttributeNames.PropertyTag = "PropertyTag";
    XmlAttributeNames.PropertyName = "PropertyName";
    XmlAttributeNames.PropertyId = "PropertyId";
    XmlAttributeNames.PropertyType = "PropertyType";
    XmlAttributeNames.TimeZoneName = "TimeZoneName";
    XmlAttributeNames.ReturnFullContactData = "ReturnFullContactData";
    XmlAttributeNames.ContactDataShape = "ContactDataShape";
    XmlAttributeNames.Numerator = "Numerator";
    XmlAttributeNames.Denominator = "Numerator";
    XmlAttributeNames.Value = "Value";
    XmlAttributeNames.ContainmentMode = "ContainmentMode";
    XmlAttributeNames.ContainmentComparison = "ContainmentComparison";
    XmlAttributeNames.Order = "Order";
    XmlAttributeNames.StartDate = "StartDate";
    XmlAttributeNames.EndDate = "EndDate";
    XmlAttributeNames.Version = "Version";
    XmlAttributeNames.Aggregate = "Aggregate";
    XmlAttributeNames.SearchScope = "SearchScope";
    XmlAttributeNames.Format = "Format";
    XmlAttributeNames.Mailbox = "Mailbox";
    XmlAttributeNames.DestinationFormat = "DestinationFormat";
    XmlAttributeNames.FolderId = "FolderId";
    XmlAttributeNames.ItemId = "ItemId";
    XmlAttributeNames.IncludePermissions = "IncludePermissions";
    XmlAttributeNames.InitialName = "InitialName";
    XmlAttributeNames.FinalName = "FinalName";
    XmlAttributeNames.AuthenticationMethod = "AuthenticationMethod";
    XmlAttributeNames.Time = "Time";
    XmlAttributeNames.Name = "Name";
    XmlAttributeNames.Bias = "Bias";
    XmlAttributeNames.Kind = "Kind";
    XmlAttributeNames.SubscribeToAllFolders = "SubscribeToAllFolders";
    XmlAttributeNames.PublicFolderServer = "PublicFolderServer";
    XmlAttributeNames.IsArchive = "IsArchive";
    XmlAttributeNames.ReturnHighlightTerms = "ReturnHighlightTerms";
    XmlAttributeNames.IsExplicit = "IsExplicit";
    XmlAttributeNames.ClientExtensionUserIdentity = "UserId";
    XmlAttributeNames.ClientExtensionEnabledOnly = "EnabledOnly";
    XmlAttributeNames.SetClientExtensionActionId = "ActionId";
    XmlAttributeNames.ClientExtensionId = "ExtensionId";
    XmlAttributeNames.ClientExtensionIsAvailable = "IsAvailable";
    XmlAttributeNames.ClientExtensionIsMandatory = "IsMandatory";
    XmlAttributeNames.ClientExtensionIsEnabledByDefault = "IsEnabledByDefault";
    XmlAttributeNames.ClientExtensionProvidedTo = "ProvidedTo";
    XmlAttributeNames.ClientExtensionType = "Type";
    XmlAttributeNames.ClientExtensionScope = "Scope";
    XmlAttributeNames.ClientExtensionMarketplaceAssetID = "MarketplaceAssetId";
    XmlAttributeNames.ClientExtensionMarketplaceContentMarket = "MarketplaceContentMarket";
    XmlAttributeNames.ClientExtensionAppStatus = "AppStatus";
    XmlAttributeNames.ClientExtensionEtoken = "Etoken";
    XmlAttributeNames.ClientExtensionInstalledDateTime = "InstalledDateTime";
    XmlAttributeNames.IsTruncated = "IsTruncated";
    XmlAttributeNames.IsJunk = "IsJunk";
    XmlAttributeNames.MoveItem = "MoveItem";
    // xsi attributes
    XmlAttributeNames.Nil = "nil";
    XmlAttributeNames.Type = "type";
})(XmlAttributeNames = exports.XmlAttributeNames || (exports.XmlAttributeNames = {}));
/*@Updated <from SourceTree description>
 * Commit: 154dbc66ac018d861c73ce489839cd9f58a1b0cd [154dbc6]
 * Parents: 67756e1846, a9a3297c0f
 * Author: David Claux <dclaux@users.noreply.github.com>
 * Date: Friday, December 4, 2015 3:14:27 AM
 * Labels: upstream/master, origin/master, master
 * Merge pull request #71 from ysanghi/master
 *
 * Publishing Latest Updates from Microsoft
 */
/**
 * XML element names.
 */
var XmlElementNames;
(function (XmlElementNames) {
    XmlElementNames.AllProperties = "AllProperties";
    XmlElementNames.ParentFolderIds = "ParentFolderIds";
    XmlElementNames.DistinguishedFolderId = "DistinguishedFolderId";
    XmlElementNames.ItemId = "ItemId";
    XmlElementNames.ItemIds = "ItemIds";
    XmlElementNames.FolderId = "FolderId";
    XmlElementNames.FolderIds = "FolderIds";
    XmlElementNames.SourceId = "SourceId";
    XmlElementNames.OccurrenceItemId = "OccurrenceItemId";
    XmlElementNames.RecurringMasterItemId = "RecurringMasterItemId";
    XmlElementNames.ItemShape = "ItemShape";
    XmlElementNames.FolderShape = "FolderShape";
    XmlElementNames.BaseShape = "BaseShape";
    XmlElementNames.IndexedPageItemView = "IndexedPageItemView";
    XmlElementNames.IndexedPageFolderView = "IndexedPageFolderView";
    XmlElementNames.FractionalPageItemView = "FractionalPageItemView";
    XmlElementNames.FractionalPageFolderView = "FractionalPageFolderView";
    XmlElementNames.SeekToConditionPageItemView = "SeekToConditionPageItemView";
    XmlElementNames.ResponseCode = "ResponseCode";
    XmlElementNames.RootFolder = "RootFolder";
    XmlElementNames.Folder = "Folder";
    XmlElementNames.ContactsFolder = "ContactsFolder";
    XmlElementNames.TasksFolder = "TasksFolder";
    XmlElementNames.SearchFolder = "SearchFolder";
    XmlElementNames.Folders = "Folders";
    XmlElementNames.Item = "Item";
    XmlElementNames.Items = "Items";
    XmlElementNames.Message = "Message";
    XmlElementNames.Mailbox = "Mailbox";
    XmlElementNames.Body = "Body";
    XmlElementNames.From = "From";
    XmlElementNames.Sender = "Sender";
    XmlElementNames.Name = "Name";
    XmlElementNames.Address = "Address";
    XmlElementNames.EmailAddress = "EmailAddress";
    XmlElementNames.RoutingType = "RoutingType";
    XmlElementNames.MailboxType = "MailboxType";
    XmlElementNames.ToRecipients = "ToRecipients";
    XmlElementNames.CcRecipients = "CcRecipients";
    XmlElementNames.BccRecipients = "BccRecipients";
    XmlElementNames.ReplyTo = "ReplyTo";
    XmlElementNames.ConversationTopic = "ConversationTopic";
    XmlElementNames.ConversationIndex = "ConversationIndex";
    XmlElementNames.IsDeliveryReceiptRequested = "IsDeliveryReceiptRequested";
    XmlElementNames.IsRead = "IsRead";
    XmlElementNames.IsReadReceiptRequested = "IsReadReceiptRequested";
    XmlElementNames.IsResponseRequested = "IsResponseRequested";
    XmlElementNames.InternetMessageId = "InternetMessageId";
    XmlElementNames.References = "References";
    XmlElementNames.ParentItemId = "ParentItemId";
    XmlElementNames.ParentFolderId = "ParentFolderId";
    XmlElementNames.ChildFolderCount = "ChildFolderCount";
    XmlElementNames.DisplayName = "DisplayName";
    XmlElementNames.TotalCount = "TotalCount";
    XmlElementNames.ItemClass = "ItemClass";
    XmlElementNames.FolderClass = "FolderClass";
    XmlElementNames.Subject = "Subject";
    XmlElementNames.MimeContent = "MimeContent";
    XmlElementNames.MimeContentUTF8 = "MimeContentUTF8";
    XmlElementNames.Sensitivity = "Sensitivity";
    XmlElementNames.Attachments = "Attachments";
    XmlElementNames.DateTimeReceived = "DateTimeReceived";
    XmlElementNames.Size = "Size";
    XmlElementNames.Categories = "Categories";
    XmlElementNames.Importance = "Importance";
    XmlElementNames.InReplyTo = "InReplyTo";
    XmlElementNames.IsSubmitted = "IsSubmitted";
    XmlElementNames.IsAssociated = "IsAssociated";
    XmlElementNames.IsDraft = "IsDraft";
    XmlElementNames.IsFromMe = "IsFromMe";
    XmlElementNames.IsHidden = "IsHidden";
    XmlElementNames.IsQuickContact = "IsQuickContact";
    XmlElementNames.IsResend = "IsResend";
    XmlElementNames.IsUnmodified = "IsUnmodified";
    XmlElementNames.IsWritable = "IsWritable";
    XmlElementNames.InternetMessageHeader = "InternetMessageHeader";
    XmlElementNames.InternetMessageHeaders = "InternetMessageHeaders";
    XmlElementNames.DateTimeSent = "DateTimeSent";
    XmlElementNames.DateTimeCreated = "DateTimeCreated";
    XmlElementNames.ResponseObjects = "ResponseObjects";
    XmlElementNames.ReminderDueBy = "ReminderDueBy";
    XmlElementNames.ReminderIsSet = "ReminderIsSet";
    XmlElementNames.ReminderMinutesBeforeStart = "ReminderMinutesBeforeStart";
    XmlElementNames.DisplayCc = "DisplayCc";
    XmlElementNames.DisplayTo = "DisplayTo";
    XmlElementNames.HasAttachments = "HasAttachments";
    XmlElementNames.ExtendedProperty = "ExtendedProperty";
    XmlElementNames.Culture = "Culture";
    XmlElementNames.FileAttachment = "FileAttachment";
    XmlElementNames.ItemAttachment = "ItemAttachment";
    XmlElementNames.AttachmentIds = "AttachmentIds";
    XmlElementNames.AttachmentId = "AttachmentId";
    XmlElementNames.ContentType = "ContentType";
    XmlElementNames.ContentLocation = "ContentLocation";
    XmlElementNames.ContentId = "ContentId";
    XmlElementNames.Content = "Content";
    XmlElementNames.SavedItemFolderId = "SavedItemFolderId";
    XmlElementNames.MessageText = "MessageText";
    XmlElementNames.DescriptiveLinkKey = "DescriptiveLinkKey";
    XmlElementNames.ItemChange = "ItemChange";
    XmlElementNames.ItemChanges = "ItemChanges";
    XmlElementNames.FolderChange = "FolderChange";
    XmlElementNames.FolderChanges = "FolderChanges";
    XmlElementNames.Updates = "Updates";
    XmlElementNames.AppendToItemField = "AppendToItemField";
    XmlElementNames.SetItemField = "SetItemField";
    XmlElementNames.DeleteItemField = "DeleteItemField";
    XmlElementNames.SetFolderField = "SetFolderField";
    XmlElementNames.DeleteFolderField = "DeleteFolderField";
    XmlElementNames.FieldURI = "FieldURI";
    XmlElementNames.RootItemId = "RootItemId";
    XmlElementNames.ReferenceItemId = "ReferenceItemId";
    XmlElementNames.NewBodyContent = "NewBodyContent";
    XmlElementNames.ReplyToItem = "ReplyToItem";
    XmlElementNames.ReplyAllToItem = "ReplyAllToItem";
    XmlElementNames.ForwardItem = "ForwardItem";
    XmlElementNames.AcceptItem = "AcceptItem";
    XmlElementNames.TentativelyAcceptItem = "TentativelyAcceptItem";
    XmlElementNames.DeclineItem = "DeclineItem";
    XmlElementNames.CancelCalendarItem = "CancelCalendarItem";
    XmlElementNames.RemoveItem = "RemoveItem";
    XmlElementNames.SuppressReadReceipt = "SuppressReadReceipt";
    XmlElementNames.SuppressReadReceipts = "SuppressReadReceipts";
    XmlElementNames.String = "String";
    XmlElementNames.Start = "Start";
    XmlElementNames.End = "End";
    XmlElementNames.ProposedStart = "ProposedStart";
    XmlElementNames.ProposedEnd = "ProposedEnd";
    XmlElementNames.OriginalStart = "OriginalStart";
    XmlElementNames.IsAllDayEvent = "IsAllDayEvent";
    XmlElementNames.LegacyFreeBusyStatus = "LegacyFreeBusyStatus";
    XmlElementNames.Location = "Location";
    XmlElementNames.When = "When";
    XmlElementNames.IsMeeting = "IsMeeting";
    XmlElementNames.IsCancelled = "IsCancelled";
    XmlElementNames.IsRecurring = "IsRecurring";
    XmlElementNames.MeetingRequestWasSent = "MeetingRequestWasSent";
    XmlElementNames.CalendarItemType = "CalendarItemType";
    XmlElementNames.MyResponseType = "MyResponseType";
    XmlElementNames.Organizer = "Organizer";
    XmlElementNames.RequiredAttendees = "RequiredAttendees";
    XmlElementNames.OptionalAttendees = "OptionalAttendees";
    XmlElementNames.Resources = "Resources";
    XmlElementNames.ConflictingMeetingCount = "ConflictingMeetingCount";
    XmlElementNames.AdjacentMeetingCount = "AdjacentMeetingCount";
    XmlElementNames.ConflictingMeetings = "ConflictingMeetings";
    XmlElementNames.AdjacentMeetings = "AdjacentMeetings";
    XmlElementNames.Duration = "Duration";
    XmlElementNames.TimeZone = "TimeZone";
    XmlElementNames.AppointmentReplyTime = "AppointmentReplyTime";
    XmlElementNames.AppointmentSequenceNumber = "AppointmentSequenceNumber";
    XmlElementNames.AppointmentState = "AppointmentState";
    XmlElementNames.Recurrence = "Recurrence";
    XmlElementNames.FirstOccurrence = "FirstOccurrence";
    XmlElementNames.LastOccurrence = "LastOccurrence";
    XmlElementNames.ModifiedOccurrences = "ModifiedOccurrences";
    XmlElementNames.DeletedOccurrences = "DeletedOccurrences";
    XmlElementNames.MeetingTimeZone = "MeetingTimeZone";
    XmlElementNames.ConferenceType = "ConferenceType";
    XmlElementNames.AllowNewTimeProposal = "AllowNewTimeProposal";
    XmlElementNames.IsOnlineMeeting = "IsOnlineMeeting";
    XmlElementNames.MeetingWorkspaceUrl = "MeetingWorkspaceUrl";
    XmlElementNames.NetShowUrl = "NetShowUrl";
    XmlElementNames.JoinOnlineMeetingUrl = "JoinOnlineMeetingUrl";
    XmlElementNames.OnlineMeetingSettings = "OnlineMeetingSettings";
    XmlElementNames.LobbyBypass = "LobbyBypass";
    XmlElementNames.AccessLevel = "AccessLevel";
    XmlElementNames.Presenters = "Presenters";
    XmlElementNames.CalendarItem = "CalendarItem";
    XmlElementNames.CalendarFolder = "CalendarFolder";
    XmlElementNames.Attendee = "Attendee";
    XmlElementNames.ResponseType = "ResponseType";
    XmlElementNames.LastResponseTime = "LastResponseTime";
    XmlElementNames.Occurrence = "Occurrence";
    XmlElementNames.DeletedOccurrence = "DeletedOccurrence";
    XmlElementNames.RelativeYearlyRecurrence = "RelativeYearlyRecurrence";
    XmlElementNames.AbsoluteYearlyRecurrence = "AbsoluteYearlyRecurrence";
    XmlElementNames.RelativeMonthlyRecurrence = "RelativeMonthlyRecurrence";
    XmlElementNames.AbsoluteMonthlyRecurrence = "AbsoluteMonthlyRecurrence";
    XmlElementNames.WeeklyRecurrence = "WeeklyRecurrence";
    XmlElementNames.DailyRecurrence = "DailyRecurrence";
    XmlElementNames.DailyRegeneration = "DailyRegeneration";
    XmlElementNames.WeeklyRegeneration = "WeeklyRegeneration";
    XmlElementNames.MonthlyRegeneration = "MonthlyRegeneration";
    XmlElementNames.YearlyRegeneration = "YearlyRegeneration";
    XmlElementNames.NoEndRecurrence = "NoEndRecurrence";
    XmlElementNames.EndDateRecurrence = "EndDateRecurrence";
    XmlElementNames.NumberedRecurrence = "NumberedRecurrence";
    XmlElementNames.Interval = "Interval";
    XmlElementNames.DayOfMonth = "DayOfMonth";
    XmlElementNames.DayOfWeek = "DayOfWeek";
    XmlElementNames.DaysOfWeek = "DaysOfWeek";
    XmlElementNames.DayOfWeekIndex = "DayOfWeekIndex";
    XmlElementNames.Month = "Month";
    XmlElementNames.StartDate = "StartDate";
    XmlElementNames.EndDate = "EndDate";
    XmlElementNames.StartTime = "StartTime";
    XmlElementNames.EndTime = "EndTime";
    XmlElementNames.NumberOfOccurrences = "NumberOfOccurrences";
    XmlElementNames.AssociatedCalendarItemId = "AssociatedCalendarItemId";
    XmlElementNames.IsDelegated = "IsDelegated";
    XmlElementNames.IsOutOfDate = "IsOutOfDate";
    XmlElementNames.HasBeenProcessed = "HasBeenProcessed";
    XmlElementNames.IsOrganizer = "IsOrganizer";
    XmlElementNames.MeetingMessage = "MeetingMessage";
    XmlElementNames.FileAs = "FileAs";
    XmlElementNames.FileAsMapping = "FileAsMapping";
    XmlElementNames.GivenName = "GivenName";
    XmlElementNames.Initials = "Initials";
    XmlElementNames.MiddleName = "MiddleName";
    XmlElementNames.NickName = "Nickname";
    XmlElementNames.CompleteName = "CompleteName";
    XmlElementNames.CompanyName = "CompanyName";
    XmlElementNames.EmailAddresses = "EmailAddresses";
    XmlElementNames.PhysicalAddresses = "PhysicalAddresses";
    XmlElementNames.PhoneNumbers = "PhoneNumbers";
    XmlElementNames.PhoneNumber = "PhoneNumber";
    XmlElementNames.AssistantName = "AssistantName";
    XmlElementNames.Birthday = "Birthday";
    XmlElementNames.BusinessHomePage = "BusinessHomePage";
    XmlElementNames.Children = "Children";
    XmlElementNames.Companies = "Companies";
    XmlElementNames.ContactSource = "ContactSource";
    XmlElementNames.Department = "Department";
    XmlElementNames.Generation = "Generation";
    XmlElementNames.ImAddresses = "ImAddresses";
    XmlElementNames.ImAddress = "ImAddress";
    XmlElementNames.JobTitle = "JobTitle";
    XmlElementNames.Manager = "Manager";
    XmlElementNames.Mileage = "Mileage";
    XmlElementNames.OfficeLocation = "OfficeLocation";
    XmlElementNames.PostalAddressIndex = "PostalAddressIndex";
    XmlElementNames.Profession = "Profession";
    XmlElementNames.SpouseName = "SpouseName";
    XmlElementNames.Surname = "Surname";
    XmlElementNames.WeddingAnniversary = "WeddingAnniversary";
    XmlElementNames.HasPicture = "HasPicture";
    XmlElementNames.Title = "Title";
    XmlElementNames.FirstName = "FirstName";
    XmlElementNames.LastName = "LastName";
    XmlElementNames.Suffix = "Suffix";
    XmlElementNames.FullName = "FullName";
    XmlElementNames.YomiFirstName = "YomiFirstName";
    XmlElementNames.YomiLastName = "YomiLastName";
    XmlElementNames.Contact = "Contact";
    XmlElementNames.Entry = "Entry";
    XmlElementNames.Street = "Street";
    XmlElementNames.City = "City";
    XmlElementNames.State = "State";
    XmlElementNames.SharePointSiteUrl = "SharePointSiteUrl";
    XmlElementNames.Country = "Country";
    XmlElementNames.CountryOrRegion = "CountryOrRegion";
    XmlElementNames.PostalCode = "PostalCode";
    XmlElementNames.PostOfficeBox = "PostOfficeBox";
    XmlElementNames.Members = "Members";
    XmlElementNames.Member = "Member";
    XmlElementNames.AdditionalProperties = "AdditionalProperties";
    XmlElementNames.ExtendedFieldURI = "ExtendedFieldURI";
    XmlElementNames.Value = "Value";
    XmlElementNames.Values = "Values";
    XmlElementNames.ToFolderId = "ToFolderId";
    XmlElementNames.ActualWork = "ActualWork";
    XmlElementNames.AssignedTime = "AssignedTime";
    XmlElementNames.BillingInformation = "BillingInformation";
    XmlElementNames.ChangeCount = "ChangeCount";
    XmlElementNames.CompleteDate = "CompleteDate";
    XmlElementNames.Contacts = "Contacts";
    XmlElementNames.DelegationState = "DelegationState";
    XmlElementNames.Delegator = "Delegator";
    XmlElementNames.DueDate = "DueDate";
    XmlElementNames.IsAssignmentEditable = "IsAssignmentEditable";
    XmlElementNames.IsComplete = "IsComplete";
    XmlElementNames.IsTeamTask = "IsTeamTask";
    XmlElementNames.Owner = "Owner";
    XmlElementNames.PercentComplete = "PercentComplete";
    XmlElementNames.Status = "Status";
    XmlElementNames.StatusDescription = "StatusDescription";
    XmlElementNames.TotalWork = "TotalWork";
    XmlElementNames.Task = "Task";
    XmlElementNames.MailboxCulture = "MailboxCulture";
    XmlElementNames.MeetingRequestType = "MeetingRequestType";
    XmlElementNames.IntendedFreeBusyStatus = "IntendedFreeBusyStatus";
    XmlElementNames.MeetingRequest = "MeetingRequest";
    XmlElementNames.MeetingResponse = "MeetingResponse";
    XmlElementNames.MeetingCancellation = "MeetingCancellation";
    XmlElementNames.ChangeHighlights = "ChangeHighlights";
    XmlElementNames.HasLocationChanged = "HasLocationChanged";
    XmlElementNames.HasStartTimeChanged = "HasStartTimeChanged";
    XmlElementNames.HasEndTimeChanged = "HasEndTimeChanged";
    XmlElementNames.BaseOffset = "BaseOffset";
    XmlElementNames.Offset = "Offset";
    XmlElementNames.Standard = "Standard";
    XmlElementNames.Daylight = "Daylight";
    XmlElementNames.Time = "Time";
    XmlElementNames.AbsoluteDate = "AbsoluteDate";
    XmlElementNames.UnresolvedEntry = "UnresolvedEntry";
    XmlElementNames.ResolutionSet = "ResolutionSet";
    XmlElementNames.Resolution = "Resolution";
    XmlElementNames.DistributionList = "DistributionList";
    XmlElementNames.DLExpansion = "DLExpansion";
    XmlElementNames.IndexedFieldURI = "IndexedFieldURI";
    XmlElementNames.PullSubscriptionRequest = "PullSubscriptionRequest";
    XmlElementNames.PushSubscriptionRequest = "PushSubscriptionRequest";
    XmlElementNames.StreamingSubscriptionRequest = "StreamingSubscriptionRequest";
    XmlElementNames.EventTypes = "EventTypes";
    XmlElementNames.EventType = "EventType";
    XmlElementNames.Timeout = "Timeout";
    XmlElementNames.Watermark = "Watermark";
    XmlElementNames.SubscriptionId = "SubscriptionId";
    XmlElementNames.SubscriptionIds = "SubscriptionIds";
    XmlElementNames.StatusFrequency = "StatusFrequency";
    XmlElementNames.URL = "URL";
    XmlElementNames.CallerData = "CallerData";
    XmlElementNames.Notification = "Notification";
    XmlElementNames.Notifications = "Notifications";
    XmlElementNames.PreviousWatermark = "PreviousWatermark";
    XmlElementNames.MoreEvents = "MoreEvents";
    XmlElementNames.TimeStamp = "TimeStamp";
    XmlElementNames.UnreadCount = "UnreadCount";
    XmlElementNames.OldParentFolderId = "OldParentFolderId";
    XmlElementNames.CopiedEvent = "CopiedEvent";
    XmlElementNames.CreatedEvent = "CreatedEvent";
    XmlElementNames.DeletedEvent = "DeletedEvent";
    XmlElementNames.ModifiedEvent = "ModifiedEvent";
    XmlElementNames.MovedEvent = "MovedEvent";
    XmlElementNames.NewMailEvent = "NewMailEvent";
    XmlElementNames.StatusEvent = "StatusEvent";
    XmlElementNames.FreeBusyChangedEvent = "FreeBusyChangedEvent";
    XmlElementNames.ExchangeImpersonation = "ExchangeImpersonation";
    XmlElementNames.ConnectingSID = "ConnectingSID";
    XmlElementNames.OpenAsAdminOrSystemService = "OpenAsAdminOrSystemService";
    XmlElementNames.LogonType = "LogonType";
    XmlElementNames.BudgetType = "BudgetType";
    XmlElementNames.ManagementRole = "ManagementRole";
    XmlElementNames.UserRoles = "UserRoles";
    XmlElementNames.ApplicationRoles = "ApplicationRoles";
    XmlElementNames.Role = "Role";
    XmlElementNames.SyncFolderId = "SyncFolderId";
    XmlElementNames.SyncScope = "SyncScope";
    XmlElementNames.SyncState = "SyncState";
    XmlElementNames.Ignore = "Ignore";
    XmlElementNames.MaxChangesReturned = "MaxChangesReturned";
    XmlElementNames.Changes = "Changes";
    XmlElementNames.IncludesLastItemInRange = "IncludesLastItemInRange";
    XmlElementNames.IncludesLastFolderInRange = "IncludesLastFolderInRange";
    XmlElementNames.Create = "Create";
    XmlElementNames.Update = "Update";
    XmlElementNames.Delete = "Delete";
    XmlElementNames.ReadFlagChange = "ReadFlagChange";
    XmlElementNames.SearchParameters = "SearchParameters";
    XmlElementNames.SoftDeleted = "SoftDeleted";
    XmlElementNames.Shallow = "Shallow";
    XmlElementNames.Associated = "Associated";
    XmlElementNames.BaseFolderId = "BaseFolderId";
    XmlElementNames.BaseFolderIds = "BaseFolderIds";
    XmlElementNames.SortOrder = "SortOrder";
    XmlElementNames.FieldOrder = "FieldOrder";
    XmlElementNames.CanDelete = "CanDelete";
    XmlElementNames.CanRenameOrMove = "CanRenameOrMove";
    XmlElementNames.MustDisplayComment = "MustDisplayComment";
    XmlElementNames.HasQuota = "HasQuota";
    XmlElementNames.IsManagedFoldersRoot = "IsManagedFoldersRoot";
    XmlElementNames.ManagedFolderId = "ManagedFolderId";
    XmlElementNames.Comment = "Comment";
    XmlElementNames.StorageQuota = "StorageQuota";
    XmlElementNames.FolderSize = "FolderSize";
    XmlElementNames.HomePage = "HomePage";
    XmlElementNames.ManagedFolderInformation = "ManagedFolderInformation";
    XmlElementNames.CalendarView = "CalendarView";
    XmlElementNames.PostedTime = "PostedTime";
    XmlElementNames.PostItem = "PostItem";
    XmlElementNames.RequestServerVersion = "RequestServerVersion";
    XmlElementNames.PostReplyItem = "PostReplyItem";
    XmlElementNames.CreateAssociated = "CreateAssociated";
    XmlElementNames.CreateContents = "CreateContents";
    XmlElementNames.CreateHierarchy = "CreateHierarchy";
    XmlElementNames.Modify = "Modify";
    XmlElementNames.Read = "Read";
    XmlElementNames.EffectiveRights = "EffectiveRights";
    XmlElementNames.LastModifiedName = "LastModifiedName";
    XmlElementNames.LastModifiedTime = "LastModifiedTime";
    XmlElementNames.ConversationId = "ConversationId";
    XmlElementNames.UniqueBody = "UniqueBody";
    XmlElementNames.BodyType = "BodyType";
    XmlElementNames.NormalizedBodyType = "NormalizedBodyType";
    XmlElementNames.UniqueBodyType = "UniqueBodyType";
    XmlElementNames.AttachmentShape = "AttachmentShape";
    XmlElementNames.UserId = "UserId";
    XmlElementNames.UserIds = "UserIds";
    XmlElementNames.CanCreateItems = "CanCreateItems";
    XmlElementNames.CanCreateSubFolders = "CanCreateSubFolders";
    XmlElementNames.IsFolderOwner = "IsFolderOwner";
    XmlElementNames.IsFolderVisible = "IsFolderVisible";
    XmlElementNames.IsFolderContact = "IsFolderContact";
    XmlElementNames.EditItems = "EditItems";
    XmlElementNames.DeleteItems = "DeleteItems";
    XmlElementNames.ReadItems = "ReadItems";
    XmlElementNames.PermissionLevel = "PermissionLevel";
    XmlElementNames.CalendarPermissionLevel = "CalendarPermissionLevel";
    XmlElementNames.SID = "SID";
    XmlElementNames.PrimarySmtpAddress = "PrimarySmtpAddress";
    XmlElementNames.DistinguishedUser = "DistinguishedUser";
    XmlElementNames.PermissionSet = "PermissionSet";
    XmlElementNames.Permissions = "Permissions";
    XmlElementNames.Permission = "Permission";
    XmlElementNames.CalendarPermissions = "CalendarPermissions";
    XmlElementNames.CalendarPermission = "CalendarPermission";
    XmlElementNames.GroupBy = "GroupBy";
    XmlElementNames.AggregateOn = "AggregateOn";
    XmlElementNames.Groups = "Groups";
    XmlElementNames.GroupedItems = "GroupedItems";
    XmlElementNames.GroupIndex = "GroupIndex";
    XmlElementNames.ConflictResults = "ConflictResults";
    XmlElementNames.Count = "Count";
    XmlElementNames.OofSettings = "OofSettings";
    XmlElementNames.UserOofSettings = "UserOofSettings";
    XmlElementNames.OofState = "OofState";
    XmlElementNames.ExternalAudience = "ExternalAudience";
    XmlElementNames.AllowExternalOof = "AllowExternalOof";
    XmlElementNames.InternalReply = "InternalReply";
    XmlElementNames.ExternalReply = "ExternalReply";
    XmlElementNames.Bias = "Bias";
    XmlElementNames.DayOrder = "DayOrder";
    XmlElementNames.Year = "Year";
    XmlElementNames.StandardTime = "StandardTime";
    XmlElementNames.DaylightTime = "DaylightTime";
    XmlElementNames.MailboxData = "MailboxData";
    XmlElementNames.MailboxDataArray = "MailboxDataArray";
    XmlElementNames.Email = "Email";
    XmlElementNames.AttendeeType = "AttendeeType";
    XmlElementNames.ExcludeConflicts = "ExcludeConflicts";
    XmlElementNames.FreeBusyViewOptions = "FreeBusyViewOptions";
    XmlElementNames.SuggestionsViewOptions = "SuggestionsViewOptions";
    XmlElementNames.FreeBusyView = "FreeBusyView";
    XmlElementNames.TimeWindow = "TimeWindow";
    XmlElementNames.MergedFreeBusyIntervalInMinutes = "MergedFreeBusyIntervalInMinutes";
    XmlElementNames.RequestedView = "RequestedView";
    XmlElementNames.FreeBusyViewType = "FreeBusyViewType";
    XmlElementNames.CalendarEventArray = "CalendarEventArray";
    XmlElementNames.CalendarEvent = "CalendarEvent";
    XmlElementNames.BusyType = "BusyType";
    XmlElementNames.MergedFreeBusy = "MergedFreeBusy";
    XmlElementNames.WorkingHours = "WorkingHours";
    XmlElementNames.WorkingPeriodArray = "WorkingPeriodArray";
    XmlElementNames.WorkingPeriod = "WorkingPeriod";
    XmlElementNames.StartTimeInMinutes = "StartTimeInMinutes";
    XmlElementNames.EndTimeInMinutes = "EndTimeInMinutes";
    XmlElementNames.GoodThreshold = "GoodThreshold";
    XmlElementNames.MaximumResultsByDay = "MaximumResultsByDay";
    XmlElementNames.MaximumNonWorkHourResultsByDay = "MaximumNonWorkHourResultsByDay";
    XmlElementNames.MeetingDurationInMinutes = "MeetingDurationInMinutes";
    XmlElementNames.MinimumSuggestionQuality = "MinimumSuggestionQuality";
    XmlElementNames.DetailedSuggestionsWindow = "DetailedSuggestionsWindow";
    XmlElementNames.CurrentMeetingTime = "CurrentMeetingTime";
    XmlElementNames.GlobalObjectId = "GlobalObjectId";
    XmlElementNames.SuggestionDayResultArray = "SuggestionDayResultArray";
    XmlElementNames.SuggestionDayResult = "SuggestionDayResult";
    XmlElementNames.Date = "Date";
    XmlElementNames.DayQuality = "DayQuality";
    XmlElementNames.SuggestionArray = "SuggestionArray";
    XmlElementNames.Suggestion = "Suggestion";
    XmlElementNames.MeetingTime = "MeetingTime";
    XmlElementNames.IsWorkTime = "IsWorkTime";
    XmlElementNames.SuggestionQuality = "SuggestionQuality";
    XmlElementNames.AttendeeConflictDataArray = "AttendeeConflictDataArray";
    XmlElementNames.UnknownAttendeeConflictData = "UnknownAttendeeConflictData";
    XmlElementNames.TooBigGroupAttendeeConflictData = "TooBigGroupAttendeeConflictData";
    XmlElementNames.IndividualAttendeeConflictData = "IndividualAttendeeConflictData";
    XmlElementNames.GroupAttendeeConflictData = "GroupAttendeeConflictData";
    XmlElementNames.NumberOfMembers = "NumberOfMembers";
    XmlElementNames.NumberOfMembersAvailable = "NumberOfMembersAvailable";
    XmlElementNames.NumberOfMembersWithConflict = "NumberOfMembersWithConflict";
    XmlElementNames.NumberOfMembersWithNoData = "NumberOfMembersWithNoData";
    XmlElementNames.SourceIds = "SourceIds";
    XmlElementNames.AlternateId = "AlternateId";
    XmlElementNames.AlternatePublicFolderId = "AlternatePublicFolderId";
    XmlElementNames.AlternatePublicFolderItemId = "AlternatePublicFolderItemId";
    XmlElementNames.DelegatePermissions = "DelegatePermissions";
    XmlElementNames.ReceiveCopiesOfMeetingMessages = "ReceiveCopiesOfMeetingMessages";
    XmlElementNames.ViewPrivateItems = "ViewPrivateItems";
    XmlElementNames.CalendarFolderPermissionLevel = "CalendarFolderPermissionLevel";
    XmlElementNames.TasksFolderPermissionLevel = "TasksFolderPermissionLevel";
    XmlElementNames.InboxFolderPermissionLevel = "InboxFolderPermissionLevel";
    XmlElementNames.ContactsFolderPermissionLevel = "ContactsFolderPermissionLevel";
    XmlElementNames.NotesFolderPermissionLevel = "NotesFolderPermissionLevel";
    XmlElementNames.JournalFolderPermissionLevel = "JournalFolderPermissionLevel";
    XmlElementNames.DelegateUser = "DelegateUser";
    XmlElementNames.DelegateUsers = "DelegateUsers";
    XmlElementNames.DeliverMeetingRequests = "DeliverMeetingRequests";
    XmlElementNames.MessageXml = "MessageXml";
    XmlElementNames.UserConfiguration = "UserConfiguration";
    XmlElementNames.UserConfigurationName = "UserConfigurationName";
    XmlElementNames.UserConfigurationProperties = "UserConfigurationProperties";
    XmlElementNames.Dictionary = "Dictionary";
    XmlElementNames.DictionaryEntry = "DictionaryEntry";
    XmlElementNames.DictionaryKey = "DictionaryKey";
    XmlElementNames.DictionaryValue = "DictionaryValue";
    XmlElementNames.XmlData = "XmlData";
    XmlElementNames.BinaryData = "BinaryData";
    XmlElementNames.FilterHtmlContent = "FilterHtmlContent";
    XmlElementNames.ConvertHtmlCodePageToUTF8 = "ConvertHtmlCodePageToUTF8";
    XmlElementNames.UnknownEntries = "UnknownEntries";
    XmlElementNames.UnknownEntry = "UnknownEntry";
    XmlElementNames.PasswordExpirationDate = "PasswordExpirationDate";
    XmlElementNames.Flag = "Flag";
    XmlElementNames.PersonaPostalAddress = "PostalAddress";
    XmlElementNames.PostalAddressType = "Type";
    XmlElementNames.EnhancedLocation = "EnhancedLocation";
    XmlElementNames.LocationDisplayName = "DisplayName";
    XmlElementNames.LocationAnnotation = "Annotation";
    XmlElementNames.LocationSource = "LocationSource";
    XmlElementNames.LocationUri = "LocationUri";
    XmlElementNames.Latitude = "Latitude";
    XmlElementNames.Longitude = "Longitude";
    XmlElementNames.Accuracy = "Accuracy";
    XmlElementNames.Altitude = "Altitude";
    XmlElementNames.AltitudeAccuracy = "AltitudeAccuracy";
    XmlElementNames.FormattedAddress = "FormattedAddress";
    XmlElementNames.Guid = "Guid";
    XmlElementNames.PhoneCallId = "PhoneCallId";
    XmlElementNames.DialString = "DialString";
    XmlElementNames.PhoneCallInformation = "PhoneCallInformation";
    XmlElementNames.PhoneCallState = "PhoneCallState";
    XmlElementNames.ConnectionFailureCause = "ConnectionFailureCause";
    XmlElementNames.SIPResponseCode = "SIPResponseCode";
    XmlElementNames.SIPResponseText = "SIPResponseText";
    XmlElementNames.WebClientReadFormQueryString = "WebClientReadFormQueryString";
    XmlElementNames.WebClientEditFormQueryString = "WebClientEditFormQueryString";
    XmlElementNames.Ids = "Ids";
    XmlElementNames.Id = "Id";
    XmlElementNames.TimeZoneDefinitions = "TimeZoneDefinitions";
    XmlElementNames.TimeZoneDefinition = "TimeZoneDefinition";
    XmlElementNames.Periods = "Periods";
    XmlElementNames.Period = "Period";
    XmlElementNames.TransitionsGroups = "TransitionsGroups";
    XmlElementNames.TransitionsGroup = "TransitionsGroup";
    XmlElementNames.Transitions = "Transitions";
    XmlElementNames.Transition = "Transition";
    XmlElementNames.AbsoluteDateTransition = "AbsoluteDateTransition";
    XmlElementNames.RecurringDayTransition = "RecurringDayTransition";
    XmlElementNames.RecurringDateTransition = "RecurringDateTransition";
    XmlElementNames.DateTime = "DateTime";
    XmlElementNames.TimeOffset = "TimeOffset";
    XmlElementNames.Day = "Day";
    XmlElementNames.TimeZoneContext = "TimeZoneContext";
    XmlElementNames.StartTimeZone = "StartTimeZone";
    XmlElementNames.EndTimeZone = "EndTimeZone";
    XmlElementNames.ReceivedBy = "ReceivedBy";
    XmlElementNames.ReceivedRepresenting = "ReceivedRepresenting";
    XmlElementNames.Uid = "UID";
    XmlElementNames.RecurrenceId = "RecurrenceId";
    XmlElementNames.DateTimeStamp = "DateTimeStamp";
    XmlElementNames.IsInline = "IsInline";
    XmlElementNames.IsContactPhoto = "IsContactPhoto";
    XmlElementNames.QueryString = "QueryString";
    XmlElementNames.HighlightTerms = "HighlightTerms";
    XmlElementNames.HighlightTerm = "Term";
    XmlElementNames.HighlightTermScope = "Scope";
    XmlElementNames.HighlightTermValue = "Value";
    XmlElementNames.CalendarEventDetails = "CalendarEventDetails";
    XmlElementNames.ID = "ID";
    XmlElementNames.IsException = "IsException";
    XmlElementNames.IsReminderSet = "IsReminderSet";
    XmlElementNames.IsPrivate = "IsPrivate";
    XmlElementNames.FirstDayOfWeek = "FirstDayOfWeek";
    XmlElementNames.Verb = "Verb";
    XmlElementNames.Parameter = "Parameter";
    XmlElementNames.ReturnValue = "ReturnValue";
    XmlElementNames.ReturnNewItemIds = "ReturnNewItemIds";
    XmlElementNames.DateTimePrecision = "DateTimePrecision";
    XmlElementNames.ConvertInlineImagesToDataUrls = "ConvertInlineImagesToDataUrls";
    XmlElementNames.InlineImageUrlTemplate = "InlineImageUrlTemplate";
    XmlElementNames.BlockExternalImages = "BlockExternalImages";
    XmlElementNames.AddBlankTargetToLinks = "AddBlankTargetToLinks";
    XmlElementNames.MaximumBodySize = "MaximumBodySize";
    XmlElementNames.StoreEntryId = "StoreEntryId";
    XmlElementNames.InstanceKey = "InstanceKey";
    XmlElementNames.NormalizedBody = "NormalizedBody";
    XmlElementNames.PolicyTag = "PolicyTag";
    XmlElementNames.ArchiveTag = "ArchiveTag";
    XmlElementNames.RetentionDate = "RetentionDate";
    XmlElementNames.DisableReason = "DisableReason";
    XmlElementNames.AppMarketplaceUrl = "AppMarketplaceUrl";
    XmlElementNames.TextBody = "TextBody";
    XmlElementNames.IconIndex = "IconIndex";
    XmlElementNames.GlobalIconIndex = "GlobalIconIndex";
    XmlElementNames.DraftItemIds = "DraftItemIds";
    XmlElementNames.HasIrm = "HasIrm";
    XmlElementNames.GlobalHasIrm = "GlobalHasIrm";
    XmlElementNames.ApprovalRequestData = "ApprovalRequestData";
    XmlElementNames.IsUndecidedApprovalRequest = "IsUndecidedApprovalRequest";
    XmlElementNames.ApprovalDecision = "ApprovalDecision";
    XmlElementNames.ApprovalDecisionMaker = "ApprovalDecisionMaker";
    XmlElementNames.ApprovalDecisionTime = "ApprovalDecisionTime";
    XmlElementNames.VotingOptionData = "VotingOptionData";
    XmlElementNames.VotingOptionDisplayName = "DisplayName";
    XmlElementNames.SendPrompt = "SendPrompt";
    XmlElementNames.VotingInformation = "VotingInformation";
    XmlElementNames.UserOptions = "UserOptions";
    XmlElementNames.VotingResponse = "VotingResponse";
    XmlElementNames.NumberOfDays = "NumberOfDays";
    XmlElementNames.AcceptanceState = "AcceptanceState";
    XmlElementNames.NlgEntityExtractionResult = "EntityExtractionResult";
    XmlElementNames.NlgAddresses = "Addresses";
    XmlElementNames.NlgAddress = "Address";
    XmlElementNames.NlgMeetingSuggestions = "MeetingSuggestions";
    XmlElementNames.NlgMeetingSuggestion = "MeetingSuggestion";
    XmlElementNames.NlgTaskSuggestions = "TaskSuggestions";
    XmlElementNames.NlgTaskSuggestion = "TaskSuggestion";
    XmlElementNames.NlgBusinessName = "BusinessName";
    XmlElementNames.NlgPeopleName = "PeopleName";
    XmlElementNames.NlgEmailAddresses = "EmailAddresses";
    XmlElementNames.NlgEmailAddress = "EmailAddress";
    XmlElementNames.NlgEmailPosition = "Position";
    XmlElementNames.NlgContacts = "Contacts";
    XmlElementNames.NlgContact = "Contact";
    XmlElementNames.NlgContactString = "ContactString";
    XmlElementNames.NlgUrls = "Urls";
    XmlElementNames.NlgUrl = "Url";
    XmlElementNames.NlgPhoneNumbers = "PhoneNumbers";
    XmlElementNames.NlgPhone = "Phone";
    XmlElementNames.NlgAttendees = "Attendees";
    XmlElementNames.NlgEmailUser = "EmailUser";
    XmlElementNames.NlgLocation = "Location";
    XmlElementNames.NlgSubject = "Subject";
    XmlElementNames.NlgMeetingString = "MeetingString";
    XmlElementNames.NlgStartTime = "StartTime";
    XmlElementNames.NlgEndTime = "EndTime";
    XmlElementNames.NlgTaskString = "TaskString";
    XmlElementNames.NlgAssignees = "Assignees";
    XmlElementNames.NlgPersonName = "PersonName";
    XmlElementNames.NlgOriginalPhoneString = "OriginalPhoneString";
    XmlElementNames.NlgPhoneString = "PhoneString";
    XmlElementNames.NlgType = "Type";
    XmlElementNames.NlgName = "Name";
    XmlElementNames.NlgUserId = "UserId";
    XmlElementNames.GetClientAccessToken = "GetClientAccessToken";
    XmlElementNames.GetClientAccessTokenResponse = "GetClientAccessTokenResponse";
    XmlElementNames.GetClientAccessTokenResponseMessage = "GetClientAccessTokenResponseMessage";
    XmlElementNames.TokenRequests = "TokenRequests";
    XmlElementNames.TokenRequest = "TokenRequest";
    XmlElementNames.TokenType = "TokenType";
    XmlElementNames.TokenValue = "TokenValue";
    XmlElementNames.TTL = "TTL";
    XmlElementNames.Tokens = "Tokens";
    XmlElementNames.MarkAsJunk = "MarkAsJunk";
    XmlElementNames.MarkAsJunkResponse = "MarkAsJunkResponse";
    XmlElementNames.MarkAsJunkResponseMessage = "MarkAsJunkResponseMessage";
    XmlElementNames.MovedItemId = "MovedItemId";
    /* #region Persona */
    XmlElementNames.CreationTime = "CreationTime";
    XmlElementNames.People = "People";
    XmlElementNames.Persona = "Persona";
    XmlElementNames.PersonaId = "PersonaId";
    XmlElementNames.PersonaShape = "PersonaShape";
    XmlElementNames.RelevanceScore = "RelevanceScore";
    XmlElementNames.TotalNumberOfPeopleInView = "TotalNumberOfPeopleInView";
    XmlElementNames.FirstMatchingRowIndex = "FirstMatchingRowIndex";
    XmlElementNames.FirstLoadedRowIndex = "FirstLoadedRowIndex";
    XmlElementNames.YomiCompanyName = "YomiCompanyName";
    XmlElementNames.Emails1 = "Emails1";
    XmlElementNames.Emails2 = "Emails2";
    XmlElementNames.Emails3 = "Emails3";
    XmlElementNames.HomeAddresses = "HomeAddresses";
    XmlElementNames.BusinessAddresses = "BusinessAddresses";
    XmlElementNames.OtherAddresses = "OtherAddresses";
    XmlElementNames.BusinessPhoneNumbers = "BusinessPhoneNumbers";
    XmlElementNames.BusinessPhoneNumbers2 = "BusinessPhoneNumbers2";
    XmlElementNames.AssistantPhoneNumbers = "AssistantPhoneNumbers";
    XmlElementNames.TTYTDDPhoneNumbers = "TTYTDDPhoneNumbers";
    XmlElementNames.HomePhones = "HomePhones";
    XmlElementNames.HomePhones2 = "HomePhones2";
    XmlElementNames.MobilePhones = "MobilePhones";
    XmlElementNames.MobilePhones2 = "MobilePhones2";
    XmlElementNames.CallbackPhones = "CallbackPhones";
    XmlElementNames.CarPhones = "CarPhones";
    XmlElementNames.HomeFaxes = "HomeFaxes";
    XmlElementNames.OrganizationMainPhones = "OrganizationMainPhones";
    XmlElementNames.OtherFaxes = "OtherFaxes";
    XmlElementNames.OtherTelephones = "OtherTelephones";
    XmlElementNames.OtherPhones2 = "OtherPhones2";
    XmlElementNames.Pagers = "Pagers";
    XmlElementNames.RadioPhones = "RadioPhones";
    XmlElementNames.TelexNumbers = "TelexNumbers";
    XmlElementNames.WorkFaxes = "WorkFaxes";
    XmlElementNames.FileAses = "FileAses";
    XmlElementNames.CompanyNames = "CompanyNames";
    XmlElementNames.DisplayNames = "DisplayNames";
    XmlElementNames.DisplayNamePrefixes = "DisplayNamePrefixes";
    XmlElementNames.GivenNames = "GivenNames";
    XmlElementNames.MiddleNames = "MiddleNames";
    XmlElementNames.Surnames = "Surnames";
    XmlElementNames.Generations = "Generations";
    XmlElementNames.Nicknames = "Nicknames";
    XmlElementNames.YomiCompanyNames = "YomiCompanyNames";
    XmlElementNames.YomiFirstNames = "YomiFirstNames";
    XmlElementNames.YomiLastNames = "YomiLastNames";
    XmlElementNames.Managers = "Managers";
    XmlElementNames.AssistantNames = "AssistantNames";
    XmlElementNames.Professions = "Professions";
    XmlElementNames.SpouseNames = "SpouseNames";
    XmlElementNames.Departments = "Departments";
    XmlElementNames.Titles = "Titles";
    XmlElementNames.ImAddresses2 = "ImAddresses2";
    XmlElementNames.ImAddresses3 = "ImAddresses3";
    XmlElementNames.DisplayNamePrefix = "DisplayNamePrefix";
    XmlElementNames.DisplayNameFirstLast = "DisplayNameFirstLast";
    XmlElementNames.DisplayNameLastFirst = "DisplayNameLastFirst";
    XmlElementNames.DisplayNameFirstLastHeader = "DisplayNameFirstLastHeader";
    XmlElementNames.DisplayNameLastFirstHeader = "DisplayNameLastFirstHeader";
    XmlElementNames.IsFavorite = "IsFavorite";
    XmlElementNames.Schools = "Schools";
    XmlElementNames.Hobbies = "Hobbies";
    XmlElementNames.Locations = "Locations";
    XmlElementNames.OfficeLocations = "OfficeLocations";
    XmlElementNames.BusinessHomePages = "BusinessHomePages";
    XmlElementNames.PersonalHomePages = "PersonalHomePages";
    XmlElementNames.ThirdPartyPhotoUrls = "ThirdPartyPhotoUrls";
    XmlElementNames.Attribution = "Attribution";
    XmlElementNames.Attributions = "Attributions";
    XmlElementNames.StringAttributedValue = "StringAttributedValue";
    XmlElementNames.DisplayNameFirstLastSortKey = "DisplayNameFirstLastSortKey";
    XmlElementNames.DisplayNameLastFirstSortKey = "DisplayNameLastFirstSortKey";
    XmlElementNames.CompanyNameSortKey = "CompanyNameSortKey";
    XmlElementNames.HomeCitySortKey = "HomeCitySortKey";
    XmlElementNames.WorkCitySortKey = "WorkCitySortKey";
    XmlElementNames.FileAsId = "FileAsId";
    XmlElementNames.FileAsIds = "FileAsIds";
    XmlElementNames.HomeCity = "HomeCity";
    XmlElementNames.WorkCity = "WorkCity";
    XmlElementNames.PersonaType = "PersonaType";
    XmlElementNames.Birthdays = "Birthdays";
    XmlElementNames.BirthdaysLocal = "BirthdaysLocal";
    XmlElementNames.WeddingAnniversaries = "WeddingAnniversaries";
    XmlElementNames.WeddingAnniversariesLocal = "WeddingAnniversariesLocal";
    XmlElementNames.OriginalDisplayName = "OriginalDisplayName";
    /* #endregion */
    /* #region People Insights */
    XmlElementNames.Person = "Person";
    XmlElementNames.Insights = "Insights";
    XmlElementNames.Insight = "Insight";
    XmlElementNames.InsightGroupType = "InsightGroupType";
    XmlElementNames.InsightType = "InsightType";
    XmlElementNames.InsightSourceType = "InsightSourceType";
    XmlElementNames.InsightValue = "InsightValue";
    XmlElementNames.InsightSource = "InsightSource";
    XmlElementNames.UpdatedUtcTicks = "UpdatedUtcTicks";
    XmlElementNames.StringInsightValue = "StringInsightValue";
    XmlElementNames.ProfileInsightValue = "ProfileInsightValue";
    XmlElementNames.JobInsightValue = "JobInsightValue";
    XmlElementNames.UserProfilePicture = "UserProfilePicture";
    XmlElementNames.EducationInsightValue = "EducationInsightValue";
    XmlElementNames.SkillInsightValue = "SkillInsightValue";
    XmlElementNames.DelveDoc = "DelveDoc";
    XmlElementNames.CompanyInsightValue = "CompanyInsightValue";
    XmlElementNames.ArrayOfInsightValue = "ArrayOfInsightValue";
    XmlElementNames.InsightContent = "InsightContent";
    XmlElementNames.SingleValueInsightContent = "SingleValueInsightContent";
    XmlElementNames.MultiValueInsightContent = "MultiValueInsightContent";
    XmlElementNames.ArrayOfInsight = "ArrayOfInsight";
    XmlElementNames.PersonType = "PersonType";
    XmlElementNames.SatoriId = "SatoriId";
    XmlElementNames.DescriptionAttribution = "DescriptionAttribution";
    XmlElementNames.ImageUrl = "ImageUrl";
    XmlElementNames.ImageUrlAttribution = "ImageUrlAttribution";
    XmlElementNames.YearFound = "YearFound";
    XmlElementNames.FinanceSymbol = "FinanceSymbol";
    XmlElementNames.WebsiteUrl = "WebsiteUrl";
    XmlElementNames.Rank = "Rank";
    XmlElementNames.Author = "Author";
    XmlElementNames.Created = "Created";
    XmlElementNames.DefaultEncodingURL = "DefaultEncodingURL";
    XmlElementNames.FileType = "FileType";
    XmlElementNames.Data = "Data";
    XmlElementNames.ItemList = "ItemList";
    XmlElementNames.Avatar = "Avatar";
    XmlElementNames.JoinedUtcTicks = "JoinedUtcTicks";
    XmlElementNames.Company = "Company";
    XmlElementNames.StartUtcTicks = "StartUtcTicks";
    XmlElementNames.EndUtcTicks = "EndUtcTicks";
    XmlElementNames.Blob = "Blob";
    XmlElementNames.PhotoSize = "PhotoSize";
    XmlElementNames.Institute = "Institute";
    XmlElementNames.Degree = "Degree";
    XmlElementNames.Strength = "Strength";
    /* #endregion */
    /* #region Conversations */
    XmlElementNames.Conversations = "Conversations";
    XmlElementNames.Conversation = "Conversation";
    XmlElementNames.UniqueRecipients = "UniqueRecipients";
    XmlElementNames.GlobalUniqueRecipients = "GlobalUniqueRecipients";
    XmlElementNames.UniqueUnreadSenders = "UniqueUnreadSenders";
    XmlElementNames.GlobalUniqueUnreadSenders = "GlobalUniqueUnreadSenders";
    XmlElementNames.UniqueSenders = "UniqueSenders";
    XmlElementNames.GlobalUniqueSenders = "GlobalUniqueSenders";
    XmlElementNames.LastDeliveryTime = "LastDeliveryTime";
    XmlElementNames.GlobalLastDeliveryTime = "GlobalLastDeliveryTime";
    XmlElementNames.GlobalCategories = "GlobalCategories";
    XmlElementNames.FlagStatus = "FlagStatus";
    XmlElementNames.GlobalFlagStatus = "GlobalFlagStatus";
    XmlElementNames.GlobalHasAttachments = "GlobalHasAttachments";
    XmlElementNames.MessageCount = "MessageCount";
    XmlElementNames.GlobalMessageCount = "GlobalMessageCount";
    XmlElementNames.GlobalUnreadCount = "GlobalUnreadCount";
    XmlElementNames.GlobalSize = "GlobalSize";
    XmlElementNames.ItemClasses = "ItemClasses";
    XmlElementNames.GlobalItemClasses = "GlobalItemClasses";
    XmlElementNames.GlobalImportance = "GlobalImportance";
    XmlElementNames.GlobalInferredImportance = "GlobalInferredImportance";
    XmlElementNames.GlobalItemIds = "GlobalItemIds";
    XmlElementNames.ChangeType = "ChangeType";
    XmlElementNames.ReadFlag = "ReadFlag";
    XmlElementNames.TotalConversationsInView = "TotalConversationsInView";
    XmlElementNames.IndexedOffset = "IndexedOffset";
    XmlElementNames.ConversationShape = "ConversationShape";
    XmlElementNames.MailboxScope = "MailboxScope";
    // ApplyConversationAction
    XmlElementNames.ApplyConversationAction = "ApplyConversationAction";
    XmlElementNames.ConversationActions = "ConversationActions";
    XmlElementNames.ConversationAction = "ConversationAction";
    XmlElementNames.ApplyConversationActionResponse = "ApplyConversationActionResponse";
    XmlElementNames.ApplyConversationActionResponseMessage = "ApplyConversationActionResponseMessage";
    XmlElementNames.EnableAlwaysDelete = "EnableAlwaysDelete";
    XmlElementNames.ProcessRightAway = "ProcessRightAway";
    XmlElementNames.DestinationFolderId = "DestinationFolderId";
    XmlElementNames.ContextFolderId = "ContextFolderId";
    XmlElementNames.ConversationLastSyncTime = "ConversationLastSyncTime";
    XmlElementNames.AlwaysCategorize = "AlwaysCategorize";
    XmlElementNames.AlwaysDelete = "AlwaysDelete";
    XmlElementNames.AlwaysMove = "AlwaysMove";
    XmlElementNames.Move = "Move";
    XmlElementNames.Copy = "Copy";
    XmlElementNames.SetReadState = "SetReadState";
    XmlElementNames.SetRetentionPolicy = "SetRetentionPolicy";
    XmlElementNames.DeleteType = "DeleteType";
    XmlElementNames.RetentionPolicyType = "RetentionPolicyType";
    XmlElementNames.RetentionPolicyTagId = "RetentionPolicyTagId";
    // GetConversationItems
    XmlElementNames.FoldersToIgnore = "FoldersToIgnore";
    XmlElementNames.ParentInternetMessageId = "ParentInternetMessageId";
    XmlElementNames.ConversationNode = "ConversationNode";
    XmlElementNames.ConversationNodes = "ConversationNodes";
    XmlElementNames.MaxItemsToReturn = "MaxItemsToReturn";
    /* #endregion */
    /* #region TeamMailbox */
    XmlElementNames.SetTeamMailbox = "SetTeamMailbox";
    XmlElementNames.SetTeamMailboxResponse = "SetTeamMailboxResponse";
    XmlElementNames.UnpinTeamMailbox = "UnpinTeamMailbox";
    XmlElementNames.UnpinTeamMailboxResponse = "UnpinTeamMailboxResponse";
    /* #endregion */
    /* #region RoomList & Room */
    XmlElementNames.RoomLists = "RoomLists";
    XmlElementNames.Rooms = "Rooms";
    XmlElementNames.Room = "Room";
    XmlElementNames.RoomList = "RoomList";
    XmlElementNames.RoomId = "Id";
    /* #endregion */
    /* #region Autodiscover */
    XmlElementNames.Autodiscover = "Autodiscover";
    XmlElementNames.BinarySecret = "BinarySecret";
    XmlElementNames.Response = "Response";
    XmlElementNames.User = "User";
    XmlElementNames.LegacyDN = "LegacyDN";
    XmlElementNames.DeploymentId = "DeploymentId";
    XmlElementNames.Account = "Account";
    XmlElementNames.AccountType = "AccountType";
    XmlElementNames.Action = "Action";
    XmlElementNames.To = "To";
    XmlElementNames.RedirectAddr = "RedirectAddr";
    XmlElementNames.RedirectUrl = "RedirectUrl";
    XmlElementNames.Protocol = "Protocol";
    XmlElementNames.Type = "Type";
    XmlElementNames.Server = "Server";
    XmlElementNames.OwnerSmtpAddress = "OwnerSmtpAddress";
    XmlElementNames.ServerDN = "ServerDN";
    XmlElementNames.ServerVersion = "ServerVersion";
    XmlElementNames.ServerVersionInfo = "ServerVersionInfo";
    XmlElementNames.AD = "AD";
    XmlElementNames.AuthPackage = "AuthPackage";
    XmlElementNames.MdbDN = "MdbDN";
    XmlElementNames.EWSUrl = "EwsUrl"; // Server side emits "Ews", not "EWS".
    XmlElementNames.EwsPartnerUrl = "EwsPartnerUrl";
    XmlElementNames.EmwsUrl = "EmwsUrl";
    XmlElementNames.ASUrl = "ASUrl";
    XmlElementNames.OOFUrl = "OOFUrl";
    XmlElementNames.UMUrl = "UMUrl";
    XmlElementNames.OABUrl = "OABUrl";
    XmlElementNames.Internal = "Internal";
    XmlElementNames.External = "External";
    XmlElementNames.OWAUrl = "OWAUrl";
    XmlElementNames.Error = "Error";
    XmlElementNames.ErrorCode = "ErrorCode";
    XmlElementNames.DebugData = "DebugData";
    XmlElementNames.Users = "Users";
    XmlElementNames.RequestedSettings = "RequestedSettings";
    XmlElementNames.Setting = "Setting";
    XmlElementNames.GetUserSettingsRequestMessage = "GetUserSettingsRequestMessage";
    XmlElementNames.RequestedServerVersion = "RequestedServerVersion";
    XmlElementNames.Request = "Request";
    XmlElementNames.RedirectTarget = "RedirectTarget";
    XmlElementNames.UserSettings = "UserSettings";
    XmlElementNames.UserSettingErrors = "UserSettingErrors";
    XmlElementNames.GetUserSettingsResponseMessage = "GetUserSettingsResponseMessage";
    XmlElementNames.ErrorMessage = "ErrorMessage";
    XmlElementNames.UserResponse = "UserResponse";
    XmlElementNames.UserResponses = "UserResponses";
    XmlElementNames.UserSettingError = "UserSettingError";
    XmlElementNames.Domain = "Domain";
    XmlElementNames.Domains = "Domains";
    XmlElementNames.DomainResponse = "DomainResponse";
    XmlElementNames.DomainResponses = "DomainResponses";
    XmlElementNames.DomainSetting = "DomainSetting";
    XmlElementNames.DomainSettings = "DomainSettings";
    XmlElementNames.DomainStringSetting = "DomainStringSetting";
    XmlElementNames.DomainSettingError = "DomainSettingError";
    XmlElementNames.DomainSettingErrors = "DomainSettingErrors";
    XmlElementNames.GetDomainSettingsRequestMessage = "GetDomainSettingsRequestMessage";
    XmlElementNames.GetDomainSettingsResponseMessage = "GetDomainSettingsResponseMessage";
    XmlElementNames.SettingName = "SettingName";
    XmlElementNames.UserSetting = "UserSetting";
    XmlElementNames.StringSetting = "StringSetting";
    XmlElementNames.WebClientUrlCollectionSetting = "WebClientUrlCollectionSetting";
    XmlElementNames.WebClientUrls = "WebClientUrls";
    XmlElementNames.WebClientUrl = "WebClientUrl";
    XmlElementNames.AuthenticationMethods = "AuthenticationMethods";
    XmlElementNames.Url = "Url";
    XmlElementNames.AlternateMailboxCollectionSetting = "AlternateMailboxCollectionSetting";
    XmlElementNames.AlternateMailboxes = "AlternateMailboxes";
    XmlElementNames.AlternateMailbox = "AlternateMailbox";
    XmlElementNames.ProtocolConnectionCollectionSetting = "ProtocolConnectionCollectionSetting";
    XmlElementNames.ProtocolConnections = "ProtocolConnections";
    XmlElementNames.ProtocolConnection = "ProtocolConnection";
    XmlElementNames.DocumentSharingLocationCollectionSetting = "DocumentSharingLocationCollectionSetting";
    XmlElementNames.DocumentSharingLocations = "DocumentSharingLocations";
    XmlElementNames.DocumentSharingLocation = "DocumentSharingLocation";
    XmlElementNames.ServiceUrl = "ServiceUrl";
    XmlElementNames.LocationUrl = "LocationUrl";
    XmlElementNames.SupportedFileExtensions = "SupportedFileExtensions";
    XmlElementNames.FileExtension = "FileExtension";
    XmlElementNames.ExternalAccessAllowed = "ExternalAccessAllowed";
    XmlElementNames.AnonymousAccessAllowed = "AnonymousAccessAllowed";
    XmlElementNames.CanModifyPermissions = "CanModifyPermissions";
    XmlElementNames.IsDefault = "IsDefault";
    XmlElementNames.EncryptionMethod = "EncryptionMethod";
    XmlElementNames.Hostname = "Hostname";
    XmlElementNames.Port = "Port";
    XmlElementNames.Version = "Version";
    XmlElementNames.MajorVersion = "MajorVersion";
    XmlElementNames.MinorVersion = "MinorVersion";
    XmlElementNames.MajorBuildNumber = "MajorBuildNumber";
    XmlElementNames.MinorBuildNumber = "MinorBuildNumber";
    XmlElementNames.RequestedVersion = "RequestedVersion";
    XmlElementNames.PublicFolderServer = "PublicFolderServer";
    XmlElementNames.Ssl = "SSL";
    XmlElementNames.SharingUrl = "SharingUrl";
    XmlElementNames.EcpUrl = "EcpUrl";
    XmlElementNames.EcpUrl_um = "EcpUrl-um";
    XmlElementNames.EcpUrl_aggr = "EcpUrl-aggr";
    XmlElementNames.EcpUrl_sms = "EcpUrl-sms";
    XmlElementNames.EcpUrl_mt = "EcpUrl-mt";
    XmlElementNames.EcpUrl_ret = "EcpUrl-ret";
    XmlElementNames.EcpUrl_publish = "EcpUrl-publish";
    XmlElementNames.EcpUrl_photo = "EcpUrl-photo";
    XmlElementNames.ExchangeRpcUrl = "ExchangeRpcUrl";
    XmlElementNames.EcpUrl_connect = "EcpUrl-connect";
    XmlElementNames.EcpUrl_tm = "EcpUrl-tm";
    XmlElementNames.EcpUrl_tmCreating = "EcpUrl-tmCreating";
    XmlElementNames.EcpUrl_tmEditing = "EcpUrl-tmEditing";
    XmlElementNames.EcpUrl_tmHiding = "EcpUrl-tmHiding";
    XmlElementNames.SiteMailboxCreationURL = "SiteMailboxCreationURL";
    XmlElementNames.EcpUrl_extinstall = "EcpUrl-extinstall";
    XmlElementNames.PartnerToken = "PartnerToken";
    XmlElementNames.PartnerTokenReference = "PartnerTokenReference";
    XmlElementNames.ServerExclusiveConnect = "ServerExclusiveConnect";
    XmlElementNames.AutoDiscoverSMTPAddress = "AutoDiscoverSMTPAddress";
    XmlElementNames.CertPrincipalName = "CertPrincipalName";
    XmlElementNames.GroupingInformation = "GroupingInformation";
    /* #endregion */
    /* #region InboxRule */
    XmlElementNames.MailboxSmtpAddress = "MailboxSmtpAddress";
    XmlElementNames.RuleId = "RuleId";
    XmlElementNames.Priority = "Priority";
    XmlElementNames.IsEnabled = "IsEnabled";
    XmlElementNames.IsNotSupported = "IsNotSupported";
    XmlElementNames.IsInError = "IsInError";
    XmlElementNames.Conditions = "Conditions";
    XmlElementNames.Exceptions = "Exceptions";
    XmlElementNames.Actions = "Actions";
    XmlElementNames.InboxRules = "InboxRules";
    XmlElementNames.Rule = "Rule";
    XmlElementNames.OutlookRuleBlobExists = "OutlookRuleBlobExists";
    XmlElementNames.RemoveOutlookRuleBlob = "RemoveOutlookRuleBlob";
    XmlElementNames.ContainsBodyStrings = "ContainsBodyStrings";
    XmlElementNames.ContainsHeaderStrings = "ContainsHeaderStrings";
    XmlElementNames.ContainsRecipientStrings = "ContainsRecipientStrings";
    XmlElementNames.ContainsSenderStrings = "ContainsSenderStrings";
    XmlElementNames.ContainsSubjectOrBodyStrings = "ContainsSubjectOrBodyStrings";
    XmlElementNames.ContainsSubjectStrings = "ContainsSubjectStrings";
    XmlElementNames.FlaggedForAction = "FlaggedForAction";
    XmlElementNames.FromAddresses = "FromAddresses";
    XmlElementNames.FromConnectedAccounts = "FromConnectedAccounts";
    XmlElementNames.IsApprovalRequest = "IsApprovalRequest";
    XmlElementNames.IsAutomaticForward = "IsAutomaticForward";
    XmlElementNames.IsAutomaticReply = "IsAutomaticReply";
    XmlElementNames.IsEncrypted = "IsEncrypted";
    XmlElementNames.IsMeetingRequest = "IsMeetingRequest";
    XmlElementNames.IsMeetingResponse = "IsMeetingResponse";
    XmlElementNames.IsNDR = "IsNDR";
    XmlElementNames.IsPermissionControlled = "IsPermissionControlled";
    XmlElementNames.IsSigned = "IsSigned";
    XmlElementNames.IsVoicemail = "IsVoicemail";
    XmlElementNames.IsReadReceipt = "IsReadReceipt";
    XmlElementNames.MessageClassifications = "MessageClassifications";
    XmlElementNames.NotSentToMe = "NotSentToMe";
    XmlElementNames.SentCcMe = "SentCcMe";
    XmlElementNames.SentOnlyToMe = "SentOnlyToMe";
    XmlElementNames.SentToAddresses = "SentToAddresses";
    XmlElementNames.SentToMe = "SentToMe";
    XmlElementNames.SentToOrCcMe = "SentToOrCcMe";
    XmlElementNames.WithinDateRange = "WithinDateRange";
    XmlElementNames.WithinSizeRange = "WithinSizeRange";
    XmlElementNames.MinimumSize = "MinimumSize";
    XmlElementNames.MaximumSize = "MaximumSize";
    XmlElementNames.StartDateTime = "StartDateTime";
    XmlElementNames.EndDateTime = "EndDateTime";
    XmlElementNames.AssignCategories = "AssignCategories";
    XmlElementNames.CopyToFolder = "CopyToFolder";
    XmlElementNames.FlagMessage = "FlagMessage";
    XmlElementNames.ForwardAsAttachmentToRecipients = "ForwardAsAttachmentToRecipients";
    XmlElementNames.ForwardToRecipients = "ForwardToRecipients";
    XmlElementNames.MarkImportance = "MarkImportance";
    XmlElementNames.MarkAsRead = "MarkAsRead";
    XmlElementNames.MoveToFolder = "MoveToFolder";
    XmlElementNames.PermanentDelete = "PermanentDelete";
    XmlElementNames.RedirectToRecipients = "RedirectToRecipients";
    XmlElementNames.SendSMSAlertToRecipients = "SendSMSAlertToRecipients";
    XmlElementNames.ServerReplyWithMessage = "ServerReplyWithMessage";
    XmlElementNames.StopProcessingRules = "StopProcessingRules";
    XmlElementNames.CreateRuleOperation = "CreateRuleOperation";
    XmlElementNames.SetRuleOperation = "SetRuleOperation";
    XmlElementNames.DeleteRuleOperation = "DeleteRuleOperation";
    XmlElementNames.Operations = "Operations";
    XmlElementNames.RuleOperationErrors = "RuleOperationErrors";
    XmlElementNames.RuleOperationError = "RuleOperationError";
    XmlElementNames.OperationIndex = "OperationIndex";
    XmlElementNames.ValidationErrors = "ValidationErrors";
    XmlElementNames.FieldValue = "FieldValue";
    /* #endregion */
    /* #region Restrictions */
    XmlElementNames.Not = "Not";
    XmlElementNames.Bitmask = "Bitmask";
    XmlElementNames.Constant = "Constant";
    XmlElementNames.Restriction = "Restriction";
    XmlElementNames.Condition = "Condition";
    XmlElementNames.Contains = "Contains";
    XmlElementNames.Excludes = "Excludes";
    XmlElementNames.Exists = "Exists";
    XmlElementNames.FieldURIOrConstant = "FieldURIOrConstant";
    XmlElementNames.And = "And";
    XmlElementNames.Or = "Or";
    XmlElementNames.IsEqualTo = "IsEqualTo";
    XmlElementNames.IsNotEqualTo = "IsNotEqualTo";
    XmlElementNames.IsGreaterThan = "IsGreaterThan";
    XmlElementNames.IsGreaterThanOrEqualTo = "IsGreaterThanOrEqualTo";
    XmlElementNames.IsLessThan = "IsLessThan";
    XmlElementNames.IsLessThanOrEqualTo = "IsLessThanOrEqualTo";
    /* #endregion */
    /* #region Directory only contact properties */
    XmlElementNames.PhoneticFullName = "PhoneticFullName";
    XmlElementNames.PhoneticFirstName = "PhoneticFirstName";
    XmlElementNames.PhoneticLastName = "PhoneticLastName";
    XmlElementNames.Alias = "Alias";
    XmlElementNames.Notes = "Notes";
    XmlElementNames.Photo = "Photo";
    XmlElementNames.UserSMIMECertificate = "UserSMIMECertificate";
    XmlElementNames.MSExchangeCertificate = "MSExchangeCertificate";
    XmlElementNames.DirectoryId = "DirectoryId";
    XmlElementNames.ManagerMailbox = "ManagerMailbox";
    XmlElementNames.DirectReports = "DirectReports";
    /* #endregion */
    /* #region Photos */
    XmlElementNames.SizeRequested = "SizeRequested";
    XmlElementNames.HasChanged = "HasChanged";
    XmlElementNames.PictureData = "PictureData";
    /* #endregion */
    /* #region Request/response element names */
    XmlElementNames.ResponseMessage = "ResponseMessage";
    XmlElementNames.ResponseMessages = "ResponseMessages";
    // FindConversation
    XmlElementNames.FindConversation = "FindConversation";
    XmlElementNames.FindConversationResponse = "FindConversationResponse";
    XmlElementNames.FindConversationResponseMessage = "FindConversationResponseMessage";
    // GetConversationItems
    XmlElementNames.GetConversationItems = "GetConversationItems";
    XmlElementNames.GetConversationItemsResponse = "GetConversationItemsResponse";
    XmlElementNames.GetConversationItemsResponseMessage = "GetConversationItemsResponseMessage";
    // FindItem
    XmlElementNames.FindItem = "FindItem";
    XmlElementNames.FindItemResponse = "FindItemResponse";
    XmlElementNames.FindItemResponseMessage = "FindItemResponseMessage";
    // GetItem
    XmlElementNames.GetItem = "GetItem";
    XmlElementNames.GetItemResponse = "GetItemResponse";
    XmlElementNames.GetItemResponseMessage = "GetItemResponseMessage";
    // CreateItem
    XmlElementNames.CreateItem = "CreateItem";
    XmlElementNames.CreateItemResponse = "CreateItemResponse";
    XmlElementNames.CreateItemResponseMessage = "CreateItemResponseMessage";
    // SendItem
    XmlElementNames.SendItem = "SendItem";
    XmlElementNames.SendItemResponse = "SendItemResponse";
    XmlElementNames.SendItemResponseMessage = "SendItemResponseMessage";
    // DeleteItem
    XmlElementNames.DeleteItem = "DeleteItem";
    XmlElementNames.DeleteItemResponse = "DeleteItemResponse";
    XmlElementNames.DeleteItemResponseMessage = "DeleteItemResponseMessage";
    // UpdateItem
    XmlElementNames.UpdateItem = "UpdateItem";
    XmlElementNames.UpdateItemResponse = "UpdateItemResponse";
    XmlElementNames.UpdateItemResponseMessage = "UpdateItemResponseMessage";
    // CopyItem
    XmlElementNames.CopyItem = "CopyItem";
    XmlElementNames.CopyItemResponse = "CopyItemResponse";
    XmlElementNames.CopyItemResponseMessage = "CopyItemResponseMessage";
    // MoveItem
    XmlElementNames.MoveItem = "MoveItem";
    XmlElementNames.MoveItemResponse = "MoveItemResponse";
    XmlElementNames.MoveItemResponseMessage = "MoveItemResponseMessage";
    // ArchiveItem
    XmlElementNames.ArchiveItem = "ArchiveItem";
    XmlElementNames.ArchiveItemResponse = "ArchiveItemResponse";
    XmlElementNames.ArchiveItemResponseMessage = "ArchiveItemResponseMessage";
    XmlElementNames.ArchiveSourceFolderId = "ArchiveSourceFolderId";
    // FindFolder
    XmlElementNames.FindFolder = "FindFolder";
    XmlElementNames.FindFolderResponse = "FindFolderResponse";
    XmlElementNames.FindFolderResponseMessage = "FindFolderResponseMessage";
    // GetFolder
    XmlElementNames.GetFolder = "GetFolder";
    XmlElementNames.GetFolderResponse = "GetFolderResponse";
    XmlElementNames.GetFolderResponseMessage = "GetFolderResponseMessage";
    // CreateFolder
    XmlElementNames.CreateFolder = "CreateFolder";
    XmlElementNames.CreateFolderResponse = "CreateFolderResponse";
    XmlElementNames.CreateFolderResponseMessage = "CreateFolderResponseMessage";
    // DeleteFolder
    XmlElementNames.DeleteFolder = "DeleteFolder";
    XmlElementNames.DeleteFolderResponse = "DeleteFolderResponse";
    XmlElementNames.DeleteFolderResponseMessage = "DeleteFolderResponseMessage";
    // EmptyFolder
    XmlElementNames.EmptyFolder = "EmptyFolder";
    XmlElementNames.EmptyFolderResponse = "EmptyFolderResponse";
    XmlElementNames.EmptyFolderResponseMessage = "EmptyFolderResponseMessage";
    // UpdateFolder
    XmlElementNames.UpdateFolder = "UpdateFolder";
    XmlElementNames.UpdateFolderResponse = "UpdateFolderResponse";
    XmlElementNames.UpdateFolderResponseMessage = "UpdateFolderResponseMessage";
    // CopyFolder
    XmlElementNames.CopyFolder = "CopyFolder";
    XmlElementNames.CopyFolderResponse = "CopyFolderResponse";
    XmlElementNames.CopyFolderResponseMessage = "CopyFolderResponseMessage";
    // MoveFolder
    XmlElementNames.MoveFolder = "MoveFolder";
    XmlElementNames.MoveFolderResponse = "MoveFolderResponse";
    XmlElementNames.MoveFolderResponseMessage = "MoveFolderResponseMessage";
    // MarkAllItemsAsRead
    XmlElementNames.MarkAllItemsAsRead = "MarkAllItemsAsRead";
    XmlElementNames.MarkAllItemsAsReadResponse = "MarkAllItemsAsReadResponse";
    XmlElementNames.MarkAllItemsAsReadResponseMessage = "MarkAllItemsAsReadResponseMessage";
    // FindPeople
    XmlElementNames.FindPeople = "FindPeople";
    XmlElementNames.FindPeopleResponse = "FindPeopleResponse";
    XmlElementNames.FindPeopleResponseMessage = "FindPeopleResponseMessage";
    // GetPeopleInsights
    XmlElementNames.GetPeopleInsights = "GetPeopleInsights";
    XmlElementNames.GetPeopleInsightsResponse = "GetPeopleInsightsResponse";
    XmlElementNames.GetPeopleInsightsResponseMessage = "GetPeopleInsightsResponseMessage";
    // GetUserPhoto
    XmlElementNames.GetUserPhoto = "GetUserPhoto";
    XmlElementNames.GetUserPhotoResponse = "GetUserPhotoResponse";
    XmlElementNames.GetUserPhotoResponseMessage = "GetUserPhotoResponseMessage";
    // GetAttachment
    XmlElementNames.GetAttachment = "GetAttachment";
    XmlElementNames.GetAttachmentResponse = "GetAttachmentResponse";
    XmlElementNames.GetAttachmentResponseMessage = "GetAttachmentResponseMessage";
    // CreateAttachment
    XmlElementNames.CreateAttachment = "CreateAttachment";
    XmlElementNames.CreateAttachmentResponse = "CreateAttachmentResponse";
    XmlElementNames.CreateAttachmentResponseMessage = "CreateAttachmentResponseMessage";
    // DeleteAttachment
    XmlElementNames.DeleteAttachment = "DeleteAttachment";
    XmlElementNames.DeleteAttachmentResponse = "DeleteAttachmentResponse";
    XmlElementNames.DeleteAttachmentResponseMessage = "DeleteAttachmentResponseMessage";
    // ResolveNames
    XmlElementNames.ResolveNames = "ResolveNames";
    XmlElementNames.ResolveNamesResponse = "ResolveNamesResponse";
    XmlElementNames.ResolveNamesResponseMessage = "ResolveNamesResponseMessage";
    // ExpandDL
    XmlElementNames.ExpandDL = "ExpandDL";
    XmlElementNames.ExpandDLResponse = "ExpandDLResponse";
    XmlElementNames.ExpandDLResponseMessage = "ExpandDLResponseMessage";
    // Subscribe
    XmlElementNames.Subscribe = "Subscribe";
    XmlElementNames.SubscribeResponse = "SubscribeResponse";
    XmlElementNames.SubscribeResponseMessage = "SubscribeResponseMessage";
    XmlElementNames.SubscriptionRequest = "SubscriptionRequest";
    // Unsubscribe
    XmlElementNames.Unsubscribe = "Unsubscribe";
    XmlElementNames.UnsubscribeResponse = "UnsubscribeResponse";
    XmlElementNames.UnsubscribeResponseMessage = "UnsubscribeResponseMessage";
    // GetEvents
    XmlElementNames.GetEvents = "GetEvents";
    XmlElementNames.GetEventsResponse = "GetEventsResponse";
    XmlElementNames.GetEventsResponseMessage = "GetEventsResponseMessage";
    // GetStreamingEvents
    XmlElementNames.GetStreamingEvents = "GetStreamingEvents";
    XmlElementNames.GetStreamingEventsResponse = "GetStreamingEventsResponse";
    XmlElementNames.GetStreamingEventsResponseMessage = "GetStreamingEventsResponseMessage";
    XmlElementNames.ConnectionStatus = "ConnectionStatus";
    XmlElementNames.ErrorSubscriptionIds = "ErrorSubscriptionIds";
    XmlElementNames.ConnectionTimeout = "ConnectionTimeout";
    XmlElementNames.HeartbeatFrequency = "HeartbeatFrequency";
    // SyncFolderItems
    XmlElementNames.SyncFolderItems = "SyncFolderItems";
    XmlElementNames.SyncFolderItemsResponse = "SyncFolderItemsResponse";
    XmlElementNames.SyncFolderItemsResponseMessage = "SyncFolderItemsResponseMessage";
    // SyncFolderHierarchy
    XmlElementNames.SyncFolderHierarchy = "SyncFolderHierarchy";
    XmlElementNames.SyncFolderHierarchyResponse = "SyncFolderHierarchyResponse";
    XmlElementNames.SyncFolderHierarchyResponseMessage = "SyncFolderHierarchyResponseMessage";
    // GetUserOofSettings
    XmlElementNames.GetUserOofSettingsRequest = "GetUserOofSettingsRequest";
    XmlElementNames.GetUserOofSettingsResponse = "GetUserOofSettingsResponse";
    // SetUserOofSettings
    XmlElementNames.SetUserOofSettingsRequest = "SetUserOofSettingsRequest";
    XmlElementNames.SetUserOofSettingsResponse = "SetUserOofSettingsResponse";
    // GetUserAvailability
    XmlElementNames.GetUserAvailabilityRequest = "GetUserAvailabilityRequest";
    XmlElementNames.GetUserAvailabilityResponse = "GetUserAvailabilityResponse";
    XmlElementNames.FreeBusyResponseArray = "FreeBusyResponseArray";
    XmlElementNames.FreeBusyResponse = "FreeBusyResponse";
    XmlElementNames.SuggestionsResponse = "SuggestionsResponse";
    // GetRoomLists
    XmlElementNames.GetRoomListsRequest = "GetRoomLists";
    XmlElementNames.GetRoomListsResponse = "GetRoomListsResponse";
    // GetRooms
    XmlElementNames.GetRoomsRequest = "GetRooms";
    XmlElementNames.GetRoomsResponse = "GetRoomsResponse";
    // ConvertId
    XmlElementNames.ConvertId = "ConvertId";
    XmlElementNames.ConvertIdResponse = "ConvertIdResponse";
    XmlElementNames.ConvertIdResponseMessage = "ConvertIdResponseMessage";
    // AddDelegate
    XmlElementNames.AddDelegate = "AddDelegate";
    XmlElementNames.AddDelegateResponse = "AddDelegateResponse";
    XmlElementNames.DelegateUserResponseMessageType = "DelegateUserResponseMessageType";
    // RemoveDelegte
    XmlElementNames.RemoveDelegate = "RemoveDelegate";
    XmlElementNames.RemoveDelegateResponse = "RemoveDelegateResponse";
    // GetDelegate
    XmlElementNames.GetDelegate = "GetDelegate";
    XmlElementNames.GetDelegateResponse = "GetDelegateResponse";
    // UpdateDelegate
    XmlElementNames.UpdateDelegate = "UpdateDelegate";
    XmlElementNames.UpdateDelegateResponse = "UpdateDelegateResponse";
    // CreateUserConfiguration
    XmlElementNames.CreateUserConfiguration = "CreateUserConfiguration";
    XmlElementNames.CreateUserConfigurationResponse = "CreateUserConfigurationResponse";
    XmlElementNames.CreateUserConfigurationResponseMessage = "CreateUserConfigurationResponseMessage";
    // DeleteUserConfiguration
    XmlElementNames.DeleteUserConfiguration = "DeleteUserConfiguration";
    XmlElementNames.DeleteUserConfigurationResponse = "DeleteUserConfigurationResponse";
    XmlElementNames.DeleteUserConfigurationResponseMessage = "DeleteUserConfigurationResponseMessage";
    // GetUserConfiguration
    XmlElementNames.GetUserConfiguration = "GetUserConfiguration";
    XmlElementNames.GetUserConfigurationResponse = "GetUserConfigurationResponse";
    XmlElementNames.GetUserConfigurationResponseMessage = "GetUserConfigurationResponseMessage";
    // UpdateUserConfiguration
    XmlElementNames.UpdateUserConfiguration = "UpdateUserConfiguration";
    XmlElementNames.UpdateUserConfigurationResponse = "UpdateUserConfigurationResponse";
    XmlElementNames.UpdateUserConfigurationResponseMessage = "UpdateUserConfigurationResponseMessage";
    // PlayOnPhone
    XmlElementNames.PlayOnPhone = "PlayOnPhone";
    XmlElementNames.PlayOnPhoneResponse = "PlayOnPhoneResponse";
    // GetPhoneCallInformation
    XmlElementNames.GetPhoneCall = "GetPhoneCallInformation";
    XmlElementNames.GetPhoneCallResponse = "GetPhoneCallInformationResponse";
    // DisconnectCall
    XmlElementNames.DisconnectPhoneCall = "DisconnectPhoneCall";
    XmlElementNames.DisconnectPhoneCallResponse = "DisconnectPhoneCallResponse";
    // GetServerTimeZones
    XmlElementNames.GetServerTimeZones = "GetServerTimeZones";
    XmlElementNames.GetServerTimeZonesResponse = "GetServerTimeZonesResponse";
    XmlElementNames.GetServerTimeZonesResponseMessage = "GetServerTimeZonesResponseMessage";
    // GetInboxRules
    XmlElementNames.GetInboxRules = "GetInboxRules";
    XmlElementNames.GetInboxRulesResponse = "GetInboxRulesResponse";
    // UpdateInboxRules
    XmlElementNames.UpdateInboxRules = "UpdateInboxRules";
    XmlElementNames.UpdateInboxRulesResponse = "UpdateInboxRulesResponse";
    // ExecuteDiagnosticMethod
    XmlElementNames.ExecuteDiagnosticMethod = "ExecuteDiagnosticMethod";
    XmlElementNames.ExecuteDiagnosticMethodResponse = "ExecuteDiagnosticMethodResponse";
    XmlElementNames.ExecuteDiagnosticMethodResponseMEssage = "ExecuteDiagnosticMethodResponseMessage";
    //GetPasswordExpirationDate
    XmlElementNames.GetPasswordExpirationDateRequest = "GetPasswordExpirationDate";
    XmlElementNames.GetPasswordExpirationDateResponse = "GetPasswordExpirationDateResponse";
    // GetSearchableMailboxes
    XmlElementNames.GetSearchableMailboxes = "GetSearchableMailboxes";
    XmlElementNames.GetSearchableMailboxesResponse = "GetSearchableMailboxesResponse";
    // GetDiscoverySearchConfiguration
    XmlElementNames.GetDiscoverySearchConfiguration = "GetDiscoverySearchConfiguration";
    XmlElementNames.GetDiscoverySearchConfigurationResponse = "GetDiscoverySearchConfigurationResponse";
    // GetHoldOnMailboxes
    XmlElementNames.GetHoldOnMailboxes = "GetHoldOnMailboxes";
    XmlElementNames.GetHoldOnMailboxesResponse = "GetHoldOnMailboxesResponse";
    // SetHoldOnMailboxes
    XmlElementNames.SetHoldOnMailboxes = "SetHoldOnMailboxes";
    XmlElementNames.SetHoldOnMailboxesResponse = "SetHoldOnMailboxesResponse";
    // SearchMailboxes
    XmlElementNames.SearchMailboxes = "SearchMailboxes";
    XmlElementNames.SearchMailboxesResponse = "SearchMailboxesResponse";
    XmlElementNames.SearchMailboxesResponseMessage = "SearchMailboxesResponseMessage";
    // GetNonIndexableItemDetails
    XmlElementNames.GetNonIndexableItemDetails = "GetNonIndexableItemDetails";
    XmlElementNames.GetNonIndexableItemDetailsResponse = "GetNonIndexableItemDetailsResponse";
    // GetNonIndexableItemStatistics
    XmlElementNames.GetNonIndexableItemStatistics = "GetNonIndexableItemStatistics";
    XmlElementNames.GetNonIndexableItemStatisticsResponse = "GetNonIndexableItemStatisticsResponse";
    // eDiscovery
    XmlElementNames.SearchQueries = "SearchQueries";
    XmlElementNames.SearchQuery = "SearchQuery";
    XmlElementNames.MailboxQuery = "MailboxQuery";
    XmlElementNames.Query = "Query";
    XmlElementNames.MailboxSearchScopes = "MailboxSearchScopes";
    XmlElementNames.MailboxSearchScope = "MailboxSearchScope";
    XmlElementNames.SearchScope = "SearchScope";
    XmlElementNames.ResultType = "ResultType";
    XmlElementNames.SortBy = "SortBy";
    XmlElementNames.Order = "Order";
    XmlElementNames.Language = "Language";
    XmlElementNames.Deduplication = "Deduplication";
    XmlElementNames.PageSize = "PageSize";
    XmlElementNames.PageItemReference = "PageItemReference";
    XmlElementNames.PageDirection = "PageDirection";
    XmlElementNames.PreviewItemResponseShape = "PreviewItemResponseShape";
    XmlElementNames.ExtendedProperties = "ExtendedProperties";
    XmlElementNames.PageItemSize = "PageItemSize";
    XmlElementNames.PageItemCount = "PageItemCount";
    XmlElementNames.ItemCount = "ItemCount";
    XmlElementNames.KeywordStats = "KeywordStats";
    XmlElementNames.KeywordStat = "KeywordStat";
    XmlElementNames.Keyword = "Keyword";
    XmlElementNames.ItemHits = "ItemHits";
    XmlElementNames.SearchPreviewItem = "SearchPreviewItem";
    XmlElementNames.ChangeKey = "ChangeKey";
    XmlElementNames.ParentId = "ParentId";
    XmlElementNames.MailboxId = "MailboxId";
    XmlElementNames.UniqueHash = "UniqueHash";
    XmlElementNames.SortValue = "SortValue";
    XmlElementNames.OwaLink = "OwaLink";
    XmlElementNames.SmtpAddress = "SmtpAddress";
    XmlElementNames.CreatedTime = "CreatedTime";
    XmlElementNames.ReceivedTime = "ReceivedTime";
    XmlElementNames.SentTime = "SentTime";
    XmlElementNames.Preview = "Preview";
    XmlElementNames.HasAttachment = "HasAttachment";
    XmlElementNames.FailedMailboxes = "FailedMailboxes";
    XmlElementNames.FailedMailbox = "FailedMailbox";
    XmlElementNames.Token = "Token";
    XmlElementNames.Refiners = "Refiners";
    XmlElementNames.Refiner = "Refiner";
    XmlElementNames.MailboxStats = "MailboxStats";
    XmlElementNames.MailboxStat = "MailboxStat";
    XmlElementNames.HoldId = "HoldId";
    XmlElementNames.ActionType = "ActionType";
    XmlElementNames.Mailboxes = "Mailboxes";
    XmlElementNames.SearchFilter = "SearchFilter";
    XmlElementNames.ReferenceId = "ReferenceId";
    XmlElementNames.IsMembershipGroup = "IsMembershipGroup";
    XmlElementNames.ExpandGroupMembership = "ExpandGroupMembership";
    XmlElementNames.SearchableMailboxes = "SearchableMailboxes";
    XmlElementNames.SearchableMailbox = "SearchableMailbox";
    XmlElementNames.SearchMailboxesResult = "SearchMailboxesResult";
    XmlElementNames.MailboxHoldResult = "MailboxHoldResult";
    XmlElementNames.Statuses = "Statuses";
    XmlElementNames.MailboxHoldStatuses = "MailboxHoldStatuses";
    XmlElementNames.MailboxHoldStatus = "MailboxHoldStatus";
    XmlElementNames.AdditionalInfo = "AdditionalInfo";
    XmlElementNames.NonIndexableItemDetail = "NonIndexableItemDetail";
    XmlElementNames.NonIndexableItemStatistic = "NonIndexableItemStatistic";
    XmlElementNames.NonIndexableItemDetails = "NonIndexableItemDetails";
    XmlElementNames.NonIndexableItemStatistics = "NonIndexableItemStatistics";
    XmlElementNames.NonIndexableItemDetailsResult = "NonIndexableItemDetailsResult";
    XmlElementNames.SearchArchiveOnly = "SearchArchiveOnly";
    XmlElementNames.ErrorDescription = "ErrorDescription";
    XmlElementNames.IsPartiallyIndexed = "IsPartiallyIndexed";
    XmlElementNames.IsPermanentFailure = "IsPermanentFailure";
    XmlElementNames.AttemptCount = "AttemptCount";
    XmlElementNames.LastAttemptTime = "LastAttemptTime";
    XmlElementNames.SearchId = "SearchId";
    XmlElementNames.DiscoverySearchConfigurations = "DiscoverySearchConfigurations";
    XmlElementNames.DiscoverySearchConfiguration = "DiscoverySearchConfiguration";
    XmlElementNames.InPlaceHoldConfigurationOnly = "InPlaceHoldConfigurationOnly";
    XmlElementNames.InPlaceHoldIdentity = "InPlaceHoldIdentity";
    XmlElementNames.ItemHoldPeriod = "ItemHoldPeriod";
    XmlElementNames.ManagedByOrganization = "ManagedByOrganization";
    XmlElementNames.IsExternalMailbox = "IsExternalMailbox";
    XmlElementNames.ExternalEmailAddress = "ExternalEmailAddress";
    XmlElementNames.ExtendedAttributes = "ExtendedAttributes";
    XmlElementNames.ExtendedAttribute = "ExtendedAttribute";
    XmlElementNames.ExtendedAttributeName = "Name";
    XmlElementNames.ExtendedAttributeValue = "Value";
    XmlElementNames.SearchScopeType = "SearchScopeType";
    /** per github issue #120 */
    XmlElementNames.IncludeNonIndexableItems = "IncludeNonIndexableItems";
    // GetAppManifests
    XmlElementNames.GetAppManifestsRequest = "GetAppManifests";
    XmlElementNames.GetAppManifestsResponse = "GetAppManifestsResponse";
    XmlElementNames.Manifests = "Manifests";
    XmlElementNames.Manifest = "Manifest";
    // GetAppManifests for TargetServerVersion > 2.5
    XmlElementNames.Apps = "Apps";
    XmlElementNames.App = "App";
    XmlElementNames.Metadata = "Metadata";
    XmlElementNames.ActionUrl = "ActionUrl";
    XmlElementNames.AppStatus = "AppStatus";
    XmlElementNames.EndNodeUrl = "EndNodeUrl";
    // GetClientExtension/SetClientExtension
    XmlElementNames.GetClientExtensionRequest = "GetClientExtension";
    XmlElementNames.ClientExtensionUserRequest = "UserParameters";
    XmlElementNames.ClientExtensionUserEnabled = "UserEnabledExtensions";
    XmlElementNames.ClientExtensionUserDisabled = "UserDisabledExtensions";
    XmlElementNames.ClientExtensionRequestedIds = "RequestedExtensionIds";
    XmlElementNames.ClientExtensionIsDebug = "IsDebug";
    XmlElementNames.ClientExtensionRawMasterTableXml = "RawMasterTableXml";
    XmlElementNames.GetClientExtensionResponse = "GetClientExtensionResponse";
    XmlElementNames.ClientExtensionSpecificUsers = "SpecificUsers";
    XmlElementNames.ClientExtensions = "ClientExtensions";
    XmlElementNames.ClientExtension = "ClientExtension";
    XmlElementNames.SetClientExtensionRequest = "SetClientExtension";
    XmlElementNames.SetClientExtensionActions = "Actions";
    XmlElementNames.SetClientExtensionAction = "Action";
    XmlElementNames.SetClientExtensionResponse = "SetClientExtensionResponse";
    XmlElementNames.SetClientExtensionResponseMessage = "SetClientExtensionResponseMessage";
    // GetEncryptionConfiguration/SetEncryptionConfiguration
    XmlElementNames.GetEncryptionConfigurationRequest = "GetEncryptionConfiguration";
    XmlElementNames.SetEncryptionConfigurationRequest = "SetEncryptionConfiguration";
    XmlElementNames.EncryptionConfigurationImageBase64 = "ImageBase64";
    XmlElementNames.EncryptionConfigurationEmailText = "EmailText";
    XmlElementNames.EncryptionConfigurationPortalText = "PortalText";
    XmlElementNames.EncryptionConfigurationDisclaimerText = "DisclaimerText";
    XmlElementNames.EncryptionConfigurationOTPEnabled = "OTPEnabled";
    XmlElementNames.GetEncryptionConfigurationResponse = "GetEncryptionConfigurationResponse";
    XmlElementNames.SetEncryptionConfigurationResponse = "SetEncryptionConfigurationResponse";
    // GetOMEConfiguration/SetOMEConfiguration
    XmlElementNames.GetOMEConfigurationRequest = "GetOMEConfiguration";
    XmlElementNames.SetOMEConfigurationRequest = "SetOMEConfiguration";
    XmlElementNames.OMEConfigurationXml = "Xml";
    XmlElementNames.GetOMEConfigurationResponse = "GetOMEConfigurationResponse";
    XmlElementNames.SetOMEConfigurationResponse = "SetOMEConfigurationResponse";
    // InstallApp
    XmlElementNames.InstallAppRequest = "InstallApp";
    XmlElementNames.InstallAppResponse = "InstallAppResponse";
    // UninstallApp
    XmlElementNames.UninstallAppRequest = "UninstallApp";
    XmlElementNames.UninstallAppResponse = "UninstallAppResponse";
    // DisableApp
    XmlElementNames.DisableAppRequest = "DisableApp";
    XmlElementNames.DisableAppResponse = "DisableAppResponse";
    // RegisterConsent
    XmlElementNames.RegisterConsentRequest = "RegisterConsent";
    XmlElementNames.RegisterConsentResponse = "RegisterConsentResponse";
    // GetAppMarketplaceUrl
    XmlElementNames.GetAppMarketplaceUrlRequest = "GetAppMarketplaceUrl";
    XmlElementNames.GetAppMarketplaceUrlResponse = "GetAppMarketplaceUrlResponse";
    // GetUserRetentionPolicyTags
    XmlElementNames.GetUserRetentionPolicyTags = "GetUserRetentionPolicyTags";
    XmlElementNames.GetUserRetentionPolicyTagsResponse = "GetUserRetentionPolicyTagsResponse";
    // MRM
    XmlElementNames.RetentionPolicyTags = "RetentionPolicyTags";
    XmlElementNames.RetentionPolicyTag = "RetentionPolicyTag";
    XmlElementNames.RetentionId = "RetentionId";
    XmlElementNames.RetentionPeriod = "RetentionPeriod";
    XmlElementNames.RetentionAction = "RetentionAction";
    XmlElementNames.Description = "Description";
    XmlElementNames.IsVisible = "IsVisible";
    XmlElementNames.OptedInto = "OptedInto";
    XmlElementNames.IsArchive = "IsArchive";
    /* #endregion */
    /* #region Groups */
    // GetUserUnifiedGroups
    XmlElementNames.GetUserUnifiedGroups = "GetUserUnifiedGroups";
    XmlElementNames.RequestedGroupsSets = "RequestedGroupsSets";
    XmlElementNames.RequestedUnifiedGroupsSetItem = "RequestedUnifiedGroupsSet";
    XmlElementNames.SortType = "SortType";
    XmlElementNames.FilterType = "FilterType";
    XmlElementNames.SortDirection = "SortDirection";
    XmlElementNames.GroupsLimit = "GroupsLimit";
    XmlElementNames.UserSmtpAddress = "UserSmtpAddress";
    XmlElementNames.GetUserUnifiedGroupsResponseMessage = "GetUserUnifiedGroupsResponseMessage";
    XmlElementNames.GroupsSets = "GroupsSets";
    XmlElementNames.UnifiedGroupsSet = "UnifiedGroupsSet";
    XmlElementNames.TotalGroups = "TotalGroups";
    XmlElementNames.GroupsTag = "Groups";
    XmlElementNames.UnifiedGroup = "UnifiedGroup";
    XmlElementNames.MailboxGuid = "MailboxGuid";
    XmlElementNames.LastVisitedTimeUtc = "LastVisitedTimeUtc";
    XmlElementNames.AccessType = "AccessType";
    XmlElementNames.ExternalDirectoryObjectId = "ExternalDirectoryObjectId";
    // GetUnifiedGroupUnseenCount
    XmlElementNames.GetUnifiedGroupUnseenCount = "GetUnifiedGroupUnseenCount";
    XmlElementNames.GroupIdentity = "GroupIdentity";
    XmlElementNames.GroupIdentityType = "IdentityType";
    XmlElementNames.GroupIdentityValue = "Value";
    XmlElementNames.GetUnifiedGroupUnseenCountResponseMessage = "GetUnifiedGroupUnseenCountResponseMessage";
    XmlElementNames.UnseenCount = "UnseenCount";
    // SetUnifiedGroupLastVisitedTimeRequest
    XmlElementNames.SetUnifiedGroupLastVisitedTime = "SetUnifiedGroupLastVisitedTime";
    XmlElementNames.SetUnifiedGroupLastVisitedTimeResponseMessage = "SetUnifiedGroupLastVisitedTimeResponseMessage";
    /* #endregion */
    /* #region SOAP element names */
    XmlElementNames.SOAPEnvelopeElementName = "Envelope";
    XmlElementNames.SOAPHeaderElementName = "Header";
    XmlElementNames.SOAPBodyElementName = "Body";
    XmlElementNames.SOAPFaultElementName = "Fault";
    XmlElementNames.SOAPFaultCodeElementName = "faultcode";
    XmlElementNames.SOAPFaultStringElementName = "faultstring";
    XmlElementNames.SOAPFaultActorElementName = "faultactor";
    XmlElementNames.SOAPDetailElementName = "detail";
    XmlElementNames.EwsResponseCodeElementName = "ResponseCode";
    XmlElementNames.EwsMessageElementName = "Message";
    XmlElementNames.EwsLineElementName = "Line";
    XmlElementNames.EwsPositionElementName = "Position";
    XmlElementNames.EwsErrorCodeElementName = "ErrorCode"; // Generated by Availability
    XmlElementNames.EwsExceptionTypeElementName = "ExceptionType"; // Generated by UM
    /* #endregion */
})(XmlElementNames = exports.XmlElementNames || (exports.XmlElementNames = {}));
/**
 * Represents a property that can be sent to or retrieved from EWS.
 */
var ComplexProperty = (function () {
    function ComplexProperty() {
        /**@internal */
        this.Namespace = XmlNamespace.Types;
        //private xmlNamespace: XmlNamespace; ^ no need for pivate property
        this.OnChange = [];
    }
    ComplexProperty.prototype.Changed = function () {
        var _this = this;
        if (this.OnChange && this.OnChange.length > 0) {
            this.OnChange.forEach(function (delegateInstance, index, array) {
                if (delegateInstance)
                    delegateInstance(_this);
            });
        }
    };
    ComplexProperty.prototype.ClearChangeLog = function () { };
    ComplexProperty.prototype.InternalLoadFromXmlJsObject = function (jsObject, service, //xmlNamespace: XmlNamespace, xmlElementName: string,
        readAction /*System.Func<T, TResult>*/) {
        //reader.EnsureCurrentNodeIsStartElement(xmlNamespace, xmlElementName);
        //debugger;//check how to implement with jsobject.
        EwsLogging.Assert(false, this.constructor.name + ".LoadFromXmlJsObject", "ComplexProperty - InternalLoadFromXmlJsObject: todo:convert to jsobjectload. object type = " + this.constructor.name);
        throw new Error("ComplexProperty - InternalLoadFromXmlJsObject: todo:convert to jsobjectload. object type = " + this.constructor.name);
        // this.ReadAttributesFromXmlJsObject(jsObject);
        // if (!jsObject.IsEmptyElement) {
        //   do {
        //     jsObject.Read();
        //     switch (jsObject.NodeType) {
        //       case Node.ELEMENT_NODE:
        //         if (!readAction(jsObject)) {
        //           jsObject.SkipCurrentElement();
        //         }
        //         break;
        //       case Node.TEXT_NODE:
        //         this.ReadTextValueFromXmlJsObject(jsObject);
        //         break;
        //     }
        //   }
        //   while (!jsObject.HasRecursiveParent(xmlElementName));
        //   jsObject.SeekLast(); // go back for next process to read.
        //}
    };
    //InternalToJson(service: ExchangeService): any { throw new Error("ComplexProperty.ts - InternalToJson : Not implemented."); }
    ComplexProperty.prototype.InternalValidate = function () { };
    //LoadFromJson(jsonProperty: JsonObject, service: ExchangeService): any { throw new Error("ComplexProperty.ts - LoadFromJson : Not implemented."); }
    //LoadFromXml(reader: EwsServiceXmlReader, xmlElementName: string): any { throw new Error("ComplexProperty.ts - LoadFromXml : Not implemented."); }
    ComplexProperty.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        this.InternalLoadFromXmlJsObject(jsObject, service, this.ReadElementsFromXmlJsObject);
        // xmlNamespace || this.Namespace,
        // xmlElementName,
    };
    /**@internal */
    ComplexProperty.prototype.ReadAttributesFromXmlJsObject = function (reader) { debugger; /*virtual method for derived class to implement if needed*/ };
    /**@internal */
    ComplexProperty.prototype.ReadTextValueFromXmlJsObject = function (jsObject) { debugger; /*virtual method for derived class to implement if needed*/ };
    ComplexProperty.prototype.SetFieldValue = function (field, value) {
        var applyChange = false;
        if (field.getValue() == null) {
            applyChange = value != null;
        }
        else {
            var fieldAny = field.getValue();
            if (fieldAny.CompareTo) {
                applyChange = fieldAny.CompareTo(value) != 0; //todo: until fix the interface check (field as IComparable).CompareTo(value) != 0;
            }
            else {
                applyChange = true;
            }
        }
        if (applyChange) {
            //debugger;//debug; check; check for ref value setting. 
            field.setValue(value);
            this.Changed();
        }
    };
    ComplexProperty.prototype.ReadElementsFromXmlJsObject = function (jsonProperty, service) { debugger; /* abstract method - should implement*/ };
    ComplexProperty.prototype.ReadElementsFromXmlJsObjectToPatch = function (jsonProperty, service) { debugger; /* abstract method - should implement*/ };
    //UpdateFromXml(reader: EwsServiceXmlReader, xmlElementName: string): any { throw new Error("ComplexProperty.ts - UpdateFromXml : Not implemented."); }
    ComplexProperty.prototype.UpdateFromXmlJsObject = function (jsObject, service /*, xmlElementName: string, xmlNamespace?: XmlNamespace*/) {
        this.InternalLoadFromXmlJsObject(jsObject, service, this.ReadElementsFromXmlJsObjectToPatch);
        // xmlNamespace || this.Namespace,
        // xmlElementName,
    };
    /// <summary>
    /// Implements ISelfValidate.Validate. Validates this instance.
    /// </summary>
    ComplexProperty.prototype.Validate = function () {
        this.InternalValidate();
    };
    /**@internal */
    ComplexProperty.prototype.WriteAttributesToXml = function (writer) { };
    /**@internal */
    ComplexProperty.prototype.WriteElementsToXml = function (writer) { };
    /** @internal reverted to simplify child class override - it breaks all derived/child class and throws error "incorrectly extends base class" due to TypeScript design */
    //WriteToXml(writer: EwsServiceXmlWriter, xmlElementName: string): void { throw new Error("ComplexProperty.ts - WriteToXml : Not implemented."); }
    /**@internal */
    ComplexProperty.prototype.WriteToXml = function (writer, xmlElementName, xmlNamespace) {
        if (!xmlNamespace)
            xmlNamespace = this.Namespace;
        writer.WriteStartElement(xmlNamespace, xmlElementName);
        this.WriteAttributesToXml(writer);
        this.WriteElementsToXml(writer);
        writer.WriteEndElement();
    };
    return ComplexProperty;
}());
exports.ComplexProperty = ComplexProperty;
var CalendarEvent = (function (_super) {
    __extends(CalendarEvent, _super);
    function CalendarEvent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.startTime = null;
        _this.endTime = null;
        _this.freeBusyStatus = 0;
        _this.details = null;
        return _this;
    }
    Object.defineProperty(CalendarEvent.prototype, "StartTime", {
        get: function () {
            return this.startTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarEvent.prototype, "EndTime", {
        get: function () {
            return this.endTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarEvent.prototype, "FreeBusyStatus", {
        get: function () {
            return this.freeBusyStatus;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarEvent.prototype, "Details", {
        get: function () {
            return this.details;
        },
        enumerable: true,
        configurable: true
    });
    CalendarEvent.prototype.LoadFromJson = function (jsonProperty, service) { throw new Error("CalendarEvent.ts - LoadFromJson : Not implemented."); };
    CalendarEvent.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.StartTime:
                    this.startTime = EwsUtilities.ParseAsUnbiasedDatetimescopedToServicetimeZone(jsonProperty[key], service);
                    break;
                case XmlElementNames.EndTime:
                    this.endTime = EwsUtilities.ParseAsUnbiasedDatetimescopedToServicetimeZone(jsonProperty[key], service);
                    break;
                case XmlElementNames.BusyType:
                    this.freeBusyStatus = LegacyFreeBusyStatus[jsonProperty[key]];
                    break;
                case XmlElementNames.CalendarEventDetails:
                    this.details = new CalendarEventDetails();
                    this.details.LoadFromXmlJsObject(jsonProperty[key], service);
                    break;
                default:
                    break;
            }
        }
    };
    return CalendarEvent;
}(ComplexProperty));
exports.CalendarEvent = CalendarEvent;
var CalendarEventDetails = (function (_super) {
    __extends(CalendarEventDetails, _super);
    function CalendarEventDetails() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.storeId = null;
        _this.subject = null;
        _this.location = null;
        _this.isMeeting = false;
        _this.isRecurring = false;
        _this.isException = false;
        _this.isReminderSet = false;
        _this.isPrivate = false;
        return _this;
    }
    Object.defineProperty(CalendarEventDetails.prototype, "StoreId", {
        get: function () {
            return this.storeId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarEventDetails.prototype, "Subject", {
        get: function () {
            return this.subject;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarEventDetails.prototype, "Location", {
        get: function () {
            return this.location;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarEventDetails.prototype, "IsMeeting", {
        get: function () {
            return this.isMeeting;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarEventDetails.prototype, "IsRecurring", {
        get: function () {
            return this.isRecurring;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarEventDetails.prototype, "IsException", {
        get: function () {
            return this.isException;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarEventDetails.prototype, "IsReminderSet", {
        get: function () {
            return this.isReminderSet;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarEventDetails.prototype, "IsPrivate", {
        get: function () {
            return this.isPrivate;
        },
        enumerable: true,
        configurable: true
    });
    CalendarEventDetails.prototype.LoadFromJson = function (jsonProperty, service) { throw new Error("CalendarEventDetails.ts - LoadFromJson : Not implemented."); };
    CalendarEventDetails.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.ID:
                    this.storeId = jsonProperty[key];
                    break;
                case XmlElementNames.Subject:
                    this.subject = jsonProperty[key];
                    break;
                case XmlElementNames.Location:
                    this.location = jsonProperty[key];
                    break;
                case XmlElementNames.IsMeeting:
                    this.isMeeting = Convert.toBool(jsonProperty[key]);
                    break;
                case XmlElementNames.IsRecurring:
                    this.isRecurring = Convert.toBool(jsonProperty[key]);
                    break;
                case XmlElementNames.IsException:
                    this.isException = Convert.toBool(jsonProperty[key]);
                    break;
                case XmlElementNames.IsReminderSet:
                    this.isReminderSet = Convert.toBool(jsonProperty[key]);
                    break;
                case XmlElementNames.IsPrivate:
                    this.isPrivate = Convert.toBool(jsonProperty[key]);
                    break;
                default:
                    break;
            }
        }
    };
    return CalendarEventDetails;
}(ComplexProperty));
exports.CalendarEventDetails = CalendarEventDetails;
var Conflict = (function (_super) {
    __extends(Conflict, _super);
    function Conflict(conflictType) {
        var _this = _super.call(this) || this;
        _this.conflictType = ConflictType.IndividualAttendeeConflict;
        _this.numberOfMembers = 0;
        _this.numberOfMembersAvailable = 0;
        _this.numberOfMembersWithConflict = 0;
        _this.numberOfMembersWithNoData = 0;
        _this.freeBusyStatus = LegacyFreeBusyStatus.Free;
        _this.conflictType = conflictType;
        return _this;
    }
    Object.defineProperty(Conflict.prototype, "ConflictType", {
        get: function () {
            return this.conflictType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conflict.prototype, "NumberOfMembers", {
        get: function () {
            return this.numberOfMembers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conflict.prototype, "NumberOfMembersAvailable", {
        get: function () {
            return this.numberOfMembersAvailable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conflict.prototype, "NumberOfMembersWithConflict", {
        get: function () {
            return this.numberOfMembersWithConflict;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conflict.prototype, "NumberOfMembersWithNoData", {
        get: function () {
            return this.numberOfMembersWithNoData;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conflict.prototype, "FreeBusyStatus", {
        get: function () {
            return this.freeBusyStatus;
        },
        enumerable: true,
        configurable: true
    });
    //LoadFromJson(jsonProperty: JsonObject, service: ExchangeService): any { throw new Error("Conflict.ts - LoadFromJson : Not implemented."); }
    Conflict.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.NumberOfMembers:
                    this.numberOfMembers = Number(jsonProperty[key]);
                    break;
                case XmlElementNames.NumberOfMembersAvailable:
                    this.numberOfMembersAvailable = Number(jsonProperty[key]);
                    break;
                case XmlElementNames.NumberOfMembersWithConflict:
                    this.numberOfMembersWithConflict = Number(jsonProperty[key]);
                    break;
                case XmlElementNames.NumberOfMembersWithNoData:
                    this.numberOfMembersWithNoData = Number(jsonProperty[key]);
                    break;
                case XmlElementNames.BusyType:
                    this.freeBusyStatus = LegacyFreeBusyStatus[jsonProperty[key]];
                    break;
                default:
                    break;
            }
        }
    };
    return Conflict;
}(ComplexProperty));
exports.Conflict = Conflict;
/**
 * Represents a user's Out of Office (OOF) settings.
 */
var OofSettings = (function (_super) {
    __extends(OofSettings, _super);
    /**
     * Initializes a new instance of OofSettings.
     */
    function OofSettings() {
        var _this = _super.call(this) || this;
        _this.state = 0;
        _this.externalAudience = 0;
        _this.allowExternalOof = 0;
        _this.duration = null;
        _this.internalReply = null;
        _this.externalReply = null;
        return _this;
    }
    Object.defineProperty(OofSettings.prototype, "State", {
        /**
         * Gets or sets the user's OOF state.
         *
         * @value The user's OOF state.
         */
        get: function () {
            return this.state;
        },
        set: function (value) {
            this.state = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OofSettings.prototype, "ExternalAudience", {
        /**
         * Gets or sets a value indicating who should receive external OOF messages.
         */
        get: function () {
            return this.externalAudience;
        },
        set: function (value) {
            this.externalAudience = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OofSettings.prototype, "Duration", {
        /**
         * Gets or sets the duration of the OOF status when State is set to OofState.Scheduled.
         */
        get: function () {
            return this.duration;
        },
        set: function (value) {
            this.duration = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OofSettings.prototype, "InternalReply", {
        /**
         * Gets or sets the OOF response sent other users in the user's domain or trusted domain.
         */
        get: function () {
            return this.internalReply;
        },
        set: function (value) {
            this.internalReply = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OofSettings.prototype, "ExternalReply", {
        /**
         * Gets or sets the OOF response sent to addresses outside the user's domain or trusted domain.
         */
        get: function () {
            return this.externalReply;
        },
        set: function (value) {
            this.externalReply = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OofSettings.prototype, "AllowExternalOof", {
        /**
         * Gets a value indicating the authorized external OOF notifications.
         */
        get: function () {
            return this.allowExternalOof;
        },
        set: function (value) {
            this.allowExternalOof = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads from xmlJsObject.
     *
     * @param   {any}               jsObject   The json property.
     * @param   {ExchangeService}   service        [description]
     */
    OofSettings.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.OofState:
                    this.state = OofState[jsObject[key]];
                    break;
                case XmlElementNames.ExternalAudience:
                    this.externalAudience = OofExternalAudience[jsObject[key]];
                    break;
                case XmlElementNames.Duration:
                    this.duration = new TimeWindow();
                    this.duration.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.InternalReply:
                    this.internalReply = new OofReply();
                    this.internalReply.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.ExternalReply:
                    this.externalReply = new OofReply();
                    this.externalReply.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * Serializes an OofReply. Emits an empty OofReply in case the one passed in is null.
     *
     * @param   {OofReply}              oofReply         The oof reply.
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    OofSettings.prototype.SerializeOofReply = function (oofReply, writer, xmlElementName) {
        if (oofReply != null) {
            oofReply.WriteToXml(writer, xmlElementName);
        }
        else {
            OofReply.WriteEmptyReplyToXml(writer, xmlElementName);
        }
    };
    /**
     * Validates this instance.
     */
    OofSettings.prototype.Validate = function () {
        if (this.State == OofState.Scheduled) {
            if (this.Duration == null) {
                throw new ArgumentException(Strings.DurationMustBeSpecifiedWhenScheduled);
            }
            EwsUtilities.ValidateParam(this.Duration, "Duration");
        }
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    OofSettings.prototype.WriteElementsToXml = function (writer) {
        _super.prototype.WriteElementsToXml.call(this, writer);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.OofState, OofState[this.State]);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ExternalAudience, OofExternalAudience[this.ExternalAudience]);
        if (this.Duration != null && this.State == OofState.Scheduled) {
            this.Duration.WriteToXml(writer, XmlElementNames.Duration);
        }
        this.SerializeOofReply(this.InternalReply, writer, XmlElementNames.InternalReply);
        this.SerializeOofReply(this.ExternalReply, writer, XmlElementNames.ExternalReply);
    };
    return OofSettings;
}(ComplexProperty));
exports.OofSettings = OofSettings;
var Suggestion = (function (_super) {
    __extends(Suggestion, _super);
    function Suggestion() {
        var _this = _super.call(this) || this;
        _this.date = null;
        _this.quality = SuggestionQuality.Excellent;
        _this.timeSuggestions = []; /*System.Collections.ObjectModel.Collection<TimeSuggestion>;*/
        return _this;
    }
    Object.defineProperty(Suggestion.prototype, "Date", {
        get: function () {
            return this.date;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Suggestion.prototype, "Quality", {
        get: function () {
            return this.quality;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Suggestion.prototype, "TimeSuggestions", {
        get: function () {
            return this.timeSuggestions;
        },
        enumerable: true,
        configurable: true
    });
    //LoadFromJson(jsonProperty: any, service: ExchangeService): any { throw new Error("Suggestion.ts - LoadFromJson : Not implemented."); }
    Suggestion.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        this.date = DateTime.Parse(jsonProperty[XmlElementNames.Date]);
        console.log("bug: Suggestion->LoadFromXml:    need to change to millisecond and with datetimekind");
        debugger;
        this.quality = SuggestionQuality[jsonProperty[XmlElementNames.DayQuality]];
        var suggestionArrayObj = jsonProperty[XmlElementNames.SuggestionArray];
        var suggestions = EwsServiceJsonReader.ReadAsArray(suggestionArrayObj, XmlElementNames.Suggestion);
        for (var _a = 0, suggestions_1 = suggestions; _a < suggestions_1.length; _a++) {
            var suggestion = suggestions_1[_a];
            var timeSuggestion = new TimeSuggestion();
            timeSuggestion.LoadFromXmlJsObject(suggestion, service);
            this.timeSuggestions.push(timeSuggestion);
        }
    };
    return Suggestion;
}(ComplexProperty));
exports.Suggestion = Suggestion;
var TimeSuggestion = (function (_super) {
    __extends(TimeSuggestion, _super);
    function TimeSuggestion() {
        var _this = _super.call(this) || this;
        _this.meetingTime = null;
        _this.isWorkTime = false;
        _this.quality = SuggestionQuality.Excellent;
        _this.conflicts = []; // System.Collections.ObjectModel.Collection<Conflict>;
        return _this;
    }
    Object.defineProperty(TimeSuggestion.prototype, "MeetingTime", {
        get: function () {
            return this.meetingTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSuggestion.prototype, "IsWorkTime", {
        get: function () {
            return this.isWorkTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSuggestion.prototype, "Quality", {
        get: function () {
            return this.quality;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeSuggestion.prototype, "Conflicts", {
        get: function () {
            return this.conflicts;
        },
        enumerable: true,
        configurable: true
    });
    //LoadFromJson(jsonProperty: any, service: ExchangeService): any { throw new Error("TimeSuggestion.ts - LoadFromJson : Not implemented."); }
    TimeSuggestion.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.MeetingTime:
                    this.meetingTime = EwsUtilities.ParseAsUnbiasedDatetimescopedToServicetimeZone(jsonProperty[key], service);
                    break;
                case XmlElementNames.IsWorkTime:
                    this.isWorkTime = Convert.toBool(jsonProperty[key]);
                    break;
                case XmlElementNames.SuggestionQuality:
                    this.quality = SuggestionQuality[jsonProperty[key]];
                    break;
                case XmlElementNames.AttendeeConflictDataArray:
                    var jsConflictDataArray = jsonProperty[key];
                    for (var conflictKey in jsConflictDataArray) {
                        if (conflictKey.indexOf("__") === 0)
                            continue;
                        var conflictType = ConflictType.IndividualAttendeeConflict;
                        var jsConflicts = EwsServiceJsonReader.ReadAsArray(jsConflictDataArray, conflictKey);
                        switch (conflictKey) {
                            case XmlElementNames.UnknownAttendeeConflictData:
                                conflictType = ConflictType.UnknownAttendeeConflict;
                                break;
                            case XmlElementNames.TooBigGroupAttendeeConflictData:
                                conflictType = ConflictType.GroupTooBigConflict;
                                break;
                            case XmlElementNames.IndividualAttendeeConflictData:
                                conflictType = ConflictType.IndividualAttendeeConflict;
                                break;
                            case XmlElementNames.GroupAttendeeConflictData:
                                conflictType = ConflictType.GroupConflict;
                                break;
                            default:
                                EwsLogging.Assert(false, "TimeSuggestion.TryReadElementFromJson", StringHelper.Format("The {0} element name does not map to any AttendeeConflict descendant.", TypeSystem.GetJsObjectTypeName(jsConflicts)));
                                // The following line to please the compiler
                                break;
                        }
                        for (var _a = 0, jsConflicts_1 = jsConflicts; _a < jsConflicts_1.length; _a++) {
                            var conflictItem = jsConflicts_1[_a];
                            var conflict = new Conflict(conflictType);
                            conflict.LoadFromXmlJsObject(conflictItem, service);
                            this.conflicts.push(conflict);
                        }
                    }
                    break;
                default:
                    break;
            }
        }
    };
    return TimeSuggestion;
}(ComplexProperty));
exports.TimeSuggestion = TimeSuggestion;
var WorkingHours = (function (_super) {
    __extends(WorkingHours, _super);
    function WorkingHours() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.LegacyTimeZone = new LegacyAvailabilityTimeZone();
        _this.daysOfTheWeek = [] /*System.Collections.ObjectModel.Collection<DayOfTheWeek>*/;
        return _this;
        //ReadElementsFromXmlJsObject(reader: any): boolean { throw new Error("WorkingHours.ts - TryReadElementFromXmlJsObject : Not implemented."); }
    }
    Object.defineProperty(WorkingHours.prototype, "TimeZone", {
        get: function () {
            return this.timeZone;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WorkingHours.prototype, "DaysOfTheWeek", {
        get: function () { return this.daysOfTheWeek; } /*System.Collections.ObjectModel.Collection<DayOfTheWeek>*/,
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WorkingHours.prototype, "StartTime", {
        get: function () { return this.startTime; } /*System.TimeSpan*/,
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WorkingHours.prototype, "EndTime", {
        get: function () { return this.endTime; } /*System.TimeSpan*/,
        enumerable: true,
        configurable: true
    });
    WorkingHours.prototype.LoadFromJson = function (jsonProperty, service) { throw new Error("WorkingHours.ts - LoadFromJson : Not implemented."); };
    WorkingHours.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.TimeZone:
                    var legacyTimeZone = new LegacyAvailabilityTimeZone();
                    legacyTimeZone.LoadFromXmlJsObject(jsonProperty[key], service);
                    this.LegacyTimeZone = legacyTimeZone;
                    //this.timeZone = legacyTimeZone.ToTimeZoneInfo();
                    break;
                case XmlElementNames.WorkingPeriodArray:
                    var workingPeriods = []; // new List<WorkingPeriod>();
                    var workingPeriodsArrayObject = jsonProperty[key];
                    var workingPeriodsArray = workingPeriodsArrayObject[XmlElementNames.WorkingPeriod];
                    if (!Array.isArray(workingPeriodsArray)) {
                        workingPeriodsArray = [workingPeriodsArray];
                    }
                    for (var _a = 0, workingPeriodsArray_1 = workingPeriodsArray; _a < workingPeriodsArray_1.length; _a++) {
                        var workingPeriodEntry = workingPeriodsArray_1[_a];
                        var workingPeriod = new WorkingPeriod();
                        workingPeriod.LoadFromXmlJsObject(workingPeriodEntry, service);
                        workingPeriods.push(workingPeriod);
                    }
                    // Availability supports a structure that can technically represent different working
                    // times for each day of the week. This is apparently how the information is stored in
                    // Exchange. However, no client (Outlook, OWA) either will let you specify different
                    // working times for each day of the week, and Outlook won't either honor that complex
                    // structure if it happens to be in Exchange.
                    // So here we'll do what Outlook and OWA do: we'll use the start and end times of the
                    // first working period, but we'll use the week days of all the periods.
                    this.startTime = workingPeriods[0].StartTime;
                    this.endTime = workingPeriods[0].EndTime;
                    for (var _b = 0, workingPeriods_1 = workingPeriods; _b < workingPeriods_1.length; _b++) {
                        var workingPeriod = workingPeriods_1[_b];
                        for (var _c = 0, _d = workingPeriods[0].DaysOfWeek; _c < _d.length; _c++) {
                            var dayOfWeek = _d[_c];
                            if (this.daysOfTheWeek.indexOf(dayOfWeek) < 0) {
                                this.daysOfTheWeek.push(dayOfWeek);
                            }
                        }
                    }
                    break;
                default:
                    break;
            }
        }
    };
    return WorkingHours;
}(ComplexProperty));
exports.WorkingHours = WorkingHours;
var WorkingPeriod = (function (_super) {
    __extends(WorkingPeriod, _super);
    function WorkingPeriod() {
        var _this = _super.call(this) || this;
        _this.daysOfWeek = [] /*System.Collections.ObjectModel.Collection<DayOfTheWeek>*/;
        _this.startTime = null /*System.TimeSpan*/;
        _this.endTime = null /*System.TimeSpan*/;
        return _this;
    }
    Object.defineProperty(WorkingPeriod.prototype, "DaysOfWeek", {
        get: function () { return this.daysOfWeek; } /*System.Collections.ObjectModel.Collection<DayOfTheWeek>*/,
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WorkingPeriod.prototype, "StartTime", {
        get: function () { return this.startTime; } /*System.TimeSpan*/,
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WorkingPeriod.prototype, "EndTime", {
        get: function () { return this.endTime; } /*System.TimeSpan*/,
        enumerable: true,
        configurable: true
    });
    WorkingPeriod.prototype.LoadFromJson = function (jsonProperty, service) { throw new Error("WorkingPeriod.ts - LoadFromJson : Not implemented."); };
    WorkingPeriod.prototype.ReadElementsFromXmlJsObject = function (reader) { throw new Error("WorkingPeriod.ts - TryReadElementFromXmlJsObject : Not implemented."); };
    WorkingPeriod.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.DayOfWeek:
                    EwsUtilities.ParseEnumValueList(this.daysOfWeek, jsonProperty[key], ' ', DayOfTheWeek);
                    break;
                case XmlElementNames.StartTimeInMinutes:
                    this.startTime = TimeSpan.FromMinutes(Number(jsonProperty[key]));
                    break;
                case XmlElementNames.EndTimeInMinutes:
                    this.endTime = TimeSpan.FromMinutes(Number(jsonProperty[key]));
                    break;
                default:
                    break;
            }
        }
    };
    return WorkingPeriod;
}(ComplexProperty));
exports.WorkingPeriod = WorkingPeriod;
/**
 * Represents a collection of DayOfTheWeek values.
 */
var DayOfTheWeekCollection = (function (_super) {
    __extends(DayOfTheWeekCollection, _super);
    /**
     * @internal Initializes a new instance of the **DayOfTheWeekCollection** class.
     */
    function DayOfTheWeekCollection() {
        var _this = _super.call(this) || this;
        _this.items = [];
        return _this;
    }
    Object.defineProperty(DayOfTheWeekCollection.prototype, "Count", {
        get: function () {
            return this.items.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the DayOfTheWeek at a specific index in the collection.
     *
     * @param   {number}        index   Index
     * @return  {DayOfTheWeek}  DayOfTheWeek at index
     */
    DayOfTheWeekCollection.prototype._getItem = function (index) {
        return this.items[index];
    };
    /**
     * Adds a day to the collection if it is not already present.
     *
     * @param   {DayOfTheWeek}   dayOfTheWeek   The day to add.
     */
    DayOfTheWeekCollection.prototype.Add = function (dayOfTheWeek) {
        if (this.items.indexOf(dayOfTheWeek) < 0) {
            this.items.push(dayOfTheWeek);
            this.Changed();
        }
    };
    /**
     * Adds multiple days to the collection if they are not already present.
     *
     * @param   {DayOfTheWeek[]}   daysOfTheWeek   The days to add.
     */
    DayOfTheWeekCollection.prototype.AddRange = function (daysOfTheWeek) {
        for (var _a = 0, daysOfTheWeek_1 = daysOfTheWeek; _a < daysOfTheWeek_1.length; _a++) {
            var dayOfTheWeek = daysOfTheWeek_1[_a];
            this.Add(dayOfTheWeek);
        }
    };
    /**
     * Clears the collection.
     */
    DayOfTheWeekCollection.prototype.Clear = function () {
        if (this.Count > 0) {
            this.items.splice(0);
            this.Changed();
        }
    };
    /**
     *  Returns an enumerator that iterates through the collection. this case this.items
     */
    DayOfTheWeekCollection.prototype.GetEnumerator = function () {
        return this.items;
    };
    /**
     * @internal Loads service object from XMLJsObject Value.
     *
     * @param   {string}            jsObject                Json Object converted from XML.
     */
    DayOfTheWeekCollection.prototype.LoadFromXmlJsObjectValue = function (jsObjectValue) {
        EwsUtilities.ParseEnumValueList(this.items, jsObjectValue, ' ', DayOfTheWeek);
    };
    /**
     * Remove a specific day from the collection.
     *
     * @param   {DayOfTheWeek}   dayOfTheWeek   The day to remove.
     * @return  {boolean}       True if the day was removed from the collection, false otherwise.
     */
    DayOfTheWeekCollection.prototype.Remove = function (dayOfTheWeek) {
        if (this.items.indexOf(dayOfTheWeek)) {
            var result = this.items.splice(this.items.indexOf(dayOfTheWeek));
            if (result.length > 0) {
                this.Changed();
            }
            return result.length > 0;
        }
        return false;
    };
    /**
     * Removes the day at a specific index.
     *
     * @param   {number}   index   The index of the day to remove.
     */
    DayOfTheWeekCollection.prototype.RemoveAt = function (index) {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }
        this.items.splice(index);
        this.Changed();
    };
    DayOfTheWeekCollection.prototype.ToString = function (separator) {
        if (separator === void 0) { separator = " "; }
        if (this.Count == 0) {
            return StringHelper.Empty;
        }
        else {
            var daysOfTheWeekArray = new Array(this.Count);
            for (var i = 0; i < this.Count; i++) {
                daysOfTheWeekArray[i] = DayOfTheWeek[this.items[i]];
            }
            return daysOfTheWeekArray.join(separator);
        }
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {string}   xmlElementName   Name of the XML element.
     */
    DayOfTheWeekCollection.prototype.WriteToXml = function (writer, xmlElementName) {
        var daysOfWeekAsString = this.ToString(" ");
        if (!StringHelper.IsNullOrEmpty(daysOfWeekAsString)) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DaysOfWeek, daysOfWeekAsString);
        }
    };
    return DayOfTheWeekCollection;
}(ComplexProperty));
exports.DayOfTheWeekCollection = DayOfTheWeekCollection;
/**
 * Represents a recurrence pattern, as used by Appointment and Task items.
 */
var Recurrence = (function (_super) {
    __extends(Recurrence, _super);
    function Recurrence(startDate) {
        var _this = _super.call(this) || this;
        _this.startDate = null;
        _this.numberOfOccurrences = null;
        _this.endDate = null;
        if (arguments.length === 1) {
            _this.startDate = startDate;
        }
        return _this;
    }
    Object.defineProperty(Recurrence.prototype, "XmlElementName", {
        /**
         * @internal Gets the name of the XML element.
         *
         * @value   The name of the XML element.
         */
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(Recurrence.prototype, "IsRegenerationPattern", {
        /**
         * @internal Gets a value indicating whether this instance is regeneration pattern.
         *
         * @value   *true* if this instance is regeneration pattern; otherwise, *false*.
         */
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Recurrence.prototype, "StartDate", {
        /**
         * Gets or sets the date and time when the recurrence start.
         */
        get: function () {
            return this.GetFieldValueOrThrowIfNull(this.startDate, "StartDate");
        },
        set: function (value) {
            this.startDate = new DateTime(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Recurrence.prototype, "HasEnd", {
        /**
         * Gets a value indicating whether the pattern has a fixed number of occurrences or an end date.
         */
        get: function () {
            return this.numberOfOccurrences !== null || this.endDate !== null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Recurrence.prototype, "NumberOfOccurrences", {
        /**
         * Gets or sets the number of occurrences after which the recurrence ends. Setting NumberOfOccurrences resets EndDate.
         */
        get: function () {
            return this.numberOfOccurrences;
        },
        set: function (value) {
            var _this = this;
            if (value < 1) {
                throw new ArgumentException(Strings.NumberOfOccurrencesMustBeGreaterThanZero);
            }
            this.SetFieldValue({ getValue: function () { return _this.numberOfOccurrences; }, setValue: function (updateValue) { _this.numberOfOccurrences = updateValue; } }, value);
            this.endDate = null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Recurrence.prototype, "EndDate", {
        /**
         * Gets or sets the date after which the recurrence ends. Setting EndDate resets NumberOfOccurrences.
         */
        get: function () {
            return this.endDate;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.endDate; }, setValue: function (updateValue) { _this.endDate = updateValue; } }, value);
            this.numberOfOccurrences = null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets a property value or throw if null.
     *
     * @typeparam   {T}     Value type.
     * @param   {T}         value   The value.
     * @param   {string}    name    The property name.
     * @return  {T}         Property value
     */
    Recurrence.prototype.GetFieldValueOrThrowIfNull = function (value, name) {
        if (typeof value !== 'undefined' && value !== null) {
            return value;
        }
        else {
            throw new ServiceValidationException(StringHelper.Format(Strings.PropertyValueMustBeSpecifiedForRecurrencePattern, name));
        }
    };
    /**
     * @internal Validates this instance.
     */
    Recurrence.prototype.InternalValidate = function () {
        _super.prototype.InternalValidate.call(this);
        if (!this.startDate) {
            throw new ServiceValidationException(Strings.RecurrencePatternMustHaveStartDate);
        }
    };
    /**
     * @internal Write properties to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    Recurrence.prototype.InternalWritePropertiesToXml = function (writer) { };
    /**
     * Compares two objects by converting them to JSON and comparing their string values
     *
     * @param   {Recurrence}    otherRecurrence   object to compare to
     * @return  {boolean}       true if the objects serialize to the same string
     */
    Recurrence.prototype.IsSame = function (otherRecurrence) {
        throw new Error("Recurrence.ts - IsSame : Not implemented. - no method calls it");
        // if (otherRecurrence == null) {
        //     return false;
        // }
        // string jsonString;
        // using(MemoryStream memoryStream = new MemoryStream())
        // {
        //     ((JsonObject)this.InternalToJson(null)).SerializeToJson(memoryStream);
        //     memoryStream.Position = 0;
        //     using(StreamReader reader = new StreamReader(memoryStream))
        //     {
        //         jsonString = reader.ReadToEnd();
        //     }
        // }
        // string otherJsonString;
        // using(MemoryStream memoryStream = new MemoryStream())
        // {
        //     ((JsonObject)otherRecurrence.InternalToJson(null)).SerializeToJson(memoryStream);
        //     memoryStream.Position = 0;
        //     using(StreamReader reader = new StreamReader(memoryStream))
        //     {
        //         otherJsonString = reader.ReadToEnd();
        //     }
        // }
        // return String.Equals(jsonString, otherJsonString, StringComparison.Ordinal);
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    Recurrence.prototype.LoadFromXmlJsObject = function (jsObject, service) {
    };
    /**
     * Sets up this recurrence so that it never ends. Calling NeverEnds is equivalent to setting both NumberOfOccurrences and EndDate to null.
     */
    Recurrence.prototype.NeverEnds = function () {
        this.numberOfOccurrences = null;
        this.endDate = null;
        this.Changed();
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    Recurrence.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Types, this.XmlElementName);
        this.InternalWritePropertiesToXml(writer);
        writer.WriteEndElement();
        var range;
        if (!this.HasEnd) {
            range = new NoEndRecurrenceRange(this.StartDate);
        }
        else if (this.NumberOfOccurrences) {
            range = new NumberedRecurrenceRange(this.StartDate, this.NumberOfOccurrences);
        }
        else {
            range = new EndDateRecurrenceRange(this.StartDate, this.EndDate);
        }
        range.WriteToXml(writer, range.XmlElementName);
    };
    return Recurrence;
}(ComplexProperty));
exports.Recurrence = Recurrence;
(function (Recurrence) {
})(Recurrence = exports.Recurrence || (exports.Recurrence = {}));
exports.Recurrence = Recurrence;
/**
 * Represents a recurrence pattern where each occurrence happens at a specific interval after the previous one.
 */
var IntervalPattern = (function (_super) {
    __extends(IntervalPattern, _super);
    function IntervalPattern(startDate, interval) {
        if (interval === void 0) { interval = 1; }
        var _this = this;
        if (arguments.length === 0) {
            _this = _super.call(this) || this;
            _this.interval = 1;
            return;
        }
        _this = _super.call(this, startDate) || this;
        if (interval < 1) {
            throw new ArgumentOutOfRangeException("interval", Strings.IntervalMustBeGreaterOrEqualToOne);
        }
        _this.Interval = interval;
        return _this;
    }
    Object.defineProperty(IntervalPattern.prototype, "Interval", {
        /**
         * Gets or sets the interval between occurrences.
         */
        get: function () {
            return this.interval;
        },
        set: function (value) {
            var _this = this;
            if (value < 1) {
                throw new ArgumentOutOfRangeException("value", Strings.IntervalMustBeGreaterOrEqualToOne);
            }
            this.SetFieldValue({ getValue: function () { return _this.interval; }, setValue: function (updateValue) { _this.interval = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Write properties to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    IntervalPattern.prototype.InternalWritePropertiesToXml = function (writer) {
        _super.prototype.InternalWritePropertiesToXml.call(this, writer);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Interval, this.Interval);
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    IntervalPattern.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.Interval:
                    this.interval = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    };
    return IntervalPattern;
}(Recurrence));
exports.IntervalPattern = IntervalPattern;
/**
 * Represents a recurrence pattern where each occurrence happens a specific number of days after the previous one.
 */
var DailyPattern = (function (_super) {
    __extends(DailyPattern, _super);
    function DailyPattern(startDate, interval) {
        var _this = this;
        if (arguments.length === 0) {
            _this = _super.call(this) || this;
            return;
        }
        _this = _super.call(this, startDate, interval) || this;
        return _this;
    }
    Object.defineProperty(DailyPattern.prototype, "XmlElementName", {
        /**
         * @internal Gets the name of the XML element.
         *
         * @value   The name of the XML element.
         */
        get: function () {
            return XmlElementNames.DailyRecurrence;
        },
        enumerable: true,
        configurable: true
    });
    return DailyPattern;
}(IntervalPattern));
exports.DailyPattern = DailyPattern;
/**
 * Represents a regeneration pattern, as used with recurring tasks, where each occurrence happens a specified number of days after the previous one is completed.
 */
var DailyRegenerationPattern = (function (_super) {
    __extends(DailyRegenerationPattern, _super);
    function DailyRegenerationPattern(startDate, interval) {
        var _this = this;
        if (arguments.length === 0) {
            _this = _super.call(this) || this;
            return;
        }
        _this = _super.call(this, startDate, interval) || this;
        return _this;
    }
    Object.defineProperty(DailyRegenerationPattern.prototype, "XmlElementName", {
        /**
         * @internal Gets the name of the XML element.
         *
         * @value   The name of the XML element.
         */
        get: function () {
            return XmlElementNames.DailyRegeneration;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DailyRegenerationPattern.prototype, "IsRegenerationPattern", {
        /**
         * Gets a value indicating whether this instance is a regeneration pattern.
         *
         * @value   *true* if this instance is a regeneration pattern; otherwise, *false*.</value>
         */
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    return DailyRegenerationPattern;
}(IntervalPattern));
exports.DailyRegenerationPattern = DailyRegenerationPattern;
/**
 * Represents a recurrence pattern where each occurrence happens on a specific day a specific number of months after the previous one.
 */
var MonthlyPattern = (function (_super) {
    __extends(MonthlyPattern, _super);
    function MonthlyPattern(startDate, interval, dayOfMonth) {
        if (dayOfMonth === void 0) { dayOfMonth = null; }
        var _this = this;
        if (arguments.length === 0) {
            _this = _super.call(this) || this;
            _this.dayOfMonth = null;
            return;
        }
        _this = _super.call(this, startDate, interval) || this;
        _this.DayOfMonth = dayOfMonth;
        return _this;
    }
    Object.defineProperty(MonthlyPattern.prototype, "XmlElementName", {
        /**
         * @internal Gets the name of the XML element.
         *
         * @value   The name of the XML element.
         */
        get: function () {
            return XmlElementNames.AbsoluteMonthlyRecurrence;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MonthlyPattern.prototype, "DayOfMonth", {
        /**
         * Gets or sets the day of the month when each occurrence happens. DayOfMonth must be between 1 and 31.
         */
        get: function () {
            return _super.prototype.GetFieldValueOrThrowIfNull.call(this, this.dayOfMonth, "DayOfMonth");
        },
        set: function (value) {
            var _this = this;
            if (value < 1 || value > 31) {
                throw new ArgumentOutOfRangeException("DayOfMonth", Strings.DayOfMonthMustBeBetween1And31);
            }
            this.SetFieldValue({ getValue: function () { return _this.dayOfMonth; }, setValue: function (updateValue) { _this.dayOfMonth = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Validates this instance.
     */
    MonthlyPattern.prototype.InternalValidate = function () {
        _super.prototype.InternalValidate.call(this);
        if (this.dayOfMonth === null) {
            throw new ServiceValidationException(Strings.DayOfMonthMustBeBetween1And31);
        }
    };
    /**
     * @internal Write properties to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    MonthlyPattern.prototype.InternalWritePropertiesToXml = function (writer) {
        _super.prototype.InternalWritePropertiesToXml.call(this, writer);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DayOfMonth, this.DayOfMonth);
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    MonthlyPattern.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.DayOfMonth:
                    this.dayOfMonth = Convert.toNumber(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    };
    return MonthlyPattern;
}(IntervalPattern));
exports.MonthlyPattern = MonthlyPattern;
/**
 * Represents a regeneration pattern, as used with recurring tasks, where each occurrence happens a specified number of months after the previous one is completed.
 */
var MonthlyRegenerationPattern = (function (_super) {
    __extends(MonthlyRegenerationPattern, _super);
    function MonthlyRegenerationPattern(startDate, interval) {
        var _this = this;
        if (arguments.length === 0) {
            _this = _super.call(this) || this;
            return;
        }
        _this = _super.call(this, startDate, interval) || this;
        return _this;
    }
    Object.defineProperty(MonthlyRegenerationPattern.prototype, "XmlElementName", {
        /**
         * @internal Gets the name of the XML element.
         *
         * @value   The name of the XML element.
         */
        get: function () {
            return XmlElementNames.MonthlyRegeneration;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MonthlyRegenerationPattern.prototype, "IsRegenerationPattern", {
        /**
         * Gets a value indicating whether this instance is a regeneration pattern.
         *
         * @value   *true* if this instance is a regeneration pattern; otherwise, *false*.</value>
         */
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    return MonthlyRegenerationPattern;
}(IntervalPattern));
exports.MonthlyRegenerationPattern = MonthlyRegenerationPattern;
/**
 * Represents a recurrence pattern where each occurrence happens on a relative day a specific number of months after the previous one.
*/
var RelativeMonthlyPattern = (function (_super) {
    __extends(RelativeMonthlyPattern, _super);
    function RelativeMonthlyPattern(startDate, interval, dayOfTheWeek, dayOfTheWeekIndex) {
        if (dayOfTheWeek === void 0) { dayOfTheWeek = null; }
        if (dayOfTheWeekIndex === void 0) { dayOfTheWeekIndex = null; }
        var _this = this;
        if (arguments.length === 0) {
            _this = _super.call(this) || this;
            _this.dayOfTheWeek = null;
            _this.dayOfTheWeekIndex = null;
            return;
        }
        _this = _super.call(this, startDate, interval) || this;
        _this.DayOfTheWeek = dayOfTheWeek;
        _this.DayOfTheWeekIndex = dayOfTheWeekIndex;
        return _this;
    }
    Object.defineProperty(RelativeMonthlyPattern.prototype, "XmlElementName", {
        /**
         * @internal Gets the name of the XML element.
         *
         * @value   The name of the XML element.
         */
        get: function () {
            return XmlElementNames.RelativeMonthlyRecurrence;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RelativeMonthlyPattern.prototype, "DayOfTheWeekIndex", {
        /**
         * Gets or sets the relative position of the day specified in DayOfTheWeek within the month.
         */
        get: function () {
            return _super.prototype.GetFieldValueOrThrowIfNull.call(this, this.dayOfTheWeekIndex, "DayOfTheWeekIndex");
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.dayOfTheWeekIndex; }, setValue: function (updateValue) { _this.dayOfTheWeekIndex = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RelativeMonthlyPattern.prototype, "DayOfTheWeek", {
        /**
         * The day of the week when each occurrence happens.
         */
        get: function () {
            return _super.prototype.GetFieldValueOrThrowIfNull.call(this, this.dayOfTheWeek, "DayOfTheWeek");
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.dayOfTheWeek; }, setValue: function (updateValue) { _this.dayOfTheWeek = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Validates this instance.
     */
    RelativeMonthlyPattern.prototype.InternalValidate = function () {
        _super.prototype.InternalValidate.call(this);
        if (this.dayOfTheWeek === null) {
            throw new ServiceValidationException(Strings.DayOfTheWeekMustBeSpecifiedForRecurrencePattern);
        }
        if (this.dayOfTheWeekIndex === null) {
            throw new ServiceValidationException(Strings.DayOfWeekIndexMustBeSpecifiedForRecurrencePattern);
        }
    };
    /**
     * @internal Write properties to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    RelativeMonthlyPattern.prototype.InternalWritePropertiesToXml = function (writer) {
        _super.prototype.InternalWritePropertiesToXml.call(this, writer);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DaysOfWeek, DayOfTheWeek[this.DayOfTheWeek]);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DayOfWeekIndex, DayOfTheWeekIndex[this.DayOfTheWeekIndex]);
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    RelativeMonthlyPattern.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.DaysOfWeek:
                    this.dayOfTheWeek = DayOfTheWeek[jsObject[key]];
                    break;
                case XmlElementNames.DayOfWeekIndex:
                    this.dayOfTheWeekIndex = DayOfTheWeekIndex[jsObject[key]];
                    break;
                default:
                    break;
            }
        }
    };
    return RelativeMonthlyPattern;
}(IntervalPattern));
exports.RelativeMonthlyPattern = RelativeMonthlyPattern;
/**
 * Represents a recurrence pattern where each occurrence happens on specific days a specific number of weeks after the previous one.
 */
var WeeklyPattern = (function (_super) {
    __extends(WeeklyPattern, _super);
    function WeeklyPattern(startDate, interval, daysOfTheWeek) {
        if (daysOfTheWeek === void 0) { daysOfTheWeek = []; }
        var _this = this;
        if (arguments.length === 0) {
            _this = _super.call(this) || this;
            _this.daysOfTheWeek = new DayOfTheWeekCollection();
            _this.daysOfTheWeek.OnChange.push(_this.DaysOfTheWeekChanged.bind(_this));
        }
        else {
            _this = _super.call(this, startDate, interval) || this;
            _this.daysOfTheWeek = new DayOfTheWeekCollection();
        }
        _this.firstDayOfWeek = null;
        _this.daysOfTheWeek.AddRange(daysOfTheWeek);
        return _this;
    }
    Object.defineProperty(WeeklyPattern.prototype, "XmlElementName", {
        /**
         * @internal Gets the name of the XML element.
         *
         * @value   The name of the XML element.
         */
        get: function () {
            return XmlElementNames.WeeklyRecurrence;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WeeklyPattern.prototype, "DaysOfTheWeek", {
        /**
         * Gets the list of the days of the week when occurrences happen.
         */
        get: function () {
            return this.daysOfTheWeek;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WeeklyPattern.prototype, "FirstDayOfWeek", {
        /**
         * Gets or sets the first day of the week for this recurrence.
         */
        get: function () {
            return _super.prototype.GetFieldValueOrThrowIfNull.call(this, this.firstDayOfWeek, "FirstDayOfWeek");
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.firstDayOfWeek; }, setValue: function (updateValue) { _this.firstDayOfWeek = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Change event handler.
     *
     * @param   {ComplexProperty}   complexProperty   The complex property.
     */
    WeeklyPattern.prototype.DaysOfTheWeekChanged = function (complexProperty) { this.Changed(); };
    /**
     * @internal Validates this instance.
     */
    WeeklyPattern.prototype.InternalValidate = function () {
        _super.prototype.InternalValidate.call(this);
        if (this.DaysOfTheWeek.Count == 0) {
            throw new ServiceValidationException(Strings.DaysOfTheWeekNotSpecified);
        }
    };
    /**
     * @internal Write properties to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    WeeklyPattern.prototype.InternalWritePropertiesToXml = function (writer) {
        _super.prototype.InternalWritePropertiesToXml.call(this, writer);
        this.DaysOfTheWeek.WriteToXml(writer, XmlElementNames.DaysOfWeek);
        if (this.firstDayOfWeek) {
            //  We only allow the "FirstDayOfWeek" parameter for the Exchange2010_SP1 schema
            //  version.
            //
            EwsUtilities.ValidatePropertyVersion(writer.Service, ExchangeVersion.Exchange2010_SP1, "FirstDayOfWeek");
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.FirstDayOfWeek, DayOfWeek[this.firstDayOfWeek]);
        }
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    WeeklyPattern.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.DaysOfWeek:
                    this.DaysOfTheWeek.LoadFromXmlJsObjectValue(jsObject[key]);
                    break;
                case XmlElementNames.FirstDayOfWeek:
                    this.FirstDayOfWeek = DayOfWeek[jsObject[key]];
                    break;
                default:
                    break;
            }
        }
    };
    return WeeklyPattern;
}(IntervalPattern));
exports.WeeklyPattern = WeeklyPattern;
/**
 * Represents a regeneration pattern, as used with recurring tasks, where each occurrence happens a specified number of weeks after the previous one is completed.
 */
var WeeklyRegenerationPattern = (function (_super) {
    __extends(WeeklyRegenerationPattern, _super);
    function WeeklyRegenerationPattern(startDate, interval) {
        var _this = this;
        if (arguments.length === 0) {
            _this = _super.call(this) || this;
            return;
        }
        _this = _super.call(this, startDate, interval) || this;
        return _this;
    }
    Object.defineProperty(WeeklyRegenerationPattern.prototype, "XmlElementName", {
        /**
         * @internal Gets the name of the XML element.
         *
         * @value   The name of the XML element.
         */
        get: function () {
            return XmlElementNames.WeeklyRegeneration;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WeeklyRegenerationPattern.prototype, "IsRegenerationPattern", {
        /**
         * Gets a value indicating whether this instance is a regeneration pattern.
         *
         * @value   *true* if this instance is a regeneration pattern; otherwise, *false*.</value>
         */
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    return WeeklyRegenerationPattern;
}(IntervalPattern));
exports.WeeklyRegenerationPattern = WeeklyRegenerationPattern;
/**
 * Represents a regeneration pattern, as used with recurring tasks, where each occurrence happens a specified number of years after the previous one is completed.
 */
var YearlyRegenerationPattern = (function (_super) {
    __extends(YearlyRegenerationPattern, _super);
    function YearlyRegenerationPattern(startDate, interval) {
        var _this = this;
        if (arguments.length === 0) {
            _this = _super.call(this) || this;
            return;
        }
        _this = _super.call(this, startDate, interval) || this;
        return _this;
    }
    Object.defineProperty(YearlyRegenerationPattern.prototype, "XmlElementName", {
        /**
         * @internal Gets the name of the XML element.
         *
         * @value   The name of the XML element.
         */
        get: function () {
            return XmlElementNames.MonthlyRegeneration;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(YearlyRegenerationPattern.prototype, "IsRegenerationPattern", {
        /**
         * Gets a value indicating whether this instance is a regeneration pattern.
         *
         * @value   *true* if this instance is a regeneration pattern; otherwise, *false*.</value>
         */
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    return YearlyRegenerationPattern;
}(IntervalPattern));
exports.YearlyRegenerationPattern = YearlyRegenerationPattern;
/**
 * Represents a recurrence pattern where each occurrence happens on a relative day every year.
 */
var RelativeYearlyPattern = (function (_super) {
    __extends(RelativeYearlyPattern, _super);
    function RelativeYearlyPattern(startDate, month, dayOfTheWeek, dayOfTheWeekIndex) {
        if (month === void 0) { month = null; }
        if (dayOfTheWeek === void 0) { dayOfTheWeek = null; }
        if (dayOfTheWeekIndex === void 0) { dayOfTheWeekIndex = null; }
        var _this = this;
        if (arguments.length === 0) {
            _this = _super.call(this) || this;
            _this.dayOfTheWeek = null;
            _this.dayOfTheWeekIndex = null;
            return;
        }
        _this = _super.call(this, startDate) || this;
        _this.Month = month;
        _this.DayOfTheWeek = dayOfTheWeek;
        _this.DayOfTheWeekIndex = dayOfTheWeekIndex;
        return _this;
    }
    Object.defineProperty(RelativeYearlyPattern.prototype, "XmlElementName", {
        /**
         * @internal Gets the name of the XML element.
         *
         * @value   The name of the XML element.
         */
        get: function () {
            return XmlElementNames.RelativeYearlyRecurrence;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RelativeYearlyPattern.prototype, "DayOfTheWeekIndex", {
        /**
         * Gets or sets the relative position of the day specified in DayOfTheWeek within the month.
         */
        get: function () {
            return _super.prototype.GetFieldValueOrThrowIfNull.call(this, this.dayOfTheWeekIndex, "DayOfTheWeekIndex");
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.dayOfTheWeekIndex; }, setValue: function (updateValue) { _this.dayOfTheWeekIndex = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RelativeYearlyPattern.prototype, "DayOfTheWeek", {
        /**
         * Gets or sets the day of the week when each occurrence happens.
         */
        get: function () {
            return _super.prototype.GetFieldValueOrThrowIfNull.call(this, this.dayOfTheWeek, "DayOfTheWeek");
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.dayOfTheWeek; }, setValue: function (updateValue) { _this.dayOfTheWeek = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RelativeYearlyPattern.prototype, "Month", {
        /**
         * Gets or sets the month of the year when each occurrence happens.
         */
        get: function () {
            return _super.prototype.GetFieldValueOrThrowIfNull.call(this, this.month, "Month");
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.month; }, setValue: function (updateValue) { _this.month = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Validates this instance.
     */
    RelativeYearlyPattern.prototype.InternalValidate = function () {
        _super.prototype.InternalValidate.call(this);
        if (this.dayOfTheWeekIndex === null) {
            throw new ServiceValidationException(Strings.DayOfWeekIndexMustBeSpecifiedForRecurrencePattern);
        }
        if (this.dayOfTheWeek === null) {
            throw new ServiceValidationException(Strings.DayOfTheWeekMustBeSpecifiedForRecurrencePattern);
        }
        if (this.month === null) {
            throw new ServiceValidationException(Strings.MonthMustBeSpecifiedForRecurrencePattern);
        }
    };
    /**
     * @internal Write properties to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    RelativeYearlyPattern.prototype.InternalWritePropertiesToXml = function (writer) {
        _super.prototype.InternalWritePropertiesToXml.call(this, writer);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DaysOfWeek, DayOfTheWeek[this.DayOfTheWeek]);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DayOfWeekIndex, DayOfTheWeekIndex[this.DayOfTheWeekIndex]);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Month, Month[this.Month]);
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    RelativeYearlyPattern.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.DaysOfWeek:
                    this.dayOfTheWeek = DayOfTheWeek[jsObject[key]];
                    break;
                case XmlElementNames.DayOfWeekIndex:
                    this.dayOfTheWeekIndex = DayOfTheWeekIndex[jsObject[key]];
                    break;
                case XmlElementNames.Month:
                    this.month = Month[jsObject[key]];
                    break;
                default:
                    break;
            }
        }
    };
    return RelativeYearlyPattern;
}(Recurrence));
exports.RelativeYearlyPattern = RelativeYearlyPattern;
/**
 * Represents a recurrence pattern where each occurrence happens on a specific day every year.
 */
var YearlyPattern = (function (_super) {
    __extends(YearlyPattern, _super);
    function YearlyPattern(startDate, month, dayOfMonth) {
        if (month === void 0) { month = null; }
        if (dayOfMonth === void 0) { dayOfMonth = null; }
        var _this = this;
        if (arguments.length === 0) {
            _this = _super.call(this) || this;
            _this.month = null;
            _this.dayOfMonth = null;
            return;
        }
        _this = _super.call(this, startDate) || this;
        _this.Month = month;
        _this.DayOfMonth = dayOfMonth;
        return _this;
    }
    Object.defineProperty(YearlyPattern.prototype, "XmlElementName", {
        /**
         * @internal Gets the name of the XML element.
         *
         * @value   The name of the XML element.
         */
        get: function () {
            return XmlElementNames.AbsoluteYearlyRecurrence;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(YearlyPattern.prototype, "Month", {
        /**
         * Gets or sets the month of the year when each occurrence happens.
         */
        get: function () {
            return _super.prototype.GetFieldValueOrThrowIfNull.call(this, this.month, "Month");
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.month; }, setValue: function (updateValue) { _this.month = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(YearlyPattern.prototype, "DayOfMonth", {
        /**
         * Gets or sets the day of the month when each occurrence happens. DayOfMonth must be between 1 and 31.
         */
        get: function () {
            return _super.prototype.GetFieldValueOrThrowIfNull.call(this, this.dayOfMonth, "DayOfMonth");
        },
        set: function (value) {
            var _this = this;
            if (value < 1 || value > 31) {
                throw new ArgumentOutOfRangeException("DayOfMonth", Strings.DayOfMonthMustBeBetween1And31);
            }
            this.SetFieldValue({ getValue: function () { return _this.dayOfMonth; }, setValue: function (updateValue) { _this.dayOfMonth = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Validates this instance.
     */
    YearlyPattern.prototype.InternalValidate = function () {
        _super.prototype.InternalValidate.call(this);
        if (this.month === null) {
            throw new ServiceValidationException(Strings.MonthMustBeSpecifiedForRecurrencePattern);
        }
        if (this.dayOfMonth === null) {
            throw new ServiceValidationException(Strings.DayOfMonthMustBeSpecifiedForRecurrencePattern);
        }
    };
    /**
     * @internal Write properties to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    YearlyPattern.prototype.InternalWritePropertiesToXml = function (writer) {
        _super.prototype.InternalWritePropertiesToXml.call(this, writer);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DayOfMonth, this.DayOfMonth);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Month, Month[this.Month]);
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    YearlyPattern.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.DayOfMonth:
                    this.dayOfMonth = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.Month:
                    this.month = Month[jsObject[key]];
                    break;
                default:
                    break;
            }
        }
    };
    return YearlyPattern;
}(Recurrence));
exports.YearlyPattern = YearlyPattern;
/**
 * @internal Represents recurrence range with start and end dates.
 */
var RecurrenceRange = (function (_super) {
    __extends(RecurrenceRange, _super);
    function RecurrenceRange(startDate) {
        if (startDate === void 0) { startDate = null; }
        var _this = _super.call(this) || this;
        _this.startDate = null;
        _this.recurrence = null;
        _this.startDate = startDate;
        return _this;
    }
    Object.defineProperty(RecurrenceRange.prototype, "XmlElementName", {
        /**
         * @internal Gets the name of the XML element.
         *
         * @value   The name of the XML element.
         */
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(RecurrenceRange.prototype, "Recurrence", {
        /**
         * @internal Gets or sets the recurrence.
         *
         * @value   The recurrence.
         */
        get: function () {
            return this.recurrence;
        },
        set: function (value) {
            this.recurrence = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RecurrenceRange.prototype, "StartDate", {
        /**
         * @internal Gets or sets the start date.
         *
         * @value   The start date.
         */
        get: function () {
            return this.startDate;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.startDate; }, setValue: function (updateValue) { _this.startDate = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Changes handler.
     */
    RecurrenceRange.prototype.Changed = function () {
        if (this.Recurrence != null) {
            this.Recurrence.Changed();
        }
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    RecurrenceRange.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.StartDate:
                    var startDate = service.ConvertStartDateToUnspecifiedDateTime(jsObject[key]);
                    if (startDate) {
                        this.startDate = startDate;
                    }
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * @internal Setup the recurrence.
     *
     * @param   {Recurrence}   recurrence   The recurrence.
     */
    RecurrenceRange.prototype.SetupRecurrence = function (recurrence) { recurrence.StartDate = this.StartDate; };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    RecurrenceRange.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.StartDate, EwsUtilities.DateTimeToXSDate(this.StartDate));
    };
    return RecurrenceRange;
}(ComplexProperty));
exports.RecurrenceRange = RecurrenceRange;
/**
 * @internal Represents recurrent range with an end date.
 */
var EndDateRecurrenceRange = (function (_super) {
    __extends(EndDateRecurrenceRange, _super);
    function EndDateRecurrenceRange(startDate, endDate) {
        if (endDate === void 0) { endDate = null; }
        var _this = this;
        if (arguments.length === 0) {
            _this = _super.call(this) || this;
        }
        else {
            _this = _super.call(this, startDate) || this;
        }
        _this.endDate = endDate;
        return _this;
    }
    Object.defineProperty(EndDateRecurrenceRange.prototype, "XmlElementName", {
        /**
         * @internal Gets the name of the XML element.
         *
         * @value   The name of the XML element.
         */
        get: function () {
            return XmlElementNames.EndDateRecurrence;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EndDateRecurrenceRange.prototype, "EndDate", {
        /**
         * Gets or sets the end date.
         *
         * @value   The end date.
         */
        get: function () {
            return this.endDate;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.endDate; }, setValue: function (updateValue) { _this.endDate = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    EndDateRecurrenceRange.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.EndDate:
                    this.endDate = service.ConvertStartDateToUnspecifiedDateTime(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * @internal Setups the recurrence.
     *
     * @param   {Recurrence}   recurrence   The recurrence.
     */
    EndDateRecurrenceRange.prototype.SetupRecurrence = function (recurrence) {
        _super.prototype.SetupRecurrence.call(this, recurrence);
        recurrence.EndDate = this.EndDate;
    };
    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    EndDateRecurrenceRange.prototype.WriteElementsToXml = function (writer) {
        _super.prototype.WriteElementsToXml.call(this, writer);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.EndDate, EwsUtilities.DateTimeToXSDate(this.EndDate));
    };
    return EndDateRecurrenceRange;
}(RecurrenceRange));
exports.EndDateRecurrenceRange = EndDateRecurrenceRange;
/**
 * @internal Represents recurrence range with no end date.
 */
var NoEndRecurrenceRange = (function (_super) {
    __extends(NoEndRecurrenceRange, _super);
    function NoEndRecurrenceRange(startDate) {
        if (startDate === void 0) { startDate = null; }
        var _this = this;
        arguments.length === 0 ? _this = _super.call(this) || this : _this = _super.call(this, startDate) || this;
        return _this;
    }
    Object.defineProperty(NoEndRecurrenceRange.prototype, "XmlElementName", {
        /**
         * @internal Gets the name of the XML element.
         *
         * @value   The name of the XML element.
         */
        get: function () {
            return XmlElementNames.NoEndRecurrence;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Setups the recurrence.
     *
     * @param   {Recurrence}   recurrence   The recurrence.
     */
    NoEndRecurrenceRange.prototype.SetupRecurrence = function (recurrence) {
        _super.prototype.SetupRecurrence.call(this, recurrence);
        recurrence.NeverEnds();
    };
    return NoEndRecurrenceRange;
}(RecurrenceRange));
exports.NoEndRecurrenceRange = NoEndRecurrenceRange;
/**
 * @internal Represents recurrence range with start and number of occurance.
 */
var NumberedRecurrenceRange = (function (_super) {
    __extends(NumberedRecurrenceRange, _super);
    function NumberedRecurrenceRange(startDate, numberOfOccurrences) {
        if (startDate === void 0) { startDate = null; }
        if (numberOfOccurrences === void 0) { numberOfOccurrences = null; }
        var _this = this;
        if (arguments.length === 0) {
            _this = _super.call(this) || this;
            return;
        }
        _this = _super.call(this, startDate) || this;
        _this.numberOfOccurrences = numberOfOccurrences;
        return _this;
    }
    Object.defineProperty(NumberedRecurrenceRange.prototype, "XmlElementName", {
        /**
         * @internal Gets the name of the XML element.
         *
         * @value   The name of the XML element.
         */
        get: function () {
            return XmlElementNames.NumberedRecurrence;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumberedRecurrenceRange.prototype, "NumberOfOccurrences", {
        /**
         * Gets or sets the number of occurrences.
         *
         * @value   The number of occurrences.
         */
        get: function () {
            return this.numberOfOccurrences;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.numberOfOccurrences; }, setValue: function (updateValue) { _this.numberOfOccurrences = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    NumberedRecurrenceRange.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.NumberOfOccurrences:
                    this.numberOfOccurrences = Convert.toNumber(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * Setups the recurrence.
     *
     * @param   {Recurrence}   recurrence   The recurrence.
     */
    NumberedRecurrenceRange.prototype.SetupRecurrence = function (recurrence) {
        _super.prototype.SetupRecurrence.call(this, recurrence);
        recurrence.NumberOfOccurrences = this.NumberOfOccurrences;
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    NumberedRecurrenceRange.prototype.WriteElementsToXml = function (writer) {
        _super.prototype.WriteElementsToXml.call(this, writer);
        if (this.NumberOfOccurrences) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.NumberOfOccurrences, this.NumberOfOccurrences);
        }
    };
    return NumberedRecurrenceRange;
}(RecurrenceRange));
exports.NumberedRecurrenceRange = NumberedRecurrenceRange;
Recurrence.DailyPattern = DailyPattern;
Recurrence.DailyRegenerationPattern = DailyRegenerationPattern;
Recurrence.IntervalPattern = IntervalPattern;
Recurrence.MonthlyPattern = MonthlyPattern;
Recurrence.MonthlyRegenerationPattern = MonthlyRegenerationPattern;
Recurrence.RelativeMonthlyPattern = RelativeMonthlyPattern;
Recurrence.RelativeYearlyPattern = RelativeYearlyPattern;
Recurrence.WeeklyPattern = WeeklyPattern;
Recurrence.WeeklyRegenerationPattern = WeeklyRegenerationPattern;
Recurrence.YearlyPattern = YearlyPattern;
Recurrence.YearlyRegenerationPattern = YearlyRegenerationPattern;
/**
 * @internal Represents a time zone period as defined in the EWS schema.
 */
var TimeZoneDefinition = (function (_super) {
    __extends(TimeZoneDefinition, _super);
    function TimeZoneDefinition(timeZoneInfo) {
        if (timeZoneInfo === void 0) { timeZoneInfo = null; }
        var _this = _super.call(this) || this;
        _this.periods = new DictionaryWithStringKey();
        _this.transitionGroups = new DictionaryWithStringKey();
        _this.transitions = [];
        if (timeZoneInfo != null && typeof timeZoneInfo !== 'undefined') {
            _this.Id = timeZoneInfo.Id;
            _this.Name = timeZoneInfo.DisplayName;
            // TimeZoneInfo only supports one standard period, which bias is the time zone's base
            // offset to UTC.
            var standardPeriod = new TimeZonePeriod();
            standardPeriod.Id = TimeZonePeriod.StandardPeriodId;
            standardPeriod.Name = TimeZonePeriod.StandardPeriodName;
            standardPeriod.Bias = new TimeSpan(-timeZoneInfo.BaseUtcOffset.TotalMilliseconds);
            //ref: very complex to calculate timezone rules and transitions. it works without adding those elements as they are optional, need to find scenario where it is mandatory.
            // let adjustmentRules: TimeZoneInfo.AdjustmentRule[] = []; // = timeZoneInfo.GetAdjustmentRules();
            // let transitionToStandardPeriod: TimeZoneTransition = new TimeZoneTransition(this, standardPeriod);
            // if (adjustmentRules.length == 0) {
            //     this.periods.Add(standardPeriod.Id, standardPeriod);
            //     // If the time zone info doesn't support Daylight Saving Time, we just need to
            //     // create one transition to one group with one transition to the standard period.
            //     let transitionGroup: TimeZoneTransitionGroup = new TimeZoneTransitionGroup(this, "0");
            //     transitionGroup.Transitions.push(transitionToStandardPeriod);
            //     this.transitionGroups.Add(transitionGroup.Id, transitionGroup);
            //     let initialTransition: TimeZoneTransition = new TimeZoneTransition(this, transitionGroup);
            //     this.transitions.push(initialTransition);
            // }
            // else {
            //     for (let i = 0; i < adjustmentRules.length; i++) {
            //         let transitionGroup: TimeZoneTransitionGroup = new TimeZoneTransitionGroup(this, this.transitionGroups.Count.toString());
            //         transitionGroup.InitializeFromAdjustmentRule(adjustmentRules[i], standardPeriod);
            //         this.transitionGroups.Add(transitionGroup.Id, transitionGroup);
            //         let transition: TimeZoneTransition;
            //         if (i == 0) {
            //             // If the first adjustment rule's start date in not undefined (DateTime.MinValue)
            //             // we need to add a dummy group with a single, simple transition to the Standard
            //             // period and a group containing the transitions mapping to the adjustment rule.
            //             if (adjustmentRules[i].DateStart > DateTime.MinValue.Date) {
            //                 let transitionToDummyGroup: TimeZoneTransition = new TimeZoneTransition(
            //                     this,
            //                     this.CreateTransitionGroupToPeriod(standardPeriod));
            //                 this.transitions.push(transitionToDummyGroup);
            //                 let absoluteDateTransition: AbsoluteDateTransition = new AbsoluteDateTransition(this, transitionGroup);
            //                 absoluteDateTransition.DateTime = adjustmentRules[i].DateStart;
            //                 transition = absoluteDateTransition;
            //                 this.periods.Add(standardPeriod.Id, standardPeriod);
            //             }
            //             else {
            //                 transition = new TimeZoneTransition(this, transitionGroup);
            //             }
            //         }
            //         else {
            //             let absoluteDateTransition: AbsoluteDateTransition = new AbsoluteDateTransition(this, transitionGroup);
            //             absoluteDateTransition.DateTime = adjustmentRules[i].DateStart;
            //             transition = absoluteDateTransition;
            //         }
            //         this.transitions.push(transition);
            //     }
            //     // If the last adjustment rule's end date is not undefined (DateTime.MaxValue),
            //     // we need to create another absolute date transition that occurs the date after
            //     // the last rule's end date. We target this additional transition to a group that
            //     // contains a single simple transition to the Standard period.
            //     let lastAdjustmentRuleEndDate: DateTime = adjustmentRules[adjustmentRules.length - 1].DateEnd;
            //     if (lastAdjustmentRuleEndDate < DateTime.MaxValue.Date) {
            //         let transitionToDummyGroup: AbsoluteDateTransition = new AbsoluteDateTransition(
            //             this,
            //             this.CreateTransitionGroupToPeriod(standardPeriod));
            //         transitionToDummyGroup.DateTime = lastAdjustmentRuleEndDate.AddDays(1);
            //         this.transitions.push(transitionToDummyGroup);
            //     }
            // }
        }
        return _this;
    }
    Object.defineProperty(TimeZoneDefinition.prototype, "Periods", {
        /**
         * @internal Gets the periods associated with this time zone definition, indexed by Id.
         */
        get: function () {
            return this.periods;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeZoneDefinition.prototype, "TransitionGroups", {
        /**
         * @internal Gets the transition groups associated with this time zone definition, indexed by Id.
         */
        get: function () {
            return this.transitionGroups;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Compares the transitions.
     *
     * @param   {TimeZoneTransition}   x   The first transition.
     * @param   {TimeZoneTransition}   y   The second transition.
     * @return  {number}       A negative number if x is less than y, 0 if x and y are equal, a positive number if x is greater than y.
     */
    TimeZoneDefinition.prototype.CompareTransitions = function (x, y) {
        if (x == y) {
            return 0;
        }
        else if (x instanceof TimeZoneTransition) {
            return -1;
        }
        else if (y instanceof TimeZoneTransition) {
            return 1;
        }
        else {
            var firstTransition = x;
            var secondTransition = y;
            return DateTime.Compare(firstTransition.DateTime, secondTransition.DateTime);
        }
    };
    /**
     * Adds a transition group with a single transition to the specified period.
     *
     * @param   {TimeZonePeriod}   timeZonePeriod   The time zone period.
     * @return  {TimeZoneTransitionGroup}           A TimeZoneTransitionGroup.
     */
    TimeZoneDefinition.prototype.CreateTransitionGroupToPeriod = function (timeZonePeriod) {
        var transitionToPeriod = new TimeZoneTransition(this, timeZonePeriod);
        var transitionGroup = new TimeZoneTransitionGroup(this, this.transitionGroups.Count.toString());
        transitionGroup.Transitions.push(transitionToPeriod);
        this.transitionGroups.Add(transitionGroup.Id, transitionGroup);
        return transitionGroup;
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    TimeZoneDefinition.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlAttributeNames.Name:
                    this.Name = jsObject[key];
                    break;
                case XmlAttributeNames.Id:
                    this.Id = jsObject[key];
                    break;
                case XmlElementNames.Periods:
                    var jsperiods = EwsServiceJsonReader.ReadAsArray(jsObject[key], XmlElementNames.Period);
                    for (var _a = 0, jsperiods_1 = jsperiods; _a < jsperiods_1.length; _a++) {
                        var jsPeriod = jsperiods_1[_a];
                        var period = new TimeZonePeriod();
                        period.LoadFromXmlJsObject(jsPeriod, service);
                        // OM:1648848 Bad timezone data from clients can include duplicate rules
                        // for one year, with duplicate ID. In that case, let the first one win.
                        if (!this.periods.containsKey(period.Id)) {
                            this.periods.Add(period.Id, period);
                        }
                        else {
                            service.TraceMessage(TraceFlags.EwsTimeZones, StringHelper.Format("An entry with the same key (Id) '{0}' already exists in Periods. Cannot add another one. Existing entry: [Name='{1}', Bias='{2}']. Entry to skip: [Name='{3}', Bias='{4}'].", period.Id, this.Periods.get(period.Id).Name, this.Periods.get(period.Id).Bias, period.Name, period.Bias));
                        }
                    }
                    break;
                case XmlElementNames.TransitionsGroups:
                    var arrayOfTransitionsType = EwsServiceJsonReader.ReadAsArray(jsObject[key], XmlElementNames.TransitionsGroup);
                    for (var _b = 0, arrayOfTransitionsType_1 = arrayOfTransitionsType; _b < arrayOfTransitionsType_1.length; _b++) {
                        var arrayOfTransitionsTypeInstance = arrayOfTransitionsType_1[_b];
                        var transitionGroup = new TimeZoneTransitionGroup(this);
                        transitionGroup.LoadFromXmlJsObject(arrayOfTransitionsTypeInstance, service);
                        this.transitionGroups.addUpdate(transitionGroup.Id, transitionGroup);
                    }
                    break;
                case XmlElementNames.Transitions:
                    for (var _key in jsObject[key]) {
                        if (TimeZoneTransitionGroup.transitionTypes.indexOf(_key) >= 0) {
                            var transitions = EwsServiceJsonReader.ReadAsArray(jsObject[key], _key);
                            for (var _c = 0, transitions_1 = transitions; _c < transitions_1.length; _c++) {
                                var item = transitions_1[_c];
                                var transition = TimeZoneTransition.Create(this, _key);
                                transition.LoadFromXmlJsObject(item, service);
                                this.transitions.push(transition);
                            }
                        }
                    }
                    break;
                default:
                    break;
            }
        }
        // EWS can return a TimeZone definition with no Id. Generate a new Id in this case.
        if (StringHelper.IsNullOrEmpty(this.Id)) {
            var nameValue = StringHelper.IsNullOrEmpty(this.Name) ? StringHelper.Empty : this.Name;
            //this.Id = TimeZoneDefinition.NoIdPrefix + Math.abs(nameValue.GetHashCode()).ToString();
            this.Id = TimeZoneDefinition.NoIdPrefix + nameValue;
        }
        this.transitions.sort(this.CompareTransitions);
    };
    /**
     * @internal Converts this time zone definition into a TimeZoneInfo structure.
     *
     * @param   {ExchangeService}   service   The service.
     * @return  {TimeZoneInfo}      A TimeZoneInfo representing the same time zone as this definition.
     */
    TimeZoneDefinition.prototype.ToTimeZoneInfo = function (service, parse) {
        if (parse === void 0) { parse = false; }
        this.Validate();
        if (!parse) {
            //ref: skipped creation based on server data, directly creating using TimeZone Mapping data. complex to translate Windows TimeZoneInfo subclasses to javascript.
            return TimeZoneInfo.FindSystemTimeZoneById(this.Id);
        }
        var result;
        // Retrieve the base offset to UTC, standard and daylight display names from
        // the last transition group, which is the one that currently applies given that
        // transitions are ordered chronologically.
        var creationParams = this.transitions[this.transitions.length - 1].TargetGroup.GetCustomTimeZoneCreationParams();
        var adjustmentRules = [];
        var startDate = DateTime.MinValue;
        var endDate;
        var effectiveEndDate;
        for (var i = 0; i < this.transitions.length; i++) {
            if (i < this.transitions.length - 1) {
                endDate = this.transitions[i + 1].DateTime;
                effectiveEndDate = endDate.AddDays(-1);
            }
            else {
                endDate = DateTime.MaxValue;
                effectiveEndDate = endDate;
            }
            // OM:1648848 Due to bad timezone data from clients the 
            // startDate may not always come before the effectiveEndDate
            if (startDate < effectiveEndDate) {
                var adjustmentRule = this.transitions[i].TargetGroup.CreateAdjustmentRule(startDate, effectiveEndDate);
                if (adjustmentRule != null) {
                    adjustmentRules.push(adjustmentRule);
                }
                startDate = endDate;
            }
            else {
                // service.TraceMessage(
                //     TraceFlags.EwsTimeZones,
                //         string.Format(
                //             "The startDate '{0}' is not before the effectiveEndDate '{1}'. Will skip creating adjustment rule.",
                //             startDate,
                //             effectiveEndDate));
            }
        }
        if (adjustmentRules.length == 0) {
            // If there are no adjustment rule, the time zone does not support Daylight
            // saving time.
            result = TimeZoneInfo.CreateCustomTimeZone(this.Id, creationParams.BaseOffsetToUtc, this.Name, creationParams.StandardDisplayName);
        }
        else {
            result = TimeZoneInfo.CreateCustomTimeZone(this.Id, creationParams.BaseOffsetToUtc, this.Name, creationParams.StandardDisplayName, creationParams.DaylightDisplayName, adjustmentRules);
        }
        return result;
    };
    /**
     * @internal Validates this time zone definition.
     */
    TimeZoneDefinition.prototype.Validate = function () {
        // The definition must have at least one period, one transition group and one transition,
        // and there must be as many transitions as there are transition groups.
        if (this.periods.Count < 1 || this.transitions.length < 1 || this.transitionGroups.Count < 1 ||
            this.transitionGroups.Count != this.transitions.length) {
            throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
        }
        // The first transition must be of type TimeZoneTransition.
        if (!(this.transitions[0] instanceof TimeZoneTransition)) {
            throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
        }
        // All transitions must be to transition groups and be either TimeZoneTransition or
        // AbsoluteDateTransition instances.
        for (var _a = 0, _b = this.transitions; _a < _b.length; _a++) {
            var transition = _b[_a];
            //Type transitionType = transition.GetType();
            if (!(transition instanceof TimeZoneTransition) && !(transition instanceof AbsoluteDateTransition)) {
                throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
            }
            if (transition.TargetGroup == null) {
                throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
            }
        }
        // All transition groups must be valid.
        for (var _c = 0, _d = this.transitionGroups.Values; _c < _d.length; _c++) {
            var transitionGroup = _d[_c];
            transitionGroup.Validate();
        }
    };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    TimeZoneDefinition.prototype.WriteAttributesToXml = function (writer) {
        // The Name attribute is only supported in Exchange 2010 and above.
        if (writer.Service.RequestedServerVersion != ExchangeVersion.Exchange2007_SP1) {
            writer.WriteAttributeValue(XmlAttributeNames.Name, this.Name);
        }
        writer.WriteAttributeValue(XmlAttributeNames.Id, this.Id);
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    TimeZoneDefinition.prototype.WriteElementsToXml = function (writer) {
        // We only emit the full time zone definition against Exchange 2010 servers and above.
        if (writer.Service.RequestedServerVersion != ExchangeVersion.Exchange2007_SP1) {
            if (this.periods.Count > 0) {
                writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Periods);
                for (var _a = 0, _b = this.periods.Items; _a < _b.length; _a++) {
                    var keyValuePair = _b[_a];
                    keyValuePair.value.WriteToXml(writer);
                }
                writer.WriteEndElement(); // Periods
            }
            if (this.transitionGroups.Count > 0) {
                writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.TransitionsGroups);
                for (var _c = 0, _d = this.transitionGroups.Items; _c < _d.length; _c++) {
                    var transitionPair = _d[_c];
                    transitionPair.value.WriteToXml(writer);
                }
                writer.WriteEndElement(); // TransitionGroups
            }
            if (this.transitions.length > 0) {
                writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Transitions);
                for (var _e = 0, _f = this.transitions; _e < _f.length; _e++) {
                    var transition = _f[_e];
                    transition.WriteToXml(writer);
                }
                writer.WriteEndElement(); // Transitions
            }
        }
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    TimeZoneDefinition.prototype.WriteToXml = function (writer) {
        _super.prototype.WriteToXml.call(this, writer, XmlElementNames.TimeZoneDefinition);
    };
    /**
     * Prefix for generated ids.
     */
    TimeZoneDefinition.NoIdPrefix = "NoId_";
    return TimeZoneDefinition;
}(ComplexProperty));
exports.TimeZoneDefinition = TimeZoneDefinition;
/**
 * @internal Represents a time zone period as defined in the EWS schema.
 */
var TimeZonePeriod = (function (_super) {
    __extends(TimeZonePeriod, _super);
    /**
     * @internal Initializes a new instance of the **TimeZonePeriod** class.
     */
    function TimeZonePeriod() {
        return _super.call(this) || this;
    }
    Object.defineProperty(TimeZonePeriod.prototype, "IsStandardPeriod", {
        /**
         * Gets a value indicating whether this period represents the Standard period.
         *
         * @value   <c>true</c> if this instance is standard period; otherwise, <c>false</c>.
         */
        get: function () {
            return this.Name.toUpperCase() === TimeZonePeriod.StandardPeriodName.toUpperCase();
            // return string.Compare(
            //     this.name,
            //     TimeZonePeriod.StandardPeriodName,
            //     StringComparison.OrdinalIgnoreCase) == 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    TimeZonePeriod.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlAttributeNames.Id:
                    this.Id = jsObject[key];
                    break;
                case XmlAttributeNames.Name:
                    this.Name = jsObject[key];
                    break;
                case XmlAttributeNames.Bias:
                    this.Bias = EwsUtilities.XSDurationToTimeSpan(jsObject[key]);
                    break;
            }
        }
    };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    TimeZonePeriod.prototype.WriteAttributesToXml = function (writer) {
        writer.WriteAttributeValue(XmlAttributeNames.Bias, EwsUtilities.TimeSpanToXSDuration(this.Bias));
        writer.WriteAttributeValue(XmlAttributeNames.Name, this.Name);
        writer.WriteAttributeValue(XmlAttributeNames.Id, this.Id);
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    TimeZonePeriod.prototype.WriteToXml = function (writer) { _super.prototype.WriteToXml.call(this, writer, XmlElementNames.Period); };
    /** @internal */
    TimeZonePeriod.StandardPeriodId = "Std";
    /** @internal */
    TimeZonePeriod.StandardPeriodName = "Standard";
    /** @internal */
    TimeZonePeriod.DaylightPeriodId = "Dlt";
    /** @internal */
    TimeZonePeriod.DaylightPeriodName = "Daylight";
    return TimeZonePeriod;
}(ComplexProperty));
exports.TimeZonePeriod = TimeZonePeriod;
/**
 * @internal Represents the base class for all time zone transitions.
 */
var TimeZoneTransition = (function (_super) {
    __extends(TimeZoneTransition, _super);
    function TimeZoneTransition(timeZoneDefinition, targetPeriodOrGroup) {
        var _this = _super.call(this) || this;
        _this.timeZoneDefinition = timeZoneDefinition;
        if (targetPeriodOrGroup instanceof TimeZonePeriod) {
            _this.targetPeriod = targetPeriodOrGroup;
        }
        else if (targetPeriodOrGroup instanceof TimeZoneTransitionGroup) {
            _this.targetGroup = targetPeriodOrGroup;
        }
        return _this;
    }
    Object.defineProperty(TimeZoneTransition.prototype, "TargetPeriod", {
        /**
         * @internal Gets the target period of the transition.
         */
        get: function () {
            return this.targetPeriod;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeZoneTransition.prototype, "TargetGroup", {
        /**
         * @internal Gets the target transition group of the transition.
         */
        get: function () {
            return this.targetGroup;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates a time zone period transition of the appropriate type given an XML element name.
     *
     * @param   {TimeZoneDefinition}    timeZoneDefinition   The time zone definition to which the transition will belong.
     * @param   {string}                xmlElementName       The XML element name.
     * @return  {TimeZoneTransition}    A TimeZonePeriodTransition instance.
     */
    TimeZoneTransition.Create = function (timeZoneDefinition, xmlElementName) {
        switch (xmlElementName) {
            case XmlElementNames.AbsoluteDateTransition:
                return new TypeContainer.AbsoluteDateTransition(timeZoneDefinition);
            case XmlElementNames.RecurringDayTransition:
                return new TypeContainer.RelativeDayOfMonthTransition(timeZoneDefinition);
            case XmlElementNames.RecurringDateTransition:
                return new TypeContainer.AbsoluteDayOfMonthTransition(timeZoneDefinition);
            case XmlElementNames.Transition:
                return new TimeZoneTransition(timeZoneDefinition);
            default:
                throw new ServiceLocalException(StringHelper.Format(Strings.UnknownTimeZonePeriodTransitionType, xmlElementName));
        }
    };
    /**
     * @internal Creates a time zone transition based on the specified transition time.
     *
     * @param   {TimeZoneDefinition}            timeZoneDefinition   The time zone definition that will own the transition.
     * @param   {TimeZonePeriod}                targetPeriod         The period the transition will target.
     * @param   {TimeZoneInfo.TransitionTime}   transitionTime       The transition time to initialize from.
     * @return  {TimeZoneTransition}            A TimeZoneTransition.
     */
    TimeZoneTransition.CreateTimeZoneTransition = function (timeZoneDefinition, targetPeriod, transitionTime) {
        var transition;
        if (transitionTime.IsFixedDateRule) {
            transition = new TypeContainer.AbsoluteDayOfMonthTransition(timeZoneDefinition, targetPeriod);
        }
        else {
            transition = new TypeContainer.RelativeDayOfMonthTransition(timeZoneDefinition, targetPeriod);
        }
        transition.InitializeFromTransitionTime(transitionTime);
        return transition;
    };
    /**
     * @internal Creates a time zone transition time.
     * @virtual
     *
     * @return  {TimeZoneInfo.TransitionTime}      A TimeZoneInfo.TransitionTime.
     */
    TimeZoneTransition.prototype.CreateTransitionTime = function () {
        throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    TimeZoneTransition.prototype.GetXmlElementName = function () {
        return XmlElementNames.Transition;
    };
    /**
     * @internal Initializes this transition based on the specified transition time.
     * @virtual
     *
     * @param   {TimeZoneInfo.TransitionTime}   transitionTime   The transition time to initialize from.
     */
    TimeZoneTransition.prototype.InitializeFromTransitionTime = function (transitionTime) { };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    TimeZoneTransition.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.To:
                    var targetKind = jsObject[key][XmlAttributeNames.Kind];
                    var targetId = jsObject[key][XmlElementNames.To];
                    switch (targetKind) {
                        case TimeZoneTransition.PeriodTarget:
                            var targetPeriod = { outValue: null };
                            if (!this.timeZoneDefinition.Periods.tryGetValue(targetId, targetPeriod)) {
                                throw new ServiceLocalException(StringHelper.Format(Strings.PeriodNotFound, targetId));
                            }
                            else {
                                this.targetPeriod = targetPeriod.outValue;
                            }
                            break;
                        case TimeZoneTransition.GroupTarget:
                            var targetGroup = { outValue: null };
                            if (!this.timeZoneDefinition.TransitionGroups.tryGetValue(targetId, targetGroup)) {
                                throw new ServiceLocalException(StringHelper.Format(Strings.TransitionGroupNotFound, targetId));
                            }
                            else {
                                this.targetGroup = targetGroup.outValue;
                            }
                            break;
                        default:
                            throw new ServiceLocalException(Strings.UnsupportedTimeZonePeriodTransitionTarget);
                    }
                    break;
            }
        }
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    TimeZoneTransition.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.To);
        if (this.targetPeriod != null) {
            writer.WriteAttributeValue(XmlAttributeNames.Kind, TimeZoneTransition.PeriodTarget);
            writer.WriteValue(this.targetPeriod.Id, XmlElementNames.To);
        }
        else {
            writer.WriteAttributeValue(XmlAttributeNames.Kind, TimeZoneTransition.GroupTarget);
            writer.WriteValue(this.targetGroup.Id, XmlElementNames.To);
        }
        writer.WriteEndElement(); // To
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    TimeZoneTransition.prototype.WriteToXml = function (writer) {
        _super.prototype.WriteToXml.call(this, writer, this.GetXmlElementName());
    };
    TimeZoneTransition.PeriodTarget = "Period";
    TimeZoneTransition.GroupTarget = "Group";
    return TimeZoneTransition;
}(ComplexProperty));
exports.TimeZoneTransition = TimeZoneTransition;
/**
 * @internal Represents a time zone period transition that occurs on a fixed (absolute) date.
 */
var AbsoluteDateTransition = (function (_super) {
    __extends(AbsoluteDateTransition, _super);
    function AbsoluteDateTransition(timeZoneDefinition, targetGroup) {
        return _super.call(this, timeZoneDefinition, targetGroup) || this;
    }
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    AbsoluteDateTransition.prototype.GetXmlElementName = function () {
        return XmlElementNames.AbsoluteDateTransition;
    };
    /**
     * @internal Initializes this transition based on the specified transition time.
     *
     * @param   {TimeZoneInfo.TransitionTime}   transitionTime   The transition time to initialize from.
     */
    AbsoluteDateTransition.prototype.InitializeFromTransitionTime = function (transitionTime) {
        throw new ServiceLocalException(Strings.UnsupportedTimeZonePeriodTransitionTarget);
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    AbsoluteDateTransition.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        if (jsObject[XmlElementNames.DateTime]) {
            this.DateTime = DateTime.Parse(jsObject[XmlElementNames.DateTime]);
        }
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    AbsoluteDateTransition.prototype.WriteElementsToXml = function (writer) {
        _super.prototype.WriteElementsToXml.call(this, writer);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DateTime, this.DateTime);
    };
    return AbsoluteDateTransition;
}(TimeZoneTransition));
exports.AbsoluteDateTransition = AbsoluteDateTransition;
/**
 * @internal Represents the base class for all recurring time zone period transitions.
 */
var AbsoluteMonthTransition = (function (_super) {
    __extends(AbsoluteMonthTransition, _super);
    function AbsoluteMonthTransition(timeZoneDefinition, targetPeriod) {
        var _this = _super.call(this, timeZoneDefinition, targetPeriod) || this;
        _this.timeOffset = null;
        _this.month = null;
        return _this;
    }
    Object.defineProperty(AbsoluteMonthTransition.prototype, "TimeOffset", {
        /**
         * @internal Gets the time offset from midnight when the transition occurs.
         */
        get: function () {
            return this.timeOffset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbsoluteMonthTransition.prototype, "Month", {
        /**
         * @internal Gets the month when the transition occurs.
         */
        get: function () {
            return this.month;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Initializes this transition based on the specified transition time.
     * @virtual
     *
     * @param   {TimeZoneInfo.TransitionTime}   transitionTime   The transition time to initialize from.
     */
    AbsoluteMonthTransition.prototype.InitializeFromTransitionTime = function (transitionTime) {
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    AbsoluteMonthTransition.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        if (jsObject[XmlElementNames.TimeOffset]) {
            this.timeOffset = EwsUtilities.XSDurationToTimeSpan(jsObject[XmlElementNames.TimeOffset]);
        }
        if (jsObject[XmlElementNames.Month]) {
            this.month = Convert.toInt(jsObject[XmlElementNames.Month]);
            EwsLogging.Assert(this.month > 0 && this.month <= 12, "AbsoluteMonthTransition.TryReadElementFromXml", "month is not in the valid 1 - 12 range.");
        }
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    AbsoluteMonthTransition.prototype.WriteElementsToXml = function (writer) {
        _super.prototype.WriteElementsToXml.call(this, writer);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.TimeOffset, EwsUtilities.TimeSpanToXSDuration(this.timeOffset));
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Month, this.month);
    };
    return AbsoluteMonthTransition;
}(TimeZoneTransition));
exports.AbsoluteMonthTransition = AbsoluteMonthTransition;
/**
 * @internal Represents a time zone period transition that occurs on a specific day of a specific month.
 */
var AbsoluteDayOfMonthTransition = (function (_super) {
    __extends(AbsoluteDayOfMonthTransition, _super);
    function AbsoluteDayOfMonthTransition(timeZoneDefinition, targetPeriod) {
        var _this = _super.call(this, timeZoneDefinition, targetPeriod) || this;
        _this.dayOfMonth = null;
        return _this;
    }
    Object.defineProperty(AbsoluteDayOfMonthTransition.prototype, "DayOfMonth", {
        /**
         * @internal Gets the day of then month when this transition occurs.
         */
        get: function () {
            return this.dayOfMonth;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates a time zone transition time.
     * @virtual
     *
     * @return  {TimeZoneInfo.TransitionTime}      A TimeZoneInfo.TransitionTime.
     */
    AbsoluteDayOfMonthTransition.prototype.CreateTransitionTime = function () {
        return TimeZoneInfo.TransitionTime.CreateFixedDateRule(new DateTime(this.TimeOffset.Milliseconds), this.Month, this.DayOfMonth);
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    AbsoluteDayOfMonthTransition.prototype.GetXmlElementName = function () {
        return XmlElementNames.RecurringDateTransition;
    };
    /**
     * @internal Initializes this transition based on the specified transition time.
     * @virtual
     *
     * @param   {TimeZoneInfo.TransitionTime}   transitionTime   The transition time to initialize from.
     */
    AbsoluteDayOfMonthTransition.prototype.InitializeFromTransitionTime = function (transitionTime) {
        _super.prototype.InitializeFromTransitionTime.call(this, transitionTime);
        this.dayOfMonth = transitionTime.Day;
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    AbsoluteDayOfMonthTransition.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        if (jsObject[XmlElementNames.Day]) {
            this.dayOfMonth = Convert.toInt(jsObject[XmlElementNames.Day]);
            EwsLogging.Assert(this.dayOfMonth > 0 && this.dayOfMonth <= 31, "AbsoluteDayOfMonthTransition.TryReadElementFromXml", "dayOfMonth is not in the valid 1 - 31 range.");
        }
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    AbsoluteDayOfMonthTransition.prototype.WriteElementsToXml = function (writer) {
        _super.prototype.WriteElementsToXml.call(this, writer);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Day, this.dayOfMonth);
    };
    return AbsoluteDayOfMonthTransition;
}(AbsoluteMonthTransition));
exports.AbsoluteDayOfMonthTransition = AbsoluteDayOfMonthTransition;
/**
 * @internal Represents a time zone period transition that occurs on a relative day of a specific month.
 */
var RelativeDayOfMonthTransition = (function (_super) {
    __extends(RelativeDayOfMonthTransition, _super);
    function RelativeDayOfMonthTransition(timeZoneDefinition, targetPeriod) {
        var _this = _super.call(this, timeZoneDefinition, targetPeriod) || this;
        _this.dayOfTheWeek = DayOfTheWeek.Sunday;
        _this.weekIndex = null;
        return _this;
    }
    Object.defineProperty(RelativeDayOfMonthTransition.prototype, "DayOfTheWeek", {
        /**
         * @internal Gets the day of the week when the transition occurs.
         */
        get: function () {
            return this.dayOfTheWeek;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RelativeDayOfMonthTransition.prototype, "WeekIndex", {
        /**
         * @internal Gets the index of the week in the month when the transition occurs.
         */
        get: function () {
            return this.weekIndex;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates a time zone transition time.
     * @virtual
     *
     * @return  {TimeZoneInfo.TransitionTime}      A TimeZoneInfo.TransitionTime.
     */
    RelativeDayOfMonthTransition.prototype.CreateTransitionTime = function () {
        return TimeZoneInfo.TransitionTime.CreateFloatingDateRule(new DateTime(this.TimeOffset.Milliseconds), this.Month, this.WeekIndex == -1 ? 5 : this.WeekIndex, EwsUtilities.EwsToSystemDayOfWeek(this.DayOfTheWeek));
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    RelativeDayOfMonthTransition.prototype.GetXmlElementName = function () {
        return XmlElementNames.RecurringDayTransition;
    };
    /**
     * @internal Initializes this transition based on the specified transition time.
     * @virtual
     *
     * @param   {TimeZoneInfo.TransitionTime}   transitionTime   The transition time to initialize from.
     */
    RelativeDayOfMonthTransition.prototype.InitializeFromTransitionTime = function (transitionTime) {
        _super.prototype.InitializeFromTransitionTime.call(this, transitionTime);
        this.dayOfTheWeek = EwsUtilities.SystemToEwsDayOfTheWeek(transitionTime.DayOfWeek);
        // TimeZoneInfo uses week indices from 1 to 5, 5 being the last week of the month.
        // EWS uses -1 to denote the last week of the month.
        this.weekIndex = transitionTime.Week == 5 ? -1 : transitionTime.Week;
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    RelativeDayOfMonthTransition.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        if (jsObject[XmlElementNames.DayOfWeek]) {
            this.dayOfTheWeek = DayOfTheWeek[jsObject[XmlElementNames.DayOfWeek]];
        }
        if (jsObject[XmlElementNames.Occurrence]) {
            this.weekIndex = Convert.toInt(jsObject[XmlElementNames.Occurrence]);
        }
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    RelativeDayOfMonthTransition.prototype.WriteElementsToXml = function (writer) {
        _super.prototype.WriteElementsToXml.call(this, writer);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DayOfWeek, DayOfTheWeek[this.dayOfTheWeek]);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Occurrence, this.weekIndex);
    };
    return RelativeDayOfMonthTransition;
}(AbsoluteMonthTransition));
exports.RelativeDayOfMonthTransition = RelativeDayOfMonthTransition;
/**
 * @internal Represents a group of time zone period transitions.
 */
var TimeZoneTransitionGroup = (function (_super) {
    __extends(TimeZoneTransitionGroup, _super);
    function TimeZoneTransitionGroup(timeZoneDefinition, id) {
        var _this = _super.call(this) || this;
        //private id: string;
        _this.transitions = [];
        _this.timeZoneDefinition = timeZoneDefinition;
        _this.Id = id;
        return _this;
    }
    Object.defineProperty(TimeZoneTransitionGroup.prototype, "SupportsDaylight", {
        /**
         * @internal Gets a value indicating whether this group contains a transition to the Daylight period.
         *
         * @value   *true* if this group contains a transition to daylight; otherwise, *false*.
         */
        get: function () {
            return this.transitions.length == 2;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeZoneTransitionGroup.prototype, "TransitionToDaylight", {
        /**
         * Gets the transition to the Daylight period.
         */
        get: function () {
            this.InitializeTransitions();
            return this.transitionToDaylight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeZoneTransitionGroup.prototype, "TransitionToStandard", {
        /**
         * Gets the transition to the Standard period.
         */
        get: function () {
            this.InitializeTransitions();
            return this.transitionToStandard;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeZoneTransitionGroup.prototype, "Transitions", {
        /**
         * @internal Gets the transitions in this group.
         */
        get: function () {
            return this.transitions;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates a time zone adjustment rule.
     *
     * @param   {DateTime}   startDate   The start date of the adjustment rule.
     * @param   {DateTime}   endDate     The end date of the adjustment rule.
     * @return  {TimeZoneInfo.AdjustmentRule}   An TimeZoneInfo.AdjustmentRule.
     */
    TimeZoneTransitionGroup.prototype.CreateAdjustmentRule = function (startDate, endDate) {
        // If there is only one transition, we can't create an adjustment rule. We have to assume
        // that the base offset to UTC is unchanged.
        if (this.transitions.length == 1) {
            return null;
        }
        return TimeZoneInfo.AdjustmentRule.CreateAdjustmentRule(startDate.Date, endDate.Date, this.GetDaylightDelta(), this.TransitionToDaylight.CreateTransitionTime(), this.TransitionToStandard.CreateTransitionTime());
    };
    /**
     * @internal Gets the offset to UTC based on this group's transitions.
     *
     * @returns {TimeZoneTransitionGroup.CustomTimeZoneCreateParams}
     */
    TimeZoneTransitionGroup.prototype.GetCustomTimeZoneCreationParams = function () {
        var result = new TimeZoneTransitionGroup.CustomTimeZoneCreateParams();
        if (this.TransitionToDaylight != null) {
            result.DaylightDisplayName = this.TransitionToDaylight.TargetPeriod.Name;
        }
        result.StandardDisplayName = this.TransitionToStandard.TargetPeriod.Name;
        // Assume that the standard period's offset is the base offset to UTC.
        // EWS returns a positive offset for time zones that are behind UTC, and
        // a negative one for time zones ahead of UTC. TimeZoneInfo does it the other
        // way around.
        result.BaseOffsetToUtc = new TimeSpan(-this.TransitionToStandard.TargetPeriod.Bias);
        return result;
    };
    /**
     * @internal Gets the delta offset for the daylight.
     *
     * @returns {TimeSpan}
     */
    TimeZoneTransitionGroup.prototype.GetDaylightDelta = function () {
        if (this.SupportsDaylight) {
            // EWS returns a positive offset for time zones that are behind UTC, and
            // a negative one for time zones ahead of UTC. TimeZoneInfo does it the other
            // way around.
            return this.TransitionToStandard.TargetPeriod.Bias.Subtract(this.TransitionToDaylight.TargetPeriod.Bias);
        }
        else {
            return TimeSpan.Zero;
        }
    };
    /**
     * Initializes this transition group based on the specified asjustment rule.
     *
     * @param   {TimeZoneInfo.AdjustmentRule}   adjustmentRule   The adjustment rule to initialize from.
     * @param   {TimeZonePeriod}                standardPeriod   A reference to the pre-created standard period.
     */
    TimeZoneTransitionGroup.prototype.InitializeFromAdjustmentRule = function (adjustmentRule, standardPeriod) {
        var daylightPeriod = new TimeZonePeriod();
        // Generate an Id of the form "Daylight/2008"
        daylightPeriod.Id = StringHelper.Format("{0}/{1}", TimeZonePeriod.DaylightPeriodId, adjustmentRule.DateStart.Year);
        daylightPeriod.Name = TimeZonePeriod.DaylightPeriodName;
        daylightPeriod.Bias = new TimeSpan(standardPeriod.Bias.TotalMilliseconds - adjustmentRule.DaylightDelta.TotalMilliseconds);
        this.timeZoneDefinition.Periods.Add(daylightPeriod.Id, daylightPeriod);
        this.transitionToDaylight = TimeZoneTransition.CreateTimeZoneTransition(this.timeZoneDefinition, daylightPeriod, adjustmentRule.DaylightTransitionStart);
        var standardPeriodToSet = new TimeZonePeriod();
        standardPeriodToSet.Id = StringHelper.Format("{0}/{1}", standardPeriod.Id, adjustmentRule.DateStart.Year);
        standardPeriodToSet.Name = standardPeriod.Name;
        standardPeriodToSet.Bias = standardPeriod.Bias;
        this.timeZoneDefinition.Periods.Add(standardPeriodToSet.Id, standardPeriodToSet);
        this.transitionToStandard = TimeZoneTransition.CreateTimeZoneTransition(this.timeZoneDefinition, standardPeriodToSet, adjustmentRule.DaylightTransitionEnd);
        this.transitions.push(this.transitionToDaylight);
        this.transitions.push(this.transitionToStandard);
    };
    /**
     * Initializes the private members holding references to the transitions to the Daylight and Standard periods.
     */
    TimeZoneTransitionGroup.prototype.InitializeTransitions = function () {
        if (this.transitionToStandard == null) {
            for (var _a = 0, _b = this.transitions; _a < _b.length; _a++) {
                var transition = _b[_a];
                if (transition.TargetPeriod.IsStandardPeriod || (this.transitions.length == 1)) {
                    this.transitionToStandard = transition;
                }
                else {
                    this.transitionToDaylight = transition;
                }
            }
        }
        // If we didn't find a Standard period, this is an invalid time zone group.
        if (this.transitionToStandard == null) {
            throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
        }
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    TimeZoneTransitionGroup.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        if (jsObject[XmlElementNames.Id]) {
            this.Id = jsObject[XmlElementNames.Id];
        }
        for (var key in jsObject) {
            if (TimeZoneTransitionGroup.transitionTypes.indexOf(key) >= 0) {
                var transitions = EwsServiceJsonReader.ReadAsArray(jsObject, key);
                for (var _a = 0, transitions_2 = transitions; _a < transitions_2.length; _a++) {
                    var item = transitions_2[_a];
                    var transition = TimeZoneTransition.Create(this.timeZoneDefinition, key);
                    transition.LoadFromXmlJsObject(item, service);
                    this.transitions.push(transition);
                }
            }
        }
    };
    /**
     * @internal Validates this transition group.
     */
    TimeZoneTransitionGroup.prototype.Validate = function () {
        // There must be exactly one or two transitions in the group.
        if (this.transitions.length < 1 || this.transitions.length > 2) {
            throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
        }
        // If there is only one transition, it must be of type TimeZoneTransition
        if (this.transitions.length == 1 && !(this.transitions[0] instanceof TimeZoneTransition)) {
            throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
        }
        // If there are two transitions, none of them should be of type TimeZoneTransition
        if (this.transitions.length == 2) {
            for (var _a = 0, _b = this.transitions; _a < _b.length; _a++) {
                var transition = _b[_a];
                try {
                    var type = transition.constructor.name;
                    //if (transition instanceof TimeZoneTransition) { // ref:  can not use due to prototype chain issue
                    if (type === "TimeZoneTransition") {
                        throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
                    }
                }
                catch (error) {
                }
            }
        }
        // All the transitions in the group must be to a period.
        for (var _c = 0, _d = this.transitions; _c < _d.length; _c++) {
            var transition = _d[_c];
            if (transition.TargetPeriod == null) {
                throw new ServiceLocalException(Strings.InvalidOrUnsupportedTimeZoneDefinition);
            }
        }
    };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    TimeZoneTransitionGroup.prototype.WriteAttributesToXml = function (writer) {
        writer.WriteAttributeValue(XmlAttributeNames.Id, this.Id);
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    TimeZoneTransitionGroup.prototype.WriteElementsToXml = function (writer) {
        for (var _a = 0, _b = this.transitions; _a < _b.length; _a++) {
            var transition = _b[_a];
            transition.WriteToXml(writer);
        }
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    TimeZoneTransitionGroup.prototype.WriteToXml = function (writer) {
        _super.prototype.WriteToXml.call(this, writer, XmlElementNames.TransitionsGroup);
    };
    /** @internal */
    TimeZoneTransitionGroup.transitionTypes = [XmlElementNames.AbsoluteDateTransition, XmlElementNames.RecurringDayTransition, XmlElementNames.RecurringDateTransition, XmlElementNames.Transition];
    return TimeZoneTransitionGroup;
}(ComplexProperty));
exports.TimeZoneTransitionGroup = TimeZoneTransitionGroup;
(function (TimeZoneTransitionGroup) {
    /**
     * @internal Represents custom time zone creation parameters.
     */
    var CustomTimeZoneCreateParams = (function () {
        /**
         * @internal Initializes a new instance of the **CustomTimeZoneCreateParams** class.
         */
        function CustomTimeZoneCreateParams() {
            this.baseOffsetToUtc = null;
            this.standardDisplayName = null;
            this.daylightDisplayName = null;
        }
        Object.defineProperty(CustomTimeZoneCreateParams.prototype, "BaseOffsetToUtc", {
            /**
             * @internal Gets or sets the base offset to UTC.
             */
            get: function () {
                return this.baseOffsetToUtc;
            },
            set: function (value) {
                this.baseOffsetToUtc = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CustomTimeZoneCreateParams.prototype, "StandardDisplayName", {
            /**
             * @internal Gets or sets the display name of the standard period.
             */
            get: function () {
                return this.standardDisplayName;
            },
            set: function (value) {
                this.standardDisplayName = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CustomTimeZoneCreateParams.prototype, "DaylightDisplayName", {
            /**
             * @internal Gets or sets the display name of the daylight period.
             */
            get: function () {
                return this.daylightDisplayName;
            },
            set: function (value) {
                this.daylightDisplayName = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CustomTimeZoneCreateParams.prototype, "HasDaylightPeriod", {
            /**
             * @internal Gets a value indicating whether the custom time zone should have a daylight period.
             *
             * @value   *true* if the custom time zone should have a daylight period; otherwise, *false*.
             */
            get: function () {
                return !StringHelper.IsNullOrEmpty(this.daylightDisplayName);
            },
            enumerable: true,
            configurable: true
        });
        return CustomTimeZoneCreateParams;
    }());
    TimeZoneTransitionGroup.CustomTimeZoneCreateParams = CustomTimeZoneCreateParams;
})(TimeZoneTransitionGroup = exports.TimeZoneTransitionGroup || (exports.TimeZoneTransitionGroup = {}));
exports.TimeZoneTransitionGroup = TimeZoneTransitionGroup;
TypeContainer.AbsoluteDateTransition = AbsoluteDateTransition;
TypeContainer.AbsoluteDayOfMonthTransition = AbsoluteDayOfMonthTransition;
TypeContainer.RelativeDayOfMonthTransition = RelativeDayOfMonthTransition;
// TimeZoneTransition.AbsoluteDateTransition = (timeZoneDefinition: TimeZoneDefinition) => {
//     return new AbsoluteDateTransition(timeZoneDefinition);
// }
// TimeZoneTransition.AbsoluteDayOfMonthTransition = (timeZoneDefinition: TimeZoneDefinition, targetPeriod?: TimeZonePeriod) => {
//     return new AbsoluteDayOfMonthTransition(timeZoneDefinition, targetPeriod);
// }
// TimeZoneTransition.RelativeDayOfMonthTransition = (timeZoneDefinition: TimeZoneDefinition, targetPeriod?: TimeZonePeriod) => {
//     return new RelativeDayOfMonthTransition(timeZoneDefinition, targetPeriod);
// }
var ApprovalRequestData = (function (_super) {
    __extends(ApprovalRequestData, _super);
    function ApprovalRequestData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ApprovalRequestData.prototype.LoadFromJson = function (jsonProperty, service) { throw new Error("ApprovalRequestData.ts - LoadFromJson : Not implemented."); };
    /**@internal */
    ApprovalRequestData.prototype.ReadElementsFromXmlJsObject = function (reader) { throw new Error("ApprovalRequestData.ts - TryReadElementFromXmlJsObject : Not implemented."); };
    return ApprovalRequestData;
}(ComplexProperty));
exports.ApprovalRequestData = ApprovalRequestData;
var ByteArrayArray = (function (_super) {
    __extends(ByteArrayArray, _super);
    function ByteArrayArray() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        //ref: bytearray not implemented here, storing base64 value instead
        _this.content = []; // System.Byte[][];//System.Collections.Generic.List<T>;
        return _this;
    }
    Object.defineProperty(ByteArrayArray.prototype, "Content", {
        get: function () {
            return this.content;
        },
        enumerable: true,
        configurable: true
    });
    ByteArrayArray.prototype.InternalToJson = function (service) { throw new Error("ByteArrayArray.ts - InternalToJson : Not implemented."); };
    ByteArrayArray.prototype.LoadFromXmlJsObject = function (jsonCollection, serviceExchangeService) {
        if (jsonCollection !== null && jsonCollection[ByteArrayArray.ItemXmlElementName]) {
            var binarydata = EwsServiceJsonReader.ReadAsArray(jsonCollection, ByteArrayArray.ItemXmlElementName);
            for (var _a = 0, binarydata_1 = binarydata; _a < binarydata_1.length; _a++) {
                var blob = binarydata_1[_a];
                this.content.push(blob); //ref: storing original base64 content //EwsServiceJsonReader.ReadBase64ElementValue(blob));
            }
        }
    };
    /**@internal */
    ByteArrayArray.prototype.WriteElementsToXml = function (writer) {
        for (var _a = 0, _b = this.content; _a < _b.length; _a++) {
            var item = _b[_a];
            writer.WriteStartElement(XmlNamespace.Types, ByteArrayArray.ItemXmlElementName);
            writer.WriteValue(item, null);
            //writer.WriteBase64ElementValue(item);
            writer.WriteEndElement();
        }
    };
    ByteArrayArray.ItemXmlElementName = "Base64Binary";
    return ByteArrayArray;
}(ComplexProperty));
exports.ByteArrayArray = ByteArrayArray;
/**
 * Encapsulates information on the changehighlights of a meeting request.
 *
 * @sealed
 */
var ChangeHighlights = (function (_super) {
    __extends(ChangeHighlights, _super);
    /**
     * @internal Initializes a new instance of the **ChangeHighlights** class.
     */
    function ChangeHighlights() {
        var _this = _super.call(this) || this;
        _this.hasLocationChanged = false;
        _this.location = null;
        _this.hasStartTimeChanged = false;
        _this.start = null;
        _this.hasEndTimeChanged = false;
        _this.end = null;
        return _this;
    }
    Object.defineProperty(ChangeHighlights.prototype, "HasLocationChanged", {
        /**
         * Gets a value indicating whether the location has changed.
         */
        get: function () {
            return this.hasLocationChanged;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChangeHighlights.prototype, "Location", {
        /**
         * Gets the old location
         */
        get: function () {
            return this.location;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChangeHighlights.prototype, "HasStartTimeChanged", {
        /**
         * Gets a value indicating whether the the start time has changed.
         */
        get: function () {
            return this.hasStartTimeChanged;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChangeHighlights.prototype, "Start", {
        /**
         * Gets the old start date and time of the meeting.
         */
        get: function () {
            return this.start;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChangeHighlights.prototype, "HasEndTimeChanged", {
        /**
         * Gets a value indicating whether the the end time has changed.
         */
        get: function () {
            return this.hasEndTimeChanged;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChangeHighlights.prototype, "End", {
        /**
         * Gets the old end date and time of the meeting.
         */
        get: function () {
            return this.end;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    ChangeHighlights.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.HasLocationChanged:
                    this.hasLocationChanged = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.Location:
                    this.location = jsObject[key];
                    break;
                case XmlElementNames.HasStartTimeChanged:
                    this.hasStartTimeChanged = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.Start:
                    this.start = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                case XmlElementNames.HasEndTimeChanged:
                    this.hasEndTimeChanged = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.End:
                    this.end = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    };
    return ChangeHighlights;
}(ComplexProperty));
exports.ChangeHighlights = ChangeHighlights;
/**
 * Represents a client token access request
 */
var ClientAccessTokenRequest = (function (_super) {
    __extends(ClientAccessTokenRequest, _super);
    function ClientAccessTokenRequest(id, tokenType, scope) {
        if (id === void 0) { id = null; }
        if (tokenType === void 0) { tokenType = ClientAccessTokenType.CallerIdentity; }
        if (scope === void 0) { scope = null; }
        var _this = _super.call(this) || this;
        _this.id = id;
        _this.tokenType = tokenType;
        _this.scope = scope;
        return _this;
    }
    Object.defineProperty(ClientAccessTokenRequest.prototype, "Id", {
        /**
         * Gets the App Id.
         */
        get: function () {
            return this.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientAccessTokenRequest.prototype, "TokenType", {
        /**
         * Gets token type.
         */
        get: function () {
            return this.tokenType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientAccessTokenRequest.prototype, "Scope", {
        /**
         * Gets the token scope.
         */
        get: function () {
            return this.scope;
        },
        enumerable: true,
        configurable: true
    });
    return ClientAccessTokenRequest;
}(ComplexProperty));
exports.ClientAccessTokenRequest = ClientAccessTokenRequest;
/**
 * Represents a app in GetAppManifests response.
 *
 * @sealed
 */
var ClientApp = (function (_super) {
    __extends(ClientApp, _super);
    /**
     * Initializes a new instance of the **ClientApp** class.
     */
    function ClientApp() {
        var _this = _super.call(this) || this;
        _this.Namespace = XmlNamespace.Types;
        return _this;
    }
    //ReadToXmlDocument(reader: EwsServiceXmlReader): any { throw new Error("ClientApp.ts - ReadToXmlDocument : Not implemented."); } //not needed.
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ClientApp.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        if (jsObject[XmlElementNames.Manifest]) {
            this.Manifest = jsObject[XmlElementNames.Manifest];
        }
        if (jsObject[XmlElementNames.Metadata]) {
            this.Metadata = new ClientAppMetadata();
            this.Metadata.LoadFromXmlJsObject(jsObject[XmlElementNames.Metadata], service);
        }
    };
    return ClientApp;
}(ComplexProperty));
exports.ClientApp = ClientApp;
/**
 * Represents a ClientAppMetadata object.
 *
 * @sealed
 */
var ClientAppMetadata = (function (_super) {
    __extends(ClientAppMetadata, _super);
    /**
     * Initializes a new instance of the **ClientAppMetadata** class.
     */
    function ClientAppMetadata() {
        var _this = _super.call(this) || this;
        _this.Namespace = XmlNamespace.Types;
        return _this;
    }
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ClientAppMetadata.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.EndNodeUrl:
                    this.EndNodeUrl = jsObject[key];
                    break;
                case XmlElementNames.ActionUrl:
                    this.ActionUrl = jsObject[key];
                    break;
                case XmlElementNames.AppStatus:
                    this.AppStatus = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    };
    return ClientAppMetadata;
}(ComplexProperty));
exports.ClientAppMetadata = ClientAppMetadata;
var ClientExtension = (function (_super) {
    __extends(ClientExtension, _super);
    function ClientExtension() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**@internal */
    ClientExtension.prototype.ReadAttributesFromXmlJsObject = function (reader) { throw new Error("ClientExtension.ts - ReadAttributesFromXml : Not implemented."); };
    /**@internal */
    ClientExtension.prototype.ReadElementsFromXmlJsObject = function (reader) { throw new Error("ClientExtension.ts - TryReadElementFromXmlJsObject : Not implemented."); };
    /**@internal */
    ClientExtension.prototype.WriteAttributesToXml = function (writer) { throw new Error("ClientExtension.ts - WriteAttributesToXml : Not implemented."); };
    /**@internal */
    ClientExtension.prototype.WriteElementsToXml = function (writer) { throw new Error("ClientExtension.ts - WriteElementsToXml : Not implemented."); };
    return ClientExtension;
}(ComplexProperty));
exports.ClientExtension = ClientExtension;
/**
 * Represents the complete name of a contact.
 */
var CompleteName = (function (_super) {
    __extends(CompleteName, _super);
    function CompleteName() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.title = null;
        _this.givenName = null;
        _this.middleName = null;
        _this.surname = null;
        _this.suffix = null;
        _this.initials = null;
        _this.fullName = null;
        _this.nickname = null;
        _this.yomiGivenName = null;
        _this.yomiSurname = null;
        return _this;
    }
    Object.defineProperty(CompleteName.prototype, "Title", {
        /**
         * Gets the contact's title.
         */
        get: function () {
            return this.title;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompleteName.prototype, "GivenName", {
        /**
         * Gets the given name (first name) of the contact.
         */
        get: function () {
            return this.givenName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompleteName.prototype, "MiddleName", {
        /**
         * Gets the middle name of the contact.
         */
        get: function () {
            return this.middleName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompleteName.prototype, "Surname", {
        /**
         * Gets the surname (last name) of the contact.
         */
        get: function () {
            return this.surname;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompleteName.prototype, "Suffix", {
        /**
         * Gets the suffix of the contact.
         */
        get: function () {
            return this.suffix;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompleteName.prototype, "Initials", {
        /**
         * Gets the initials of the contact.
         */
        get: function () {
            return this.initials;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompleteName.prototype, "FullName", {
        /**
         * Gets the full name of the contact.
         */
        get: function () {
            return this.fullName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompleteName.prototype, "NickName", {
        /**
         * Gets the nickname of the contact.
         */
        get: function () {
            return this.nickname;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompleteName.prototype, "YomiGivenName", {
        /**
         * Gets the Yomi given name (first name) of the contact.
         */
        get: function () {
            return this.yomiGivenName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompleteName.prototype, "YomiSurname", {
        /**
         * Gets the Yomi surname (last name) of the contact.
         */
        get: function () {
            return this.yomiSurname;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    CompleteName.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.Title:
                    this.title = jsObject[key];
                    break;
                case XmlElementNames.FirstName:
                    this.givenName = jsObject[key];
                    break;
                case XmlElementNames.MiddleName:
                    this.middleName = jsObject[key];
                    break;
                case XmlElementNames.LastName:
                    this.surname = jsObject[key];
                    break;
                case XmlElementNames.Suffix:
                    this.suffix = jsObject[key];
                    break;
                case XmlElementNames.Initials:
                    this.initials = jsObject[key];
                    break;
                case XmlElementNames.FullName:
                    this.fullName = jsObject[key];
                    break;
                case XmlElementNames.NickName:
                    this.nickname = jsObject[key];
                    break;
                case XmlElementNames.YomiFirstName:
                    this.yomiGivenName = jsObject[key];
                    break;
                case XmlElementNames.YomiLastName:
                    this.yomiSurname = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param {EwsServiceXmlWriter} writer  The writer.
     */
    CompleteName.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Title, this.Title);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.FirstName, this.GivenName);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.MiddleName, this.MiddleName);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.LastName, this.Surname);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Suffix, this.Suffix);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Initials, this.Initials);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.FullName, this.FullName);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.NickName, this.NickName);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.YomiFirstName, this.YomiGivenName);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.YomiLastName, this.YomiSurname);
    };
    return CompleteName;
}(ComplexProperty));
exports.CompleteName = CompleteName;
/**
 * Represents an ContactPhoneEntity object.
 */
var ContactPhoneEntity = (function (_super) {
    __extends(ContactPhoneEntity, _super);
    /**
     * Initializes a new instance of the **ContactPhoneEntity** class.
     */
    function ContactPhoneEntity() {
        var _this = _super.call(this) || this;
        /**
         * Gets the phone entity OriginalPhoneString.
         */
        _this.OriginalPhoneString = null;
        /**
         * Gets the phone entity PhoneString.
         */
        _this.PhoneString = null;
        /**
         * Gets the phone entity Type.
         */
        _this.Type = null;
        return _this;
    }
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    ContactPhoneEntity.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.NlgOriginalPhoneString:
                    this.OriginalPhoneString = jsObject[key];
                    break;
                case XmlElementNames.NlgPhoneString:
                    this.PhoneString = jsObject[key];
                    break;
                case XmlElementNames.NlgType:
                    this.Type = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    };
    return ContactPhoneEntity;
}(ComplexProperty));
exports.ContactPhoneEntity = ContactPhoneEntity;
/**
 * Represents the response to a GetConversationItems operation.
 *
 * @sealed
 */
var ConversationNode = (function (_super) {
    __extends(ConversationNode, _super);
    /**
     * @internal Initializes a new instance of the **ConversationNode** class.
     *
     * @param   {PropertySet}   propertySet   The property set.
     */
    function ConversationNode(propertySet) {
        var _this = _super.call(this) || this;
        _this.propertySet = null;
        /**
         * Gets or sets the Internet message id of the node.
         */
        _this.InternetMessageId = null;
        /**
         * Gets or sets the Internet message id of the parent node.
         */
        _this.ParentInternetMessageId = null;
        _this.propertySet = propertySet;
        return _this;
    }
    /**
     * Gets the item instance.
     *
     * @param   {ExchangeService}   service          The service.
     * @param   {string}            xmlElementName   Name of the XML element.
     * @return  {Item}              Item.
     */
    ConversationNode.prototype.GetObjectInstance = function (service, xmlElementName) {
        return (new ItemInfo()).CreateEwsObjectFromXmlElementName(service, xmlElementName);
    };
    /**
     * @internal Obtains EWS XML element name for this object.
     *
     * @return  {string}      The XML element name.
     */
    ConversationNode.prototype.GetXmlElementName = function () {
        return XmlElementNames.ConversationNode;
    };
    /**
     * @internal Loads from XMLjsObject.
     *
     * @param   {any}               jsObject   The json property.
     * @param   {ExchangeService}   service        [description]
     */
    ConversationNode.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        this.InternetMessageId = jsObject[XmlElementNames.InternetMessageId];
        if (jsObject[XmlElementNames.ParentInternetMessageId]) {
            this.ParentInternetMessageId = jsObject[XmlElementNames.ParentInternetMessageId];
        }
        if (jsObject[XmlElementNames.Items]) {
            this.Items = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson(jsObject, service, XmlElementNames.Items, this.GetObjectInstance.bind(this), false, /* clearPropertyBag */ this.propertySet, /* requestedPropertySet */ false); /* summaryPropertiesOnly */
        }
    };
    return ConversationNode;
}(ComplexProperty));
exports.ConversationNode = ConversationNode;
/**
 *
 *
 * @sealed
 */
var ConversationRequest = (function (_super) {
    __extends(ConversationRequest, _super);
    function ConversationRequest(conversationId, syncState) {
        if (conversationId === void 0) { conversationId = null; }
        if (syncState === void 0) { syncState = null; }
        var _this = _super.call(this) || this;
        _this.ConversationId = conversationId;
        _this.SyncState = syncState;
        return _this;
    }
    /**
     * @internal Validates this instance.
     */
    ConversationRequest.prototype.InternalValidate = function () {
        EwsUtilities.ValidateParam(this.ConversationId, "ConversationId");
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    ConversationRequest.prototype.WriteToXml = function (writer, xmlElementName) {
        writer.WriteStartElement(XmlNamespace.Types, xmlElementName);
        this.ConversationId.WriteToXml(writer);
        if (this.SyncState != null) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.SyncState, this.SyncState);
        }
        writer.WriteEndElement();
    };
    return ConversationRequest;
}(ComplexProperty));
exports.ConversationRequest = ConversationRequest;
/**
 *
 *
 * @sealed
 */
var ConversationResponse = (function (_super) {
    __extends(ConversationResponse, _super);
    /**
     * @internal Initializes a new instance of the **ConversationResponse** class.
     *
     * @param   {PropertySet}   propertySet   The property set.
     */
    function ConversationResponse(propertySet) {
        var _this = _super.call(this) || this;
        /**
         * Property set used to fetch items in the conversation.
         */
        _this.propertySet = null;
        /**
         * Gets the conversation id.
         *
         * internal set
         */
        _this.ConversationId = null;
        /**
         * Gets the sync state.
         *
         * internal set
         */
        _this.SyncState = null;
        /**
         * Gets the conversation nodes.
         *
         * internal set
         */
        _this.ConversationNodes = null;
        _this.propertySet = propertySet;
        return _this;
    }
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    ConversationResponse.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        this.ConversationId = new ConversationId();
        this.ConversationId.LoadFromXmlJsObject(jsObject[XmlElementNames.ConversationId], service);
        if (jsObject[XmlElementNames.SyncState]) {
            this.SyncState = jsObject[XmlElementNames.SyncState];
        }
        this.ConversationNodes = new ConversationNodeCollection(this.propertySet);
        if (jsObject[XmlElementNames.ConversationNodes]) {
            this.ConversationNodes.LoadFromXmlJsObject(EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.ConversationNodes], XmlElementNames.ConversationNode), service);
        }
    };
    return ConversationResponse;
}(ComplexProperty));
exports.ConversationResponse = ConversationResponse;
/**
 * Represents the permissions of a delegate user.
 *
 * @sealed
 */
var DelegatePermissions = (function (_super) {
    __extends(DelegatePermissions, _super);
    /**
     * @internal Initializes a new instance of the **DelegatePermissions** class.
     */
    function DelegatePermissions() {
        var _this = _super.call(this) || this;
        _this.delegateFolderPermissions = null;
        var dictionary = new DictionaryWithStringKey();
        dictionary.Add(XmlElementNames.CalendarFolderPermissionLevel, new DelegateFolderPermission());
        dictionary.Add(XmlElementNames.TasksFolderPermissionLevel, new DelegateFolderPermission());
        dictionary.Add(XmlElementNames.InboxFolderPermissionLevel, new DelegateFolderPermission());
        dictionary.Add(XmlElementNames.ContactsFolderPermissionLevel, new DelegateFolderPermission());
        dictionary.Add(XmlElementNames.NotesFolderPermissionLevel, new DelegateFolderPermission());
        dictionary.Add(XmlElementNames.JournalFolderPermissionLevel, new DelegateFolderPermission());
        _this.delegateFolderPermissions = dictionary;
        return _this;
    }
    Object.defineProperty(DelegatePermissions.prototype, "CalendarFolderPermissionLevel", {
        /**
         * Gets or sets the delegate user's permission on the principal's calendar.
         */
        get: function () {
            return this.delegateFolderPermissions.get(XmlElementNames.CalendarFolderPermissionLevel).PermissionLevel;
        },
        set: function (value) {
            this.delegateFolderPermissions.get(XmlElementNames.CalendarFolderPermissionLevel).PermissionLevel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DelegatePermissions.prototype, "TasksFolderPermissionLevel", {
        /**
         * Gets or sets the delegate user's permission on the principal's tasks folder.
         */
        get: function () {
            return this.delegateFolderPermissions.get(XmlElementNames.TasksFolderPermissionLevel).PermissionLevel;
        },
        set: function (value) {
            this.delegateFolderPermissions.get(XmlElementNames.TasksFolderPermissionLevel).PermissionLevel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DelegatePermissions.prototype, "InboxFolderPermissionLevel", {
        /**
         * Gets or sets the delegate user's permission on the principal's inbox.
         */
        get: function () {
            return this.delegateFolderPermissions.get(XmlElementNames.InboxFolderPermissionLevel).PermissionLevel;
        },
        set: function (value) {
            this.delegateFolderPermissions.get(XmlElementNames.InboxFolderPermissionLevel).PermissionLevel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DelegatePermissions.prototype, "ContactsFolderPermissionLevel", {
        /**
         * Gets or sets the delegate user's permission on the principal's contacts folder.
         */
        get: function () {
            return this.delegateFolderPermissions.get(XmlElementNames.ContactsFolderPermissionLevel).PermissionLevel;
        },
        set: function (value) {
            this.delegateFolderPermissions.get(XmlElementNames.ContactsFolderPermissionLevel).PermissionLevel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DelegatePermissions.prototype, "NotesFolderPermissionLevel", {
        /**
         * Gets or sets the delegate user's permission on the principal's notes folder.
         */
        get: function () {
            return this.delegateFolderPermissions.get(XmlElementNames.NotesFolderPermissionLevel).PermissionLevel;
        },
        set: function (value) {
            this.delegateFolderPermissions.get(XmlElementNames.NotesFolderPermissionLevel).PermissionLevel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DelegatePermissions.prototype, "JournalFolderPermissionLevel", {
        /**
         * Gets or sets the delegate user's permission on the principal's journal folder.
         */
        get: function () {
            return this.delegateFolderPermissions.get(XmlElementNames.JournalFolderPermissionLevel).PermissionLevel;
        },
        set: function (value) {
            this.delegateFolderPermissions.get(XmlElementNames.JournalFolderPermissionLevel).PermissionLevel = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    DelegatePermissions.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            var delegateFolderPermission = null;
            if (this.delegateFolderPermissions.containsKey(key)) {
                delegateFolderPermission = this.delegateFolderPermissions.get(key);
                delegateFolderPermission.Initialize(DelegateFolderPermissionLevel[jsObject[key]]);
            }
        }
    };
    /**
     * @internal Resets this instance.
     */
    DelegatePermissions.prototype.Reset = function () {
        for (var _a = 0, _b = this.delegateFolderPermissions.Values; _a < _b.length; _a++) {
            var delegateFolderPermission = _b[_a];
            delegateFolderPermission.Reset();
        }
    };
    /**
     * @internal Validates this instance for AddDelegate.
     */
    DelegatePermissions.prototype.ValidateAddDelegate = function () {
        // If any folder permission is Custom, throw
        //
        this.delegateFolderPermissions.Values.forEach(function (permission) {
            if (permission.PermissionLevel == DelegateFolderPermissionLevel.Custom) {
                throw new ServiceValidationException(Strings.CannotSetDelegateFolderPermissionLevelToCustom);
            }
        });
    };
    /**
     * @internal Validates this instance for UpdateDelegate.
     */
    DelegatePermissions.prototype.ValidateUpdateDelegate = function () {
        // If any folder permission was changed to custom, throw
        //
        this.delegateFolderPermissions.Values.forEach(function (permission) {
            if (permission.PermissionLevel == DelegateFolderPermissionLevel.Custom && !permission.IsExistingPermissionLevelCustom) {
                throw new ServiceValidationException(Strings.CannotSetDelegateFolderPermissionLevelToCustom);
            }
        });
    };
    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    DelegatePermissions.prototype.WriteElementsToXml = function (writer) {
        this.WritePermissionToXml(writer, XmlElementNames.CalendarFolderPermissionLevel);
        this.WritePermissionToXml(writer, XmlElementNames.TasksFolderPermissionLevel);
        this.WritePermissionToXml(writer, XmlElementNames.InboxFolderPermissionLevel);
        this.WritePermissionToXml(writer, XmlElementNames.ContactsFolderPermissionLevel);
        this.WritePermissionToXml(writer, XmlElementNames.NotesFolderPermissionLevel);
        this.WritePermissionToXml(writer, XmlElementNames.JournalFolderPermissionLevel);
    };
    /**
     * Write permission to Xml.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {string}                xmlElementName   The element name.
     */
    DelegatePermissions.prototype.WritePermissionToXml = function (writer, xmlElementName) {
        var delegateFolderPermissionLevel = this.delegateFolderPermissions.get(xmlElementName).PermissionLevel;
        // UpdateDelegate fails if Custom permission level is round tripped
        //
        if (delegateFolderPermissionLevel != DelegateFolderPermissionLevel.Custom) {
            writer.WriteElementValue(XmlNamespace.Types, xmlElementName, DelegateFolderPermissionLevel[delegateFolderPermissionLevel]);
        }
    };
    return DelegatePermissions;
}(ComplexProperty));
exports.DelegatePermissions = DelegatePermissions;
/**
 * @internal Represents a folder's DelegateFolderPermissionLevel
 */
var DelegateFolderPermission = (function () {
    function DelegateFolderPermission() {
        /**
         * @internal Gets or sets the delegate user's permission on a principal's folder.
         */
        this.PermissionLevel = DelegateFolderPermissionLevel.None;
        /**
         * @internal Gets IsExistingPermissionLevelCustom.
         */
        this.IsExistingPermissionLevelCustom = false;
    }
    /**
     * Intializes this DelegateFolderPermission.
     *
     * @param   {DelegateFolderPermissionLevel}   permissionLevel   The DelegateFolderPermissionLevel
     */
    DelegateFolderPermission.prototype.Initialize = function (permissionLevel) {
        this.PermissionLevel = permissionLevel;
        this.IsExistingPermissionLevelCustom = (permissionLevel === DelegateFolderPermissionLevel.Custom);
    };
    /**
     * @internal Resets this DelegateFolderPermission.
     */
    DelegateFolderPermission.prototype.Reset = function () {
        this.Initialize(DelegateFolderPermissionLevel.None);
    };
    return DelegateFolderPermission;
}());
/**
 * Represents a delegate user.
 *
 * @sealed
 */
var DelegateUser = (function (_super) {
    __extends(DelegateUser, _super);
    function DelegateUser(primarySmtpAddressOrStandardUser) {
        var _this = _super.call(this) || this;
        _this.userId = new UserId();
        _this.permissions = new DelegatePermissions();
        _this.receiveCopiesOfMeetingMessages = false;
        _this.viewPrivateItems = false;
        // Confusing error message refers to Calendar folder permissions when adding delegate access for a user
        // without including Calendar Folder permissions.
        //
        _this.receiveCopiesOfMeetingMessages = false;
        _this.viewPrivateItems = false;
        if (typeof primarySmtpAddressOrStandardUser === 'string') {
            _this.userId.PrimarySmtpAddress = primarySmtpAddressOrStandardUser;
        }
        else {
            _this.userId.StandardUser = primarySmtpAddressOrStandardUser;
        }
        return _this;
    }
    Object.defineProperty(DelegateUser.prototype, "UserId", {
        /**
         * Gets the user Id of the delegate user.
         */
        get: function () {
            return this.userId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DelegateUser.prototype, "Permissions", {
        /**
         * Gets the list of delegate user's permissions.
         */
        get: function () {
            return this.permissions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DelegateUser.prototype, "ReceiveCopiesOfMeetingMessages", {
        /**
         * Gets or sets a value indicating if the delegate user should receive copies of meeting requests.
         */
        get: function () {
            return this.receiveCopiesOfMeetingMessages;
        },
        set: function (value) {
            this.receiveCopiesOfMeetingMessages = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DelegateUser.prototype, "ViewPrivateItems", {
        /**
         * Gets or sets a value indicating if the delegate user should be able to view the principal's private items.
         */
        get: function () {
            return this.viewPrivateItems;
        },
        set: function (value) {
            this.viewPrivateItems = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Validates this instance.
     */
    DelegateUser.prototype.InternalValidate = function () {
        if (this.UserId == null) {
            throw new ServiceValidationException(Strings.UserIdForDelegateUserNotSpecified);
        }
        else if (!this.UserId.IsValid()) {
            throw new ServiceValidationException(Strings.DelegateUserHasInvalidUserId);
        }
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    DelegateUser.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.UserId:
                    this.userId = new UserId();
                    this.userId.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.DelegatePermissions:
                    this.permissions.Reset();
                    this.permissions.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.ReceiveCopiesOfMeetingMessages:
                    this.receiveCopiesOfMeetingMessages = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.ViewPrivateItems:
                    this.viewPrivateItems = Convert.toBool(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * @internal Validates this instance for AddDelegate.
     */
    DelegateUser.prototype.ValidateAddDelegate = function () {
        this.permissions.ValidateAddDelegate();
    };
    /**
     * @internal Validates this instance for UpdateDelegate.
     */
    DelegateUser.prototype.ValidateUpdateDelegate = function () {
        this.permissions.ValidateUpdateDelegate();
    };
    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    DelegateUser.prototype.WriteElementsToXml = function (writer) {
        this.UserId.WriteToXml(writer, XmlElementNames.UserId);
        this.Permissions.WriteToXml(writer, XmlElementNames.DelegatePermissions);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ReceiveCopiesOfMeetingMessages, this.ReceiveCopiesOfMeetingMessages);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ViewPrivateItems, this.ViewPrivateItems);
    };
    return DelegateUser;
}(ComplexProperty));
exports.DelegateUser = DelegateUser;
/**
 * Encapsulates information on the deleted occurrence of a recurring appointment.
 */
var DeletedOccurrenceInfo = (function (_super) {
    __extends(DeletedOccurrenceInfo, _super);
    /**
     * @internal Initializes a new instance of the **DeletedOccurrenceInfo** class.
     */
    function DeletedOccurrenceInfo() {
        var _this = _super.call(this) || this;
        /**
         * The original start date and time of the deleted occurrence.
         *
         * /remarks/    The EWS schema contains a Start property for deleted occurrences but it's really the original start date and time of the occurrence.
         */
        _this.originalStart = null;
        return _this;
    }
    Object.defineProperty(DeletedOccurrenceInfo.prototype, "OriginalStart", {
        /**
         * Gets the original start date and time of the deleted occurrence.
         */
        get: function () {
            return this.originalStart;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    DeletedOccurrenceInfo.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        if (jsObject[XmlElementNames.Start]) {
            this.originalStart = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[XmlElementNames.Start]);
        }
    };
    return DeletedOccurrenceInfo;
}(ComplexProperty));
exports.DeletedOccurrenceInfo = DeletedOccurrenceInfo;
/**
 * Represents an EmailUserEntity object.
 */
var EmailUserEntity = (function (_super) {
    __extends(EmailUserEntity, _super);
    /**
     * Initializes a new instance of the **EmailUserEntity** class.
     */
    function EmailUserEntity() {
        var _this = _super.call(this) || this;
        _this.Namespace = XmlNamespace.Types;
        return _this;
    }
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    EmailUserEntity.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.NlgName:
                    this.Name = jsObject[key];
                    break;
                case XmlElementNames.NlgUserId:
                    this.UserId = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    };
    return EmailUserEntity;
}(ComplexProperty));
exports.EmailUserEntity = EmailUserEntity;
/**
 * Represents Enhanced Location.
 */
var EnhancedLocation = (function (_super) {
    __extends(EnhancedLocation, _super);
    function EnhancedLocation(displayName, annotation, personaPostalAddress) {
        if (annotation === void 0) { annotation = StringHelper.Empty; }
        if (personaPostalAddress === void 0) { personaPostalAddress = new PersonaPostalAddress(); }
        var _this = _super.call(this) || this;
        _this.displayName = null;
        _this.annotation = null;
        _this.personaPostalAddress = null;
        _this.displayName = displayName;
        _this.annotation = annotation;
        _this.personaPostalAddress = personaPostalAddress;
        _this.personaPostalAddress.OnChange.push(_this.PersonaPostalAddress_OnChange.bind(_this));
        return _this;
    }
    Object.defineProperty(EnhancedLocation.prototype, "DisplayName", {
        /**
         * Gets or sets the Location DisplayName.
         */
        get: function () {
            return this.displayName;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.displayName; }, setValue: function (fieldValue) { _this.displayName = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EnhancedLocation.prototype, "Annotation", {
        /**
         * Gets or sets the Location Annotation.
         */
        get: function () {
            return this.annotation;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.annotation; }, setValue: function (fieldValue) { _this.annotation = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EnhancedLocation.prototype, "PersonaPostalAddress", {
        /**
         * Gets or sets the Persona Postal Address.
         */
        get: function () {
            return this.personaPostalAddress;
        },
        set: function (value) {
            var _this = this;
            if (this.personaPostalAddress !== value) {
                if (this.personaPostalAddress !== null) {
                    ArrayHelper.RemoveEntry(this.personaPostalAddress.OnChange, this.PersonaPostalAddress_OnChange);
                }
                this.SetFieldValue({ getValue: function () { return _this.personaPostalAddress; }, setValue: function (fieldValue) { _this.personaPostalAddress = fieldValue; } }, value);
                this.personaPostalAddress.OnChange.push(this.PersonaPostalAddress_OnChange.bind(this));
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Validates this instance.
     */
    EnhancedLocation.prototype.InternalValidate = function () {
        _super.prototype.InternalValidate.call(this);
        EwsUtilities.ValidateParam(this.displayName, "DisplayName");
        EwsUtilities.ValidateParamAllowNull(this.annotation, "Annotation");
        EwsUtilities.ValidateParamAllowNull(this.personaPostalAddress, "PersonaPostalAddress");
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    EnhancedLocation.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.LocationDisplayName:
                    this.displayName = jsObject[key];
                    break;
                case XmlElementNames.LocationAnnotation:
                    this.annotation = jsObject[key];
                    break;
                case XmlElementNames.PersonaPostalAddress:
                    this.personaPostalAddress = new PersonaPostalAddress();
                    this.personaPostalAddress.LoadFromXmlJsObject(jsObject[key], service);
                    this.personaPostalAddress.OnChange.push(this.PersonaPostalAddress_OnChange.bind(this));
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * PersonaPostalAddress OnChange.
     *
     * @param   {ComplexProperty}   complexProperty   ComplexProperty object.
     */
    EnhancedLocation.prototype.PersonaPostalAddress_OnChange = function (complexProperty) { this.Changed(); };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    EnhancedLocation.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.LocationDisplayName, this.displayName);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.LocationAnnotation, this.annotation);
        this.personaPostalAddress.WriteToXml(writer);
    };
    return EnhancedLocation;
}(ComplexProperty));
exports.EnhancedLocation = EnhancedLocation;
/**
 * Represents an EntityExtractionResult object.
 */
var EntityExtractionResult = (function (_super) {
    __extends(EntityExtractionResult, _super);
    /**
     * @internal Initializes a new instance of the **EntityExtractionResult** class.
     */
    function EntityExtractionResult() {
        var _this = _super.call(this) || this;
        /**
         * Gets the extracted Addresses.
         */
        _this.Addresses = null;
        /**
         * Gets the extracted MeetingSuggestions.
         */
        _this.MeetingSuggestions = null;
        /**
         * Gets the extracted TaskSuggestions.
         */
        _this.TaskSuggestions = null;
        /**
         * Gets the extracted EmailAddresses.
         */
        _this.EmailAddresses = null;
        /**
         * Gets the extracted Contacts.
         */
        _this.Contacts = null;
        /**
         * Gets the extracted Urls.
         */
        _this.Urls = null;
        /**
         * Gets the extracted PhoneNumbers
         */
        _this.PhoneNumbers = null;
        _this.Namespace = XmlNamespace.Types;
        return _this;
    }
    /**
     * @internal Read element from XMLJsObject.
     *
     * @param   {any}   jsObject   xmljsonObject
     * @return  {ExchangeService} the ExchangeService
     */
    EntityExtractionResult.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            if (jsObject.hasOwnProperty(key)) {
                switch (key) {
                    case XmlElementNames.NlgAddresses:
                        this.Addresses = new AddressEntityCollection();
                        this.Addresses.LoadFromXmlJsObject(jsObject[key], service);
                        break;
                    case XmlElementNames.NlgMeetingSuggestions:
                        this.MeetingSuggestions = new MeetingSuggestionCollection();
                        this.MeetingSuggestions.LoadFromXmlJsObject(jsObject[key], service);
                        break;
                    case XmlElementNames.NlgTaskSuggestions:
                        this.TaskSuggestions = new TaskSuggestionCollection();
                        this.TaskSuggestions.LoadFromXmlJsObject(jsObject[key], service);
                        break;
                    case XmlElementNames.NlgEmailAddresses:
                        this.EmailAddresses = new EmailAddressEntityCollection();
                        this.EmailAddresses.LoadFromXmlJsObject(jsObject[key], service);
                        break;
                    case XmlElementNames.NlgContacts:
                        this.Contacts = new ContactEntityCollection();
                        this.Contacts.LoadFromXmlJsObject(jsObject[key], service);
                        break;
                    case XmlElementNames.NlgUrls:
                        this.Urls = new UrlEntityCollection();
                        this.Urls.LoadFromXmlJsObject(jsObject[key], service);
                        break;
                    case XmlElementNames.NlgPhoneNumbers:
                        this.PhoneNumbers = new PhoneEntityCollection();
                        this.PhoneNumbers.LoadFromXmlJsObject(jsObject[key], service);
                        break;
                    default:
                        break;
                }
            }
        }
    };
    return EntityExtractionResult;
}(ComplexProperty));
exports.EntityExtractionResult = EntityExtractionResult;
var ExtendedProperty = (function (_super) {
    __extends(ExtendedProperty, _super);
    function ExtendedProperty(propertyDefinition) {
        var _this = _super.call(this) || this;
        _this.propertyDefinition = null;
        _this.value = null;
        //EwsUtilities.ValidateParam(propertyDefinition, "propertyDefinition");
        if (typeof propertyDefinition !== 'undefined')
            _this.propertyDefinition = propertyDefinition;
        return _this;
    }
    Object.defineProperty(ExtendedProperty.prototype, "PropertyDefinition", {
        get: function () {
            return this.propertyDefinition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExtendedProperty.prototype, "Value", {
        get: function () {
            return this.value;
        },
        set: function (value) {
            var _this = this;
            EwsUtilities.ValidateParam(value, "value");
            this.SetFieldValue({ getValue: function () { return _this.value; }, setValue: function (val) { return _this.value = val; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    ExtendedProperty.prototype.Equals = function (obj) { throw new Error("ExtendedProperty.ts - Equals : Not implemented."); };
    ExtendedProperty.prototype.GetHashCode = function () { throw new Error("ExtendedProperty.ts - GetHashCode : Not implemented."); };
    ExtendedProperty.prototype.GetStringValue = function () { throw new Error("ExtendedProperty.ts - GetStringValue : Not implemented."); };
    //InternalToJson(service: ExchangeService): any { throw new Error("ExtendedProperty.ts - InternalToJson : Not implemented."); }
    ExtendedProperty.prototype.LoadFromJson = function (jsonProperty, service) { throw new Error("ExtendedProperty.ts - LoadFromJson : Not implemented."); };
    ExtendedProperty.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        if (jsonProperty[XmlElementNames.ExtendedFieldURI]) {
            this.propertyDefinition = new ExtendedPropertyDefinition();
            this.propertyDefinition.LoadPropertyValueFromXmlJsObject(jsonProperty[XmlElementNames.ExtendedFieldURI]);
        }
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.ExtendedFieldURI:
                    //pre processed above
                    break;
                case XmlElementNames.Value:
                    EwsLogging.Assert(this.PropertyDefinition != null, "ExtendedProperty.TryReadElementFromXml", "PropertyDefintion is missing");
                    var stringValue = jsonProperty[key];
                    this.value = MapiTypeConverter.ConvertToValue(this.PropertyDefinition.MapiType, stringValue);
                    break;
                case XmlElementNames.Values:
                    EwsLogging.Assert(this.PropertyDefinition != null, "ExtendedProperty.TryReadElementFromXml", "PropertyDefintion is missing");
                    var stringList = new StringList(XmlElementNames.Value);
                    var jsonCollection = EwsServiceJsonReader.ReadAsArray(jsonProperty, key);
                    stringList.CreateFromXmlJsObjectCollection(jsonCollection, service);
                    this.value = MapiTypeConverter.ConvertToValue(this.PropertyDefinition.MapiType, stringList.GetEnumerator());
                    break;
                default:
                    break;
            }
        }
    };
    /**@internal */
    ExtendedProperty.prototype.WriteElementsToXml = function (writer) {
        this.PropertyDefinition.WriteToXml(writer);
        if (MapiTypeConverter.IsArrayType(this.PropertyDefinition.MapiType)) {
            var array = this.Value;
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Values);
            for (var index = 0; index < array.length; index++) {
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Value, MapiTypeConverter.ConvertToString(this.PropertyDefinition.MapiType, array[index]));
            }
            writer.WriteEndElement();
        }
        else {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Value, MapiTypeConverter.ConvertToString(this.PropertyDefinition.MapiType, this.Value));
        }
    };
    return ExtendedProperty;
}(ComplexProperty));
exports.ExtendedProperty = ExtendedProperty;
/**
 * Encapsulates information on the occurrence of a recurring appointment.
 */
var Flag = (function (_super) {
    __extends(Flag, _super);
    /**
     * Initializes a new instance of the **Flag** class.
     */
    function Flag() {
        var _this = _super.call(this) || this;
        _this.flagStatus = ItemFlagStatus.NotFlagged;
        _this.startDate = null;
        _this.dueDate = null;
        _this.completeDate = null;
        return _this;
    }
    Object.defineProperty(Flag.prototype, "FlagStatus", {
        /**
         * Gets or sets the flag status.
         */
        get: function () {
            return this.flagStatus;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.flagStatus; }, setValue: function (updateValue) { _this.flagStatus = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Flag.prototype, "StartDate", {
        /**
         * Gets the start date.
         */
        get: function () {
            return this.startDate;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.startDate; }, setValue: function (updateValue) { _this.startDate = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Flag.prototype, "DueDate", {
        /**
         * Gets the due date.
         */
        get: function () {
            return this.dueDate;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.dueDate; }, setValue: function (updateValue) { _this.dueDate = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Flag.prototype, "CompleteDate", {
        /**
         * Gets the complete date.
         */
        get: function () {
            return this.completeDate;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.completeDate; }, setValue: function (updateValue) { _this.completeDate = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    Flag.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.FlagStatus:
                    this.flagStatus = ItemFlagStatus[jsObject[key]];
                    break;
                case XmlElementNames.StartDate:
                    this.startDate = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                case XmlElementNames.DueDate:
                    this.dueDate = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                case XmlElementNames.CompleteDate:
                    this.completeDate = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * @internal Validates this instance.
     */
    Flag.prototype.Validate = function () {
        EwsUtilities.ValidateParam(this.flagStatus, "FlagStatus");
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    Flag.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.FlagStatus, ItemFlagStatus[this.FlagStatus]);
        if (this.FlagStatus == ItemFlagStatus.Flagged && this.StartDate != null && this.DueDate != null) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.StartDate, this.StartDate);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DueDate, this.DueDate);
        }
        else if (this.FlagStatus == ItemFlagStatus.Complete && this.CompleteDate != null) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.CompleteDate, this.CompleteDate);
        }
    };
    return Flag;
}(ComplexProperty));
exports.Flag = Flag;
/**
 * Represents a permission on a folder.
 *
 * @sealed
 */
var FolderPermission = (function (_super) {
    __extends(FolderPermission, _super);
    function FolderPermission(userIdOrStandardUserOrSmtpAddress, permissionLevel) {
        var _this = _super.call(this) || this;
        if (typeof userIdOrStandardUserOrSmtpAddress !== 'undefined' && typeof permissionLevel === 'undefined')
            throw new Error("FolderPermission - Constructor: permission level parameter cant be undefined or null when userid/smtpaddress/standarduser is provided in first place.");
        if (typeof userIdOrStandardUserOrSmtpAddress === 'undefined') {
            _this.userId = new UserId();
        }
        else {
            _this.permissionLevel = permissionLevel;
            if (typeof userIdOrStandardUserOrSmtpAddress === 'string' || typeof userIdOrStandardUserOrSmtpAddress === 'number') {
                _this.userId = new UserId(userIdOrStandardUserOrSmtpAddress);
            }
            else {
                _this.userId = userIdOrStandardUserOrSmtpAddress;
            }
        }
        return _this;
    }
    Object.defineProperty(FolderPermission.prototype, "UserId", {
        /**
         * Gets the Id of the user the permission applies to.
         */
        get: function () {
            return this.userId;
        },
        set: function (value) {
            var _this = this;
            if (this.userId != null) {
                ArrayHelper.RemoveEntry(this.userId.OnChange, this.PropertyChanged);
            }
            this.SetFieldValue({ getValue: function () { return _this.userId; }, setValue: function (id) { return _this.userId = id; } }, value);
            if (this.userId != null) {
                this.userId.OnChange.push(this.PropertyChanged.bind(this));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderPermission.prototype, "CanCreateItems", {
        /**
         * Gets or sets a value indicating whether the user can create new items.
         */
        get: function () {
            return this.canCreateItems;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.canCreateItems; }, setValue: function (data) { return _this.canCreateItems = data; } }, value);
            this.AdjustPermissionLevel();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderPermission.prototype, "CanCreateSubFolders", {
        /**
         * Gets or sets a value indicating whether the user can create sub-folders.
         */
        get: function () {
            return this.canCreateSubFolders;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.canCreateSubFolders; }, setValue: function (data) { return _this.canCreateSubFolders = data; } }, value);
            this.AdjustPermissionLevel();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderPermission.prototype, "IsFolderOwner", {
        /**
         * Gets or sets a value indicating whether the user owns the folder.
         */
        get: function () {
            return this.isFolderOwner;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.isFolderOwner; }, setValue: function (data) { return _this.isFolderOwner = data; } }, value);
            this.AdjustPermissionLevel();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderPermission.prototype, "IsFolderVisible", {
        /**
         * Gets or sets a value indicating whether the folder is visible to the user.
         */
        get: function () {
            return this.isFolderVisible;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.isFolderVisible; }, setValue: function (data) { return _this.isFolderVisible = data; } }, value);
            this.AdjustPermissionLevel();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderPermission.prototype, "IsFolderContact", {
        /**
         * Gets or sets a value indicating whether the user is a contact for the folder.
         */
        get: function () {
            return this.isFolderContact;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.isFolderContact; }, setValue: function (data) { return _this.isFolderContact = data; } }, value);
            this.AdjustPermissionLevel();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderPermission.prototype, "EditItems", {
        /**
         * Gets or sets a value indicating if/how the user can edit existing items.
         */
        get: function () {
            return this.editItems;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.editItems; }, setValue: function (data) { return _this.editItems = data; } }, value);
            this.AdjustPermissionLevel();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderPermission.prototype, "DeleteItems", {
        /**
         * Gets or sets a value indicating if/how the user can delete existing items.
         */
        get: function () {
            return this.deleteItems;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.deleteItems; }, setValue: function (data) { return _this.deleteItems = data; } }, value);
            this.AdjustPermissionLevel();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderPermission.prototype, "ReadItems", {
        /**
         * Gets or sets the read items access permission.
         */
        get: function () {
            return this.readItems;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.readItems; }, setValue: function (data) { return _this.readItems = data; } }, value);
            this.AdjustPermissionLevel();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderPermission.prototype, "PermissionLevel", {
        /**
         * Gets or sets the permission level.
         */
        get: function () {
            return this.permissionLevel;
        },
        set: function (value) {
            var _this = this;
            if (this.permissionLevel != value) {
                if (value == FolderPermissionLevel.Custom) {
                    throw new ServiceLocalException(Strings.CannotSetPermissionLevelToCustom);
                }
                this.AssignIndividualPermissions(FolderPermission.defaultPermissions.Member[value]);
                this.SetFieldValue({ getValue: function () { return _this.permissionLevel; }, setValue: function (data) { return _this.permissionLevel = data; } }, value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderPermission.prototype, "DisplayPermissionLevel", {
        /**
         * Gets the permission level that Outlook would display for this folder permission.
         */
        get: function () {
            // If permission level is set to Custom, see if there's a variant
            // that Outlook would map to the same permission level.
            if (this.permissionLevel == FolderPermissionLevel.Custom) {
                for (var _a = 0, _b = FolderPermission.levelVariants.Member; _a < _b.length; _a++) {
                    var variant = _b[_a];
                    if (this.IsEqualTo(variant)) {
                        return variant.PermissionLevel;
                    }
                }
            }
            return this.permissionLevel;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Determines the permission level of this folder permission based on its individual settings, and sets the PermissionLevel property accordingly.
     */
    FolderPermission.prototype.AdjustPermissionLevel = function () {
        for (var key in FolderPermission.defaultPermissions.Member) {
            var value = FolderPermission.defaultPermissions.Member[key];
            if (this.IsEqualTo(value)) {
                this.permissionLevel = key;
                return;
            }
        }
        this.permissionLevel = FolderPermissionLevel.Custom;
    };
    /**
     * Copies the values of the individual permissions of the specified folder permission to this folder permissions.
     *
     * @param   {FolderPermission}   permission   The folder permission to copy the values from.
     */
    FolderPermission.prototype.AssignIndividualPermissions = function (permission) {
        this.canCreateItems = permission.CanCreateItems;
        this.canCreateSubFolders = permission.CanCreateSubFolders;
        this.isFolderContact = permission.IsFolderContact;
        this.isFolderOwner = permission.IsFolderOwner;
        this.isFolderVisible = permission.IsFolderVisible;
        this.editItems = permission.EditItems;
        this.deleteItems = permission.DeleteItems;
        this.readItems = permission.ReadItems;
    };
    /**
     * Create a copy of this FolderPermission instance.
     *
     * @return  {FolderPermission}      Clone of this instance.
     */
    FolderPermission.prototype.Clone = function () {
        var res = new FolderPermission();
        res.canCreateItems = this.canCreateItems;
        res.canCreateSubFolders = this.canCreateSubFolders;
        res.deleteItems = this.deleteItems;
        res.editItems = this.editItems;
        res.isFolderContact = this.isFolderContact;
        res.isFolderOwner = this.isFolderOwner;
        res.isFolderVisible = this.isFolderVisible;
        res.permissionLevel = this.permissionLevel;
        res.readItems = this.readItems;
        res.userId = this.userId;
        return res;
    };
    /**
     * Determines whether the specified folder permission is the same as this one. The comparison does not take UserId and PermissionLevel into consideration.
     *
     * @param   {FolderPermission}  permission   The folder permission to compare with this folder permission.
     * @return  {boolean}           True is the specified folder permission is equal to this one, false otherwise.
     */
    FolderPermission.prototype.IsEqualTo = function (permission) {
        return this.CanCreateItems == permission.CanCreateItems &&
            this.CanCreateSubFolders == permission.CanCreateSubFolders &&
            this.IsFolderContact == permission.IsFolderContact &&
            this.IsFolderVisible == permission.IsFolderVisible &&
            this.IsFolderOwner == permission.IsFolderOwner &&
            this.EditItems == permission.EditItems &&
            this.DeleteItems == permission.DeleteItems &&
            this.ReadItems == permission.ReadItems;
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    FolderPermission.prototype.LoadFromXmlJsObject = function (jsObject /*JsonObject*/, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.UserId:
                    this.UserId = new UserId();
                    this.UserId.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.CanCreateItems:
                    this.canCreateItems = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.CanCreateSubFolders:
                    this.canCreateSubFolders = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsFolderOwner:
                    this.isFolderOwner = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsFolderVisible:
                    this.isFolderVisible = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsFolderContact:
                    this.isFolderContact = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.EditItems:
                    //debugger;//check for assignable enumeration type
                    this.editItems = PermissionScope[jsObject[key]];
                    break;
                case XmlElementNames.DeleteItems:
                    //debugger;//check for assignable enumeration type
                    this.deleteItems = PermissionScope[jsObject[key]];
                    break;
                case XmlElementNames.ReadItems:
                    //debugger;//check for assignable enumeration type
                    this.readItems = FolderPermissionReadAccess[jsObject[key]];
                    break;
                case XmlElementNames.PermissionLevel:
                case XmlElementNames.CalendarPermissionLevel:
                    //debugger;//check for assignable enumeration type
                    this.permissionLevel = FolderPermissionLevel[jsObject[key]];
                    break;
                default:
                    break;
            }
        }
        this.AdjustPermissionLevel();
    };
    /**
     * Property was changed.
     *
     * @param   {ComplexProperty}   complexProperty   The complex property.
     */
    FolderPermission.prototype.PropertyChanged = function (complexProperty) {
        this.Changed();
    };
    //Validate(isCalendarFolder: boolean, permissionIndex: number): void { throw new Error("FolderPermission.ts - Validate : Not implemented."); }
    /**
     * @internal Validates this instance.
     * ## parameters not optional: Typescript inheritance issue if not set as optional in code.
     *
     * @param   {boolean}   isCalendarFolder   if set to true calendar permissions are allowed.
     * @param   {number}    permissionIndex    Index of the permission.
     */
    FolderPermission.prototype.Validate = function (isCalendarFolder, permissionIndex) {
        if (typeof isCalendarFolder === 'undefined' || typeof permissionIndex === 'undefined')
            throw new Error("FolderPermission - Validate: incorrect call to validate, without the isCalendar or permissionIndex pearameter. this signature makes it optional to comply with typescript inheritance system and to avoid compiletime error.");
        // Check UserId
        if (!this.UserId.IsValid()) {
            throw new ServiceValidationException(StringHelper.Format(Strings.FolderPermissionHasInvalidUserId, permissionIndex));
        }
        // If this permission is to be used for a non-calendar folder make sure that read access and permission level aren't set to Calendar-only values
        if (!isCalendarFolder) {
            if ((this.readItems == FolderPermissionReadAccess.TimeAndSubjectAndLocation) ||
                (this.readItems == FolderPermissionReadAccess.TimeOnly)) {
                throw new ServiceLocalException(StringHelper.Format(Strings.ReadAccessInvalidForNonCalendarFolder, this.readItems));
            }
            if ((this.permissionLevel == FolderPermissionLevel.FreeBusyTimeAndSubjectAndLocation) ||
                (this.permissionLevel == FolderPermissionLevel.FreeBusyTimeOnly)) {
                throw new ServiceLocalException(StringHelper.Format(Strings.PermissionLevelInvalidForNonCalendarFolder, FolderPermissionLevel[this.permissionLevel]));
            }
        }
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer             The writer.
     * @param   {boolean}               isCalendarFolder   If true, this permission is for a calendar folder.
     */
    FolderPermission.prototype.WriteElementsToXml = function (writer, isCalendarFolder) {
        if (isCalendarFolder === void 0) { isCalendarFolder = false; }
        if (this.UserId != null) {
            this.UserId.WriteToXml(writer, XmlElementNames.UserId);
        }
        if (this.PermissionLevel == FolderPermissionLevel.Custom) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.CanCreateItems, this.CanCreateItems);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.CanCreateSubFolders, this.CanCreateSubFolders);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsFolderOwner, this.IsFolderOwner);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsFolderVisible, this.IsFolderVisible);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsFolderContact, this.IsFolderContact);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.EditItems, this.EditItems);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DeleteItems, this.DeleteItems);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ReadItems, this.ReadItems);
        }
        writer.WriteElementValue(XmlNamespace.Types, isCalendarFolder ? XmlElementNames.CalendarPermissionLevel : XmlElementNames.PermissionLevel, FolderPermissionLevel[this.PermissionLevel]);
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer             The writer.
     * @param   {string}                xmlElementName     Name of the XML element.
     * @param   {XmlNamespace}          xmlNamespace
     * @param   {isCalendarFolder}      isCalendarFolder   If true, this permission is for a calendar folder.
     */
    FolderPermission.prototype.WriteToXml = function (writer, xmlElementName, xmlNamespace, isCalendarFolder) {
        if (isCalendarFolder === void 0) { isCalendarFolder = false; }
        writer.WriteStartElement(this.Namespace, xmlElementName);
        this.WriteAttributesToXml(writer);
        this.WriteElementsToXml(writer, isCalendarFolder);
        writer.WriteEndElement();
    };
    FolderPermission.defaultPermissions = new LazyMember(function () {
        var result = {}; // new Dictionary<FolderPermissionLevel, FolderPermission>();
        var permission = new FolderPermission();
        permission.canCreateItems = false;
        permission.canCreateSubFolders = false;
        permission.deleteItems = PermissionScope.None;
        permission.editItems = PermissionScope.None;
        permission.isFolderContact = false;
        permission.isFolderOwner = false;
        permission.isFolderVisible = false;
        permission.readItems = FolderPermissionReadAccess.None;
        result[FolderPermissionLevel.None] = permission;
        permission = new FolderPermission();
        permission.canCreateItems = true;
        permission.canCreateSubFolders = false;
        permission.deleteItems = PermissionScope.None;
        permission.editItems = PermissionScope.None;
        permission.isFolderContact = false;
        permission.isFolderOwner = false;
        permission.isFolderVisible = true;
        permission.readItems = FolderPermissionReadAccess.None;
        result[FolderPermissionLevel.Contributor] = permission;
        permission = new FolderPermission();
        permission.canCreateItems = false;
        permission.canCreateSubFolders = false;
        permission.deleteItems = PermissionScope.None;
        permission.editItems = PermissionScope.None;
        permission.isFolderContact = false;
        permission.isFolderOwner = false;
        permission.isFolderVisible = true;
        permission.readItems = FolderPermissionReadAccess.FullDetails;
        result[FolderPermissionLevel.Reviewer] = permission;
        permission = new FolderPermission();
        permission.canCreateItems = true;
        permission.canCreateSubFolders = false;
        permission.deleteItems = PermissionScope.Owned;
        permission.editItems = PermissionScope.None;
        permission.isFolderContact = false;
        permission.isFolderOwner = false;
        permission.isFolderVisible = true;
        permission.readItems = FolderPermissionReadAccess.FullDetails;
        result[FolderPermissionLevel.NoneditingAuthor] = permission;
        permission = new FolderPermission();
        permission.canCreateItems = true;
        permission.canCreateSubFolders = false;
        permission.deleteItems = PermissionScope.Owned;
        permission.editItems = PermissionScope.Owned;
        permission.isFolderContact = false;
        permission.isFolderOwner = false;
        permission.isFolderVisible = true;
        permission.readItems = FolderPermissionReadAccess.FullDetails;
        result[FolderPermissionLevel.Author] = permission;
        permission = new FolderPermission();
        permission.canCreateItems = true;
        permission.canCreateSubFolders = true;
        permission.deleteItems = PermissionScope.Owned;
        permission.editItems = PermissionScope.Owned;
        permission.isFolderContact = false;
        permission.isFolderOwner = false;
        permission.isFolderVisible = true;
        permission.readItems = FolderPermissionReadAccess.FullDetails;
        result[FolderPermissionLevel.PublishingAuthor] = permission;
        permission = new FolderPermission();
        permission.canCreateItems = true;
        permission.canCreateSubFolders = false;
        permission.deleteItems = PermissionScope.All;
        permission.editItems = PermissionScope.All;
        permission.isFolderContact = false;
        permission.isFolderOwner = false;
        permission.isFolderVisible = true;
        permission.readItems = FolderPermissionReadAccess.FullDetails;
        result[FolderPermissionLevel.Editor] = permission;
        permission = new FolderPermission();
        permission.canCreateItems = true;
        permission.canCreateSubFolders = true;
        permission.deleteItems = PermissionScope.All;
        permission.editItems = PermissionScope.All;
        permission.isFolderContact = false;
        permission.isFolderOwner = false;
        permission.isFolderVisible = true;
        permission.readItems = FolderPermissionReadAccess.FullDetails;
        result[FolderPermissionLevel.PublishingEditor] = permission;
        permission = new FolderPermission();
        permission.canCreateItems = true;
        permission.canCreateSubFolders = true;
        permission.deleteItems = PermissionScope.All;
        permission.editItems = PermissionScope.All;
        permission.isFolderContact = true;
        permission.isFolderOwner = true;
        permission.isFolderVisible = true;
        permission.readItems = FolderPermissionReadAccess.FullDetails;
        result[FolderPermissionLevel.Owner] = permission;
        permission = new FolderPermission();
        permission.canCreateItems = false;
        permission.canCreateSubFolders = false;
        permission.deleteItems = PermissionScope.None;
        permission.editItems = PermissionScope.None;
        permission.isFolderContact = false;
        permission.isFolderOwner = false;
        permission.isFolderVisible = false;
        permission.readItems = FolderPermissionReadAccess.TimeOnly;
        result[FolderPermissionLevel.FreeBusyTimeOnly] = permission;
        permission = new FolderPermission();
        permission.canCreateItems = false;
        permission.canCreateSubFolders = false;
        permission.deleteItems = PermissionScope.None;
        permission.editItems = PermissionScope.None;
        permission.isFolderContact = false;
        permission.isFolderOwner = false;
        permission.isFolderVisible = false;
        permission.readItems = FolderPermissionReadAccess.TimeAndSubjectAndLocation;
        result[FolderPermissionLevel.FreeBusyTimeAndSubjectAndLocation] = permission;
        return result;
    });
    /**
     * Variants of pre-defined permission levels that Outlook also displays with the same levels.
     */
    FolderPermission.levelVariants = new LazyMember(function () {
        var results = []; // new List<FolderPermission>();
        var permissionNone = FolderPermission.defaultPermissions.Member[FolderPermissionLevel.None];
        var permissionOwner = FolderPermission.defaultPermissions.Member[FolderPermissionLevel.Owner];
        // PermissionLevelNoneOption1
        var permission = permissionNone.Clone();
        permission.isFolderVisible = true;
        results.push(permission);
        // PermissionLevelNoneOption2
        permission = permissionNone.Clone();
        permission.isFolderContact = true;
        results.push(permission);
        // PermissionLevelNoneOption3
        permission = permissionNone.Clone();
        permission.isFolderContact = true;
        permission.isFolderVisible = true;
        results.push(permission);
        // PermissionLevelOwnerOption1
        permission = permissionOwner.Clone();
        permission.isFolderContact = false;
        results.push(permission);
        return results;
    });
    return FolderPermission;
}(ComplexProperty));
exports.FolderPermission = FolderPermission;
var GroupMember = (function (_super) {
    __extends(GroupMember, _super);
    function GroupMember() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GroupMember.prototype.AddressInformationChanged = function (complexProperty) { throw new Error("GroupMember.ts - AddressInformationChanged : Not implemented."); };
    GroupMember.prototype.InternalToJson = function (service) { throw new Error("GroupMember.ts - InternalToJson : Not implemented."); };
    GroupMember.prototype.LoadFromJson = function (jsonProperty, service) { throw new Error("GroupMember.ts - LoadFromJson : Not implemented."); };
    /**@internal */
    GroupMember.prototype.ReadAttributesFromXmlJsObject = function (reader) { throw new Error("GroupMember.ts - ReadAttributesFromXml : Not implemented."); };
    /**@internal */
    GroupMember.prototype.ReadElementsFromXmlJsObject = function (reader) { throw new Error("GroupMember.ts - TryReadElementFromXmlJsObject : Not implemented."); };
    /**@internal */
    GroupMember.prototype.WriteAttributesToXml = function (writer) { throw new Error("GroupMember.ts - WriteAttributesToXml : Not implemented."); };
    /**@internal */
    GroupMember.prototype.WriteElementsToXml = function (writer) { throw new Error("GroupMember.ts - WriteElementsToXml : Not implemented."); };
    return GroupMember;
}(ComplexProperty));
exports.GroupMember = GroupMember;
//}
/**
 * Represents an AQS highlight term.
 *
 * @sealed
 */
var HighlightTerm = (function (_super) {
    __extends(HighlightTerm, _super);
    /**
     * @internal Initializes a new instance of the **HighlightTerm** class.
     */
    function HighlightTerm() {
        var _this = _super.call(this) || this;
        /**
         * Term scope.
         */
        _this.scope = null;
        /**
         * Term value.
         */
        _this.value = null;
        return _this;
    }
    Object.defineProperty(HighlightTerm.prototype, "Scope", {
        /**
         * Gets term scope.
         */
        get: function () {
            return this.scope;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HighlightTerm.prototype, "Value", {
        /**
         * Gets term value.
         */
        get: function () {
            return this.value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    HighlightTerm.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        if (jsObject[XmlElementNames.HighlightTermScope]) {
            this.scope = jsObject[XmlElementNames.HighlightTermScope];
        }
        if (jsObject[XmlElementNames.HighlightTermValue]) {
            this.value = jsObject[XmlElementNames.HighlightTermValue];
        }
    };
    return HighlightTerm;
}(ComplexProperty));
exports.HighlightTerm = HighlightTerm;
/**
 * Represents an Internet message header.
 */
var InternetMessageHeader = (function (_super) {
    __extends(InternetMessageHeader, _super);
    /**
     * @internal Initializes a new instance of the **InternetMessageHeader** class.
     */
    function InternetMessageHeader() {
        var _this = _super.call(this) || this;
        _this.name = null;
        _this.value = null;
        return _this;
    }
    Object.defineProperty(InternetMessageHeader.prototype, "Name", {
        /**
         * The name of the header.
         */
        get: function () {
            return this.name;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.name; }, setValue: function (nameValue) { _this.name = nameValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InternetMessageHeader.prototype, "Value", {
        /**
         * The value of the header.
         */
        get: function () {
            return this.value;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.value; }, setValue: function (valueValue) { _this.value = valueValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads from XMLJsObject.
     *
     * @param   {any}   jsonProperty   The json property.
     * @param   {ExchangeService}   service        The ExchangeService instance
     */
    InternetMessageHeader.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlAttributeNames.HeaderName:
                    this.name = jsObject[key];
                    break;
                case XmlElementNames.InternetMessageHeader://JsonObject.JsonValueString: //ref: //info: custom parser in ExtensionMethods uses name of type when there is attribute value as well as text value
                    this.value = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * Obtains a string representation of the header.
     *
     * @return  {string}      The string representation of the header.
     */
    InternetMessageHeader.prototype.ToString = function () { return StringHelper.Format("{0}={1}", this.Name, this.Value); };
    InternetMessageHeader.prototype.toString = function () { return this.ToString(); };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    InternetMessageHeader.prototype.WriteAttributesToXml = function (writer) { writer.WriteAttributeValue(XmlAttributeNames.HeaderName, this.Name); };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    InternetMessageHeader.prototype.WriteElementsToXml = function (writer) { writer.WriteValue(this.Value, this.Name); };
    return InternetMessageHeader;
}(ComplexProperty));
exports.InternetMessageHeader = InternetMessageHeader;
/**
 * Represents a collection of items.
 */
var ItemCollection = (function (_super) {
    __extends(ItemCollection, _super);
    /**
     * Initializes a new instance of the **ItemCollection** class.
     *
     */
    function ItemCollection() {
        var _this = _super.call(this) || this;
        _this.__implements = ["ISelfValidate", "IJsonSerializable", "IEnumerable<TItem>", "IJsonCollectionDeserializer"];
        _this.items = []; // System.Collections.Generic.List<T>;
        return _this;
    }
    Object.defineProperty(ItemCollection.prototype, "Count", {
        /**
         * Gets the total number of items in the collection.
         */
        get: function () {
            return this.items.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the item at the specified index.
     *
     * @param   {number}   index   The zero-based index of the item to get.
     * @return  {TItem}     The item at the specified index.
     */
    ItemCollection.prototype._getItem = function (index) {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }
        return this.items[index];
    };
    ItemCollection.prototype.GetEnumerator = function () { throw new Error("ItemCollection.ts - GetEnumerator : Not implemented."); }; //wil be implementedfor ES6 later with yield
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    ItemCollection.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        var collectionObj = undefined;
        if (ArrayHelper.isArray(jsObject)) {
            collectionObj = jsObject;
        }
        else {
            collectionObj = [jsObject];
        }
        for (var _a = 0, collectionObj_1 = collectionObj; _a < collectionObj_1.length; _a++) {
            var entry = collectionObj_1[_a];
            var jsonServiceObject = entry;
            var item = (new ItemInfo()).CreateEwsObjectFromXmlElementName(service, TypeSystem.GetJsObjectTypeName(jsonServiceObject));
            item.LoadFromXmlJsObject(jsonServiceObject, service, true);
            this.items.push(item);
        }
    };
    return ItemCollection;
}(ComplexProperty));
exports.ItemCollection = ItemCollection;
/**
 * Represents a mailbox reference.
 */
var Mailbox = (function (_super) {
    __extends(Mailbox, _super);
    function Mailbox(smtpAddressOrAddress, routingType) {
        if (smtpAddressOrAddress === void 0) { smtpAddressOrAddress = null; }
        if (routingType === void 0) { routingType = null; }
        var _this = _super.call(this) || this;
        _this.Address = smtpAddressOrAddress;
        _this.RoutingType = routingType;
        return _this;
    }
    Object.defineProperty(Mailbox.prototype, "IsValid", {
        /**
         * True if this instance is valid, false otherthise.
         *
         * @value   *true* if this instance is valid; otherwise, *false*.
         */
        get: function () {
            return !StringHelper.IsNullOrEmpty(this.Address);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Determines whether the specified  is equal to the current .
     *
     * @param   {any}   obj   The  to compare with the current .
     * @return  {boolean}       true if the specified  is equal to the current ; otherwise, false.
     *
     * @exception   {NullReferenceException}    The **obj** parameter is null.
     */
    Mailbox.prototype.Equals = function (obj) {
        if (this === obj) {
            return true;
        }
        else {
            var other = obj;
            if (!(other instanceof Mailbox)) {
                return false;
            }
            else if (((this.Address == null) && (other.Address == null)) ||
                ((this.Address != null) && this.Address === other.Address)) {
                return ((this.RoutingType == null) && (other.RoutingType == null)) ||
                    ((this.RoutingType != null) && this.RoutingType === other.RoutingType);
            }
            else {
                return false;
            }
        }
    };
    //GetHashCode(): number { throw new Error("Mailbox.ts - GetHashCode : Not implemented."); }
    /**
     * @internal Validates this instance.
     */
    Mailbox.prototype.InternalValidate = function () {
        _super.prototype.InternalValidate.call(this);
        EwsUtilities.ValidateNonBlankStringParamAllowNull(this.Address, "address");
        EwsUtilities.ValidateNonBlankStringParamAllowNull(this.RoutingType, "routingType");
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    Mailbox.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        //debug:
        if (jsonProperty[XmlElementNames.EmailAddress]) {
            this.Address = jsonProperty[XmlElementNames.EmailAddress]; //.ReadAsString(XmlElementNames.EmailAddress);
        }
        if (jsonProperty[XmlElementNames.RoutingType]) {
            this.RoutingType = jsonProperty[XmlElementNames.RoutingType]; //.ReadAsString(XmlElementNames.RoutingType);
        }
    };
    /**
     * Returns a  that represents the current .
     *
     * @return  {string}      A **String** that represents the current **Object**.
     */
    Mailbox.prototype.ToString = function () {
        if (!this.IsValid) {
            return StringHelper.Empty;
        }
        else if (!StringHelper.IsNullOrEmpty(this.RoutingType)) {
            return this.RoutingType + ":" + this.Address;
        }
        else {
            return this.Address;
        }
    };
    Mailbox.prototype.toString = function () {
        return this.ToString();
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    Mailbox.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.EmailAddress, this.Address);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.RoutingType, this.RoutingType);
    };
    /**
     * Get a string representation for using this instance in a search filter.
     * ISearchStringProvider.GetSearchString
     *
     * @return  {string}      String representation of instance.
     */
    Mailbox.prototype.GetSearchString = function () {
        return this.Address;
    };
    return Mailbox;
}(ComplexProperty));
exports.Mailbox = Mailbox;
var ManagedFolderInformation = (function (_super) {
    __extends(ManagedFolderInformation, _super);
    function ManagedFolderInformation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ManagedFolderInformation.prototype.LoadFromJson = function (jsonProperty /*JsonObject*/, service) { throw new Error("ManagedFolderInformation.ts - LoadFromJson : Not implemented."); };
    /**@internal */
    ManagedFolderInformation.prototype.ReadElementsFromXmlJsObject = function (reader) { throw new Error("ManagedFolderInformation.ts - TryReadElementFromXmlJsObject : Not implemented."); };
    return ManagedFolderInformation;
}(ComplexProperty));
exports.ManagedFolderInformation = ManagedFolderInformation;
//}
/**
 * @internal Represents a time zone in which a meeting is defined.
 * @sealed
 */
var MeetingTimeZone = (function (_super) {
    __extends(MeetingTimeZone, _super);
    function MeetingTimeZone(timeZoneOrName) {
        if (timeZoneOrName === void 0) { timeZoneOrName = null; }
        var _this = _super.call(this) || this;
        _this.name = null;
        _this.baseOffset = null;
        _this.standard = null;
        _this.daylight = null;
        if (arguments.length === 1) {
            if (timeZoneOrName instanceof TimeZoneInfo) {
                // Unfortunately, MeetingTimeZone does not support all the time transition types
                // supported by TimeZoneInfo. That leaves us unable to accurately convert TimeZoneInfo
                // into MeetingTimeZone. So we don't... Instead, we emit the time zone's Id and
                // hope the server will find a match (which it should).
                _this.Name = timeZoneOrName.Id;
            }
            else {
                _this.name = timeZoneOrName;
            }
        }
        return _this;
    }
    Object.defineProperty(MeetingTimeZone.prototype, "Name", {
        /**
         * Gets or sets the name of the time zone.
         */
        get: function () {
            return this.name;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.name; }, setValue: function (fieldValue) { _this.name = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingTimeZone.prototype, "BaseOffset", {
        /**
         * Gets or sets the base offset of the time zone from the UTC time zone.
         */
        get: function () {
            return this.baseOffset;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.baseOffset; }, setValue: function (fieldValue) { _this.baseOffset = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingTimeZone.prototype, "Standard", {
        /**
         * Gets or sets a TimeChange defining when the time changes to Standard Time.
         */
        get: function () {
            return this.standard;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.standard; }, setValue: function (fieldValue) { _this.standard = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingTimeZone.prototype, "Daylight", {
        /**
         * Gets or sets a TimeChange defining when the time changes to Daylight Saving Time.
         */
        get: function () {
            return this.daylight;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.daylight; }, setValue: function (fieldValue) { _this.daylight = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    MeetingTimeZone.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.BaseOffset:
                    this.baseOffset = EwsUtilities.XSDurationToTimeSpan(jsonProperty[key]);
                    break;
                case XmlElementNames.Standard:
                    this.standard = new TimeChange();
                    this.standard.LoadFromXmlJsObject(jsonProperty[key], service);
                    break;
                case XmlElementNames.Daylight:
                    this.daylight = new TimeChange();
                    this.daylight.LoadFromXmlJsObject(jsonProperty[key], service);
                    break;
                case XmlAttributeNames.TimeZoneName:
                    this.name = jsonProperty[key];
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * @internal Converts this meeting time zone into a TimeZoneInfo structure.
    */
    MeetingTimeZone.prototype.ToTimeZoneInfo = function () {
        // MeetingTimeZone.ToTimeZoneInfo throws ArgumentNullException if name is null
        // TimeZoneName is optional, may not show in the response.
        if (StringHelper.IsNullOrEmpty(this.Name)) {
            return null;
        }
        var result = null;
        try {
            result = TimeZoneInfo.FindSystemTimeZoneById(this.Name);
        }
        catch (exception) {
            // Could not find a time zone with that Id on the local system.
        }
        // Again, we cannot accurately convert MeetingTimeZone into TimeZoneInfo
        // because TimeZoneInfo doesn't support absolute date transitions. So if
        // there is no system time zone that has a matching Id, we return null.
        return result;
    };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    MeetingTimeZone.prototype.WriteAttributesToXml = function (writer) {
        writer.WriteAttributeValue(XmlAttributeNames.TimeZoneName, this.Name);
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    MeetingTimeZone.prototype.WriteElementsToXml = function (writer) {
        if (this.BaseOffset) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.BaseOffset, EwsUtilities.TimeSpanToXSDuration(this.BaseOffset));
        }
        if (this.Standard != null) {
            this.Standard.WriteToXml(writer, XmlElementNames.Standard);
        }
        if (this.Daylight != null) {
            this.Daylight.WriteToXml(writer, XmlElementNames.Daylight);
        }
    };
    return MeetingTimeZone;
}(ComplexProperty));
exports.MeetingTimeZone = MeetingTimeZone;
/**
 * Represents the normalized body of an item - the HTML fragment representation of the body.
 */
var NormalizedBody = (function (_super) {
    __extends(NormalizedBody, _super);
    /**
     * Initializes a new instance of the **NormalizedBody** class.
     */
    function NormalizedBody() {
        var _this = _super.call(this) || this;
        _this.bodyType = BodyType.HTML;
        _this.text = null;
        _this.isTruncated = false;
        return _this;
    }
    Object.defineProperty(NormalizedBody.prototype, "BodyType", {
        /**
         * Gets the type of the normalized body's text.
         */
        get: function () {
            return this.bodyType;
        },
        set: function (value) {
            this.bodyType = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalizedBody.prototype, "Text", {
        /**
         * Gets the text of the normalized body.
         */
        get: function () {
            return this.text;
        },
        set: function (value) {
            this.text = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalizedBody.prototype, "IsTruncated", {
        /**
         * Gets whether the body is truncated.
         */
        get: function () {
            return this.isTruncated;
        },
        set: function (value) {
            this.isTruncated = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    NormalizedBody.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlAttributeNames.BodyType:
                    this.bodyType = BodyType[jsObject[key]];
                    break;
                case XmlAttributeNames.IsTruncated:
                    this.isTruncated = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.NormalizedBody:
                    this.text = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * Returns a **String** that represents the current **Object**.
     *
     * @return  {string}      A **String** that represents the current **Object**.
     */
    NormalizedBody.prototype.ToString = function () { return this.Text || StringHelper.Empty; };
    NormalizedBody.prototype.toString = function () { return this.ToString(); };
    /**
     * @internal Writes attributes to XML.
     *
     * @param {EwsServiceXmlWriter} writer  The writer.
     */
    NormalizedBody.prototype.WriteAttributesToXml = function (writer) {
        writer.WriteAttributeValue(XmlAttributeNames.BodyType, this.BodyType);
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param {EwsServiceXmlWriter} writer  The writer.
     */
    NormalizedBody.prototype.WriteElementsToXml = function (writer) {
        if (!StringHelper.IsNullOrEmpty(this.Text)) {
            writer.WriteValue(this.Text, XmlElementNames.NormalizedBody);
        }
    };
    return NormalizedBody;
}(ComplexProperty));
exports.NormalizedBody = NormalizedBody;
/**
 * Encapsulates information on the occurrence of a recurring appointment.
 */
var OccurrenceInfo = (function (_super) {
    __extends(OccurrenceInfo, _super);
    /**
     *  @internal Initializes a new instance of the **OccurrenceInfo** class.
     */
    function OccurrenceInfo() {
        var _this = _super.call(this) || this;
        _this.itemId = null;
        _this.start = null;
        _this.end = null;
        _this.originalStart = null;
        return _this;
    }
    Object.defineProperty(OccurrenceInfo.prototype, "ItemId", {
        /**
         * Gets the Id of the occurrence.
         */
        get: function () {
            return this.itemId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OccurrenceInfo.prototype, "Start", {
        /**
         * Gets the start date and time of the occurrence.
         */
        get: function () {
            return this.start;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OccurrenceInfo.prototype, "End", {
        /**
         * Gets the end date and time of the occurrence.
         */
        get: function () {
            return this.end;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OccurrenceInfo.prototype, "OriginalStart", {
        /**
         * Gets the original start date and time of the occurrence.
         */
        get: function () {
            return this.originalStart;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    OccurrenceInfo.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.ItemId:
                    this.itemId = new ItemId();
                    this.itemId.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.Start:
                    this.start = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                case XmlElementNames.End:
                    this.end = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                case XmlElementNames.OriginalStart:
                    this.originalStart = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    };
    return OccurrenceInfo;
}(ComplexProperty));
exports.OccurrenceInfo = OccurrenceInfo;
/**
 * Represents Lync online meeting settings.
 */
var OnlineMeetingSettings = (function (_super) {
    __extends(OnlineMeetingSettings, _super);
    function OnlineMeetingSettings(lobbyBypassOrOnlineMeetingSettings, accessLevel, presenters) {
        var _this = _super.call(this) || this;
        _this.lobbyBypass = LobbyBypass.Disabled;
        _this.accessLevel = OnlineMeetingAccessLevel.Locked;
        _this.presenters = Presenters.Disabled;
        switch (arguments.length) {
            case 1:
                var onlineMeetingSettings = lobbyBypassOrOnlineMeetingSettings;
                EwsUtilities.ValidateParam(lobbyBypassOrOnlineMeetingSettings, "OnlineMeetingSettings");
                _this.LobbyBypass = onlineMeetingSettings.LobbyBypass;
                _this.AccessLevel = onlineMeetingSettings.AccessLevel;
                _this.Presenters = onlineMeetingSettings.Presenters;
                break;
            case 3:
                _this.lobbyBypass = lobbyBypassOrOnlineMeetingSettings;
                _this.accessLevel = accessLevel;
                _this.presenters = presenters;
                break;
            default:
                break;
        }
        return _this;
    }
    Object.defineProperty(OnlineMeetingSettings.prototype, "LobbyBypass", {
        /**
         * Gets or sets the online meeting setting that describes whether users dialing in by phone have to wait in the lobby.
         */
        get: function () {
            return this.lobbyBypass;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.lobbyBypass; }, setValue: function (fieldValue) { _this.LobbyBypass = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OnlineMeetingSettings.prototype, "AccessLevel", {
        /**
         * Gets or sets the online meeting setting that describes access permission to the meeting.
         */
        get: function () {
            return this.accessLevel;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.accessLevel; }, setValue: function (fieldValue) { _this.accessLevel = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OnlineMeetingSettings.prototype, "Presenters", {
        /**
         * Gets or sets the online meeting setting that defines the meeting leaders.
         */
        get: function () {
            return this.presenters;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.presenters; }, setValue: function (fieldValue) { _this.presenters = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    OnlineMeetingSettings.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.LobbyBypass:
                    this.lobbyBypass = LobbyBypass[jsObject[key]];
                    break;
                case XmlElementNames.AccessLevel:
                    this.accessLevel = OnlineMeetingAccessLevel[jsObject[key]];
                    break;
                case XmlElementNames.Presenters:
                    this.presenters = Presenters[jsObject[key]];
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    OnlineMeetingSettings.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.LobbyBypass, this.LobbyBypass);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.AccessLevel, this.AccessLevel);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Presenters, this.Presenters);
    };
    return OnlineMeetingSettings;
}(ComplexProperty));
exports.OnlineMeetingSettings = OnlineMeetingSettings;
/**
 * Represents PersonaPostalAddress.
 */
var PersonaPostalAddress = (function (_super) {
    __extends(PersonaPostalAddress, _super);
    function PersonaPostalAddress(street, city, state, country, postalCode, postOfficeBox, locationSource, locationUri, formattedAddress, latitude, longitude, accuracy, altitude, altitudeAccuracy) {
        var _this = _super.call(this) || this;
        _this.street = null;
        _this.city = null;
        _this.state = null;
        _this.country = null;
        _this.postalCode = null;
        _this.postOfficeBox = null;
        _this.type = null;
        _this.latitude = null;
        _this.longitude = null;
        _this.accuracy = null;
        _this.altitude = null;
        _this.altitudeAccuracy = null;
        _this.formattedAddress = null;
        _this.uri = null;
        _this.source = 0;
        if (arguments.length === 0)
            return _this;
        _this.street = street;
        _this.city = city;
        _this.state = state;
        _this.country = country;
        _this.postalCode = postalCode;
        _this.postOfficeBox = postOfficeBox;
        _this.latitude = latitude;
        _this.longitude = longitude;
        _this.source = locationSource;
        _this.uri = locationUri;
        _this.formattedAddress = formattedAddress;
        _this.accuracy = accuracy;
        _this.altitude = altitude;
        _this.altitudeAccuracy = altitudeAccuracy;
        return _this;
    }
    Object.defineProperty(PersonaPostalAddress.prototype, "Street", {
        /**
         * Gets or sets the Street.
         */
        get: function () {
            return this.street;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.street; }, setValue: function (fieldValue) { _this.street = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PersonaPostalAddress.prototype, "City", {
        /**
         * Gets or sets the City.
         */
        get: function () {
            return this.city;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.city; }, setValue: function (fieldValue) { _this.city = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PersonaPostalAddress.prototype, "State", {
        /**
         * Gets or sets the state.
         */
        get: function () {
            return this.state;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.state; }, setValue: function (fieldValue) { _this.state = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PersonaPostalAddress.prototype, "Country", {
        /**
         * Gets or sets the Country.
         */
        get: function () {
            return this.country;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.country; }, setValue: function (fieldValue) { _this.country = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PersonaPostalAddress.prototype, "PostalCode", {
        /**
         * Gets or sets the PostalCode.
         */
        get: function () {
            return this.postalCode;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.postalCode; }, setValue: function (fieldValue) { _this.postalCode = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PersonaPostalAddress.prototype, "PostOfficeBox", {
        /**
         * Gets or sets the PostOfficeBox.
         */
        get: function () {
            return this.postOfficeBox;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.postOfficeBox; }, setValue: function (fieldValue) { _this.postOfficeBox = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PersonaPostalAddress.prototype, "Type", {
        /**
         * Gets or sets the Type.
         */
        get: function () {
            return this.type;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.type; }, setValue: function (fieldValue) { _this.type = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PersonaPostalAddress.prototype, "Source", {
        /**
         * Gets or sets the location source type.
         */
        get: function () {
            return this.source;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.source; }, setValue: function (fieldValue) { _this.source = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PersonaPostalAddress.prototype, "Uri", {
        /**
         * Gets or sets the location Uri.
         */
        get: function () {
            return this.uri;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.uri; }, setValue: function (fieldValue) { _this.uri = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PersonaPostalAddress.prototype, "Latitude", {
        /**
         * Gets or sets a value indicating location latitude.
         */
        get: function () {
            return this.latitude;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.latitude; }, setValue: function (fieldValue) { _this.latitude = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PersonaPostalAddress.prototype, "Longitude", {
        /**
         * Gets or sets a value indicating location longitude.
         */
        get: function () {
            return this.longitude;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.longitude; }, setValue: function (fieldValue) { _this.longitude = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PersonaPostalAddress.prototype, "Accuracy", {
        /**
         * Gets or sets the location accuracy.
         */
        get: function () {
            return this.accuracy;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.accuracy; }, setValue: function (fieldValue) { _this.accuracy = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PersonaPostalAddress.prototype, "Altitude", {
        /**
         * Gets or sets the location altitude.
         */
        get: function () {
            return this.altitude;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.altitude; }, setValue: function (fieldValue) { _this.altitude = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PersonaPostalAddress.prototype, "AltitudeAccuracy", {
        /**
         * Gets or sets the location altitude accuracy.
         */
        get: function () {
            return this.altitudeAccuracy;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.altitudeAccuracy; }, setValue: function (fieldValue) { _this.altitudeAccuracy = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PersonaPostalAddress.prototype, "FormattedAddress", {
        /**
         * Gets or sets the street address.
         */
        get: function () {
            return this.formattedAddress;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.formattedAddress; }, setValue: function (fieldValue) { _this.formattedAddress = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    PersonaPostalAddress.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.Street:
                    this.street = jsObject[key];
                    break;
                case XmlElementNames.City:
                    this.city = jsObject[key];
                    break;
                case XmlElementNames.Country:
                    this.country = jsObject[key];
                    break;
                case XmlElementNames.PostalCode:
                    this.postalCode = jsObject[key];
                    break;
                case XmlElementNames.PostOfficeBox:
                    this.postOfficeBox = jsObject[key];
                    break;
                case XmlElementNames.PostalAddressType:
                    this.type = jsObject[key];
                    break;
                case XmlElementNames.Latitude:
                    this.latitude = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.Longitude:
                    this.longitude = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.Accuracy:
                    this.accuracy = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.Altitude:
                    this.altitude = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.AltitudeAccuracy:
                    this.altitudeAccuracy = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.FormattedAddress:
                    this.formattedAddress = jsObject[key];
                    break;
                case XmlElementNames.LocationUri:
                    this.uri = jsObject[key];
                    break;
                case XmlElementNames.LocationSource:
                    this.source = LocationSource[jsObject[key]];
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    PersonaPostalAddress.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Street, this.street);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.City, this.city);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.State, this.state);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Country, this.country);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.PostalCode, this.postalCode);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.PostOfficeBox, this.postOfficeBox);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.PostalAddressType, this.type);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Latitude, this.latitude);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Longitude, this.longitude);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Accuracy, this.accuracy);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Altitude, this.altitude);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.AltitudeAccuracy, this.altitudeAccuracy);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.FormattedAddress, this.formattedAddress);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.LocationUri, this.uri);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.LocationSource, this.source);
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    PersonaPostalAddress.prototype.WriteToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.PersonaPostalAddress);
        this.WriteElementsToXml(writer);
        writer.WriteEndElement(); // xmlElementName
    };
    return PersonaPostalAddress;
}(ComplexProperty));
exports.PersonaPostalAddress = PersonaPostalAddress;
/**
 * Represents a rule that automatically handles incoming messages.
 * A rule consists of a set of conditions and exceptions that determine whether or not a set of actions should be executed on incoming messages.
 *
 * @sealed
 */
var Rule = (function (_super) {
    __extends(Rule, _super);
    /**
     * Initializes a new instance of the **Rule** class.
     */
    function Rule() {
        var _this = _super.call(this) || this;
        /**
         * The rule ID.
         */
        _this.ruleId = null;
        /**
         * The rule display name.
         */
        _this.displayName = null;
        /**
         * The rule priority.
         */
        _this.priority = 0;
        /**
         * The rule status of enabled or not.
         */
        _this.isEnabled = false;
        /**
         * The rule status of is supported or not.
         */
        _this.isNotSupported = false;
        /**
         * The rule status of in error or not.
         */
        _this.isInError = false;
        /**
         * The rule conditions.
         */
        _this.conditions = null;
        /**
         * The rule actions.
         */
        _this.actions = null;
        /**
         * The rule exceptions.
         */
        _this.exceptions = null;
        //// New rule has priority as 0 by default //todo: fix 0 or 1 when it it changes in offical repo
        _this.priority = 1;
        //// New rule is enabled by default
        _this.isEnabled = true;
        _this.conditions = new RulePredicates();
        _this.actions = new RuleActions();
        _this.exceptions = new RulePredicates();
        return _this;
    }
    Object.defineProperty(Rule.prototype, "Id", {
        /**
         * Gets or sets the Id of this rule.
         */
        get: function () {
            return this.ruleId;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.Id; }, setValue: function (updateValue) { _this.Id = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rule.prototype, "DisplayName", {
        /**
         * Gets or sets the name of this rule as it should be displayed to the user.
         */
        get: function () {
            return this.displayName;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.displayName; }, setValue: function (updateValue) { _this.displayName = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rule.prototype, "Priority", {
        /**
         * Gets or sets the priority of this rule, which determines its execution order.
         */
        get: function () {
            return this.priority;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.priority; }, setValue: function (updateValue) { _this.priority = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rule.prototype, "IsEnabled", {
        /**
         * Gets or sets a value indicating whether this rule is enabled.
         */
        get: function () {
            return this.isEnabled;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.isEnabled; }, setValue: function (updateValue) { _this.isEnabled = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rule.prototype, "IsNotSupported", {
        /**
         * Gets a value indicating whether this rule can be modified via EWS. If IsNotSupported is true, the rule cannot be modified via EWS.
         */
        get: function () {
            return this.isNotSupported;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rule.prototype, "IsInError", {
        /**
         * Gets or sets a value indicating whether this rule has errors. A rule that is in error cannot be processed unless it is updated and the error is corrected.
         */
        get: function () {
            return this.isInError;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.isInError; }, setValue: function (updateValue) { _this.isInError = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rule.prototype, "Conditions", {
        /**
         * Gets the conditions that determine whether or not this rule should be executed against incoming messages.
         */
        get: function () {
            return this.conditions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rule.prototype, "Actions", {
        /**
         * Gets the actions that should be executed against incoming messages if the conditions evaluate as true.
         */
        get: function () {
            return this.actions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rule.prototype, "Exceptions", {
        /**
         * Gets the exceptions that determine if this rule should be skipped even if its conditions evaluate to true.
         */
        get: function () {
            return this.exceptions;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Validates this instance.
     */
    Rule.prototype.InternalValidate = function () {
        _super.prototype.InternalValidate.call(this);
        EwsUtilities.ValidateParam(this.displayName, "DisplayName");
        EwsUtilities.ValidateParam(this.conditions, "Conditions");
        EwsUtilities.ValidateParam(this.exceptions, "Exceptions");
        EwsUtilities.ValidateParam(this.actions, "Actions");
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    Rule.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.DisplayName:
                    this.displayName = jsObject[key];
                    break;
                case XmlElementNames.RuleId:
                    this.ruleId = jsObject[key];
                    break;
                case XmlElementNames.Priority:
                    this.priority = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.IsEnabled:
                    this.isEnabled = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsNotSupported:
                    this.isNotSupported = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsInError:
                    this.isInError = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.Conditions:
                    this.conditions.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.Actions:
                    this.actions.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.Exceptions:
                    this.exceptions.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    Rule.prototype.WriteElementsToXml = function (writer) {
        if (!StringHelper.IsNullOrEmpty(this.Id)) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.RuleId, this.Id);
        }
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DisplayName, this.DisplayName);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Priority, this.Priority);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsEnabled, this.IsEnabled);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsInError, this.IsInError);
        this.Conditions.WriteToXml(writer, XmlElementNames.Conditions);
        this.Exceptions.WriteToXml(writer, XmlElementNames.Exceptions);
        this.Actions.WriteToXml(writer, XmlElementNames.Actions);
    };
    return Rule;
}(ComplexProperty));
exports.Rule = Rule;
/**
 * Represents the set of actions available for a rule.
 *
 * @sealed
 */
var RuleActions = (function (_super) {
    __extends(RuleActions, _super);
    /**
     * @internal Initializes a new instance of the **RuleActions** class.
     */
    function RuleActions() {
        var _this = _super.call(this) || this;
        /**
         * The AssignCategories action.
         */
        _this.assignCategories = null;
        /**
         * The CopyToFolder action.
         */
        _this.copyToFolder = null;
        /**
         * The Delete action.
         */
        _this.delete = false;
        /**
         * The ForwardAsAttachmentToRecipients action.
         */
        _this.forwardAsAttachmentToRecipients = null;
        /**
         * The ForwardToRecipients action.
         */
        _this.forwardToRecipients = null;
        /**
         * The MarkImportance action.
         */
        _this.markImportance = null; //Nullable
        /**
         * The MarkAsRead action.
         */
        _this.markAsRead = false;
        /**
         * The MoveToFolder action.
         */
        _this.moveToFolder = null;
        /**
         * The PermanentDelete action.
         */
        _this.permanentDelete = false;
        /**
         * The RedirectToRecipients action.
         */
        _this.redirectToRecipients = null;
        /**
         * The SendSMSAlertToRecipients action.
         */
        _this.sendSMSAlertToRecipients = null;
        /**
         * The ServerReplyWithMessage action.
         */
        _this.serverReplyWithMessage = null;
        /**
         * The StopProcessingRules action.
         */
        _this.stopProcessingRules = false;
        _this.assignCategories = new StringList();
        _this.forwardAsAttachmentToRecipients = new EmailAddressCollection(XmlElementNames.Address);
        _this.forwardToRecipients = new EmailAddressCollection(XmlElementNames.Address);
        _this.redirectToRecipients = new EmailAddressCollection(XmlElementNames.Address);
        _this.sendSMSAlertToRecipients = [];
        return _this;
    }
    Object.defineProperty(RuleActions.prototype, "AssignCategories", {
        /**
         * Gets the categories that should be stamped on incoming messages.
         * To disable stamping incoming messages with categories, set AssignCategories to null.
         */
        get: function () {
            return this.assignCategories;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuleActions.prototype, "CopyToFolder", {
        /**
         * Gets or sets the Id of the folder incoming messages should be copied to.
         * To disable copying incoming messages to a folder, set CopyToFolder to null.
         */
        get: function () {
            return this.copyToFolder;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.copyToFolder; }, setValue: function (updateValue) { _this.copyToFolder = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuleActions.prototype, "Delete", {
        /**
         * Gets or sets a value indicating whether incoming messages should be automatically moved to the Deleted Items folder.
         */
        get: function () {
            return this.delete;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.delete; }, setValue: function (updateValue) { _this.delete = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuleActions.prototype, "ForwardAsAttachmentToRecipients", {
        /**
         * Gets the e-mail addresses to which incoming messages should be forwarded as attachments.
         * To disable forwarding incoming messages as attachments, empty the ForwardAsAttachmentToRecipients list.
         */
        get: function () {
            return this.forwardAsAttachmentToRecipients;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuleActions.prototype, "ForwardToRecipients", {
        /**
         * Gets the e-mail addresses to which incoming messages should be forwarded.
         * To disable forwarding incoming messages, empty the ForwardToRecipients list.
         */
        get: function () {
            return this.forwardToRecipients;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuleActions.prototype, "MarkImportance", {
        /**
         * @Nullable Gets or sets the importance that should be stamped on incoming messages.
         * To disable the stamping of incoming messages with an importance, set MarkImportance to null.
         */
        get: function () {
            return this.markImportance;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.markImportance; }, setValue: function (updateValue) { _this.markImportance = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuleActions.prototype, "MarkAsRead", {
        /**
         * Gets or sets a value indicating whether incoming messages should be marked as read.
         */
        get: function () {
            return this.markAsRead;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.markAsRead; }, setValue: function (updateValue) { _this.markAsRead = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuleActions.prototype, "MoveToFolder", {
        /**
         * Gets or sets the Id of the folder to which incoming messages should be moved.
         * To disable the moving of incoming messages to a folder, set CopyToFolder to null.
         */
        get: function () {
            return this.moveToFolder;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.moveToFolder; }, setValue: function (updateValue) { _this.moveToFolder = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuleActions.prototype, "PermanentDelete", {
        /**
         * Gets or sets a value indicating whether incoming messages should be permanently deleted. When a message is permanently deleted, it is never saved into the recipient's mailbox. To delete a message after it has been saved into the recipient's mailbox, use the Delete action.
         */
        get: function () {
            return this.permanentDelete;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.permanentDelete; }, setValue: function (updateValue) { _this.permanentDelete = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuleActions.prototype, "RedirectToRecipients", {
        /**
         * Gets the e-mail addresses to which incoming messages should be redirecteded.
         * To disable redirection of incoming messages, empty the RedirectToRecipients list. Unlike forwarded mail, redirected mail maintains the original sender and recipients.
         */
        get: function () {
            return this.redirectToRecipients;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuleActions.prototype, "SendSMSAlertToRecipients", {
        /**
         * Gets the phone numbers to which an SMS alert should be sent.
         * To disable sending SMS alerts for incoming messages, empty the SendSMSAlertToRecipients list.
         */
        get: function () {
            return this.sendSMSAlertToRecipients;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuleActions.prototype, "ServerReplyWithMessage", {
        /**
         * Gets or sets the Id of the template message that should be sent as a reply to incoming messages.
         * To disable automatic replies, set ServerReplyWithMessage to null.
         */
        get: function () {
            return this.serverReplyWithMessage;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.serverReplyWithMessage; }, setValue: function (updateValue) { _this.serverReplyWithMessage = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuleActions.prototype, "StopProcessingRules", {
        /**
         * Gets or sets a value indicating whether subsequent rules should be evaluated.
         */
        get: function () {
            return this.stopProcessingRules;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.stopProcessingRules; }, setValue: function (updateValue) { _this.stopProcessingRules = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Convert the SMS recipient list from EmailAddressCollection type to MobilePhone collection type.
     *
     * @param   {EmailAddressCollection}   emailCollection   Recipient list in EmailAddressCollection type.
     * @return  {MobilePhone[]}		A MobilePhone collection object containing all SMS recipient in MobilePhone type.
     */
    RuleActions.ConvertSMSRecipientsFromEmailAddressCollectionToMobilePhoneCollection = function (emailCollection) {
        var mobilePhoneCollection = [];
        for (var _a = 0, _b = emailCollection.Items; _a < _b.length; _a++) {
            var emailAddress = _b[_a];
            mobilePhoneCollection.push(new MobilePhone(emailAddress.Name, emailAddress.Address));
        }
        return mobilePhoneCollection;
    };
    /**
     * Convert the SMS recipient list from MobilePhone collection type to EmailAddressCollection type.
     *
     * @param   {MobilePhone[]}   recipientCollection   Recipient list in a MobilePhone collection type.
     * @return  {EmailAddressCollection}		An EmailAddressCollection object containing recipients with "MOBILE" address type.
     */
    RuleActions.ConvertSMSRecipientsFromMobilePhoneCollectionToEmailAddressCollection = function (recipientCollection) {
        var emailCollection = new EmailAddressCollection(XmlElementNames.Address);
        for (var _a = 0, recipientCollection_1 = recipientCollection; _a < recipientCollection_1.length; _a++) {
            var recipient = recipientCollection_1[_a];
            var emailAddress = new EmailAddress(recipient.Name, recipient.PhoneNumber, RuleActions.MobileType);
            emailCollection.Add(emailAddress);
        }
        return emailCollection;
    };
    /**
     * @internal Validates this instance.
     */
    RuleActions.prototype.InternalValidate = function () {
        _super.prototype.InternalValidate.call(this);
        EwsUtilities.ValidateParam(this.forwardAsAttachmentToRecipients, "ForwardAsAttachmentToRecipients");
        EwsUtilities.ValidateParam(this.forwardToRecipients, "ForwardToRecipients");
        EwsUtilities.ValidateParam(this.redirectToRecipients, "RedirectToRecipients");
        for (var _a = 0, _b = this.sendSMSAlertToRecipients; _a < _b.length; _a++) {
            var sendSMSAlertToRecipient = _b[_a];
            EwsUtilities.ValidateParam(sendSMSAlertToRecipient, "SendSMSAlertToRecipient");
        }
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    RuleActions.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.AssignCategories:
                    this.assignCategories.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.CopyToFolder:
                    this.copyToFolder = new FolderId();
                    this.copyToFolder.LoadFromXmlJsObject(jsObject[key][XmlElementNames.FolderId], service);
                    break;
                case XmlElementNames.Delete:
                    this.delete = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.ForwardAsAttachmentToRecipients:
                    this.forwardAsAttachmentToRecipients.LoadFromXmlJsObject(jsObject[key][XmlElementNames.Address], service);
                    break;
                case XmlElementNames.ForwardToRecipients:
                    this.forwardToRecipients.LoadFromXmlJsObject(jsObject[key][XmlElementNames.Address], service);
                    break;
                case XmlElementNames.MarkImportance:
                    this.markImportance = Importance[jsObject[key]];
                    break;
                case XmlElementNames.MarkAsRead:
                    this.markAsRead = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.MoveToFolder:
                    this.moveToFolder = new FolderId();
                    this.moveToFolder.LoadFromXmlJsObject(jsObject[key][XmlElementNames.FolderId], service);
                    break;
                case XmlElementNames.PermanentDelete:
                    this.permanentDelete = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.RedirectToRecipients:
                    this.redirectToRecipients.LoadFromXmlJsObject(jsObject[key][XmlElementNames.Address], service);
                    break;
                case XmlElementNames.SendSMSAlertToRecipients:
                    var smsRecipientCollection = new EmailAddressCollection(XmlElementNames.Address);
                    smsRecipientCollection.LoadFromXmlJsObject(jsObject[key][XmlElementNames.Address], service);
                    this.sendSMSAlertToRecipients = RuleActions.ConvertSMSRecipientsFromEmailAddressCollectionToMobilePhoneCollection(smsRecipientCollection);
                    break;
                case XmlElementNames.ServerReplyWithMessage:
                    this.serverReplyWithMessage = new ItemId();
                    this.serverReplyWithMessage.LoadFromXmlJsObject(jsObject[key][XmlElementNames.ItemId], service);
                    break;
                case XmlElementNames.StopProcessingRules:
                    this.stopProcessingRules = Convert.toBool(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    RuleActions.prototype.WriteElementsToXml = function (writer) {
        if (this.AssignCategories.Count > 0) {
            this.AssignCategories.WriteToXml(writer, XmlElementNames.AssignCategories);
        }
        if (this.CopyToFolder != null) {
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.CopyToFolder);
            this.CopyToFolder.WriteToXml(writer);
            writer.WriteEndElement();
        }
        if (this.Delete != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Delete, this.Delete);
        }
        if (this.ForwardAsAttachmentToRecipients.Count > 0) {
            this.ForwardAsAttachmentToRecipients.WriteToXml(writer, XmlElementNames.ForwardAsAttachmentToRecipients);
        }
        if (this.ForwardToRecipients.Count > 0) {
            this.ForwardToRecipients.WriteToXml(writer, XmlElementNames.ForwardToRecipients);
        }
        if (this.MarkImportance) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.MarkImportance, Importance[this.MarkImportance]);
        }
        if (this.MarkAsRead != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.MarkAsRead, this.MarkAsRead);
        }
        if (this.MoveToFolder != null) {
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.MoveToFolder);
            this.MoveToFolder.WriteToXml(writer);
            writer.WriteEndElement();
        }
        if (this.PermanentDelete != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.PermanentDelete, this.PermanentDelete);
        }
        if (this.RedirectToRecipients.Count > 0) {
            this.RedirectToRecipients.WriteToXml(writer, XmlElementNames.RedirectToRecipients);
        }
        if (this.SendSMSAlertToRecipients.length > 0) {
            var emailCollection = RuleActions.ConvertSMSRecipientsFromMobilePhoneCollectionToEmailAddressCollection(this.SendSMSAlertToRecipients);
            emailCollection.WriteToXml(writer, XmlElementNames.SendSMSAlertToRecipients);
        }
        if (this.ServerReplyWithMessage != null) {
            this.ServerReplyWithMessage.WriteToXml(writer, XmlElementNames.ServerReplyWithMessage);
        }
        if (this.StopProcessingRules != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.StopProcessingRules, this.StopProcessingRules);
        }
    };
    /**
     * SMS recipient address type.
     */
    RuleActions.MobileType = "MOBILE";
    return RuleActions;
}(ComplexProperty));
exports.RuleActions = RuleActions;
/**
 * Represents a collection of rules.
 *
 * @sealed
 */
var RuleCollection = (function (_super) {
    __extends(RuleCollection, _super);
    /**
     * @internal Initializes a new instance of the **RuleCollection** class.
     */
    function RuleCollection() {
        var _this = _super.call(this) || this;
        /**
         * The OutlookRuleBlobExists flag.
         */
        _this.outlookRuleBlobExists = false;
        /**
         * The rules in the rule collection.
         */
        _this.rules = null;
        _this.rules = [];
        return _this;
    }
    Object.defineProperty(RuleCollection.prototype, "OutlookRuleBlobExists", {
        /**
         * Gets a value indicating whether an Outlook rule blob exists in the user's mailbox. To update rules with EWS when the Outlook rule blob exists, call SetInboxRules passing true as the value of the removeOutlookBlob parameter.
         */
        get: function () {
            return this.outlookRuleBlobExists;
        },
        set: function (value) {
            this.outlookRuleBlobExists = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuleCollection.prototype, "Count", {
        /**
         * Gets the number of rules in this collection.
         */
        get: function () {
            return this.rules.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the rule at the specified index in the collection.
     *
     * @param   {number}   index   The index of the rule to get.
     * @return  {Rule}	The rule at the specified index.
     */
    RuleCollection.prototype._getItem = function (index) {
        if (index < 0 || index >= this.rules.length) {
            throw new ArgumentOutOfRangeException("Index");
        }
        return this.rules[index];
    };
    /**
     *  Returns an enumerator that iterates through the collection. this case this.rules
     */
    RuleCollection.prototype.GetEnumerator = function () {
        return this.rules;
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    RuleCollection.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        var jsRules = EwsServiceJsonReader.ReadAsArray(jsObject, XmlElementNames.Rule);
        for (var _a = 0, jsRules_1 = jsRules; _a < jsRules_1.length; _a++) {
            var jsRule = jsRules_1[_a];
            var rule = new Rule();
            rule.LoadFromXmlJsObject(jsRule, service);
            this.rules.push(rule);
        }
    };
    return RuleCollection;
}(ComplexProperty));
exports.RuleCollection = RuleCollection;
/**
 * Represents an error that occurred as a result of executing a rule operation.
 *
 * @sealed
 */
var RuleError = (function (_super) {
    __extends(RuleError, _super);
    /**
     * @internal Initializes a new instance of the **RuleError** class.
     */
    function RuleError() {
        var _this = _super.call(this) || this;
        /**
         * Rule property.
         */
        _this.ruleProperty = RuleProperty.RuleId;
        /**
         * Rule validation error code.
         */
        _this.errorCode = RuleErrorCode.ADOperationFailure;
        /**
         * Error message.
         */
        _this.errorMessage = null;
        /**
         * Field value.
         */
        _this.value = null;
        return _this;
    }
    Object.defineProperty(RuleError.prototype, "RuleProperty", {
        /**
         * Gets the property which failed validation.
         */
        get: function () {
            return this.ruleProperty;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuleError.prototype, "ErrorCode", {
        /**
         * Gets the validation error code.
         */
        get: function () {
            return this.errorCode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuleError.prototype, "ErrorMessage", {
        /**
         * Gets the error message.
         */
        get: function () {
            return this.errorMessage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuleError.prototype, "Value", {
        /**
         * Gets the value that failed validation.
         */
        get: function () {
            return this.value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    RuleError.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.FieldURI:
                    this.ruleProperty = RuleProperty[jsObject[key]];
                    break;
                case XmlElementNames.ErrorCode:
                    this.errorCode = RuleErrorCode[jsObject[key]];
                    break;
                case XmlElementNames.ErrorMessage:
                    this.errorMessage = jsObject[key];
                    break;
                case XmlElementNames.FieldValue:
                    this.value = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    };
    return RuleError;
}(ComplexProperty));
exports.RuleError = RuleError;
/**
 * Represents an error that occurred while processing a rule operation.
 *
 * @sealed
 */
var RuleOperationError = (function (_super) {
    __extends(RuleOperationError, _super);
    /**
     * @internal Initializes a new instance of the **RuleOperationError** class.
     */
    function RuleOperationError() {
        var _this = _super.call(this) || this;
        /**
         * Index of the operation mapping to the error.
         */
        _this.operationIndex = 0;
        /**
         * RuleOperation object mapping to the error.
         */
        _this.operation = null;
        /**
         * RuleError Collection.
         */
        _this.ruleErrors = null;
        return _this;
    }
    Object.defineProperty(RuleOperationError.prototype, "Operation", {
        /**
         * Gets the operation that resulted in an error.
         */
        get: function () {
            return this.operation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuleOperationError.prototype, "Count", {
        /**
         * Gets the number of rule errors in the list.
         */
        get: function () {
            return this.ruleErrors.Count;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the rule error at the specified index.
     *
     * @param   {number}   index   The index of the rule error to get.
     * @return  {RuleError}	The rule error at the specified index.
     */
    RuleOperationError.prototype._getItem = function (index) {
        if (index < 0 || index >= this.ruleErrors.Count) {
            throw new ArgumentOutOfRangeException("Index");
        }
        return this.ruleErrors._getItem(index);
    };
    /**
     *  Returns an enumerator that iterates through the collection. this case this.rules
     */
    RuleOperationError.prototype.GetEnumerator = function () {
        return this.ruleErrors.GetEnumerator();
    };
    /**
     * @internal Set operation property by the index of a given opeation enumerator.
     *
     * @param   {RuleOperation[]}   operations   Operation enumerator.
     */
    RuleOperationError.prototype.SetOperationByIndex = function (operations) {
        this.operation = operations[this.operationIndex];
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    RuleOperationError.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.OperationIndex:
                    this.operationIndex = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.ValidationErrors:
                    this.ruleErrors = new RuleErrorCollection();
                    this.ruleErrors.CreateFromXmlJsObjectCollection(jsObject[key], service);
                    break;
                default:
                    break;
            }
        }
    };
    return RuleOperationError;
}(ComplexProperty));
exports.RuleOperationError = RuleOperationError;
/**
 * Represents the date and time range within which messages have been received.
 *
 * @sealed
 */
var RulePredicateDateRange = (function (_super) {
    __extends(RulePredicateDateRange, _super);
    /**
     * @internal Initializes a new instance of the **RulePredicateDateRange** class.
     */
    function RulePredicateDateRange() {
        var _this = _super.call(this) || this;
        /**
         * The start DateTime.
         */
        _this.start = null; //Nullable
        /**
         * The end DateTime.
         */
        _this.end = null; //Nullable
        return _this;
    }
    Object.defineProperty(RulePredicateDateRange.prototype, "Start", {
        /**
         * @Nullable Gets or sets the range start date and time.
         * If Start is set to null, no start date applies.
         */
        get: function () {
            return this.start;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.start; }, setValue: function (updateValue) { _this.start = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicateDateRange.prototype, "End", {
        /**
         * @Nullable Gets or sets the range end date and time.
         * If End is set to null, no end date applies.
         */
        get: function () {
            return this.end;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.end; }, setValue: function (updateValue) { _this.end = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Validates this instance.
     */
    RulePredicateDateRange.prototype.InternalValidate = function () {
        _super.prototype.InternalValidate.call(this);
        if (this.start &&
            this.end &&
            this.start.TotalMilliSeconds > this.end.TotalMilliSeconds) {
            throw new ServiceValidationException("Start date time cannot be bigger than end date time.");
        }
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    RulePredicateDateRange.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.StartDateTime:
                    this.start = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                case XmlElementNames.EndDateTime:
                    this.end = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    RulePredicateDateRange.prototype.WriteElementsToXml = function (writer) {
        if (this.Start) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.StartDateTime, this.Start);
        }
        if (this.End) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.EndDateTime, this.End);
        }
    };
    return RulePredicateDateRange;
}(ComplexProperty));
exports.RulePredicateDateRange = RulePredicateDateRange;
/**
 * Represents the set of conditions and exceptions available for a rule.
 *
 * @sealed
 */
var RulePredicates = (function (_super) {
    __extends(RulePredicates, _super);
    /**
     * @internal Initializes a new instance of the **RulePredicates** class.
     */
    function RulePredicates() {
        var _this = _super.call(this) || this;
        /**
         * The HasCategories predicate.
         */
        _this.categories = null;
        /**
         * The ContainsBodyStrings predicate.
         */
        _this.containsBodyStrings = null;
        /**
         * The ContainsHeaderStrings predicate.
         */
        _this.containsHeaderStrings = null;
        /**
         * The ContainsRecipientStrings predicate.
         */
        _this.containsRecipientStrings = null;
        /**
         * The ContainsSenderStrings predicate.
         */
        _this.containsSenderStrings = null;
        /**
         * The ContainsSubjectOrBodyStrings predicate.
         */
        _this.containsSubjectOrBodyStrings = null;
        /**
         * The ContainsSubjectStrings predicate.
         */
        _this.containsSubjectStrings = null;
        /**
         * The FlaggedForAction predicate.
         */
        _this.flaggedForAction = null; //Nullable
        /**
         * The FromAddresses predicate.
         */
        _this.fromAddresses = null;
        /**
         * The FromConnectedAccounts predicate.
         */
        _this.fromConnectedAccounts = null;
        /**
         * The HasAttachments predicate.
         */
        _this.hasAttachments = false;
        /**
         * The Importance predicate.
         */
        _this.importance = null; //Nullable
        /**
         * The IsApprovalRequest predicate.
         */
        _this.isApprovalRequest = false;
        /**
         * The IsAutomaticForward predicate.
         */
        _this.isAutomaticForward = false;
        /**
         * The IsAutomaticReply predicate.
         */
        _this.isAutomaticReply = false;
        /**
         * The IsEncrypted predicate.
         */
        _this.isEncrypted = false;
        /**
         * The IsMeetingRequest predicate.
         */
        _this.isMeetingRequest = false;
        /**
         * The IsMeetingResponse predicate.
         */
        _this.isMeetingResponse = false;
        /**
         * The IsNDR predicate.
         */
        _this.isNonDeliveryReport = false;
        /**
         * The IsPermissionControlled predicate.
         */
        _this.isPermissionControlled = false;
        /**
         * The IsSigned predicate.
         */
        _this.isSigned = false;
        /**
         * The IsVoicemail predicate.
         */
        _this.isVoicemail = false;
        /**
         * The IsReadReceipt predicate.
         */
        _this.isReadReceipt = false;
        /**
         * The ItemClasses predicate.
         */
        _this.itemClasses = null;
        /**
         * The MessageClassifications predicate.
         */
        _this.messageClassifications = null;
        /**
         * The NotSentToMe predicate.
         */
        _this.notSentToMe = false;
        /**
         * The SentCcMe predicate.
         */
        _this.sentCcMe = false;
        /**
         * The SentOnlyToMe predicate.
         */
        _this.sentOnlyToMe = false;
        /**
         * The SentToAddresses predicate.
         */
        _this.sentToAddresses = null;
        /**
         * The SentToMe predicate.
         */
        _this.sentToMe = false;
        /**
         * The SentToOrCcMe predicate.
         */
        _this.sentToOrCcMe = false;
        /**
         * The Sensitivity predicate.
         */
        _this.sensitivity = null; //Nullable
        /**
         * The WithinDateRange predicate.
         */
        _this.withinDateRange = null;
        /**
         * The WithinSizeRange predicate.
         */
        _this.withinSizeRange = null;
        _this.categories = new StringList();
        _this.containsBodyStrings = new StringList();
        _this.containsHeaderStrings = new StringList();
        _this.containsRecipientStrings = new StringList();
        _this.containsSenderStrings = new StringList();
        _this.containsSubjectOrBodyStrings = new StringList();
        _this.containsSubjectStrings = new StringList();
        _this.fromAddresses = new EmailAddressCollection(XmlElementNames.Address);
        _this.fromConnectedAccounts = new StringList();
        _this.itemClasses = new StringList();
        _this.messageClassifications = new StringList();
        _this.sentToAddresses = new EmailAddressCollection(XmlElementNames.Address);
        _this.withinDateRange = new RulePredicateDateRange();
        _this.withinSizeRange = new RulePredicateSizeRange();
        return _this;
    }
    Object.defineProperty(RulePredicates.prototype, "Categories", {
        /**
         * Gets the categories that an incoming message should be stamped with for the condition or exception to apply.
         * To disable this predicate, empty the list.
         */
        get: function () {
            return this.categories;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "ContainsBodyStrings", {
        /**
         * Gets the strings that should appear in the body of incoming messages for the condition or exception to apply.
         * To disable this predicate, empty the list.
         */
        get: function () {
            return this.containsBodyStrings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "ContainsHeaderStrings", {
        /**
         * Gets the strings that should appear in the headers of incoming messages for the condition or exception to apply.
         * To disable this predicate, empty the list.
         */
        get: function () {
            return this.containsHeaderStrings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "ContainsRecipientStrings", {
        /**
         * Gets the strings that should appear in either the To or Cc fields of incoming messages for the condition or exception to apply.
         * To disable this predicate, empty the list.
         */
        get: function () {
            return this.containsRecipientStrings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "ContainsSenderStrings", {
        /**
         * Gets the strings that should appear in the From field of incoming messages for the condition or exception to apply.
         * To disable this predicate, empty the list.
         */
        get: function () {
            return this.containsSenderStrings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "ContainsSubjectOrBodyStrings", {
        /**
         * Gets the strings that should appear in either the body or the subject of incoming messages for the condition or exception to apply.
         * To disable this predicate, empty the list.
         */
        get: function () {
            return this.containsSubjectOrBodyStrings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "ContainsSubjectStrings", {
        /**
         * Gets the strings that should appear in the subject of incoming messages for the condition or exception to apply.
         * To disable this predicate, empty the list.
         */
        get: function () {
            return this.containsSubjectStrings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "FlaggedForAction", {
        /**
         * @Nullable Gets or sets the flag for action value that should appear on incoming messages for the condition or execption to apply.
         * To disable this predicate, set it to null.
         */
        get: function () {
            return this.flaggedForAction;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.flaggedForAction; }, setValue: function (updateValue) { _this.flaggedForAction = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "FromAddresses", {
        /**
         * Gets the e-mail addresses of the senders of incoming messages for the condition or exception to apply.
         * To disable this predicate, empty the list.
         */
        get: function () {
            return this.fromAddresses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "HasAttachments", {
        /**
         * Gets or sets a value indicating whether incoming messages must have attachments for the condition or exception to apply.
         */
        get: function () {
            return this.hasAttachments;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.hasAttachments; }, setValue: function (updateValue) { _this.hasAttachments = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "Importance", {
        /**
         * @Nullable Gets or sets the importance that should be stamped on incoming messages for the condition or exception to apply.
         * To disable this predicate, set it to null.
         */
        get: function () {
            return this.importance;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.importance; }, setValue: function (updateValue) { _this.importance = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "IsApprovalRequest", {
        /**
         * Gets or sets a value indicating whether incoming messages must be approval requests for the condition or exception to apply.
         */
        get: function () {
            return this.isApprovalRequest;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.isApprovalRequest; }, setValue: function (updateValue) { _this.isApprovalRequest = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "IsAutomaticForward", {
        /**
         * Gets or sets a value indicating whether incoming messages must be automatic forwards for the condition or exception to apply.
         */
        get: function () {
            return this.isAutomaticForward;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.isAutomaticForward; }, setValue: function (updateValue) { _this.isAutomaticForward = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "IsAutomaticReply", {
        /**
         * Gets or sets a value indicating whether incoming messages must be automatic replies for the condition or exception to apply.
         */
        get: function () {
            return this.isAutomaticReply;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.isAutomaticReply; }, setValue: function (updateValue) { _this.isAutomaticReply = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "IsEncrypted", {
        /**
         * Gets or sets a value indicating whether incoming messages must be S/MIME encrypted for the condition or exception to apply.
         */
        get: function () {
            return this.isEncrypted;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.isEncrypted; }, setValue: function (updateValue) { _this.isEncrypted = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "IsMeetingRequest", {
        /**
         * Gets or sets a value indicating whether incoming messages must be meeting requests for the condition or exception to apply.
         */
        get: function () {
            return this.isMeetingRequest;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.isMeetingRequest; }, setValue: function (updateValue) { _this.isMeetingRequest = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "IsMeetingResponse", {
        /**
         * Gets or sets a value indicating whether incoming messages must be meeting responses for the condition or exception to apply.
         */
        get: function () {
            return this.isMeetingResponse;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.isMeetingResponse; }, setValue: function (updateValue) { _this.isMeetingResponse = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "IsNonDeliveryReport", {
        /**
         * Gets or sets a value indicating whether incoming messages must be non-delivery reports (NDR) for the condition or exception to apply.
         */
        get: function () {
            return this.isNonDeliveryReport;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.isNonDeliveryReport; }, setValue: function (updateValue) { _this.isNonDeliveryReport = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "IsPermissionControlled", {
        /**
         * Gets or sets a value indicating whether incoming messages must be permission controlled (RMS protected) for the condition or exception to apply.
         */
        get: function () {
            return this.isPermissionControlled;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.isPermissionControlled; }, setValue: function (updateValue) { _this.isPermissionControlled = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "IsSigned", {
        /**
         * Gets or sets a value indicating whether incoming messages must be S/MIME signed for the condition or exception to apply.
         */
        get: function () {
            return this.isSigned;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.isSigned; }, setValue: function (updateValue) { _this.isSigned = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "IsVoicemail", {
        /**
         * Gets or sets a value indicating whether incoming messages must be voice mails for the condition or exception to apply.
         */
        get: function () {
            return this.isVoicemail;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.isVoicemail; }, setValue: function (updateValue) { _this.isVoicemail = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "IsReadReceipt", {
        /**
         * Gets or sets a value indicating whether incoming messages must be read receipts for the condition or exception to apply.
         */
        get: function () {
            return this.isReadReceipt;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.isReadReceipt; }, setValue: function (updateValue) { _this.isReadReceipt = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "FromConnectedAccounts", {
        /**
         * Gets the e-mail account names from which incoming messages must have been aggregated for the condition or exception to apply.
         * To disable this predicate, empty the list.
         */
        get: function () {
            return this.fromConnectedAccounts;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "ItemClasses", {
        /**
         * Gets the item classes that must be stamped on incoming messages for the condition or exception to apply.
         * To disable this predicate, empty the list.
         */
        get: function () {
            return this.itemClasses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "MessageClassifications", {
        /**
         * Gets the message classifications that must be stamped on incoming messages for the condition or exception to apply.
         * To disable this predicate, empty the list.
         */
        get: function () {
            return this.messageClassifications;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "NotSentToMe", {
        /**
         * Gets or sets a value indicating whether the owner of the mailbox must NOT be a To recipient of the incoming messages for the condition or exception to apply.
         */
        get: function () {
            return this.notSentToMe;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.notSentToMe; }, setValue: function (updateValue) { _this.notSentToMe = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "SentCcMe", {
        /**
         * Gets or sets a value indicating whether the owner of the mailbox must be a Cc recipient of incoming messages for the condition or exception to apply.
         */
        get: function () {
            return this.sentCcMe;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.sentCcMe; }, setValue: function (updateValue) { _this.sentCcMe = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "SentOnlyToMe", {
        /**
         * Gets or sets a value indicating whether the owner of the mailbox must be the only To recipient of incoming messages for the condition or exception to apply.
         */
        get: function () {
            return this.sentOnlyToMe;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.sentOnlyToMe; }, setValue: function (updateValue) { _this.sentOnlyToMe = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "SentToAddresses", {
        /**
         * Gets the e-mail addresses incoming messages must have been sent to for the condition or exception to apply.
         * To disable this predicate, empty the list.
         */
        get: function () {
            return this.sentToAddresses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "SentToMe", {
        /**
         * Gets or sets a value indicating whether the owner of the mailbox must be a To recipient of incoming messages for the condition or exception to apply.
         */
        get: function () {
            return this.sentToMe;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.sentToMe; }, setValue: function (updateValue) { _this.sentToMe = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "SentToOrCcMe", {
        /**
         * Gets or sets a value indicating whether the owner of the mailbox must be either a To or Cc recipient of incoming messages for the condition or exception to apply.
         */
        get: function () {
            return this.sentToOrCcMe;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.sentToOrCcMe; }, setValue: function (updateValue) { _this.sentToOrCcMe = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "Sensitivity", {
        /**
         * @Nullable Gets or sets the sensitivity that must be stamped on incoming messages for the condition or exception to apply.
         * To disable this predicate, set it to null.
         */
        get: function () {
            return this.sensitivity;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.sensitivity; }, setValue: function (updateValue) { _this.sensitivity = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "WithinDateRange", {
        /**
         * Gets the date range within which incoming messages must have been received for the condition or exception to apply.
         * To disable this predicate, set both its Start and End properties to null.
         */
        get: function () {
            return this.withinDateRange;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicates.prototype, "WithinSizeRange", {
        /**
         * Gets the minimum and maximum sizes incoming messages must have for the condition or exception to apply.
         * To disable this predicate, set both its MinimumSize and MaximumSize properties to null.
         */
        get: function () {
            return this.withinSizeRange;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Validates this instance.
     */
    RulePredicates.prototype.InternalValidate = function () {
        _super.prototype.InternalValidate.call(this);
        EwsUtilities.ValidateParam(this.fromAddresses, "FromAddresses");
        EwsUtilities.ValidateParam(this.sentToAddresses, "SentToAddresses");
        EwsUtilities.ValidateParam(this.withinDateRange, "WithinDateRange");
        EwsUtilities.ValidateParam(this.withinSizeRange, "WithinSizeRange");
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    RulePredicates.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.Categories:
                    this.categories.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.ContainsBodyStrings:
                    this.containsBodyStrings.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.ContainsHeaderStrings:
                    this.containsHeaderStrings.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.ContainsRecipientStrings:
                    this.containsRecipientStrings.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.ContainsSenderStrings:
                    this.containsSenderStrings.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.ContainsSubjectOrBodyStrings:
                    this.containsSubjectOrBodyStrings.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.ContainsSubjectStrings:
                    this.containsSubjectStrings.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.FlaggedForAction:
                    this.flaggedForAction = FlaggedForAction[jsObject[key]];
                    break;
                case XmlElementNames.FromAddresses:
                    this.fromAddresses.CreateFromXmlJsObjectCollection(jsObject[key][XmlElementNames.Address], service);
                    break;
                case XmlElementNames.FromConnectedAccounts:
                    this.fromConnectedAccounts.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.HasAttachments:
                    this.hasAttachments = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.Importance:
                    this.importance = Importance[jsObject[key]];
                    break;
                case XmlElementNames.IsApprovalRequest:
                    this.isApprovalRequest = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsAutomaticForward:
                    this.isAutomaticForward = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsAutomaticReply:
                    this.isAutomaticReply = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsEncrypted:
                    this.isEncrypted = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsMeetingRequest:
                    this.isMeetingRequest = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsMeetingResponse:
                    this.isMeetingResponse = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsNDR:
                    this.isNonDeliveryReport = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsPermissionControlled:
                    this.isPermissionControlled = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsSigned:
                    this.isSigned = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsVoicemail:
                    this.isVoicemail = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.IsReadReceipt:
                    this.isReadReceipt = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.ItemClasses:
                    this.itemClasses.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.MessageClassifications:
                    this.messageClassifications.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.NotSentToMe:
                    this.notSentToMe = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.SentCcMe:
                    this.sentCcMe = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.SentOnlyToMe:
                    this.sentOnlyToMe = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.SentToAddresses:
                    this.sentToAddresses.CreateFromXmlJsObjectCollection(jsObject[key][XmlElementNames.Address], service);
                    break;
                case XmlElementNames.SentToMe:
                    this.sentToMe = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.SentToOrCcMe:
                    this.sentToOrCcMe = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.Sensitivity:
                    this.sensitivity = Sensitivity[jsObject[key]];
                    break;
                case XmlElementNames.WithinDateRange:
                    this.withinDateRange.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.WithinSizeRange:
                    this.withinSizeRange.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    RulePredicates.prototype.WriteElementsToXml = function (writer) {
        if (this.Categories.Count > 0) {
            this.Categories.WriteToXml(writer, XmlElementNames.Categories);
        }
        if (this.ContainsBodyStrings.Count > 0) {
            this.ContainsBodyStrings.WriteToXml(writer, XmlElementNames.ContainsBodyStrings);
        }
        if (this.ContainsHeaderStrings.Count > 0) {
            this.ContainsHeaderStrings.WriteToXml(writer, XmlElementNames.ContainsHeaderStrings);
        }
        if (this.ContainsRecipientStrings.Count > 0) {
            this.ContainsRecipientStrings.WriteToXml(writer, XmlElementNames.ContainsRecipientStrings);
        }
        if (this.ContainsSenderStrings.Count > 0) {
            this.ContainsSenderStrings.WriteToXml(writer, XmlElementNames.ContainsSenderStrings);
        }
        if (this.ContainsSubjectOrBodyStrings.Count > 0) {
            this.ContainsSubjectOrBodyStrings.WriteToXml(writer, XmlElementNames.ContainsSubjectOrBodyStrings);
        }
        if (this.ContainsSubjectStrings.Count > 0) {
            this.ContainsSubjectStrings.WriteToXml(writer, XmlElementNames.ContainsSubjectStrings);
        }
        if (this.FlaggedForAction) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.FlaggedForAction, FlaggedForAction[this.FlaggedForAction]);
        }
        if (this.FromAddresses.Count > 0) {
            this.FromAddresses.WriteToXml(writer, XmlElementNames.FromAddresses);
        }
        if (this.FromConnectedAccounts.Count > 0) {
            this.FromConnectedAccounts.WriteToXml(writer, XmlElementNames.FromConnectedAccounts);
        }
        if (this.HasAttachments != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.HasAttachments, this.HasAttachments);
        }
        if (this.Importance) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Importance, Importance[this.Importance]);
        }
        if (this.IsApprovalRequest != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsApprovalRequest, this.IsApprovalRequest);
        }
        if (this.IsAutomaticForward != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsAutomaticForward, this.IsAutomaticForward);
        }
        if (this.IsAutomaticReply != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsAutomaticReply, this.IsAutomaticReply);
        }
        if (this.IsEncrypted != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsEncrypted, this.IsEncrypted);
        }
        if (this.IsMeetingRequest != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsMeetingRequest, this.IsMeetingRequest);
        }
        if (this.IsMeetingResponse != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsMeetingResponse, this.IsMeetingResponse);
        }
        if (this.IsNonDeliveryReport != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsNDR, this.IsNonDeliveryReport);
        }
        if (this.IsPermissionControlled != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsPermissionControlled, this.IsPermissionControlled);
        }
        if (this.isReadReceipt != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsReadReceipt, this.IsReadReceipt);
        }
        if (this.IsSigned != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsSigned, this.IsSigned);
        }
        if (this.IsVoicemail != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsVoicemail, this.IsVoicemail);
        }
        if (this.ItemClasses.Count > 0) {
            this.ItemClasses.WriteToXml(writer, XmlElementNames.ItemClasses);
        }
        if (this.MessageClassifications.Count > 0) {
            this.MessageClassifications.WriteToXml(writer, XmlElementNames.MessageClassifications);
        }
        if (this.NotSentToMe != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.NotSentToMe, this.NotSentToMe);
        }
        if (this.SentCcMe != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.SentCcMe, this.SentCcMe);
        }
        if (this.SentOnlyToMe != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.SentOnlyToMe, this.SentOnlyToMe);
        }
        if (this.SentToAddresses.Count > 0) {
            this.SentToAddresses.WriteToXml(writer, XmlElementNames.SentToAddresses);
        }
        if (this.SentToMe != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.SentToMe, this.SentToMe);
        }
        if (this.SentToOrCcMe != false) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.SentToOrCcMe, this.SentToOrCcMe);
        }
        if (this.Sensitivity) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Sensitivity, Sensitivity[this.Sensitivity]);
        }
        if (this.WithinDateRange.Start || this.WithinDateRange.End) {
            this.WithinDateRange.WriteToXml(writer, XmlElementNames.WithinDateRange);
        }
        if (this.WithinSizeRange.MaximumSize || this.WithinSizeRange.MinimumSize) {
            this.WithinSizeRange.WriteToXml(writer, XmlElementNames.WithinSizeRange);
        }
    };
    return RulePredicates;
}(ComplexProperty));
exports.RulePredicates = RulePredicates;
/**
 * Represents the minimum and maximum size of a message.
 *
 * @sealed
 */
var RulePredicateSizeRange = (function (_super) {
    __extends(RulePredicateSizeRange, _super);
    /**
     * @internal Initializes a new instance of the **RulePredicateSizeRange** class.
     */
    function RulePredicateSizeRange() {
        var _this = _super.call(this) || this;
        /**
         * Minimum Size.
         */
        _this.minimumSize = null; //Nullable
        /**
         * Mamixmum Size.
         */
        _this.maximumSize = null; //Nullable
        return _this;
    }
    Object.defineProperty(RulePredicateSizeRange.prototype, "MinimumSize", {
        /**
         * @Nullable Gets or sets the minimum size, in kilobytes.
         * If MinimumSize is set to null, no minimum size applies.
         */
        get: function () {
            return this.minimumSize;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.minimumSize; }, setValue: function (updateValue) { _this.minimumSize = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RulePredicateSizeRange.prototype, "MaximumSize", {
        /**
         * @Nullable Gets or sets the maximum size, in kilobytes.
         * If MaximumSize is set to null, no maximum size applies.
         */
        get: function () {
            return this.maximumSize;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.maximumSize; }, setValue: function (updateValue) { _this.maximumSize = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Validates this instance.
     */
    RulePredicateSizeRange.prototype.InternalValidate = function () {
        _super.prototype.InternalValidate.call(this);
        if (this.minimumSize &&
            this.maximumSize &&
            this.minimumSize > this.maximumSize) {
            throw new ServiceValidationException("MinimumSize cannot be larger than MaximumSize.");
        }
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    RulePredicateSizeRange.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.MinimumSize:
                    this.minimumSize = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.MaximumSize:
                    this.maximumSize = Convert.toNumber(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    RulePredicateSizeRange.prototype.WriteElementsToXml = function (writer) {
        if (this.MinimumSize) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.MinimumSize, this.MinimumSize);
        }
        if (this.MaximumSize) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.MaximumSize, this.MaximumSize);
        }
    };
    return RulePredicateSizeRange;
}(ComplexProperty));
exports.RulePredicateSizeRange = RulePredicateSizeRange;
var SearchFolderParameters = (function (_super) {
    __extends(SearchFolderParameters, _super);
    function SearchFolderParameters() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SearchFolderParameters.prototype.InternalToJson = function (service) { throw new Error("SearchFolderParameters.ts - InternalToJson : Not implemented."); };
    SearchFolderParameters.prototype.LoadFromJson = function (jsonProperty, service) { throw new Error("SearchFolderParameters.ts - LoadFromJson : Not implemented."); };
    SearchFolderParameters.prototype.PropertyChanged = function (complexProperty) { throw new Error("SearchFolderParameters.ts - PropertyChanged : Not implemented."); };
    /**@internal */
    SearchFolderParameters.prototype.ReadAttributesFromXmlJsObject = function (reader) { throw new Error("SearchFolderParameters.ts - ReadAttributesFromXml : Not implemented."); };
    /**@internal */
    SearchFolderParameters.prototype.ReadElementsFromXmlJsObject = function (reader) { throw new Error("SearchFolderParameters.ts - TryReadElementFromXmlJsObject : Not implemented."); };
    SearchFolderParameters.prototype.Validate = function () { throw new Error("SearchFolderParameters.ts - Validate : Not implemented."); };
    /**@internal */
    SearchFolderParameters.prototype.WriteAttributesToXml = function (writer) { throw new Error("SearchFolderParameters.ts - WriteAttributesToXml : Not implemented."); };
    /**@internal */
    SearchFolderParameters.prototype.WriteElementsToXml = function (writer) { throw new Error("SearchFolderParameters.ts - WriteElementsToXml : Not implemented."); };
    return SearchFolderParameters;
}(ComplexProperty));
exports.SearchFolderParameters = SearchFolderParameters;
//}
var SetClientExtensionAction = (function (_super) {
    __extends(SetClientExtensionAction, _super);
    function SetClientExtensionAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**@internal */
    SetClientExtensionAction.prototype.WriteAttributesToXml = function (writer) { throw new Error("SetClientExtensionAction.ts - WriteAttributesToXml : Not implemented."); };
    /**@internal */
    SetClientExtensionAction.prototype.WriteElementsToXml = function (writer) { throw new Error("SetClientExtensionAction.ts - WriteElementsToXml : Not implemented."); };
    return SetClientExtensionAction;
}(ComplexProperty));
exports.SetClientExtensionAction = SetClientExtensionAction;
//}
/**
 * Represents a list of strings.
 *
 * @sealed
 */
var StringList = (function (_super) {
    __extends(StringList, _super);
    function StringList(stringOrItemXmlElementName) {
        if (stringOrItemXmlElementName === void 0) { stringOrItemXmlElementName = null; }
        var _this = _super.call(this) || this;
        _this.items = [];
        _this.itemXmlElementName = XmlElementNames.String;
        if (stringOrItemXmlElementName !== null) {
            if (typeof stringOrItemXmlElementName === 'string') {
                _this.itemXmlElementName = stringOrItemXmlElementName;
            }
            else {
                _this.AddRange(stringOrItemXmlElementName);
            }
        }
        return _this;
    }
    Object.defineProperty(StringList.prototype, "Count", {
        /**
         * Gets the number of strings in the list.
         */
        get: function () {
            return this.items.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets or sets the string at the specified index.
     *
     * @param   {number}    index   The index of the string to get or set.
     * @return  {string}    The string at the specified index.
     */
    StringList.prototype._getItem = function (index) {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index - " + Strings.IndexIsOutOfRange);
        }
        return this.items[index];
    };
    /**
     * Gets or sets the string at the specified index.
     *
     * @param   {number}    index   The index of the string to get or set.
     * @return  {string}    The string at the specified index.
     */
    StringList.prototype._setItem = function (index, value) {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index - " + Strings.IndexIsOutOfRange);
        }
        if (this.items[index] !== value) {
            this.items[index] = value;
            this.Changed();
        }
    };
    /**
     * Adds a string to the list.
     *
     * @param   {string}   s   The string to add.
     */
    StringList.prototype.Add = function (s) {
        this.items.push(s);
        this.Changed();
    };
    /**
     * Adds multiple strings to the list.
     *
     * @param   {string[]}   strings   The strings to add.
     */
    StringList.prototype.AddRange = function (strings) {
        var changed = false;
        for (var _a = 0, strings_1 = strings; _a < strings_1.length; _a++) {
            var s = strings_1[_a];
            if (!this.Contains(s)) {
                this.items.push(s);
                changed = true;
            }
        }
        if (changed) {
            this.Changed();
        }
    };
    /**
     * Clears the list.
     */
    StringList.prototype.Clear = function () {
        this.items.splice(0);
        this.Changed();
    };
    /**
     * Determines whether the list contains a specific string.
     *
     * @param   {string}    s   The string to check the presence of.
     * @return  {boolean}   True if s is present in the list, false otherwise.
     */
    StringList.prototype.Contains = function (s) { return this.items.indexOf(s) >= 0; };
    /**
     * @internal Loads from XMLJsObject collection to create a new collection item.
     *
     * @interface   IJsonCollectionDeserializer
     *
     * @param   {any}               jsObjectCollection   The json collection.
     * @param   {ExchangeService}   service          The service.
     */
    StringList.prototype.CreateFromXmlJsObjectCollection = function (jsObjectCollection, service) {
        var collection = jsObjectCollection[this.itemXmlElementName];
        if (!ArrayHelper.isArray(collection)) {
            collection = [collection];
        }
        for (var _a = 0, collection_1 = collection; _a < collection_1.length; _a++) {
            var item = collection_1[_a];
            this.Add(item);
        }
    };
    StringList.prototype.Equals = function (obj) { throw new Error("StringList.ts - Equals : Not implemented."); };
    /**
     *  Returns an enumerator that iterates through the collection. this case this.items
     */
    StringList.prototype.GetEnumerator = function () {
        return this.items;
    };
    StringList.prototype.GetHashCode = function () { throw new Error("StringList.ts - GetHashCode : Not implemented."); };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    StringList.prototype.LoadFromXmlJsObject = function (jsObjectCollection, service) {
        this.CreateFromXmlJsObjectCollection(jsObjectCollection, service);
    };
    /**
     * Removes a string from the list.
     *
     * @param   {string}   s   The string to remove.
     * @return  {boolean}       True is s was removed, false otherwise.
     */
    StringList.prototype.Remove = function (s) {
        var result = ArrayHelper.RemoveEntry(this.items, s);
        if (result) {
            this.Changed();
        }
        return result;
    };
    /**
     * Removes the string at the specified position from the list.
     *
     * @param   {number}   index   The index of the string to remove.
     */
    StringList.prototype.RemoveAt = function (index) {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index - " + Strings.IndexIsOutOfRange);
        }
        this.items.splice(index, 1);
        this.Changed();
    };
    /**
     * Generates a string representation of all the items in the list.
     *
     * @return  {string}      A comma-separated list of the strings present in the list.
     */
    StringList.prototype.ToString = function () {
        return this.items.join(",");
    };
    /**
     * @internal Loads from XMLJsObject collection to update collection Items.
     *
     * @interface   IJsonCollectionDeserializer
     *
     * @param   {any}               jsObjectCollection   The XMLJsObject collection.
     * @param   {ExchangeService}   service          The service.
     */
    StringList.prototype.UpdateFromXmlJsObjectCollection = function (jsObjectCollection, service) {
        throw new Error("StringList.ts - UpdateFromXmlJsObjectCollection : Not implemented.");
    };
    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    StringList.prototype.WriteElementsToXml = function (writer) {
        for (var _a = 0, _b = this.items; _a < _b.length; _a++) {
            var item = _b[_a];
            writer.WriteStartElement(XmlNamespace.Types, this.itemXmlElementName);
            writer.WriteValue(item, this.itemXmlElementName);
            writer.WriteEndElement();
        }
    };
    return StringList;
}(ComplexProperty));
exports.StringList = StringList;
/**
 * @internal Represents a change of time for a time zone.
 * @sealed
 */
var TimeChange = (function (_super) {
    __extends(TimeChange, _super);
    function TimeChange(offset, time) {
        if (offset === void 0) { offset = null; }
        if (time === void 0) { time = null; }
        var _this = _super.call(this) || this;
        _this.timeZoneName = null;
        _this.offset = null;
        _this.time = null;
        _this.absoluteDate = null;
        _this.recurrence = null;
        if (offset) {
            _this.offset = offset;
        }
        if (time) {
            _this.time = time;
        }
        return _this;
    }
    Object.defineProperty(TimeChange.prototype, "TimeZoneName", {
        /**
         * Gets or sets the name of the associated time zone.
         */
        get: function () {
            return this.timeZoneName;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.timeZoneName; }, setValue: function (fieldValue) { _this.timeZoneName = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeChange.prototype, "Offset", {
        /**
         * Gets or sets the offset since the beginning of the year when the change occurs.
         */
        get: function () {
            return this.offset;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.offset; }, setValue: function (fieldValue) { _this.offset = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeChange.prototype, "Time", {
        /**
         * Gets or sets the time at which the change occurs.
         */
        get: function () {
            return this.time;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.time; }, setValue: function (fieldValue) { _this.time = fieldValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeChange.prototype, "AbsoluteDate", {
        /**
         * Gets or sets the absolute date at which the change occurs. AbsoluteDate and Recurrence are mutually exclusive; setting one resets the other.
         */
        get: function () {
            return this.absoluteDate;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.absoluteDate; }, setValue: function (fieldValue) { _this.absoluteDate = fieldValue; } }, value);
            if (this.absoluteDate != null) {
                this.recurrence = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeChange.prototype, "Recurrence", {
        /**
         * Gets or sets the recurrence pattern defining when the change occurs. Recurrence and AbsoluteDate are mutually exclusive; setting one resets the other.
         */
        get: function () {
            return this.recurrence;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.recurrence; }, setValue: function (fieldValue) { _this.recurrence = fieldValue; } }, value);
            if (this.recurrence != null) {
                this.absoluteDate = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    TimeChange.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.Offset:
                    this.offset = EwsUtilities.XSDurationToTimeSpan(jsonProperty[key]);
                case XmlElementNames.RelativeYearlyRecurrence:
                    this.Recurrence = new TimeChangeRecurrence();
                    this.Recurrence.LoadFromXmlJsObject(jsonProperty[key], service);
                case XmlElementNames.AbsoluteDate:
                    var dateTime = DateTime.Parse(jsonProperty[key]);
                    // TODO: BUG
                    this.absoluteDate = new DateTime(dateTime.ToUniversalTime().TotalMilliSeconds, DateTimeKind.Unspecified);
                case XmlElementNames.Time:
                    this.time = new Time(DateTime.Parse(jsonProperty[key]));
                default:
            }
        }
    };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    TimeChange.prototype.WriteAttributesToXml = function (writer) {
        writer.WriteAttributeValue(XmlAttributeNames.TimeZoneName, this.TimeZoneName);
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    TimeChange.prototype.WriteElementsToXml = function (writer) {
        if (this.Offset) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Offset, EwsUtilities.TimeSpanToXSDuration(this.Offset));
        }
        if (this.Recurrence != null) {
            this.Recurrence.WriteToXml(writer, XmlElementNames.RelativeYearlyRecurrence);
        }
        if (this.AbsoluteDate) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.AbsoluteDate, EwsUtilities.DateTimeToXSDate(new DateTime(this.AbsoluteDate.TotalMilliSeconds, DateTimeKind.Unspecified)));
        }
        if (this.Time != null) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Time, this.Time.ToXSTime());
        }
    };
    return TimeChange;
}(ComplexProperty));
exports.TimeChange = TimeChange;
/**
 * @internal Represents a recurrence pattern for a time change in a time zone.
 * @sealed
 */
var TimeChangeRecurrence = (function (_super) {
    __extends(TimeChangeRecurrence, _super);
    function TimeChangeRecurrence(dayOfTheWeekIndex, dayOfTheWeek, month) {
        if (dayOfTheWeekIndex === void 0) { dayOfTheWeekIndex = null; }
        if (dayOfTheWeek === void 0) { dayOfTheWeek = null; }
        if (month === void 0) { month = null; }
        var _this = _super.call(this) || this;
        _this.dayOfTheWeekIndex = dayOfTheWeekIndex;
        _this.dayOfTheWeek = dayOfTheWeek;
        _this.month = month;
        return _this;
    }
    Object.defineProperty(TimeChangeRecurrence.prototype, "DayOfTheWeekIndex", {
        /**
         * Gets or sets the index of the day in the month at which the time change occurs.
         */
        get: function () {
            return this.dayOfTheWeekIndex;
        },
        set: function (value) {
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeChangeRecurrence.prototype, "DayOfTheWeek", {
        /**
         * Gets or sets the day of the week the time change occurs.
         */
        get: function () {
            return this.dayOfTheWeek;
        },
        set: function (value) {
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeChangeRecurrence.prototype, "Month", {
        /**
         * Gets or sets the month the time change occurs.
         */
        get: function () {
            return this.month;
        },
        set: function (value) {
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    TimeChangeRecurrence.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.DaysOfWeek:
                    this.dayOfTheWeek = DayOfTheWeek[jsonProperty[key]];
                case XmlElementNames.DayOfWeekIndex:
                    this.dayOfTheWeekIndex = DayOfTheWeekIndex[jsonProperty[key]];
                case XmlElementNames.Month:
                    this.month = Month[jsonProperty[key]];
                default:
            }
        }
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    TimeChangeRecurrence.prototype.WriteElementsToXml = function (writer) {
        if (this.DayOfTheWeek) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DaysOfWeek, this.DayOfTheWeek);
        }
        if (this.dayOfTheWeekIndex) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DayOfWeekIndex, this.DayOfTheWeekIndex);
        }
        if (this.Month) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Month, this.Month);
        }
    };
    return TimeChangeRecurrence;
}(ComplexProperty));
exports.TimeChangeRecurrence = TimeChangeRecurrence;
/**
 * Represents the body part of an item that is unique to the conversation the item is part of.
 */
var UniqueBody = (function (_super) {
    __extends(UniqueBody, _super);
    /**
     * Initializes a new instance of the **UniqueBody** class.
     */
    function UniqueBody() {
        var _this = _super.call(this) || this;
        _this.bodyType = BodyType.HTML;
        _this.text = null;
        _this.isTruncated = false;
        return _this;
    }
    Object.defineProperty(UniqueBody.prototype, "BodyType", {
        /**
         * Gets the type of the normalized body's text.
         */
        get: function () {
            return this.bodyType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UniqueBody.prototype, "Text", {
        /**
         * Gets the text of the normalized body.
         */
        get: function () {
            return this.text;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UniqueBody.prototype, "IsTruncated", {
        /**
         * Gets whether the body is truncated.
         */
        get: function () {
            return this.isTruncated;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    UniqueBody.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlAttributeNames.BodyType:
                    this.bodyType = BodyType[jsObject[key]];
                    break;
                case XmlAttributeNames.IsTruncated:
                    this.isTruncated = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.UniqueBody:
                    this.text = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * Returns a **String** that represents the current **Object**.
     *
     * @return  {string}      A **String** that represents the current **Object**.
     */
    UniqueBody.prototype.ToString = function () { return this.Text || StringHelper.Empty; };
    UniqueBody.prototype.toString = function () { return this.ToString(); };
    /**
     * @internal Writes attributes to XML.
     *
     * @param {EwsServiceXmlWriter} writer  The writer.
     */
    UniqueBody.prototype.WriteAttributesToXml = function (writer) {
        writer.WriteAttributeValue(XmlAttributeNames.BodyType, this.BodyType);
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param {EwsServiceXmlWriter} writer  The writer.
     */
    UniqueBody.prototype.WriteElementsToXml = function (writer) {
        if (!StringHelper.IsNullOrEmpty(this.Text)) {
            writer.WriteValue(this.Text, XmlElementNames.UniqueBody);
        }
    };
    return UniqueBody;
}(ComplexProperty));
exports.UniqueBody = UniqueBody;
/**
 * Represents a user configuration's Dictionary property.
 *
 * @sealed
 */
var UserConfigurationDictionary = (function (_super) {
    __extends(UserConfigurationDictionary, _super);
    /**
     * @internal Initializes a new instance of **UserConfigurationDictionary** class.
     */
    function UserConfigurationDictionary() {
        var _this = _super.call(this) || this;
        _this.dictionary = null;
        _this.isDirty = false;
        _this.dictionary = new Dictionary(UserConfigurationDictionary._dictionaryKeyPicker);
        return _this;
    }
    Object.defineProperty(UserConfigurationDictionary.prototype, "Count", {
        /**
         * Gets the number of elements in the user configuration dictionary.
         */
        get: function () {
            return this.dictionary.Count;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserConfigurationDictionary.prototype, "IsDirty", {
        /**
         * @internal Gets or sets the isDirty flag.
         */
        get: function () {
            return this.isDirty;
        },
        set: function (value) {
            this.isDirty = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets or sets the element with the specified key.
     *
     * @param   {string | DateTime | boolean | number}                          key   The key of the element to get or set.
     * @return  {DateTime | string | number | boolean | string[] | number[]}    The element with the specified key.
     */
    UserConfigurationDictionary.prototype._getItem = function (key) {
        return this.dictionary.get(key);
    };
    /**
     * Gets or sets the element with the specified key.
     *
     * @param   {string | DateTime | boolean | number}                          key     The key of the element to get or set.
     * @param  {DateTime | string | number | boolean | string[] | number[]}     value    The element value to update at specified key.
     */
    UserConfigurationDictionary.prototype._setItem = function (key, value) {
        this.ValidateEntry(key, value);
        this.dictionary.set(key, value);
        this.Changed();
    };
    /**
     * Adds an element with the provided key and value to the user configuration dictionary.
     *
     * @param   {string | DateTime | boolean | number}                          key     The object to use as the key of the element to add. **Restrict usage of byteArray or complex type for key, consider using string and number only**.
     * @param   {DateTime | string | number | boolean | string[] | number[]}    value   The object to use as the value of the element to add.
     */
    UserConfigurationDictionary.prototype.Add = function (key, value) {
        this.ValidateEntry(key, value);
        this.dictionary.Add(key, value);
        this.Changed();
    };
    /**
     * @internal Instance was changed.
     */
    UserConfigurationDictionary.prototype.Changed = function () {
        _super.prototype.Changed.call(this);
        this.isDirty = true;
    };
    /**
     * Removes all items from the user configuration dictionary.
     */
    UserConfigurationDictionary.prototype.Clear = function () {
        if (this.dictionary.Count != 0) {
            this.dictionary.clear();
            this.Changed();
        }
    };
    /**
     * Constructs a dictionary object (key or entry value) from the specified type and string list.
     *
     * @param   {UserConfigurationDictionaryObjectType}     type      Object type to construct.
     * @param   {string[]}                                  value     Value of the dictionary object as a string list
     * @param   {ExchangeService}                           service   The service.
     * @return  {any}                                       Dictionary object.
     */
    UserConfigurationDictionary.prototype.ConstructObject = function (type, value /*System.Collections.Generic.List<string>*/, service) {
        EwsLogging.Assert(value != null, "UserConfigurationDictionary.ConstructObject", "value is null");
        EwsLogging.Assert((value.length == 1 || type == UserConfigurationDictionaryObjectType.StringArray), "UserConfigurationDictionary.ConstructObject", "value is array but type is not StringArray");
        var dictionaryObject = null;
        switch (type) {
            case UserConfigurationDictionaryObjectType.Boolean:
                dictionaryObject = Convert.toBool(value[0]);
                break;
            case UserConfigurationDictionaryObjectType.Byte:
                dictionaryObject = Convert.toNumber(value[0]); //info: byte is number, no Byte type in js 
                break;
            case UserConfigurationDictionaryObjectType.ByteArray:
                dictionaryObject = value[0]; //Convert.FromBase64String(value[0]); //info: ByteArray is base64 string here, avoiding binary value here
                break;
            case UserConfigurationDictionaryObjectType.DateTime:
                var dateTime = service.ConvertUniversalDateTimeStringToLocalDateTime(value[0]);
                if (dateTime) {
                    dictionaryObject = dateTime;
                }
                else {
                    EwsLogging.Assert(false, "UserConfigurationDictionary.ConstructObject", "DateTime is null");
                }
                break;
            case UserConfigurationDictionaryObjectType.Integer32:
                dictionaryObject = Convert.toNumber(value[0]);
                break;
            case UserConfigurationDictionaryObjectType.Integer64:
                dictionaryObject = Convert.toNumber(value[0]);
                break;
            case UserConfigurationDictionaryObjectType.String:
                dictionaryObject = value[0];
                break;
            case UserConfigurationDictionaryObjectType.StringArray:
                dictionaryObject = value;
                break;
            case UserConfigurationDictionaryObjectType.UnsignedInteger32:
                dictionaryObject = Convert.toNumber(value[0]);
                break;
            case UserConfigurationDictionaryObjectType.UnsignedInteger64:
                dictionaryObject = Convert.toNumber(value[0]);
                break;
            default:
                EwsLogging.Assert(false, "UserConfigurationDictionary.ConstructObject", "Type not recognized: " + UserConfigurationDictionaryObjectType[type]);
                break;
        }
        return dictionaryObject;
    };
    /**
     * Determines whether the user configuration dictionary contains an element with the specified key.
     *
     * @param   {any}   key     The key to locate in the user configuration dictionary.
     * @return  {boolean}       true if the user configuration dictionary contains an element with the key; otherwise false.
     */
    UserConfigurationDictionary.prototype.ContainsKey = function (key) {
        return this.dictionary.containsKey(key);
    };
    /**
     * @internal Loads from XMLJsObject collection to create a new collection item.
     *
     * @interface   IJsonCollectionDeserializer
     *
     * @param   {any}               jsObjectCollection   The json collection.
     * @param   {ExchangeService}   service          The service.
     */
    UserConfigurationDictionary.prototype.CreateFromXMLJsObjectCollection = function (jsObjectCollection, service) {
        var collection = EwsServiceJsonReader.ReadAsArray(jsObjectCollection, XmlElementNames.DictionaryEntry);
        for (var _a = 0, collection_2 = collection; _a < collection_2.length; _a++) {
            var jsonEntry = collection_2[_a];
            var parsedKey = this.GetDictionaryObject(jsonEntry[XmlElementNames.DictionaryKey], service);
            var parsedValue = this.GetDictionaryObject(jsonEntry[XmlElementNames.DictionaryValue], service);
            this.dictionary.addUpdate(parsedKey, parsedValue);
        }
    };
    /**
     * Gets the dictionary object.
     *
     * @param   {any}               jsonObject   The json object.
     * @param   {ExchangeService}   service      The service.
     * @return  {any}               the dictionary object
     */
    UserConfigurationDictionary.prototype.GetDictionaryObject = function (jsonObject, service) {
        if (jsonObject == null) {
            return null;
        }
        var type = UserConfigurationDictionary.GetObjectType(jsonObject[XmlElementNames.Type]);
        var values = this.GetObjectValue(EwsServiceJsonReader.ReadAsArray(jsonObject, XmlElementNames.Value));
        return this.ConstructObject(type, values, service);
    };
    UserConfigurationDictionary.prototype.GetEnumerator = function () { return this.dictionary; };
    /**
     * Gets the type of the object.
     *
     * @param   {string}   type   The type.
     * @return  {UserConfigurationDictionaryObjectType}     UserConfigurationDictionaryObjectType for the string value
     */
    UserConfigurationDictionary.GetObjectType = function (type) {
        return UserConfigurationDictionaryObjectType[type];
    };
    /**
     * Gets the object value.
     *
     * @param   {any[]}   valueArray   The value array.
     * @return  {string[]}  string array from object Array
     */
    UserConfigurationDictionary.prototype.GetObjectValue = function (valueArray) {
        var stringArray = [];
        for (var _a = 0, valueArray_1 = valueArray; _a < valueArray_1.length; _a++) {
            var value = valueArray_1[_a];
            stringArray.push(value);
        }
        return stringArray;
    };
    /**
     * Gets the type code.
     *
     * @param   {ExchangeServiceBase}                                   service                The service.
     * @param   {any}                                                   dictionaryObject       The dictionary object.
     * @param   {IRefParam<UserConfigurationDictionaryObjectType>}      dictionaryObjectType   Type of the dictionary object.
     * @param   {IRefParam<string>}                                     valueAsString          The value as string.
     */
    UserConfigurationDictionary.GetTypeCode = function (service, dictionaryObject, dictionaryObjectType, valueAsString) {
        // Handle all other types by TypeCode
        var typeofDictionaryObject = typeof dictionaryObject;
        if (typeofDictionaryObject === 'string') {
            dictionaryObjectType.setValue(UserConfigurationDictionaryObjectType.String);
            valueAsString.setValue(dictionaryObject);
        }
        else if (typeofDictionaryObject === 'boolean') {
            dictionaryObjectType.setValue(UserConfigurationDictionaryObjectType.Boolean);
            valueAsString.setValue(EwsUtilities.BoolToXSBool(dictionaryObject));
        }
        else if (typeofDictionaryObject === 'number') {
            var num = Convert.toNumber(dictionaryObject);
            dictionaryObjectType.setValue(UserConfigurationDictionaryObjectType.Integer32);
            if (num >= 0 && num <= 255) {
                dictionaryObjectType.setValue(UserConfigurationDictionaryObjectType.Byte);
            }
            else if (num < 0 && num < -2147483648) {
                dictionaryObjectType.setValue(UserConfigurationDictionaryObjectType.Integer64);
            }
            else if (num >= 0 && num > 2147483647) {
                dictionaryObjectType.setValue(UserConfigurationDictionaryObjectType.UnsignedInteger64);
            }
            else if (num >= 0 && num <= 2147483647) {
                dictionaryObjectType.setValue(UserConfigurationDictionaryObjectType.UnsignedInteger32);
            }
            valueAsString.setValue(num.toString());
        }
        else if (dictionaryObject instanceof DateTime) {
            dictionaryObjectType.setValue(UserConfigurationDictionaryObjectType.DateTime);
            valueAsString.setValue(service.ConvertDateTimeToUniversalDateTimeString(dictionaryObject));
        }
        else {
            EwsLogging.Assert(false, "UserConfigurationDictionary.WriteObjectValueToXml", "Unsupported type: " + typeof dictionaryObject);
        }
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    UserConfigurationDictionary.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        this.CreateFromXMLJsObjectCollection(jsObject, service);
    };
    /**
     * Removes the element with the specified key from the user configuration dictionary.
     *
     * @param   {key}   key     The key of the element to remove.
     * @return  {boolean}       true if the element is successfully removed; otherwise false.
     */
    UserConfigurationDictionary.prototype.Remove = function (key) {
        var isRemoved = this.dictionary.remove(key);
        if (isRemoved) {
            this.Changed();
        }
        return isRemoved;
    };
    /**
     * Gets the value associated with the specified key.
     *
     * @param   {any}   key     The key whose value to get.
     * @param   {any}   value   When this method returns, the value associated with the specified key, if the key is found; otherwise, null.
     * @return  {boolean}       true if the user configuration dictionary contains the key; otherwise false.
     */
    UserConfigurationDictionary.prototype.TryGetValue = function (key, value) {
        return this.dictionary.tryGetValue(key, value);
    };
    /**
     * @internal Loads from XMLJsObject collection to update collection Items.
     *
     * @interface   IJsonCollectionDeserializer
     *
     * @param   {any}               jsObjectCollection   The XMLJsObject collection.
     * @param   {ExchangeService}   service          The service.
     */
    UserConfigurationDictionary.prototype.UpdateFromXMLJsObjectCollection = function (jsObjectCollection, service) { throw new Error("UserConfigurationDictionary.ts - UpdateFromJsonCollection : Not implemented."); };
    /**
     * Validate the array object.
     *
     * @param   {Array<any>}   dictionaryObjectAsArray   Object to validate
     */
    UserConfigurationDictionary.prototype.ValidateArrayObject = function (dictionaryObjectAsArray /*System.Array*/) {
        // // This logic is based on Microsoft.Exchange.Data.Storage.ConfigurationDictionary.CheckElementSupportedType().
        // if (dictionaryObjectAsArray as string[]) {
        //     if (dictionaryObjectAsArray.Length > 0) {
        //         for (let arrayElement of dictionaryObjectAsArray) {
        //             if (arrayElement == null) {
        //                 throw new ServiceLocalException(Strings.NullStringArrayElementInvalid);
        //             }
        //         }
        //     }
        //     else {
        //         throw new ServiceLocalException(Strings.ZeroLengthArrayInvalid);
        //     }
        // }
        // else if (dictionaryObjectAsArray as byte[]) {
        //     if (dictionaryObjectAsArray.Length <= 0) {
        //         throw new ServiceLocalException(Strings.ZeroLengthArrayInvalid);
        //     }
        // }
        // else {
        //     throw new ServiceLocalException(string.Format(Strings.ObjectTypeNotSupported, dictionaryObjectAsArray.GetType()));
        // }
        // This logic is based on Microsoft.Exchange.Data.Storage.ConfigurationDictionary.CheckElementSupportedType().
        if (dictionaryObjectAsArray.length > 0) {
            var firstNonEmptyElement = ArrayHelper.Find(dictionaryObjectAsArray, function (item) { return item != null && typeof item !== 'undefined'; });
            if (!firstNonEmptyElement) {
                throw new ServiceLocalException(Strings.NullStringArrayElementInvalid);
            }
            var arrayType = typeof firstNonEmptyElement;
            if (arrayType !== 'string' && arrayType !== 'number') {
                throw new ServiceLocalException(StringHelper.Format(Strings.ObjectTypeNotSupported, arrayType));
            }
            for (var _a = 0, dictionaryObjectAsArray_1 = dictionaryObjectAsArray; _a < dictionaryObjectAsArray_1.length; _a++) {
                var arrayElement = dictionaryObjectAsArray_1[_a];
                var elementType = typeof arrayElement;
                if (arrayElement && elementType != arrayType) {
                    throw new ServiceLocalException(StringHelper.Format(Strings.ObjectTypeNotSupported, "<" + elementType + "," + arrayType + ">"));
                }
                if (arrayType === 'string' && arrayElement == null) {
                    throw new ServiceLocalException(Strings.NullStringArrayElementInvalid);
                }
            }
        }
        else {
            throw new ServiceLocalException(Strings.ZeroLengthArrayInvalid);
        }
    };
    /**
     * Validates the specified key and value.
     *
     * @param   {any}   key     The dictionary entry key.
     * @param   {any}   value   The dictionary entry value.
     */
    UserConfigurationDictionary.prototype.ValidateEntry = function (key, value) {
        this.ValidateObject(key);
        this.ValidateObject(value);
    };
    /**
     * Validates the dictionary object (key or entry value).
     *
     * @param   {any}   dictionaryObject   Object to validate.
     */
    UserConfigurationDictionary.prototype.ValidateObject = function (dictionaryObject) {
        // Keys may not be null but we rely on the internal dictionary to throw if the key is null.
        if (dictionaryObject != null) {
            var dictionaryObjectAsArray = dictionaryObject;
            if (ArrayHelper.isArray(dictionaryObjectAsArray)) {
                this.ValidateArrayObject(dictionaryObjectAsArray);
            }
            else {
                this.ValidateObjectType(dictionaryObject);
            }
        }
    };
    /**
     * Validates the dictionary object type.
     *
     * @param   {any}   type   Type to validate.
     */
    UserConfigurationDictionary.prototype.ValidateObjectType = function (dictionaryObject /*System.Type*/) {
        var typeofDictionaryObject = typeof dictionaryObject;
        var type = null;
        if (typeofDictionaryObject === 'string') {
            type = UserConfigurationDictionaryObjectType.String;
        }
        else if (typeofDictionaryObject === 'boolean') {
            type = UserConfigurationDictionaryObjectType.Boolean;
        }
        else if (typeofDictionaryObject === 'number') {
            var num = Convert.toNumber(dictionaryObject);
            type = UserConfigurationDictionaryObjectType.Integer32;
            if (num >= 0 && num <= 255) {
                type = UserConfigurationDictionaryObjectType.Byte;
            }
            else if (num < 0 && num < -2147483648) {
                type = UserConfigurationDictionaryObjectType.Integer64;
            }
            else if (num >= 0 && num > 2147483647) {
                type = UserConfigurationDictionaryObjectType.UnsignedInteger64;
            }
            else if (num >= 0 && num <= 2147483647) {
                type = UserConfigurationDictionaryObjectType.UnsignedInteger32;
            }
        }
        else if (dictionaryObject instanceof DateTime) {
            type = UserConfigurationDictionaryObjectType.DateTime;
        }
        var isValidType = false;
        switch (type) {
            case UserConfigurationDictionaryObjectType.Boolean:
            case UserConfigurationDictionaryObjectType.Byte:
            case UserConfigurationDictionaryObjectType.DateTime:
            case UserConfigurationDictionaryObjectType.Integer32:
            case UserConfigurationDictionaryObjectType.Integer64:
            case UserConfigurationDictionaryObjectType.String:
            case UserConfigurationDictionaryObjectType.UnsignedInteger32:
            case UserConfigurationDictionaryObjectType.UnsignedInteger64:
                isValidType = true;
                break;
        }
        if (!isValidType) {
            throw new ServiceLocalException(StringHelper.Format(Strings.ObjectTypeNotSupported, type));
        }
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    UserConfigurationDictionary.prototype.WriteElementsToXml = function (writer) {
        EwsLogging.Assert(writer != null, "UserConfigurationDictionary.WriteElementsToXml", "writer is null");
        for (var _a = 0, _b = this.dictionary.Items; _a < _b.length; _a++) {
            var dictionaryEntry = _b[_a];
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.DictionaryEntry);
            this.WriteObjectToXml(writer, XmlElementNames.DictionaryKey, dictionaryEntry.key);
            this.WriteObjectToXml(writer, XmlElementNames.DictionaryValue, dictionaryEntry.value);
            writer.WriteEndElement();
        }
    };
    /**
     * Writes a dictionary entry type to Xml.
     *
     * @param   {EwsServiceXmlWriter}                       writer                 The writer.
     * @param   {UserConfigurationDictionaryObjectType}     dictionaryObjectType   Type to write.
     */
    UserConfigurationDictionary.prototype.WriteEntryTypeToXml = function (writer, dictionaryObjectType) {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Type);
        writer.WriteValue(UserConfigurationDictionaryObjectType[dictionaryObjectType], XmlElementNames.Type);
        writer.WriteEndElement();
    };
    /**
     * Writes a dictionary entry value to Xml.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     * @param   {string}                value    Value to write.
     */
    UserConfigurationDictionary.prototype.WriteEntryValueToXml = function (writer, value) {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Value);
        // While an entry value can't be null, if the entry is an array, an element of the array can be null.
        if (value != null) {
            writer.WriteValue(value, XmlElementNames.Value);
        }
        writer.WriteEndElement();
    };
    /**
     * Writes a dictionary object (key or value) to Xml.
     *
     * @param   {EwsServiceXmlWriter}   writer             The writer.
     * @param   {string}                xmlElementName     The Xml element name.
     * @param   {any}                   dictionaryObject   The object to write.
     */
    UserConfigurationDictionary.prototype.WriteObjectToXml = function (writer, xmlElementName, dictionaryObject) {
        EwsLogging.Assert(writer != null, "UserConfigurationDictionary.WriteObjectToXml", "writer is null");
        EwsLogging.Assert(xmlElementName != null, "UserConfigurationDictionary.WriteObjectToXml", "xmlElementName is null");
        writer.WriteStartElement(XmlNamespace.Types, xmlElementName);
        if (dictionaryObject == null) {
            EwsLogging.Assert(xmlElementName != XmlElementNames.DictionaryKey, "UserConfigurationDictionary.WriteObjectToXml", "Key is null");
            writer.WriteAttributeValue(EwsUtilities.EwsXmlSchemaInstanceNamespacePrefix, XmlAttributeNames.Nil, EwsUtilities.XSTrue);
        }
        else {
            this.WriteObjectValueToXml(writer, dictionaryObject);
        }
        writer.WriteEndElement();
    };
    /**
     * Writes a dictionary Object's value to Xml.
     *
     * @param   {EwsServiceXmlWriter}   writer             The writer.
     * @param   {any}                   dictionaryObject   The dictionary object to write.
     */
    UserConfigurationDictionary.prototype.WriteObjectValueToXml = function (writer, dictionaryObject) {
        EwsLogging.Assert(writer != null, "UserConfigurationDictionary.WriteObjectValueToXml", "writer is null");
        EwsLogging.Assert(dictionaryObject != null, "UserConfigurationDictionary.WriteObjectValueToXml", "dictionaryObject is null");
        // This logic is based on Microsoft.Exchange.Services.Core.GetUserConfiguration.ConstructDictionaryObject().
        //
        // Object values are either:
        //   . an array of strings
        //   . a single value
        //
        // Single values can be:
        //   . base64 string (from a byte array)
        //   . datetime, boolean, byte, short, int, long, string, ushort, unint, ulong
        //
        //Assume string value for default
        var dictionaryObjectType = UserConfigurationDictionaryObjectType.String;
        var valueAsString = null;
        //First check for Array
        if (ArrayHelper.isArray(dictionaryObject)) {
            // First check for a string array         
            var dictionaryObjectAsStringArray = ArrayHelper.OfType(dictionaryObject, function (item) { return typeof item === 'string'; });
            if (dictionaryObjectAsStringArray.length > 0) {
                //array with string
                if (dictionaryObjectAsStringArray.length === dictionaryObject.length) {
                    //all array elements are string
                    this.WriteEntryTypeToXml(writer, UserConfigurationDictionaryObjectType.StringArray);
                    for (var _a = 0, dictionaryObjectAsStringArray_1 = dictionaryObjectAsStringArray; _a < dictionaryObjectAsStringArray_1.length; _a++) {
                        var arrayElement = dictionaryObjectAsStringArray_1[_a];
                        this.WriteEntryValueToXml(writer, arrayElement);
                    }
                }
                else {
                    throw new ServiceLocalException(Strings.NullStringArrayElementInvalid);
                }
            }
            //check for byte[] for base64 conversion to single element //todo: byte[] conversion to base64 using Buffer
            var dictionaryObjectAsByteArray = ArrayHelper.OfType(dictionaryObject, function (item) { return typeof item === 'number'; });
            if (dictionaryObjectAsByteArray.length > 0 && dictionaryObjectAsByteArray.length === dictionaryObject.length) {
                // Convert byte array to base64 string
                dictionaryObjectType = UserConfigurationDictionaryObjectType.ByteArray;
                valueAsString = Convert.ToBase64String(dictionaryObjectAsByteArray);
                this.WriteEntryTypeToXml(writer, dictionaryObjectType);
                this.WriteEntryValueToXml(writer, valueAsString);
            }
            else {
                throw new ServiceLocalException(Strings.NullStringArrayElementInvalid);
            }
        }
        else {
            // if not a string array, all other object values are returned as a single element
            var refDictionaryObjectType = { getValue: function () { return dictionaryObjectType; }, setValue: function (value) { dictionaryObjectType = value; } };
            var refValueAsString = { getValue: function () { return valueAsString; }, setValue: function (value) { valueAsString = value; } };
            UserConfigurationDictionary.GetTypeCode(writer.Service, dictionaryObject, refDictionaryObjectType, refValueAsString);
            this.WriteEntryTypeToXml(writer, refDictionaryObjectType.getValue());
            this.WriteEntryValueToXml(writer, refValueAsString.getValue());
        }
    };
    /**
     * required before initializing new UserConfigurationDictionary
     */
    UserConfigurationDictionary._dictionaryKeyPicker = function (key) { return key ? key.toString() : ''; };
    return UserConfigurationDictionary;
}(ComplexProperty));
exports.UserConfigurationDictionary = UserConfigurationDictionary;
/**
 * Represents the Id of a user.
 *
 * @sealed
 */
var UserId = (function (_super) {
    __extends(UserId, _super);
    function UserId(primarySmtpAddressOrStandardUser) {
        var _this = _super.call(this) || this;
        _this.sID = null;
        _this.primarySmtpAddress = null;
        _this.displayName = null;
        _this.standardUser = null;
        if (typeof primarySmtpAddressOrStandardUser !== 'undefined') {
            if (typeof primarySmtpAddressOrStandardUser === 'string') {
                _this.primarySmtpAddress = primarySmtpAddressOrStandardUser;
            }
            else {
                _this.standardUser = primarySmtpAddressOrStandardUser;
            }
        }
        return _this;
    }
    Object.defineProperty(UserId.prototype, "SID", {
        /**
         * Gets or sets the SID of the user.
         */
        get: function () {
            return this.sID;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.sID; }, setValue: function (data) { return _this.sID = data; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserId.prototype, "PrimarySmtpAddress", {
        /**
         * Gets or sets the primary SMTP address or the user.
         */
        get: function () {
            return this.primarySmtpAddress;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.primarySmtpAddress; }, setValue: function (data) { return _this.primarySmtpAddress = data; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserId.prototype, "DisplayName", {
        /**
         * Gets or sets the display name of the user.
         */
        get: function () {
            return this.displayName;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.displayName; }, setValue: function (data) { return _this.displayName = data; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserId.prototype, "StandardUser", {
        /**
         * Gets or sets a value indicating which standard user the user represents.
         *
         * @Nullable
         */
        get: function () {
            return this.standardUser;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.standardUser; }, setValue: function (data) { return _this.standardUser = data; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Determines whether this instance is valid.
     *
     * @return  {boolean}      true if this instance is valid; otherwise, false.
     */
    UserId.prototype.IsValid = function () {
        return typeof this.StandardUser === 'number' || !StringHelper.IsNullOrEmpty(this.PrimarySmtpAddress) || !StringHelper.IsNullOrEmpty(this.SID);
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    UserId.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.SID:
                    this.sID = jsObject[key];
                    break;
                case XmlElementNames.PrimarySmtpAddress:
                    this.primarySmtpAddress = jsObject[key];
                    break;
                case XmlElementNames.DisplayName:
                    this.displayName = jsObject[key];
                    break;
                case XmlElementNames.DistinguishedUser:
                    //debugger;//check for enum value consistency
                    this.standardUser = StandardUser[jsObject[key]];
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    UserId.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.SID, this.SID);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.PrimarySmtpAddress, this.PrimarySmtpAddress);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DisplayName, this.DisplayName);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DistinguishedUser, StandardUser[this.StandardUser]);
    };
    return UserId;
}(ComplexProperty));
exports.UserId = UserId;
/**
 * Represents voting information.
 * @sealed
 */
var VotingInformation = (function (_super) {
    __extends(VotingInformation, _super);
    /**
     * @internal Initializes a new instance of the **VotingInformation** class.
     */
    function VotingInformation() {
        var _this = _super.call(this) || this;
        _this.userOptions = [];
        _this.votingResponse = null;
        return _this;
    }
    Object.defineProperty(VotingInformation.prototype, "UserOptions", {
        /**
         * Gets the list of user options.
         */
        get: function () {
            return this.userOptions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VotingInformation.prototype, "VotingResponse", {
        /**
         * Gets the voting response.
         */
        get: function () {
            return this.votingResponse;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    VotingInformation.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        if (jsObject[XmlElementNames.UserOptions]) {
            var votingOptionObjects = EwsServiceJsonReader.ReadAsArray(jsObject, XmlElementNames.UserOptions);
            for (var _a = 0, votingOptionObjects_1 = votingOptionObjects; _a < votingOptionObjects_1.length; _a++) {
                var votingOptionObject = votingOptionObjects_1[_a];
                var option = new VotingOptionData();
                option.LoadFromXmlJsObject(votingOptionObject, service);
                this.userOptions.push(option);
            }
        }
        if (jsObject[XmlElementNames.VotingResponse]) {
            this.votingResponse = jsObject[XmlElementNames.VotingResponse];
        }
    };
    return VotingInformation;
}(ComplexProperty));
exports.VotingInformation = VotingInformation;
/**
 * Represents voting option information.
 * @sealed
 */
var VotingOptionData = (function (_super) {
    __extends(VotingOptionData, _super);
    /**
     * @internal Initializes a new instance of the **VotingOptionData** class.
     */
    function VotingOptionData() {
        var _this = _super.call(this) || this;
        _this.displayName = null;
        _this.sendPrompt = SendPrompt.None;
        return _this;
    }
    Object.defineProperty(VotingOptionData.prototype, "DisplayName", {
        /**
         * Gets the display name for the voting option.
         */
        get: function () {
            return this.displayName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VotingOptionData.prototype, "SendPrompt", {
        /**
         * Gets the send prompt.
         */
        get: function () {
            return this.sendPrompt;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    VotingOptionData.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.VotingOptionDisplayName:
                    this.displayName = jsObject[key];
                    break;
                case XmlElementNames.SendPrompt:
                    this.sendPrompt = SendPrompt[jsObject[key]];
                    break;
                default:
                    break;
            }
        }
    };
    return VotingOptionData;
}(ComplexProperty));
exports.VotingOptionData = VotingOptionData;
/**
 * Represents an attachment to an item.
 */
var Attachment = (function (_super) {
    __extends(Attachment, _super);
    function Attachment(ownerOrService) {
        var _this = _super.call(this) || this;
        _this.owner = null;
        _this.id = null;
        _this.name = null;
        _this.contentType = null;
        _this.contentId = null;
        _this.contentLocation = null;
        _this.size = 0;
        _this.lastModifiedTime = null;
        _this.isInline = false;
        _this.service = null;
        if (arguments.length === 1 && (ownerOrService === null || ownerOrService instanceof TypeContainer.Item)) {
            _this.owner = ownerOrService;
            if (ownerOrService !== null) {
                _this.service = _this.owner.Service;
            }
            return _this;
        }
        _this.service = ownerOrService;
        return _this;
    }
    Object.defineProperty(Attachment.prototype, "Id", {
        /**
         * Gets the Id of the attachment.
         */
        get: function () {
            return this.id;
        },
        set: function (value) {
            this.id = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Attachment.prototype, "Name", {
        /***
         * Gets or sets the name of the attachment.
         */
        get: function () {
            return this.name;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.name; }, setValue: function (updateValue) { _this.name = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Attachment.prototype, "ContentType", {
        /**
         * Gets or sets the content type of the attachment.
         */
        get: function () {
            return this.contentType;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.contentType; }, setValue: function (updateValue) { _this.contentType = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Attachment.prototype, "ContentId", {
        /**
         * Gets or sets the content Id of the attachment. ContentId can be used as a custom way to identify an attachment in order to reference it from within the body of the item the attachment belongs to.
         */
        get: function () {
            return this.contentId;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.contentId; }, setValue: function (updateValue) { _this.contentId = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Attachment.prototype, "ContentLocation", {
        /**
         * Gets or sets the content location of the attachment. ContentLocation can be used to associate an attachment with a Url defining its location on the Web.
         */
        get: function () {
            return this.contentLocation;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.contentLocation; }, setValue: function (updateValue) { _this.contentLocation = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Attachment.prototype, "Size", {
        /**
         * Gets the size of the attachment.
         */
        get: function () {
            EwsUtilities.ValidatePropertyVersion(this.service, ExchangeVersion.Exchange2010, "Size");
            return this.size;
        },
        set: function (value) {
            var _this = this;
            EwsUtilities.ValidatePropertyVersion(this.service, ExchangeVersion.Exchange2010, "Size");
            this.SetFieldValue({ getValue: function () { return _this.size; }, setValue: function (updateValue) { _this.size = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Attachment.prototype, "LastModifiedTime", {
        /**
         * Gets the date and time when this attachment was last modified.
         */
        get: function () {
            EwsUtilities.ValidatePropertyVersion(this.service, ExchangeVersion.Exchange2010, "LastModifiedTime");
            return this.lastModifiedTime;
        },
        set: function (value) {
            var _this = this;
            EwsUtilities.ValidatePropertyVersion(this.service, ExchangeVersion.Exchange2010, "LastModifiedTime");
            this.SetFieldValue({ getValue: function () { return _this.lastModifiedTime; }, setValue: function (updateValue) { _this.lastModifiedTime = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Attachment.prototype, "IsInline", {
        /**
         * Gets or sets a value indicating whether this is an inline attachment. Inline attachments are not visible to end users.
         */
        get: function () {
            EwsUtilities.ValidatePropertyVersion(this.service, ExchangeVersion.Exchange2010, "IsInline");
            return this.isInline;
        },
        set: function (value) {
            var _this = this;
            EwsUtilities.ValidatePropertyVersion(this.service, ExchangeVersion.Exchange2010, "IsInline");
            this.SetFieldValue({ getValue: function () { return _this.isInline; }, setValue: function (updateValue) { _this.isInline = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Attachment.prototype, "IsNew", {
        /**
         * @internal True if the attachment has not yet been saved, false otherwise.
         */
        get: function () {
            return StringHelper.IsNullOrEmpty(this.Id);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Attachment.prototype, "Owner", {
        /**
         * @internal Gets the owner of the attachment.
         */
        get: function () {
            return this.owner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Attachment.prototype, "Service", {
        /**
         * @internal Gets the related exchange service.
         */
        get: function () {
            return this.service;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    Attachment.prototype.GetXmlElementName = function () { console.log("Attachment.ts - GetXmlElementName : Abstract - must implement."); return StringHelper.Empty; };
    /**
     * @internal Load the attachment.
     *
     * @param   {BodyType}                      bodyType               Type of the body.
     * @param   {PropertyDefinitionBase[]}      additionalProperties   The additional properties.
     */
    Attachment.prototype.InternalLoad = function (bodyType, additionalProperties) {
        return this.service.GetAttachment(this, bodyType, additionalProperties);
    };
    //InternalToJson(service: ExchangeService): any { throw new Error("Attachment.ts - InternalToJson : Not implemented."); }
    /**
     * Loads the attachment. Calling this method results in a call to EWS.
     */
    Attachment.prototype.Load = function () {
        return this.InternalLoad(null, null);
    };
    /**
     * Loads the attachment id from json.
     *
     * @param   {any}   jsonObject   The json object.
     */
    Attachment.prototype.LoadAttachmentIdFromXMLJsObject = function (jsonObject) {
        this.id = jsonObject[XmlAttributeNames.Id];
        if (this.Owner != null && jsonObject[XmlAttributeNames.RootItemChangeKey]) {
            var rootItemChangeKey = jsonObject[XmlAttributeNames.RootItemChangeKey];
            if (!StringHelper.IsNullOrEmpty(rootItemChangeKey)) {
                this.Owner.RootItemId.ChangeKey = rootItemChangeKey;
            }
        }
    };
    /**
     * @internal Loads from XMLjsObject.
     *
     * @param   {any}               jsonObject
     * @param   {ExchangeService}   service
     */
    Attachment.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.AttachmentId:
                    this.LoadAttachmentIdFromXMLJsObject(jsObject[key]);
                    break;
                case XmlElementNames.Name:
                    this.name = jsObject[key];
                    break;
                case XmlElementNames.ContentType:
                    this.contentType = jsObject[key];
                    break;
                case XmlElementNames.ContentId:
                    this.contentId = jsObject[key];
                    break;
                case XmlElementNames.ContentLocation:
                    this.contentLocation = jsObject[key];
                    break;
                case XmlElementNames.Size:
                    this.size = Convert.toInt(jsObject[key]);
                    break;
                case XmlElementNames.LastModifiedTime:
                    this.lastModifiedTime = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                case XmlElementNames.IsInline:
                    this.isInline = Convert.toBool(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * @internal Sets value of field.
     *
     * /remarks/    We override the base implementation. Attachments cannot be modified so any attempts the change a property on an existing attachment is an error.
     *
     * @param   {IRefParam<T>}      field   The field.
     * @param   {T}                 value   The value.
     */
    Attachment.prototype.SetFieldValue = function (field, value) {
        this.ThrowIfThisIsNotNew();
        _super.prototype.SetFieldValue.call(this, field, value);
    };
    /**
     * @internal Throws exception if this is not a new service object.
     */
    Attachment.prototype.ThrowIfThisIsNotNew = function () {
        if (!this.IsNew) {
            throw new Error(Strings.AttachmentCannotBeUpdated); //InvalidOperationException
        }
    };
    //ReadElementsFromXmlJsObject(reader: any): boolean { throw new Error("Attachment.ts - TryReadElementFromXmlJsObject : Not implemented."); }
    /**
     * @internal Validates this instance.
     *
     * @param   {number}   attachmentIndex   Index of this attachment.
     */
    Attachment.prototype.Validate = function (attachmentIndex) {
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    Attachment.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Name, this.Name);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ContentType, this.ContentType);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ContentId, this.ContentId);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ContentLocation, this.ContentLocation);
        if (writer.Service.RequestedServerVersion > ExchangeVersion.Exchange2007_SP1) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsInline, this.IsInline);
        }
    };
    return Attachment;
}(ComplexProperty));
exports.Attachment = Attachment;
/**
 * Represents a file attachment.
 */
var FileAttachment = (function (_super) {
    __extends(FileAttachment, _super);
    function FileAttachment(ownerOrService) {
        var _this = _super.call(this, ownerOrService) || this;
        _this.fileName = null;
        //private contentStream: Stream = null;
        //private content: number[] = null;
        _this.base64Content = null;
        //private loadToStream: Stream = null;
        _this.isContactPhoto = false;
        return _this;
    }
    Object.defineProperty(FileAttachment.prototype, "FileName", {
        /**
         * Gets the name of the file the attachment is linked to.
         */
        get: function () {
            return this.fileName;
        },
        set: function (value) {
            _super.prototype.ThrowIfThisIsNotNew.call(this);
            this.fileName = value;
            //this.content = null;
            this.base64Content = null;
            //this.contentStream = null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileAttachment.prototype, "Base64Content", {
        // /**
        //  * Gets or sets the content stream.
        //  */
        // get ContentStream(): Stream {
        //     return this.contentStream;
        // }
        // set ContentStream(value: Stream) {
        //     super.ThrowIfThisIsNotNew();
        //     this.contentStream = value;
        //     this.content = null;
        //     this.fileName = null;
        // }
        // /**
        //  * Gets the content of the attachment into memory. Content is set only when Load() is called.
        //  */
        // get Content(): number[] {
        //     return this.content;
        // }
        // set Content(value: number[]) {
        //     super.ThrowIfThisIsNotNew();
        //     this.content = value;
        //     this.fileName = null;
        //     this.contentStream = null;
        // }
        /**
         * Gets the base64 content of the attachment into memory. Content is set only when Load() is called.
         */
        get: function () {
            return this.base64Content;
        },
        set: function (value) {
            _super.prototype.ThrowIfThisIsNotNew.call(this);
            this.base64Content = value;
            this.fileName = null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileAttachment.prototype, "IsContactPhoto", {
        /**
         * Gets or sets a value indicating whether this attachment is a contact photo.
         */
        get: function () {
            EwsUtilities.ValidatePropertyVersion(this.Service, ExchangeVersion.Exchange2010, "IsContactPhoto");
            return this.isContactPhoto;
        },
        set: function (value) {
            EwsUtilities.ValidatePropertyVersion(this.Service, ExchangeVersion.Exchange2010, "IsContactPhoto");
            _super.prototype.ThrowIfThisIsNotNew.call(this);
            this.isContactPhoto = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    FileAttachment.prototype.GetXmlElementName = function () { return XmlElementNames.FileAttachment; };
    //InternalToJson(service: ExchangeService): any { throw new Error("FileAttachment.ts - InternalToJson : Not implemented."); }
    // /**
    //  * Loads the content of the file attachment into the specified stream. Calling this method results in a call to EWS.
    //  *
    //  * @param   {any}   stream   The stream to load the content of the attachment into.
    //  */    
    // Load(stream: any /* System.IO.Stream */): void;
    // /**
    //  * Loads the content of the file attachment into the specified file. Calling this method results in a call to EWS.
    //  *
    //  * @param   {string}   fileName   The name of the file to load the content of the attachment into. If the file already exists, it is overwritten.
    //  */        
    // Load(fileName?: string): void;
    // Load(fileName?: string | any): Promise<void> {
    //     return  super.Load();
    // }
    //ref: //info: - skipped, this can be loaded from base class
    /**
     * @internal Loads from XMLjsObject.
     *
     * @param   {any}               jsonProperty   The json property.
     * @param   {ExchangeService}   service        [description]
     */
    FileAttachment.prototype.LoadFromXmlJsObject = function (jsObject /*JsonObject*/, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.IsContactPhoto:
                    this.isContactPhoto = Convert.toBool(jsObject[key]);
                    break;
                case XmlElementNames.Content:
                    this.base64Content = jsObject[key];
                    // if (this.loadToStream != null)
                    // {
                    //     jsObject.ReadAsBase64Content(key, this.loadToStream);
                    // }
                    // else
                    // {
                    //     // If there's a file attachment content handler, use it. Otherwise
                    //     // load the content into a byte array.
                    //     // TODO: Should we mark the attachment to indicate that content is stored elsewhere?
                    //     if (service.FileAttachmentContentHandler != null)
                    //     {
                    //         Stream outputStream = service.FileAttachmentContentHandler.GetOutputStream(this.Id);
                    //         if (outputStream != null)
                    //         {
                    //             jsObject.ReadAsBase64Content(key, outputStream);
                    //         }
                    //         else
                    //         {
                    //             this.content = jsObject.ReadAsBase64Content(key);
                    //         }
                    //     }
                    //     else
                    //     {
                    //         this.content = jsObject.ReadAsBase64Content(key);
                    //     }
                    // }
                    break;
                default:
                    break;
            }
        }
    };
    //ReadElementsFromXmlJsObject(reader: any): boolean { throw new Error("FileAttachment.ts - TryReadElementFromXmlJsObject : Not implemented."); }
    FileAttachment.prototype.ReadElementsFromXmlJsObjectToPatch = function (reader) { throw new Error("FileAttachment.ts - ReadElementsFromXmlJsObjectToPatch : Not implemented."); };
    /**
     * @internal Validates this instance.
     *
     * @param   {number}   attachmentIndex   Index of this attachment.
     */
    FileAttachment.prototype.Validate = function (attachmentIndex) {
        if (StringHelper.IsNullOrEmpty(this.Name) && (this.base64Content == null)) {
            throw new ServiceValidationException(StringHelper.Format(Strings.FileAttachmentContentIsNotSet, attachmentIndex));
        }
    };
    /**
     * @internal Writes elements and content to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    FileAttachment.prototype.WriteElementsToXml = function (writer) {
        _super.prototype.WriteElementsToXml.call(this, writer);
        if (writer.Service.RequestedServerVersion > ExchangeVersion.Exchange2007_SP1) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsContactPhoto, this.isContactPhoto);
        }
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Content);
        if (!StringHelper.IsNullOrEmpty(this.FileName)) {
            throw new Error("FileAttachment.ts - File reading from disk is not implemented. Always use Base64Content property ");
            // using (FileStream fileStream = new FileStream(this.FileName, FileMode.Open, FileAccess.Read))
            // {
            //     writer.WriteBase64ElementValue(fileStream);
            // }
        }
        else if (!StringHelper.IsNullOrEmpty(this.base64Content)) {
            writer.WriteValue(this.base64Content, null);
        }
        else {
            EwsLogging.Assert(false, "FileAttachment.WriteElementsToXml", "The attachment's content is not set.");
        }
        writer.WriteEndElement();
    };
    return FileAttachment;
}(Attachment));
exports.FileAttachment = FileAttachment;
/**
 * Represents an item attachment.
 */
var ItemAttachment = (function (_super) {
    __extends(ItemAttachment, _super);
    function ItemAttachment(ownerOrService) {
        var _this = _super.call(this, ownerOrService) || this;
        /**
         * The item associated with the attachment.
         */
        _this.item = null;
        return _this;
    }
    Object.defineProperty(ItemAttachment.prototype, "Item", {
        /**
         * Gets the item associated with the attachment.
         */
        get: function () {
            return this.item;
        },
        set: function (value) {
            _super.prototype.ThrowIfThisIsNotNew.call(this);
            //todo: implement logic for onchange
            if (this.item !== null) {
                //this.item.OnChange.Remove(this.ItemChanged);
            }
            this.item = value;
            if (this.item !== null) {
                //this.item.OnChange.Add(this.ItemChanged);
            }
        },
        enumerable: true,
        configurable: true
    });
    /** to workaround base.Item property accessor of c# //ref: //info: */
    ItemAttachment.prototype._setItem = function (value) {
        this.item = value;
    };
    /**
     * @internal Obtains EWS XML element name for this object.
     *
     * @return  {string}      The XML element name.
     */
    ItemAttachment.prototype.GetXmlElementName = function () { return XmlElementNames.ItemAttachment; };
    //InternalToJson(service: ExchangeService): any { throw new Error("ItemAttachment.ts - InternalToJson : Not implemented."); }
    /**
     * Implements the OnChange event handler for the item associated with the attachment.
     *
     * @param   {ServiceObject}   serviceObject   The service object that triggered the OnChange event.
     */
    ItemAttachment.prototype.ItemChanged = function (serviceObject) {
        if (this.Owner != null) {
            this.Owner.PropertyBag.Changed();
        }
    };
    ItemAttachment.prototype.Load = function (bodyTypeOrPeoperties, additionalProperties) {
        var argsLength = arguments.length;
        var props = null;
        var bodyType = null;
        if (argsLength === 1) {
            props = bodyTypeOrPeoperties;
        }
        if (argsLength === 2) {
            bodyType = bodyTypeOrPeoperties;
        }
        if (argsLength > 2) {
            throw new Error("ItemAttachment.ts - Load with " + argsLength + " parameters, invalid number of arguments, check documentation and try again.");
        }
        return this.InternalLoad(bodyType, props);
    };
    /**
     * @internal Loads from XMLjsObject.
     *
     * @param   {any}               jsObject   The json property.
     * @param   {ExchangeService}   service        [description]
     */
    ItemAttachment.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.Item:
                case XmlElementNames.CalendarItem:
                case XmlElementNames.Contact:
                case XmlElementNames.DistributionList:
                case XmlElementNames.Conversation:
                case XmlElementNames.Message:
                case XmlElementNames.MeetingCancellation:
                case XmlElementNames.MeetingMessage:
                case XmlElementNames.MeetingRequest:
                case XmlElementNames.MeetingResponse:
                case XmlElementNames.Persona:
                case XmlElementNames.PostItem:
                case XmlElementNames.Task:
                    var itemObj = jsObject[key];
                    if (itemObj != null) {
                        this.item = (new ItemInfo()).CreateEwsObjectFromXmlElementName(this.Service, key);
                        if (this.item != null) {
                            this.item.LoadFromXmlJsObject(itemObj, this.Service, true);
                        }
                    }
                    break;
                default:
                    break;
            }
        }
    };
    //ReadElementsFromXmlJsObject(reader: any): void { throw new Error("ItemAttachment.ts - TryReadElementFromXmlJsObject : Not implemented."); }    
    ItemAttachment.prototype.ReadElementsFromXmlJsObjectToPatch = function (reader) { throw new Error("ItemAttachment.ts - TryReadElementFromXmlToPatch : Not implemented."); };
    /**
     * @internal Validates this instance.
     *
     * @param   {number}   attachmentIndex   Index of this attachment.
     */
    ItemAttachment.prototype.Validate = function (attachmentIndex) {
        if (StringHelper.IsNullOrEmpty(this.Name)) {
            throw new ServiceValidationException(StringHelper.Format(Strings.ItemAttachmentMustBeNamed, attachmentIndex));
        }
        // Recurse through any items attached to item attachment.
        this.Item.Attachments.Validate();
    };
    /**
     * @internal Writes the properties of this object as XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer to write the elements to.
     */
    ItemAttachment.prototype.WriteElementsToXml = function (writer) {
        _super.prototype.WriteElementsToXml.call(this, writer);
        this.Item.WriteToXml(writer);
    };
    return ItemAttachment;
}(Attachment));
exports.ItemAttachment = ItemAttachment;
/**
 * Represents a strongly typed item attachment. **Workaround of ItemAttachment<TItem>** - not allowed in typescript to have two class, one generic and one non-generic
 */
var ItemAttachmentOf = (function (_super) {
    __extends(ItemAttachmentOf, _super);
    /**
     * @internal Initializes a new instance of the **ItemAttachmentOf** class.
     *
     * @param   {Item}   owner   The owner of the attachment.
     */
    function ItemAttachmentOf(owner) {
        return _super.call(this, owner) || this;
    }
    Object.defineProperty(ItemAttachmentOf.prototype, "Item", {
        /**
         * Gets the item associated with the attachment.
         */
        get: function () { return this.item; },
        set: function (value) { /** this.Item = value; */ _super.prototype._setItem.call(this, value); },
        enumerable: true,
        configurable: true
    });
    return ItemAttachmentOf;
}(ItemAttachment));
exports.ItemAttachmentOf = ItemAttachmentOf;
//Moved to ItemAttachmentOf.ts for simplicity
var DictionaryEntryProperty = (function (_super) {
    __extends(DictionaryEntryProperty, _super);
    function DictionaryEntryProperty(key) {
        var _this = _super.call(this) || this;
        _this.key = null;
        _this.key = key;
        return _this;
    }
    Object.defineProperty(DictionaryEntryProperty.prototype, "Key", {
        get: function () {
            return this.key;
        },
        set: function (value) {
            this.key = value;
        },
        enumerable: true,
        configurable: true
    });
    /**@internal */
    DictionaryEntryProperty.prototype.ReadAttributesFromXmlJsObject = function (reader) { throw new Error("DictionaryEntryProperty.ts - ReadAttributesFromXml : Not used."); };
    /**@internal */
    DictionaryEntryProperty.prototype.WriteAttributesToXml = function (writer) { writer.WriteAttributeValue(XmlAttributeNames.Key, this.keyType[this.Key]); };
    DictionaryEntryProperty.prototype.WriteDeleteUpdateToJson = function (service, ewsObject, updates /*System.Collections.Generic.List<T>*/) { throw new Error("DictionaryEntryProperty.ts - WriteDeleteUpdateToJson : Not implemented."); };
    /**@internal */
    DictionaryEntryProperty.prototype.WriteDeleteUpdateToXml = function (writer, ewsObject) { return false; };
    DictionaryEntryProperty.prototype.WriteSetUpdateToJson = function (service, ewsObject, propertyDefinition, updates /*System.Collections.Generic.List<T>*/) { throw new Error("DictionaryEntryProperty.ts - WriteSetUpdateToJson : Not implemented."); };
    /**@internal */
    DictionaryEntryProperty.prototype.WriteSetUpdateToXml = function (writer, ewsObject, ownerDictionaryXmlElementName) { return false; };
    return DictionaryEntryProperty;
}(ComplexProperty));
exports.DictionaryEntryProperty = DictionaryEntryProperty;
var EmailAddressEntry = (function (_super) {
    __extends(EmailAddressEntry, _super);
    function EmailAddressEntry(key, emailAddress) {
        if (key === void 0) { key = EmailAddressKey.EmailAddress1; }
        if (emailAddress === void 0) { emailAddress = new EmailAddress(); }
        var _this = _super.call(this, key) || this;
        _this.emailAddress = null;
        _this.keyType = EmailAddressKey;
        _this.emailAddress = emailAddress;
        if (_this.emailAddress != null) {
            _this.emailAddress.OnChange.push(_this.EmailAddressChanged.bind(_this));
        }
        return _this;
    }
    Object.defineProperty(EmailAddressEntry.prototype, "EmailAddress", {
        get: function () {
            return this.emailAddress;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.emailAddress; }, setValue: function (address) { _this.emailAddress = address; } }, value);
            if (this.emailAddress != null) {
                this.emailAddress.OnChange.push(this.EmailAddressChanged.bind(this));
            }
        },
        enumerable: true,
        configurable: true
    });
    EmailAddressEntry.prototype.EmailAddressChanged = function (complexProperty) { this.Changed(); };
    EmailAddressEntry.prototype.InternalToJson = function (service) { throw new Error("EmailAddressEntry.ts - InternalToJson : Not implemented."); };
    EmailAddressEntry.prototype.LoadFromJson = function (jsonProperty, service) { throw new Error("EmailAddressEntry.ts - LoadFromJson : Not implemented."); };
    EmailAddressEntry.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlAttributeNames.Key:
                    this.Key = EmailAddressKey[jsonProperty[key]];
                    break;
                case XmlAttributeNames.Name:
                    this.EmailAddress.Name = jsonProperty[key];
                    break;
                case XmlAttributeNames.RoutingType:
                    this.EmailAddress.RoutingType = jsonProperty[key];
                    break;
                case XmlAttributeNames.MailboxType:
                    this.EmailAddress.MailboxType = MailboxType.FromEwsEnumString(jsonProperty[key]);
                    break;
                case XmlElementNames.EmailAddress:
                    this.EmailAddress.Address = jsonProperty[key];
                    break;
            }
        }
        //ref: ews-javascript-api specific workaround for text node in complexproperty
        if (jsonProperty[XmlElementNames.Entry]) {
            if (this.emailAddress.Address === null) {
                this.emailAddress.Address = jsonProperty[XmlElementNames.Entry];
            }
        }
    };
    // ReadAttributesFromXmlJsObject(reader: EwsServiceXmlReader): any { throw new Error("EmailAddressEntry.ts - ReadAttributesFromXml : Not implemented."); }
    // ReadTextValueFromXmlJsObject(reader: EwsServiceXmlReader): any { throw new Error("EmailAddressEntry.ts - ReadTextValueFromXml : Not implemented."); }
    /**@internal */
    EmailAddressEntry.prototype.WriteAttributesToXml = function (writer) {
        _super.prototype.WriteAttributesToXml.call(this, writer);
        if (writer.Service.RequestedServerVersion > ExchangeVersion.Exchange2007_SP1) {
            writer.WriteAttributeValue(XmlAttributeNames.Name, this.EmailAddress.Name);
            writer.WriteAttributeValue(XmlAttributeNames.RoutingType, this.EmailAddress.RoutingType);
            if (this.EmailAddress.MailboxType != MailboxType.Unknown) {
                writer.WriteAttributeValue(XmlAttributeNames.MailboxType, MailboxType.ToEwsEnumString(this.EmailAddress.MailboxType));
            }
        }
    };
    /**@internal */
    EmailAddressEntry.prototype.WriteElementsToXml = function (writer) { writer.WriteValue(this.EmailAddress.Address, XmlElementNames.EmailAddress); };
    return EmailAddressEntry;
}(DictionaryEntryProperty));
exports.EmailAddressEntry = EmailAddressEntry;
var ImAddressEntry = (function (_super) {
    __extends(ImAddressEntry, _super);
    function ImAddressEntry(key, imAddress) {
        if (key === void 0) { key = ImAddressKey.ImAddress1; }
        if (imAddress === void 0) { imAddress = null; }
        var _this = _super.call(this, key) || this;
        _this.imAddress = null;
        _this.keyType = ImAddressKey;
        _this.imAddress = imAddress;
        return _this;
    }
    Object.defineProperty(ImAddressEntry.prototype, "ImAddress", {
        get: function () {
            return this.imAddress;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.imAddress; }, setValue: function (address) { _this.imAddress = address; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    ImAddressEntry.prototype.InternalToJson = function (service) { throw new Error("ImAddressEntry.ts - InternalToJson : Not implemented."); };
    ImAddressEntry.prototype.LoadFromJson = function (jsonProperty, service) { throw new Error("ImAddressEntry.ts - LoadFromJson : Not implemented."); };
    ImAddressEntry.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        this.Key = ImAddressKey[jsonProperty[XmlAttributeNames.Key]];
        this.ImAddress = jsonProperty[XmlElementNames.Entry]; // ImAddress];//ElementValue becomes Same ElementName when it has attribute. 
    };
    /**@internal */
    ImAddressEntry.prototype.WriteElementsToXml = function (writer) { writer.WriteValue(this.ImAddress, XmlElementNames.ImAddress); };
    return ImAddressEntry;
}(DictionaryEntryProperty));
exports.ImAddressEntry = ImAddressEntry;
var PhoneNumberEntry = (function (_super) {
    __extends(PhoneNumberEntry, _super);
    function PhoneNumberEntry(key, phoneNumber) {
        if (key === void 0) { key = PhoneNumberKey.AssistantPhone; }
        if (phoneNumber === void 0) { phoneNumber = null; }
        var _this = _super.call(this, key) || this;
        _this.phoneNumber = null;
        _this.keyType = PhoneNumberKey;
        _this.phoneNumber = phoneNumber;
        return _this;
    }
    Object.defineProperty(PhoneNumberEntry.prototype, "PhoneNumber", {
        get: function () {
            return this.phoneNumber;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.phoneNumber; }, setValue: function (address) { _this.phoneNumber = address; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    PhoneNumberEntry.prototype.InternalToJson = function (service) { throw new Error("PhoneNumberEntry.ts - InternalToJson : Not implemented."); };
    PhoneNumberEntry.prototype.LoadFromJson = function (jsonProperty, service) { throw new Error("PhoneNumberEntry.ts - LoadFromJson : Not implemented."); };
    PhoneNumberEntry.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        this.Key = PhoneNumberKey[jsonProperty[XmlAttributeNames.Key]];
        this.phoneNumber = jsonProperty[XmlElementNames.Entry]; //PhoneNumber
    };
    /**@internal */
    PhoneNumberEntry.prototype.WriteElementsToXml = function (writer) { writer.WriteValue(this.PhoneNumber, XmlElementNames.PhoneNumber); };
    return PhoneNumberEntry;
}(DictionaryEntryProperty));
exports.PhoneNumberEntry = PhoneNumberEntry;
var PhysicalAddressSchema = (function () {
    function PhysicalAddressSchema() {
    }
    Object.defineProperty(PhysicalAddressSchema, "XmlElementNames", {
        get: function () {
            return PhysicalAddressSchema.xmlElementNames.Member;
        },
        enumerable: true,
        configurable: true
    });
    PhysicalAddressSchema.Street = "Street";
    PhysicalAddressSchema.City = "City";
    PhysicalAddressSchema.State = "State";
    PhysicalAddressSchema.CountryOrRegion = "CountryOrRegion";
    PhysicalAddressSchema.PostalCode = "PostalCode";
    PhysicalAddressSchema.xmlElementNames = new LazyMember(function () {
        var list = [];
        list.push("Street");
        list.push("City");
        list.push("State");
        list.push("CountryOrRegion");
        list.push("PostalCode");
        return list;
    });
    return PhysicalAddressSchema;
}());
/**
 * PhysicalAddressEntry class
 */
var PhysicalAddressEntry = (function (_super) {
    __extends(PhysicalAddressEntry, _super);
    function PhysicalAddressEntry() {
        var _this = _super.call(this) || this;
        _this.propertyBag = null;
        _this.keyType = PhysicalAddressKey;
        _this.propertyBag = new SimplePropertyBag(function (key) { return key; });
        _this.propertyBag.OnChange.push(_this.PropertyBagChanged.bind(_this));
        return _this;
    }
    Object.defineProperty(PhysicalAddressEntry.prototype, "Street", {
        get: function () {
            return this.propertyBag._getItem("Street");
        },
        set: function (value) {
            this.propertyBag._setItem("Street", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PhysicalAddressEntry.prototype, "City", {
        get: function () {
            return this.propertyBag._getItem("City");
        },
        set: function (value) {
            this.propertyBag._setItem("City", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PhysicalAddressEntry.prototype, "State", {
        get: function () {
            return this.propertyBag._getItem("State");
        },
        set: function (value) {
            this.propertyBag._setItem("State", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PhysicalAddressEntry.prototype, "CountryOrRegion", {
        get: function () {
            return this.propertyBag._getItem("CountryOrRegion");
        },
        set: function (value) {
            this.propertyBag._setItem("CountryOrRegion", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PhysicalAddressEntry.prototype, "PostalCode", {
        get: function () {
            return this.propertyBag._getItem("PostalCode");
        },
        set: function (value) {
            this.propertyBag._setItem("PostalCode", value);
        },
        enumerable: true,
        configurable: true
    });
    PhysicalAddressEntry.prototype.ClearChangeLog = function () { this.propertyBag.ClearChangeLog(); };
    PhysicalAddressEntry.prototype.GetFieldUri = function (xmlElementName) { return "contacts:PhysicalAddress:" + xmlElementName; };
    PhysicalAddressEntry.prototype.InternalToJson = function (service) { throw new Error("PhysicalAddressEntry.ts - InternalToJson : Not implemented."); };
    /**@internal */
    PhysicalAddressEntry.prototype.InternalWriteDeleteFieldToXml = function (writer, ewsObject, fieldXmlElementName) {
        writer.WriteStartElement(XmlNamespace.Types, ewsObject.GetDeleteFieldXmlElementName());
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.IndexedFieldURI);
        writer.WriteAttributeValue(XmlAttributeNames.FieldURI, this.GetFieldUri(fieldXmlElementName));
        writer.WriteAttributeValue(XmlAttributeNames.FieldIndex, PhysicalAddressKey[this.Key]);
        writer.WriteEndElement(); // IndexedFieldURI
        writer.WriteEndElement(); // ewsObject.GetDeleteFieldXmlElementName()
    };
    PhysicalAddressEntry.prototype.InternalWriteDeleteUpdateToJson = function (ewsObject, propertyName, updates /*System.Collections.Generic.List<any>*/) { throw new Error("PhysicalAddressEntry.ts - InternalWriteDeleteUpdateToJson : Not implemented."); };
    PhysicalAddressEntry.prototype.LoadFromJson = function (jsonProperty, service) { throw new Error("PhysicalAddressEntry.ts - LoadFromJson : Not implemented."); };
    PhysicalAddressEntry.prototype.PropertyBagChanged = function () { this.Changed(); };
    PhysicalAddressEntry.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        this.Key = PhysicalAddressKey[jsonProperty[XmlAttributeNames.Key]];
        this.Street = jsonProperty[XmlElementNames.Street];
        this.City = jsonProperty[XmlElementNames.City];
        this.State = jsonProperty[XmlElementNames.State];
        this.Street = jsonProperty[XmlElementNames.Street];
        this.CountryOrRegion = jsonProperty[XmlElementNames.CountryOrRegion];
        this.PostalCode = jsonProperty[XmlElementNames.PostalCode];
    };
    PhysicalAddressEntry.prototype.WriteDeleteUpdateToJson = function (service, ewsObject, updates /*System.Collections.Generic.List<any>*/) { throw new Error("PhysicalAddressEntry.ts - WriteDeleteUpdateToJson : Not implemented."); };
    /**@internal */
    PhysicalAddressEntry.prototype.WriteDeleteUpdateToXml = function (writer, ewsObject) {
        for (var _a = 0, _b = PhysicalAddressSchema.XmlElementNames; _a < _b.length; _a++) {
            var xmlElementName = _b[_a];
            this.InternalWriteDeleteFieldToXml(writer, ewsObject, xmlElementName);
        }
        return true;
    };
    /**@internal */
    PhysicalAddressEntry.prototype.WriteElementsToXml = function (writer) {
        for (var _a = 0, _b = PhysicalAddressSchema.XmlElementNames; _a < _b.length; _a++) {
            var xmlElementName = _b[_a];
            writer.WriteElementValue(XmlNamespace.Types, xmlElementName, this.propertyBag._getItem(xmlElementName));
        }
    };
    PhysicalAddressEntry.prototype.WriteSetUpdateToJson = function (service, ewsObject, propertyDefinition, updates /*System.Collections.Generic.List<JsonObject>*/) { throw new Error("PhysicalAddressEntry.ts - WriteSetUpdateToJson : Not implemented."); };
    /**@internal */
    PhysicalAddressEntry.prototype.WriteSetUpdateToXml = function (writer, ewsObject, ownerDictionaryXmlElementName) {
        var fieldsToSet = [];
        for (var _a = 0, _b = this.propertyBag.AddedItems; _a < _b.length; _a++) {
            var xmlElementName = _b[_a];
            fieldsToSet.push(xmlElementName);
        }
        for (var _c = 0, _d = this.propertyBag.ModifiedItems; _c < _d.length; _c++) {
            var xmlElementName = _d[_c];
            fieldsToSet.push(xmlElementName);
        }
        for (var _e = 0, fieldsToSet_1 = fieldsToSet; _e < fieldsToSet_1.length; _e++) {
            var xmlElementName = fieldsToSet_1[_e];
            writer.WriteStartElement(XmlNamespace.Types, ewsObject.GetSetFieldXmlElementName());
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.IndexedFieldURI);
            writer.WriteAttributeValue(XmlAttributeNames.FieldURI, this.GetFieldUri(xmlElementName));
            writer.WriteAttributeValue(XmlAttributeNames.FieldIndex, PhysicalAddressKey[this.Key]);
            writer.WriteEndElement(); // IndexedFieldURI
            writer.WriteStartElement(XmlNamespace.Types, ewsObject.GetXmlElementName());
            writer.WriteStartElement(XmlNamespace.Types, ownerDictionaryXmlElementName);
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Entry);
            this.WriteAttributesToXml(writer);
            writer.WriteElementValue(XmlNamespace.Types, xmlElementName, this.propertyBag._getItem(xmlElementName));
            writer.WriteEndElement(); // Entry
            writer.WriteEndElement(); // ownerDictionaryXmlElementName
            writer.WriteEndElement(); // ewsObject.GetXmlElementName()
            writer.WriteEndElement(); // ewsObject.GetSetFieldXmlElementName()
        }
        for (var _f = 0, _g = this.propertyBag.RemovedItems; _f < _g.length; _f++) {
            var xmlElementName = _g[_f];
            this.InternalWriteDeleteFieldToXml(writer, ewsObject, xmlElementName);
        }
        return true;
    };
    return PhysicalAddressEntry;
}(DictionaryEntryProperty));
exports.PhysicalAddressEntry = PhysicalAddressEntry;
/**
 * Represents a generic dictionary that can be sent to or retrieved from EWS.
 *
 * @typeparam   <TKey>      The type of key.
 * @typeparam   <TEntry>    The type of entry.
 */
var DictionaryProperty = (function (_super) {
    __extends(DictionaryProperty, _super);
    /**
     * @internal Initializes a new instance of the **DictionaryProperty** class.
     *
     * @param   {DictionaryKeyType}	dictionaryKeyType	Dictionary Key type, needed to workaround c# type checking of generics.
     */
    function DictionaryProperty(dictionaryKeyType) {
        var _this = _super.call(this) || this;
        _this.dictionaryKeyType = DictionaryKeyType.EmailAddressKey;
        _this.dictionaryKeyDelegate = function (key) { return _this.dictionaryKeyTypeEnum[key]; };
        _this.entries = new Dictionary(_this.dictionaryKeyDelegate);
        _this.removedEntries = new Dictionary(_this.dictionaryKeyDelegate);
        _this.addedEntries = [];
        _this.modifiedEntries = [];
        _this.dictionaryKeyType = dictionaryKeyType;
        _this.dictionaryKeyTypeEnum = EwsUtilities.GetDictionaryKeyTypeEnum(_this.dictionaryKeyType);
        return _this;
    }
    Object.defineProperty(DictionaryProperty.prototype, "Entries", {
        /**
         * Gets the entries.
         *
         * @value   The entries.
         */
        get: function () {
            return this.entries;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Clears the change log.
     */
    DictionaryProperty.prototype.ClearChangeLog = function () {
        this.addedEntries.splice(0);
        this.removedEntries.clear();
        this.modifiedEntries.splice(0);
        for (var _a = 0, _b = this.entries.Values; _a < _b.length; _a++) {
            var entry = _b[_a];
            entry.ClearChangeLog();
        }
    };
    /**
     * Determines whether this instance contains the specified key.
     *
     * @param   {TKey}      key   The key.
     * @return  {boolean}   true if this instance contains the specified key; otherwise, false.
     */
    DictionaryProperty.prototype.Contains = function (key) {
        return this.Entries.containsKey(key);
    };
    /**
     * @internal Creates the entry.
     *
     * @return  {TEntry}  Dictionary entry.
     */
    DictionaryProperty.prototype.CreateEntry = function () {
        return this.CreateEntryInstance();
    };
    /**
     * Entry was changed.
     *
     * @param   {}   complexProperty   The complex property.
     */
    DictionaryProperty.prototype.EntryChanged = function (complexProperty) {
        var key = complexProperty.Key;
        if (this.addedEntries.indexOf(key) === -1 && this.modifiedEntries.indexOf(key) === -1) {
            this.modifiedEntries.push(key);
            this.Changed();
        }
    };
    /**
     * @internal Gets the name of the entry XML element.
     *
     * @param   {TEntry}    entry   The entry.
     * @return  {string}    XML element name.
     */
    DictionaryProperty.prototype.GetEntryXmlElementName = function (entry) {
        return XmlElementNames.Entry;
    };
    /**
     * @internal Gets the index of the field.
     *
     * @param   {TKey}      key   The key.
     * @return  {string}    Key index.
     */
    DictionaryProperty.prototype.GetFieldIndex = function (key) {
        return this.dictionaryKeyTypeEnum[key];
    };
    /**
     * @internal Gets the field URI.
     *
     * @return  {string}      Field URI.
     */
    DictionaryProperty.prototype.GetFieldURI = function () {
        return null;
    };
    /**
     * @internal Add entry.
     *
     * @param   {TEntry}   entry   The entry.
     */
    DictionaryProperty.prototype.InternalAdd = function (entry) {
        entry.OnChange.push(this.EntryChanged.bind(this));
        this.entries.Add(entry.Key, entry);
        this.addedEntries.push(entry.Key);
        this.removedEntries.remove(entry.Key);
        this.Changed();
    };
    /**
     * @internal Add or replace entry.
     *
     * @param   {TEntry}   entry   The entry.
     */
    DictionaryProperty.prototype.InternalAddOrReplace = function (entry) {
        var oldEntry = { outValue: null };
        if (this.entries.tryGetValue(entry.Key, oldEntry)) {
            ArrayHelper.RemoveEntry(oldEntry.outValue.OnChange, this.EntryChanged);
            entry.OnChange.push(this.EntryChanged.bind(this));
            if (this.addedEntries.indexOf(entry.Key) === -1) {
                if (this.modifiedEntries.indexOf(entry.Key) === -1) {
                    this.modifiedEntries.push(entry.Key);
                }
            }
            this.Changed();
        }
        else {
            this.InternalAdd(entry);
        }
    };
    /**
     * Remove entry based on key.
     *
     * @param   {TKey}   key   The key.
     */
    DictionaryProperty.prototype.InternalRemove = function (key) {
        var entry = { outValue: null };
        if (this.entries.tryGetValue(key, entry)) {
            ArrayHelper.RemoveEntry(entry.outValue.OnChange, this.EntryChanged);
            this.entries.remove(key);
            this.removedEntries.Add(key, entry.outValue);
            this.Changed();
        }
        ArrayHelper.RemoveEntry(this.addedEntries, key);
        ArrayHelper.RemoveEntry(this.modifiedEntries, key);
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    DictionaryProperty.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        if (jsonProperty[XmlElementNames.Entry]) {
            var entries = EwsServiceJsonReader.ReadAsArray(jsonProperty, XmlElementNames.Entry);
            for (var _a = 0, entries_1 = entries; _a < entries_1.length; _a++) {
                var jsonEntry = entries_1[_a];
                var entry = this.CreateEntryInstance();
                entry.LoadFromXmlJsObject(jsonEntry, service);
                this.InternalAdd(entry);
            }
        }
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    DictionaryProperty.prototype.WriteElementsToXml = function (writer) {
        for (var _a = 0, _b = this.entries.Items; _a < _b.length; _a++) {
            var keyValuePair = _b[_a];
            keyValuePair.value.WriteToXml(writer, this.GetEntryXmlElementName(keyValuePair.value));
        }
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {XmlNamespace}          xmlNamespace     The XML namespace.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    DictionaryProperty.prototype.WriteToXml = function (writer, xmlElementName, xmlNamespace) {
        // Only write collection if it has at least one element.
        if (this.entries.Count > 0) {
            _super.prototype.WriteToXml.call(this, writer, xmlElementName, xmlNamespace);
        }
    };
    /**
     * Writes the URI to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     * @param   {TKey}                  key      The key.
     */
    DictionaryProperty.prototype.WriteUriToXml = function (writer, key) {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.IndexedFieldURI);
        writer.WriteAttributeValue(XmlAttributeNames.FieldURI, this.GetFieldURI());
        writer.WriteAttributeValue(XmlAttributeNames.FieldIndex, this.GetFieldIndex(key));
        writer.WriteEndElement();
    };
    /**
     * @internal Writes the update to XML.
     * ICustomUpdateSerializer.WriteSetUpdateToXml
     *
     * @param   {EwsServiceXmlWriter}   writer               The writer.
     * @param   {ServiceObject}         ewsObject            The ews object.
     * @param   {PropertyDefinition}    propertyDefinition   Property definition.
     * @return  {boolean}               True if property generated serialization.
     */
    DictionaryProperty.prototype.WriteSetUpdateToXml = function (writer, ewsObject, propertyDefinition) {
        var tempEntries = [];
        for (var _a = 0, _b = this.addedEntries; _a < _b.length; _a++) {
            var key = _b[_a];
            tempEntries.push(this.entries.get(key));
        }
        for (var _c = 0, _d = this.modifiedEntries; _c < _d.length; _c++) {
            var key = _d[_c];
            tempEntries.push(this.entries.get(key));
        }
        for (var _e = 0, tempEntries_1 = tempEntries; _e < tempEntries_1.length; _e++) {
            var entry = tempEntries_1[_e];
            if (!entry.WriteSetUpdateToXml(writer, ewsObject, propertyDefinition.XmlElementName)) {
                writer.WriteStartElement(XmlNamespace.Types, ewsObject.GetSetFieldXmlElementName());
                this.WriteUriToXml(writer, entry.Key);
                writer.WriteStartElement(XmlNamespace.Types, ewsObject.GetXmlElementName());
                writer.WriteStartElement(XmlNamespace.Types, propertyDefinition.XmlElementName);
                entry.WriteToXml(writer, this.GetEntryXmlElementName(entry));
                writer.WriteEndElement();
                writer.WriteEndElement();
                writer.WriteEndElement();
            }
        }
        for (var _f = 0, _g = this.removedEntries.Values; _f < _g.length; _f++) {
            var entry = _g[_f];
            if (!entry.WriteDeleteUpdateToXml(writer, ewsObject)) {
                writer.WriteStartElement(XmlNamespace.Types, ewsObject.GetDeleteFieldXmlElementName());
                this.WriteUriToXml(writer, entry.Key);
                writer.WriteEndElement();
            }
        }
        return true;
    };
    /**
     * @internal Writes the deletion update to XML.
     * ICustomUpdateSerializer.WriteDeleteUpdateToXml
     *
     * @param   {EwsServiceXmlWriter}   writer      The writer.
     * @param   {ServiceObject}         ewsObject   The ews object.
     * @return  {boolean}               True if property generated serialization.
     */
    DictionaryProperty.prototype.WriteDeleteUpdateToXml = function (writer, ewsObject) {
        // Use the default XML serializer.
        return false;
    };
    return DictionaryProperty;
}(ComplexProperty));
exports.DictionaryProperty = DictionaryProperty;
var EmailAddressDictionary = (function (_super) {
    __extends(EmailAddressDictionary, _super);
    function EmailAddressDictionary() {
        return _super.call(this, DictionaryKeyType.EmailAddressKey) || this;
    }
    /**
     * Gets or sets the e-mail address at the specified key.
     *
     * @param   {EmailAddressKey}   key   The key of the e-mail address to get or set.
     * @return  {EmailAddress}         The e-mail address at the specified key.
     */
    EmailAddressDictionary.prototype._getItem = function (key) {
        return this.Entries.get(key).EmailAddress;
    };
    /**
     * Gets or sets the e-mail address at the specified key.
     *
     * @param   {EmailAddressKey}   key   The key of the e-mail address to get or set.
     * @return  {EmailAddress}         The e-mail address at the specified key.
     */
    EmailAddressDictionary.prototype._setItem = function (key, value) {
        if (value == null) {
            this.InternalRemove(key);
        }
        else {
            var entry = { outValue: null };
            if (this.Entries.tryGetValue(key, entry)) {
                entry.outValue.EmailAddress = value;
                this.Changed();
            }
            else {
                var newEntry = new EmailAddressEntry(key, value);
                this.InternalAdd(newEntry);
            }
        }
    };
    /**
     * @internal Creates instance of dictionary entry.
     *
     * @return  {EmailAddressEntry}      New instance.
     */
    EmailAddressDictionary.prototype.CreateEntryInstance = function () { return new EmailAddressEntry(); };
    /**
     * @internal Gets the field URI.
     *
     * @return  {string}      Field URI.
     */
    EmailAddressDictionary.prototype.GetFieldURI = function () { return "contacts:EmailAddress"; };
    /**
     * Tries to get the e-mail address associated with the specified key.
     *
     * @param   {EmailAddressKey}   key            The key.
     * @param   {IOutParam<EmailAddress>}   emailAddress   When this method returns, contains the e-mail address associated with the specified key, if the key is found; otherwise, null. This parameter is passed uninitialized.
     * @return  {boolean}                  true if the Dictionary contains an e-mail address associated with the specified key; otherwise, false.
     */
    EmailAddressDictionary.prototype.TryGetValue = function (key, emailAddress) {
        var entry = null;
        if (this.Entries.tryGetValue(key, entry)) {
            emailAddress.outValue = entry.outValue.EmailAddress;
            return true;
        }
        else {
            emailAddress = null;
            return false;
        }
    };
    return EmailAddressDictionary;
}(DictionaryProperty));
exports.EmailAddressDictionary = EmailAddressDictionary;
var ImAddressDictionary = (function (_super) {
    __extends(ImAddressDictionary, _super);
    function ImAddressDictionary() {
        return _super.call(this, DictionaryKeyType.ImAddressKey) || this;
    }
    ImAddressDictionary.prototype._getItem = function (key) {
        return this.Entries.get(key).ImAddress;
    };
    ImAddressDictionary.prototype._setItem = function (key, value) {
        if (value == null) {
            this.InternalRemove(key);
        }
        else {
            var entry = { outValue: null };
            if (this.Entries.tryGetValue(key, entry)) {
                entry.outValue.ImAddress = value;
                this.Changed();
            }
            else {
                var newEntry = new ImAddressEntry(key, value);
                this.InternalAdd(newEntry);
            }
        }
    };
    ImAddressDictionary.prototype.CreateEntryInstance = function () { return new ImAddressEntry(); };
    ImAddressDictionary.prototype.GetFieldURI = function () { return "contacts:ImAddress"; };
    ImAddressDictionary.prototype.TryGetValue = function (key, imAddress) {
        var entry = { outValue: null };
        if (this.Entries.tryGetValue(key, entry)) {
            imAddress.outValue = entry.outValue.ImAddress;
            return true;
        }
        else {
            imAddress.outValue = null;
            return false;
        }
    };
    return ImAddressDictionary;
}(DictionaryProperty));
exports.ImAddressDictionary = ImAddressDictionary;
var PhoneNumberDictionary = (function (_super) {
    __extends(PhoneNumberDictionary, _super);
    function PhoneNumberDictionary() {
        return _super.call(this, DictionaryKeyType.PhoneNumberKey) || this;
    }
    PhoneNumberDictionary.prototype._getItem = function (key) {
        return this.Entries.get(key).PhoneNumber;
    };
    PhoneNumberDictionary.prototype._setItem = function (key, value) {
        if (value == null) {
            this.InternalRemove(key);
        }
        else {
            var entry = { outValue: null };
            if (this.Entries.tryGetValue(key, entry)) {
                entry.outValue.PhoneNumber = value;
                this.Changed();
            }
            else {
                var newEntry = new PhoneNumberEntry(key, value);
                this.InternalAdd(newEntry);
            }
        }
    };
    PhoneNumberDictionary.prototype.CreateEntryInstance = function () { return new PhoneNumberEntry(); };
    PhoneNumberDictionary.prototype.GetFieldURI = function () { return "contacts:PhoneNumber"; };
    PhoneNumberDictionary.prototype.TryGetValue = function (key, phoneNumber) {
        var entry = { outValue: null };
        if (this.Entries.tryGetValue(key, entry)) {
            phoneNumber.outValue = entry.outValue.PhoneNumber;
            return true;
        }
        else {
            phoneNumber = null;
            return false;
        }
    };
    return PhoneNumberDictionary;
}(DictionaryProperty));
exports.PhoneNumberDictionary = PhoneNumberDictionary;
var PhysicalAddressDictionary = (function (_super) {
    __extends(PhysicalAddressDictionary, _super);
    function PhysicalAddressDictionary() {
        return _super.call(this, DictionaryKeyType.PhysicalAddressKey) || this;
    }
    PhysicalAddressDictionary.prototype._getItem = function (key) {
        return this.Entries.get(key);
    };
    PhysicalAddressDictionary.prototype._setItem = function (key, value) {
        if (value == null) {
            this.InternalRemove(key);
        }
        else {
            value.Key = key;
            this.InternalAddOrReplace(value);
        }
    };
    PhysicalAddressDictionary.prototype.CreateEntryInstance = function () { return new PhysicalAddressEntry(); };
    PhysicalAddressDictionary.prototype.TryGetValue = function (key, physicalAddress) { return this.Entries.tryGetValue(key, physicalAddress); };
    return PhysicalAddressDictionary;
}(DictionaryProperty));
exports.PhysicalAddressDictionary = PhysicalAddressDictionary;
/**
 * Represents an e-mail address.
 */
var EmailAddress = (function (_super) {
    __extends(EmailAddress, _super);
    function EmailAddress(smtpAddressOrNameOrMailbox, smtpAddressOrAddress, routingType, mailboxType, itemId) {
        var _this = _super.call(this) || this;
        /**
         * Display name.
         */
        _this.name = null;
        /**
         * Email address.
         */
        _this.address = null;
        /**
         * Routing type.
         */
        _this.routingType = null;
        /**
         * Mailbox type.
         */
        _this.mailboxType = null;
        /**
         * ItemId - Contact or PDL.
         */
        _this.id = null;
        if (smtpAddressOrNameOrMailbox instanceof EmailAddress) {
            EwsUtilities.ValidateParam(smtpAddressOrNameOrMailbox, "mailbox");
            _this.Name = smtpAddressOrNameOrMailbox.Name;
            _this.Address = smtpAddressOrNameOrMailbox.Address;
            _this.RoutingType = smtpAddressOrNameOrMailbox.RoutingType;
            _this.MailboxType = smtpAddressOrNameOrMailbox.MailboxType;
            _this.Id = smtpAddressOrNameOrMailbox.Id;
        }
        else {
            var argsLength = arguments.length;
            if (argsLength === 1) {
                _this.address = smtpAddressOrNameOrMailbox;
            }
            else if (argsLength > 1) {
                _this.name = smtpAddressOrNameOrMailbox;
                _this.address = smtpAddressOrAddress;
                if (argsLength >= 3) {
                    _this.routingType = routingType;
                }
                if (argsLength >= 4) {
                    _this.mailboxType = mailboxType;
                }
                if (argsLength === 5) {
                    _this.id = itemId;
                }
            }
        }
        return _this;
    }
    Object.defineProperty(EmailAddress.prototype, "Name", {
        /**
         * Gets or sets the name associated with the e-mail address.
         */
        get: function () {
            return this.name;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.name; }, setValue: function (updateValue) { _this.name = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailAddress.prototype, "Address", {
        /**
         * Gets or sets the actual address associated with the e-mail address. The type of the Address property must match the specified routing type. If RoutingType is not set, Address is assumed to be an SMTP address.
         */
        get: function () {
            return this.address;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.address; }, setValue: function (updateValue) { _this.address = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailAddress.prototype, "RoutingType", {
        /**
         * Gets or sets the routing type associated with the e-mail address. If RoutingType is not set, Address is assumed to be an SMTP address.
         */
        get: function () {
            return this.routingType;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.routingType; }, setValue: function (updateValue) { _this.routingType = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailAddress.prototype, "MailboxType", {
        /**
         * Gets or sets the type of the e-mail address.
         */
        get: function () {
            return this.mailboxType;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.mailboxType; }, setValue: function (updateValue) { _this.mailboxType = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailAddress.prototype, "Id", {
        /**
         * Gets or sets the Id of the contact the e-mail address represents. When Id is specified, Address should be set to null.
         */
        get: function () {
            return this.id;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.id; }, setValue: function (updateValue) { _this.id = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get a string representation for using this instance in a search filter.
     * ISearchStringProvider.GetSearchString
     *
     * @return  {string}      String representation of instance.
     */
    EmailAddress.prototype.GetSearchString = function () {
        return this.Address;
    };
    EmailAddress.prototype.ReadElementsFromXmlJsObject = function (reader) { throw new Error("EmailAddress.ts - TryReadElementFromXmlJsObject : Not implemented."); };
    //todo: implement UpdateFromXmlJsObject
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    EmailAddress.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.Name:
                    this.name = jsObject[key];
                    break;
                case XmlElementNames.EmailAddress:
                    this.address = jsObject[key];
                    break;
                case XmlElementNames.RoutingType:
                    this.routingType = jsObject[key];
                    break;
                case XmlElementNames.MailboxType:
                    this.mailboxType = MailboxType.FromEwsEnumString(jsObject[key]);
                    break;
                case XmlElementNames.ItemId:
                    this.id = new ItemId();
                    this.id.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * Returns a **string** that represents the current **object**.
     *
     * @return  {string}      A **string** that represents the current **object**.
     */
    EmailAddress.prototype.ToString = function () {
        var addressPart = null;
        if (StringHelper.IsNullOrEmpty(this.Address)) {
            return StringHelper.Empty;
        }
        if (!StringHelper.IsNullOrEmpty(this.RoutingType)) {
            addressPart = this.RoutingType + ":" + this.Address;
        }
        else {
            addressPart = this.Address;
        }
        if (!StringHelper.IsNullOrEmpty(this.Name)) {
            return this.Name + " <" + addressPart + ">";
        }
        else {
            return addressPart;
        }
    };
    EmailAddress.prototype.toString = function () {
        return this.ToString();
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    EmailAddress.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Name, this.Name);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.EmailAddress, this.Address);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.RoutingType, this.RoutingType);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.MailboxType, MailboxType.ToEwsEnumString(this.MailboxType));
        if (this.Id != null) {
            this.Id.WriteToXml(writer); //, XmlElementNames.ItemId);
        }
    };
    /**
     * SMTP routing type.
     */
    EmailAddress.SmtpRoutingType = "SMTP";
    return EmailAddress;
}(ComplexProperty));
exports.EmailAddress = EmailAddress;
/**
 * Represents an attendee to a meeting.
 */
var Attendee = (function (_super) {
    __extends(Attendee, _super);
    function Attendee(smtpAddressOrNameOrMailbox, smtpAddress, routingType) {
        var _this = this;
        switch (arguments.length) {
            case 1:
                _this = _super.call(this, smtpAddressOrNameOrMailbox) || this;
                if (typeof smtpAddressOrNameOrMailbox === 'string') {
                    EwsUtilities.ValidateParam(smtpAddressOrNameOrMailbox, "smtpAddress");
                }
                break;
            case 2:
                _this = _super.call(this, smtpAddressOrNameOrMailbox, smtpAddress) || this;
                break;
            case 3:
                _this = _super.call(this, smtpAddressOrNameOrMailbox, smtpAddress, routingType) || this;
                break;
            default:
                _this = _super.call(this) || this;
                break;
        }
        _this.responseType = null;
        _this.lastResponseTime = null;
        return _this;
    }
    Object.defineProperty(Attendee.prototype, "ResponseType", {
        /**
         * Gets the type of response the attendee gave to the meeting invitation it received.
         */
        get: function () {
            return this.responseType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Attendee.prototype, "LastResponseTime", {
        /**
         * Gets the date and time when the attendee last responded to a meeting invitation or update.
         */
        get: function () {
            return this.lastResponseTime;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    Attendee.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            if (key.indexOf("__") === 0) {
                continue;
            }
            switch (key) {
                case XmlElementNames.Mailbox:
                    _super.prototype.LoadFromXmlJsObject.call(this, jsObject[key], service);
                    break;
                case XmlElementNames.ResponseType:
                    this.responseType = MeetingResponseType[jsObject[key]];
                    break;
                case XmlElementNames.LastResponseTime:
                    this.lastResponseTime = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    Attendee.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(this.Namespace, XmlElementNames.Mailbox);
        _super.prototype.WriteElementsToXml.call(this, writer);
        writer.WriteEndElement();
    };
    return Attendee;
}(EmailAddress));
exports.Attendee = Attendee;
/**
 * Represents an ExtractedEntity object.
 */
var ExtractedEntity = (function (_super) {
    __extends(ExtractedEntity, _super);
    /**
     * Initializes a new instance of the **ExtractedEntity** class.
     */
    function ExtractedEntity() {
        var _this = _super.call(this) || this;
        /**
         * Gets the Position.
         */
        _this.Position = EmailPosition.LatestReply;
        _this.Namespace = XmlNamespace.Types;
        return _this;
    }
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    ExtractedEntity.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        if (jsObject[XmlElementNames.NlgEmailPosition]) {
            this.Position = EmailPosition[jsObject[XmlElementNames.NlgEmailPosition]] || this.Position;
        }
        // for (let key in jsObject) {
        //     switch (key) {
        //         case XmlElementNames.NlgEmailPosition:
        //             this.Position = EmailPosition[<string>jsObject[key]] || this.Position;
        //             break;
        //         default:
        //             break;
        //     }
        // }
    };
    return ExtractedEntity;
}(ComplexProperty));
exports.ExtractedEntity = ExtractedEntity;
/**
 * Represents an AddressEntity object.
 */
var AddressEntity = (function (_super) {
    __extends(AddressEntity, _super);
    /**
     * Initializes a new instance of the **AddressEntity** class.
     */
    function AddressEntity() {
        return _super.call(this) || this;
    }
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    AddressEntity.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.NlgAddress:
                    this.Address = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    };
    return AddressEntity;
}(ExtractedEntity));
exports.AddressEntity = AddressEntity;
/**
 * Represents an ContactEntity object.
 */
var ContactEntity = (function (_super) {
    __extends(ContactEntity, _super);
    /**
     * Initializes a new instance of the **ContactEntity** class.
     */
    function ContactEntity() {
        var _this = _super.call(this) || this;
        /**
         * Gets the contact entity PersonName.
         */
        _this.PersonName = null;
        /**
         * Gets the contact entity BusinessName.
         */
        _this.BusinessName = null;
        /**
         * Gets the contact entity PhoneNumbers.
         */
        _this.PhoneNumbers = null;
        /**
         * Gets the contact entity Urls.
         */
        _this.Urls = null;
        /**
         * Gets the contact entity EmailAddresses.
         */
        _this.EmailAddresses = null;
        /**
         * Gets the contact entity Addresses.
         */
        _this.Addresses = null;
        /**
         * Gets the contact entity ContactString.
         */
        _this.ContactString = null;
        return _this;
    }
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    ContactEntity.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.NlgPersonName:
                    this.PersonName = jsObject[key];
                    break;
                case XmlElementNames.NlgBusinessName:
                    this.BusinessName = jsObject[key];
                    break;
                case XmlElementNames.NlgPhoneNumbers:
                    this.PhoneNumbers = new ContactPhoneEntityCollection();
                    this.PhoneNumbers.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.NlgUrls:
                    this.Urls = new StringList(XmlElementNames.NlgUrl);
                    this.Urls.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.NlgEmailAddresses:
                    this.EmailAddresses = new StringList(XmlElementNames.NlgEmailAddress);
                    this.EmailAddresses.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.NlgAddresses:
                    this.EmailAddresses = new StringList(XmlElementNames.NlgEmailAddress);
                    this.Addresses.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.NlgContactString:
                    this.ContactString = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    };
    return ContactEntity;
}(ExtractedEntity));
exports.ContactEntity = ContactEntity;
/**
 * Represents an EmailAddressEntity object.
 */
var EmailAddressEntity = (function (_super) {
    __extends(EmailAddressEntity, _super);
    /**
     * @internal Initializes a new instance of the **EmailAddressEntity** class.
     */
    function EmailAddressEntity() {
        return _super.call(this) || this;
    }
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    EmailAddressEntity.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.NlgEmailAddress:
                    this.EmailAddress = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    };
    return EmailAddressEntity;
}(ExtractedEntity));
exports.EmailAddressEntity = EmailAddressEntity;
/**
 * Represents an MeetingSuggestion object.
 */
var MeetingSuggestion = (function (_super) {
    __extends(MeetingSuggestion, _super);
    /**
     * @internal Initializes a new instance of the **MeetingSuggestion** class.
     */
    function MeetingSuggestion() {
        var _this = _super.call(this) || this;
        /**
         * Gets the meeting suggestion Attendees.
         */
        _this.Attendees = null;
        /**
         * Gets the meeting suggestion Location.
         */
        _this.Location = null;
        /**
         * Gets the meeting suggestion Subject.
         */
        _this.Subject = null;
        /**
         * Gets the meeting suggestion MeetingString.
         */
        _this.MeetingString = null;
        /**
         * Gets the meeting suggestion StartTime.
         */
        _this.StartTime = null;
        /**
         * Gets the meeting suggestion EndTime.
         */
        _this.EndTime = null;
        return _this;
    }
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    MeetingSuggestion.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.NlgAttendees:
                    this.Attendees = new EmailUserEntityCollection();
                    this.Attendees.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.NlgLocation:
                    this.Location = jsObject[key];
                    break;
                case XmlElementNames.NlgSubject:
                    this.Subject = jsObject[key];
                    break;
                case XmlElementNames.NlgMeetingString:
                    this.MeetingString = jsObject[key];
                    break;
                case XmlElementNames.NlgStartTime:
                    this.StartTime = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                case XmlElementNames.NlgEndTime:
                    this.EndTime = service.ConvertUniversalDateTimeStringToLocalDateTime(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    };
    return MeetingSuggestion;
}(ExtractedEntity));
exports.MeetingSuggestion = MeetingSuggestion;
/**
 * Represents an PhoneEntity object.
 */
var PhoneEntity = (function (_super) {
    __extends(PhoneEntity, _super);
    /**
     * @internal Initializes a new instance of the **PhoneEntity** class.
     */
    function PhoneEntity() {
        return _super.call(this) || this;
    }
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    PhoneEntity.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.NlgOriginalPhoneString:
                    this.OriginalPhoneString = jsObject[key];
                    break;
                case XmlElementNames.NlgPhoneString:
                    this.PhoneString = jsObject[key];
                    break;
                case XmlElementNames.NlgType:
                    this.Type = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    };
    return PhoneEntity;
}(ExtractedEntity));
exports.PhoneEntity = PhoneEntity;
/**
 * Represents an TaskSuggestion object.
 */
var TaskSuggestion = (function (_super) {
    __extends(TaskSuggestion, _super);
    /**
     * @internal Initializes a new instance of the **TaskSuggestion** class.
     */
    function TaskSuggestion() {
        return _super.call(this) || this;
    }
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    TaskSuggestion.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.NlgTaskString:
                    this.TaskString = jsObject[key];
                    break;
                case XmlElementNames.NlgAssignees:
                    this.Assignees = new EmailUserEntityCollection();
                    this.Assignees.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                default:
                    break;
            }
        }
    };
    return TaskSuggestion;
}(ExtractedEntity));
exports.TaskSuggestion = TaskSuggestion;
/**
 * Represents an UrlEntity object.
 */
var UrlEntity = (function (_super) {
    __extends(UrlEntity, _super);
    /**
     * Initializes a new instance of the **UrlEntity** class.
     */
    function UrlEntity() {
        return _super.call(this) || this;
    }
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    UrlEntity.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.NlgUrl:
                    this.Url = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    };
    return UrlEntity;
}(ExtractedEntity));
exports.UrlEntity = UrlEntity;
var MessageBody = (function (_super) {
    __extends(MessageBody, _super);
    function MessageBody(bodyTypeOrText, text) {
        var _this = _super.call(this) || this;
        _this.bodyType = 0;
        _this.text = null;
        var argslength = arguments.length;
        if (argslength === 0) {
            return _this;
        }
        var bodyType = BodyType.HTML;
        var strText = text;
        if (argslength === 1 && typeof bodyTypeOrText === "string") {
            strText = bodyTypeOrText;
        }
        if (argslength === 2 && typeof bodyTypeOrText === "number") {
            bodyType = bodyTypeOrText;
        }
        _this.bodyType = bodyType;
        _this.text = strText;
        return _this;
    }
    Object.defineProperty(MessageBody.prototype, "BodyType", {
        get: function () {
            return this.bodyType;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.bodyType; }, setValue: function (bodytype) { return _this.bodyType = bodytype; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MessageBody.prototype, "Text", {
        get: function () {
            return this.text;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.text; }, setValue: function (txt) { return _this.text = txt; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    MessageBody.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            if (key.indexOf("__") === 0) {
                continue;
            }
            switch (key) {
                case XmlAttributeNames.BodyType:
                    this.bodyType = BodyType[jsObject[key]];
                    break;
                case XmlElementNames.Body: //info - Body Element text - custom parser in ews-javascript-api. 
                case XmlElementNames.TextBody://info - TextBody Element text - custom parser in ews-javascript-api. 
                    this.text = jsObject[key];
                    break;
                case XmlAttributeNames.IsTruncated:
                    //ref: IsTruncated not captured 
                    break;
                default:
                    debugger; //check exact name of body element
                    break;
            }
        }
    };
    /**@internal */
    MessageBody.prototype.ReadAttributesFromXmlJsObject = function (reader) { throw new Error("MessageBody.ts - ReadAttributesFromXml : Not implemented. - should not be called"); };
    /**@internal */
    MessageBody.prototype.ReadTextValueFromXmlJsObject = function (reader) { throw new Error("MessageBody.ts - ReadTextValueFromXml : Not implemented. - should not be called"); };
    MessageBody.prototype.ToString = function () { return (this.Text == null) ? StringHelper.Empty : this.Text; };
    /**@internal */
    MessageBody.prototype.WriteAttributesToXml = function (writer) { writer.WriteAttributeValue(XmlAttributeNames.BodyType, BodyType[this.BodyType]); };
    /**@internal */
    MessageBody.prototype.WriteElementsToXml = function (writer) {
        if (!StringHelper.IsNullOrEmpty(this.Text)) {
            writer.WriteValue(this.Text, XmlElementNames.Body);
        }
    };
    return MessageBody;
}(ComplexProperty));
exports.MessageBody = MessageBody;
/**
 * Represents the body of a message.
 */
var TextBody = (function (_super) {
    __extends(TextBody, _super);
    function TextBody(text) {
        if (text === void 0) { text = null; }
        var _this = this;
        arguments.length === 0 ? _this = _super.call(this) || this : _this = _super.call(this, BodyType.Text, text) || this;
        return _this;
    }
    return TextBody;
}(MessageBody));
exports.TextBody = TextBody;
/**
 * Represents the MIME content of an item.
 */
var MimeContentBase = (function (_super) {
    __extends(MimeContentBase, _super);
    function MimeContentBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * to set XMLElementName when reading XML JsObject value.
         */
        _this.xmlElementName = XmlElementNames.MimeContent;
        return _this;
    }
    Object.defineProperty(MimeContentBase.prototype, "CharacterSet", {
        /**
         * Gets or sets the character set of the content.
         */
        get: function () {
            return this.characterSet;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.characterSet; }, setValue: function (updateValue) { _this.characterSet = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MimeContentBase.prototype, "Content", {
        /**
         * Gets or sets the content.  - ews-javascript-api this is base64 value without encoding applied.
         */
        get: function () {
            return this.content;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.content; }, setValue: function (updateValue) { _this.content = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    MimeContentBase.prototype.LoadFromXmlJsObject = function (jsObject /*JsonObject*/, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlAttributeNames.CharacterSet:
                    this.characterSet = jsObject[key];
                    break;
                case this.xmlElementName://ref: text value in xml2jsobject
                    this.content = jsObject[key];
                    ;
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * @internal Writes attributes to XML.
     *
     * @param {EwsServiceXmlWriter} writer  The writer.
     */
    MimeContentBase.prototype.WriteAttributesToXml = function (writer) {
        writer.WriteAttributeValue(XmlAttributeNames.CharacterSet, this.CharacterSet);
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param {EwsServiceXmlWriter} writer  The writer.
     */
    MimeContentBase.prototype.WriteElementsToXml = function (writer) {
        if (!StringHelper.IsNullOrEmpty(this.Content)) {
            writer.WriteValue(this.Content, this.xmlElementName);
            //writer.WriteBase64ElementValue(this.Content);
        }
    };
    return MimeContentBase;
}(ComplexProperty));
exports.MimeContentBase = MimeContentBase;
/**
 * Represents the MIME content of an item.
 */
var MimeContent = (function (_super) {
    __extends(MimeContent, _super);
    function MimeContent(characterSet, content) {
        if (characterSet === void 0) { characterSet = null; }
        if (content === void 0) { content = null; }
        var _this = _super.call(this) || this;
        _this.CharacterSet = characterSet;
        _this.Content = content;
        _this.xmlElementName = XmlElementNames.MimeContent;
        return _this;
    }
    /**
     * Returns a **String** that represents the current **Object**.
     *
     * @return  {string}      A **String** that represents the current **Object**.
     */
    MimeContent.prototype.ToString = function () {
        return this.Content || StringHelper.Empty;
        //ref: //info: 
        //todo: implement arraybuffer and encoding using TextDecoder or some other tech
        // if (this.Content == null) {
        //     return StringHelper.Empty;
        // }
        // else {
        //     try {
        //         // Try to convert to original MIME content using specified charset. If this fails, 
        //         // return the Base64 representation of the content.
        //         // Note: Encoding.GetString can throw DecoderFallbackException which is a subclass
        //         // of ArgumentException.
        //         string charSet = string.IsNullOrEmpty(this.CharacterSet)
        //             ? Encoding.UTF8.EncodingName
        //             : this.CharacterSet;
        //         Encoding encoding = Encoding.GetEncoding(charSet);
        //         return encoding.GetString(this.Content);
        //     }
        //     catch (ArgumentException) {
        //         return Convert.ToBase64String(this.Content);
        //     }
        // }
    };
    MimeContent.prototype.toString = function () { return this.ToString(); };
    return MimeContent;
}(MimeContentBase));
exports.MimeContent = MimeContent;
/**
 * Represents the MIME content of an item.
 */
var MimeContentUTF8 = (function (_super) {
    __extends(MimeContentUTF8, _super);
    function MimeContentUTF8(characterSet) {
        if (characterSet === void 0) { characterSet = null; }
        var _this = _super.call(this) || this;
        _this.CharacterSet = characterSet;
        _this.Content = "utf-8"; //c# - Encoding.UTF8.BodyName, nodejs - utf8 not utf-8
        _this.xmlElementName = XmlElementNames.MimeContentUTF8;
        return _this;
    }
    /**
     * Returns a **String** that represents the current **Object**.
     *
     * @return  {string}      A **String** that represents the current **Object**.
     */
    MimeContentUTF8.prototype.ToString = function () {
        return this.Content || StringHelper.Empty;
        //ref: //info: 
        //todo: implement arraybuffer and encoding using TextDecoder or some other tech
        //            if (this.Content == null)
        //            {
        //                return string.Empty;
        //            }
        //            else
        //            {
        //                try
        //                {
        //                    // Try to convert to original MIME content using specified charset. If this fails, 
        //                    // return the Base64 representation of the content.
        //                    // Note: Encoding.GetString can throw DecoderFallbackException which is a subclass
        //                    // of ArgumentException.
        //                    // it should always be UTF8 encoding for MimeContentUTF8
        //                    return Encoding.UTF8.GetString(this.Content);
        //                }
        //                catch (ArgumentException)
        //                {
        //                    return Convert.ToBase64String(this.Content);
        //                }
        //            }
    };
    MimeContentUTF8.prototype.toString = function () { return this.ToString(); };
    return MimeContentUTF8;
}(MimeContentBase));
exports.MimeContentUTF8 = MimeContentUTF8;
/**
 * Represents the retention tag of an item.
 */
var RetentionTagBase = (function (_super) {
    __extends(RetentionTagBase, _super);
    /**
     * Initializes a new instance of the **RetentionTagBase** class.
     *
     * @param {string}  xmlElementName   Xml element name.
     */
    function RetentionTagBase(xmlElementName) {
        var _this = _super.call(this) || this;
        /**
         * Xml element name.
         */
        _this.xmlElementName = null;
        /**
         * Is explicit.
         */
        _this.isExplicit = false;
        /**
         * Retention id.
         */
        _this.retentionId = null;
        _this.xmlElementName = xmlElementName;
        return _this;
    }
    Object.defineProperty(RetentionTagBase.prototype, "IsExplicit", {
        /**
         * Gets or sets if the tag is explicit.
         */
        get: function () {
            return this.isExplicit;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.isExplicit; }, setValue: function (updateValue) { _this.isExplicit = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RetentionTagBase.prototype, "RetentionId", {
        /**
         * Gets or sets the retention id.
         */
        get: function () {
            return this.retentionId;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.retentionId; }, setValue: function (updateValue) { _this.retentionId = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    RetentionTagBase.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlAttributeNames.IsExplicit:
                    this.isExplicit = Convert.toBool(jsObject[key]);
                    break;
                case this.xmlElementName:
                    this.retentionId = new Guid(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * Returns a **String** that represents the current **Object**.
     *
     * @return  {string}      A **String** that represents the current **Object**.
     */
    RetentionTagBase.prototype.ToString = function () {
        if (this.retentionId == null || this.retentionId == Guid.Empty) {
            return StringHelper.Empty;
        }
        else {
            return this.retentionId.ToString();
        }
    };
    RetentionTagBase.prototype.toString = function () { return this.ToString(); };
    /**
     * @internal Writes attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    RetentionTagBase.prototype.WriteAttributesToXml = function (writer) {
        writer.WriteAttributeValue(XmlAttributeNames.IsExplicit, this.isExplicit);
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    RetentionTagBase.prototype.WriteElementsToXml = function (writer) {
        if (this.retentionId != null && this.retentionId != Guid.Empty) {
            writer.WriteValue(this.retentionId.ToString(), this.xmlElementName);
        }
    };
    return RetentionTagBase;
}(ComplexProperty));
exports.RetentionTagBase = RetentionTagBase;
/**
 * Represents the archive tag of an item or folder.
 */
var ArchiveTag = (function (_super) {
    __extends(ArchiveTag, _super);
    function ArchiveTag(isExplicit, retentionId) {
        if (isExplicit === void 0) { isExplicit = false; }
        if (retentionId === void 0) { retentionId = null; }
        var _this = _super.call(this, XmlElementNames.ArchiveTag) || this;
        _this.IsExplicit = isExplicit;
        _this.RetentionId = retentionId;
        return _this;
    }
    return ArchiveTag;
}(RetentionTagBase));
exports.ArchiveTag = ArchiveTag;
/**
 * Represents the policy tag of an item or folder.
 */
var PolicyTag = (function (_super) {
    __extends(PolicyTag, _super);
    function PolicyTag(isExplicit, retentionId) {
        if (isExplicit === void 0) { isExplicit = false; }
        if (retentionId === void 0) { retentionId = null; }
        var _this = _super.call(this, XmlElementNames.PolicyTag) || this;
        _this.IsExplicit = isExplicit;
        _this.RetentionId = retentionId;
        return _this;
    }
    return PolicyTag;
}(RetentionTagBase));
exports.PolicyTag = PolicyTag;
/**
 * Represents an operation to be performed on a rule.
 */
var RuleOperation = (function (_super) {
    __extends(RuleOperation, _super);
    /**
     * @internal Initializes a new instance of the **RuleOperation** class.
     */
    function RuleOperation() {
        return _super.call(this) || this;
    }
    Object.defineProperty(RuleOperation.prototype, "XmlElementName", {
        /**
         * @internal Gets the XML element name of the rule operation.
         */
        get: function () {
            throw new Error("abstract - must implement");
        },
        enumerable: true,
        configurable: true
    });
    return RuleOperation;
}(ComplexProperty));
exports.RuleOperation = RuleOperation;
/**
 * Represents an operation to create a new rule.
 *
 * @sealed
 */
var CreateRuleOperation = (function (_super) {
    __extends(CreateRuleOperation, _super);
    function CreateRuleOperation(rule) {
        if (rule === void 0) { rule = null; }
        var _this = _super.call(this) || this;
        _this.rule = rule;
        return _this;
    }
    Object.defineProperty(CreateRuleOperation.prototype, "Rule", {
        /**
         * Gets or sets the rule to be created.
         */
        get: function () {
            return this.rule;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.rule; }, setValue: function (updateValue) { _this.rule = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CreateRuleOperation.prototype, "XmlElementName", {
        /**
         * @internal Gets the Xml element name of the CreateRuleOperation object.
         */
        get: function () {
            return XmlElementNames.CreateRuleOperation;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Validates this instance.
     */
    CreateRuleOperation.prototype.InternalValidate = function () {
        EwsUtilities.ValidateParam(this.rule, "Rule");
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    CreateRuleOperation.prototype.WriteElementsToXml = function (writer) {
        this.Rule.WriteToXml(writer, XmlElementNames.Rule);
    };
    return CreateRuleOperation;
}(RuleOperation));
exports.CreateRuleOperation = CreateRuleOperation;
/**
 * Represents an operation to delete an existing rule.
 *
 * @sealed
 */
var DeleteRuleOperation = (function (_super) {
    __extends(DeleteRuleOperation, _super);
    function DeleteRuleOperation(ruleId) {
        if (ruleId === void 0) { ruleId = null; }
        var _this = _super.call(this) || this;
        _this.ruleId = ruleId;
        return _this;
    }
    Object.defineProperty(DeleteRuleOperation.prototype, "RuleId", {
        /**
         * Gets or sets the Id of the rule to delete.
         */
        get: function () {
            return this.ruleId;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.ruleId; }, setValue: function (updateValue) { _this.ruleId = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DeleteRuleOperation.prototype, "XmlElementName", {
        /**
         * @internal Gets the Xml element name of the DeleteRuleOperation object.
         */
        get: function () {
            return XmlElementNames.DeleteRuleOperation;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Validates this instance.
     */
    DeleteRuleOperation.prototype.InternalValidate = function () {
        EwsUtilities.ValidateParam(this.ruleId, "RuleId");
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    DeleteRuleOperation.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.RuleId, this.RuleId);
    };
    return DeleteRuleOperation;
}(RuleOperation));
exports.DeleteRuleOperation = DeleteRuleOperation;
/**
 * Represents an operation to update an existing rule.
 *
 * @sealed
 */
var SetRuleOperation = (function (_super) {
    __extends(SetRuleOperation, _super);
    function SetRuleOperation(rule) {
        if (rule === void 0) { rule = null; }
        var _this = _super.call(this) || this;
        _this.rule = rule;
        return _this;
    }
    Object.defineProperty(SetRuleOperation.prototype, "Rule", {
        /**
         * Gets or sets the rule to be updated.
         */
        get: function () {
            return this.rule;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.rule; }, setValue: function (updateValue) { _this.rule = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SetRuleOperation.prototype, "XmlElementName", {
        /**
         * @internal Gets the Xml element name of the SetRuleOperation object.
         */
        get: function () {
            return XmlElementNames.SetRuleOperation;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Validates this instance.
     */
    SetRuleOperation.prototype.InternalValidate = function () {
        EwsUtilities.ValidateParam(this.rule, "Rule");
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    SetRuleOperation.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.Rule:
                    this.rule = new Rule();
                    this.rule.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    SetRuleOperation.prototype.WriteElementsToXml = function (writer) {
        this.Rule.WriteToXml(writer, XmlElementNames.Rule);
    };
    return SetRuleOperation;
}(RuleOperation));
exports.SetRuleOperation = SetRuleOperation;
var ServiceId = (function (_super) {
    __extends(ServiceId, _super);
    function ServiceId(uniqueId) {
        var _this = _super.call(this) || this;
        if (!StringHelper.IsNullOrEmpty(uniqueId)) {
            EwsUtilities.ValidateParam(uniqueId, "uniqueId");
            _this.UniqueId = uniqueId;
        }
        return _this;
    }
    Object.defineProperty(ServiceId.prototype, "IsValid", {
        get: function () { return this.IsValidProxy(); },
        enumerable: true,
        configurable: true
    });
    ServiceId.prototype.IsValidProxy = function () { return !StringHelper.IsNullOrEmpty(this.UniqueId); }; //proxy to be able to call super. from inherited child
    ServiceId.prototype.Assign = function (source) {
        this.UniqueId = source.UniqueId;
        this.ChangeKey = source.ChangeKey;
    };
    ServiceId.prototype.Equals = function (obj) {
        if (this === obj) {
            return true;
        }
        else {
            var other = obj;
            if (!(other instanceof ServiceId)) {
                return false;
            }
            else if (!(this.IsValid && other.IsValid)) {
                return false;
            }
            else {
                return this.UniqueId === other.UniqueId; //.Equals(other.UniqueId);
            }
        }
    };
    //GetHashCode(): number { return this.IsValid ? this.UniqueId.GetHashCode() : super.GetHashCode();}
    //GetJsonTypeName(): string { throw new Error("ServiceId.ts - GetJsonTypeName : Not implemented."); }
    ServiceId.prototype.GetXmlElementName = function () { throw new Error("abstract method must implement."); };
    //InternalToJson(service: ExchangeService): any { throw new Error("ServiceId.ts - InternalToJson : Not implemented."); }
    //LoadFromJson(jsonProperty: JsonObject, service: ExchangeService): any { throw new Error("ServiceId.ts - LoadFromJson : Not implemented."); }
    ServiceId.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlAttributeNames.Id:
                    this.UniqueId = jsObject[key];
                    break;
                case XmlAttributeNames.ChangeKey:
                    this.ChangeKey = jsObject[key];
                    break;
                default:
                    break;
            }
        }
    };
    /**@internal */
    ServiceId.prototype.ReadAttributesFromXmlJsObject = function (reader) {
        this.UniqueId = reader.ReadAttributeValue(null, XmlAttributeNames.Id);
        this.ChangeKey = reader.ReadAttributeValue(null, XmlAttributeNames.ChangeKey);
    };
    ServiceId.prototype.SameIdAndChangeKey = function (other) {
        if (this.Equals(other)) {
            return ((this.ChangeKey == null) && (other.ChangeKey == null)) ||
                this.ChangeKey === other.ChangeKey;
        }
        else {
            return false;
        }
    };
    ServiceId.prototype.ToString = function () { return (this.UniqueId == null) ? "" : this.UniqueId; };
    /**@internal */
    ServiceId.prototype.WriteAttributesToXml = function (writer) {
        writer.WriteAttributeValue(XmlAttributeNames.Id, this.UniqueId);
        writer.WriteAttributeValue(XmlAttributeNames.ChangeKey, this.ChangeKey);
    };
    /** @internal */
    ServiceId.prototype.WriteToXml = function (writer, xmlElementName, xmlNamespace) {
        if (arguments.length > 2) {
            _super.prototype.WriteToXml.call(this, writer, xmlElementName, xmlNamespace);
        }
        else if (arguments.length > 1) {
            _super.prototype.WriteToXml.call(this, writer, xmlElementName);
        }
        else {
            _super.prototype.WriteToXml.call(this, writer, this.GetXmlElementName());
        }
    };
    return ServiceId;
}(ComplexProperty));
exports.ServiceId = ServiceId;
/**
 * Represents the Id of a Conversation.
 */
var ConversationId = (function (_super) {
    __extends(ConversationId, _super);
    function ConversationId(uniqueId) {
        var _this = this;
        arguments.length === 0 ? _this = _super.call(this) || this : _this = _super.call(this, uniqueId) || this;
        return _this;
    }
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    ConversationId.prototype.GetXmlElementName = function () { return XmlElementNames.ConversationId; };
    /**
     * Gets a string representation of the Conversation Id.
     *
     * @return  {string}      The string representation of the conversation id.
     */
    ConversationId.prototype.ToString = function () {
        // We have ignored the change key portion
        return this.UniqueId;
    };
    ConversationId.prototype.toString = function () { return this.ToString(); };
    return ConversationId;
}(ServiceId));
exports.ConversationId = ConversationId;
var FolderId = (function (_super) {
    __extends(FolderId, _super);
    //    constructor(uniqueId?: string, folderName?: WellKnownFolderName, mailbox?: Mailbox) {
    //        super(uniqueId);
    //
    //        this.mailbox = mailbox;
    //        this.folderName = folderName;
    //    }
    function FolderId(folderName, mailbox) {
        var _this = _super.call(this) || this;
        _this.mailbox = mailbox;
        _this.folderName = folderName;
        return _this;
    }
    Object.defineProperty(FolderId.prototype, "FolderName", {
        get: function () { return this.folderName; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderId.prototype, "Mailbox", {
        get: function () { return this.mailbox; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderId.prototype, "IsValid", {
        get: function () {
            if (this.FolderName) {
                return (this.Mailbox == null) || this.Mailbox.IsValid;
            }
            else {
                return _super.prototype.IsValidProxy.call(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    FolderId.prototype.Equals = function (obj) {
        if (this === obj) {
            return true;
        }
        else {
            var other = obj;
            if (!(other instanceof FolderId)) {
                return false;
            }
            else if (this.FolderName) {
                if (other.FolderName && this.FolderName === other.FolderName) {
                    if (this.Mailbox != null) {
                        return this.Mailbox.Equals(other.Mailbox);
                    }
                    else if (other.Mailbox == null) {
                        return true;
                    }
                }
            }
            else if (_super.prototype.Equals.call(this, other)) {
                return true;
            }
            return false;
        }
    };
    //GetHashCode(): number { throw new Error("FolderId.ts - GetHashCode : Not implemented."); }
    FolderId.prototype.GetXmlElementName = function () { return typeof this.folderName !== 'undefined' && this.FolderName >= 0 ? XmlElementNames.DistinguishedFolderId : XmlElementNames.FolderId; };
    //InternalToJson(service: ExchangeService): any { throw new Error("FolderId.ts - InternalToJson : Not implemented."); }
    FolderId.prototype.ToString = function () {
        if (this.IsValid) {
            if (this.FolderName) {
                if ((this.mailbox != null) && this.mailbox.IsValid) {
                    return StringHelper.Format("{0} ({1})", WellKnownFolderName[this.folderName], this.Mailbox.ToString());
                }
                else {
                    return WellKnownFolderName[this.FolderName];
                }
            }
            else {
                return _super.prototype.ToString.call(this);
            }
        }
        else {
            return "";
        }
    };
    FolderId.prototype.Validate = function (version) {
        if (version) {
            // The FolderName property is a WellKnownFolderName, an enumeration type. If the property
            // is set, make sure that the value is valid for the request version.
            if (this.FolderName) {
                EwsUtilities.ValidateEnumVersionValue(WellKnownFolderName, this.FolderName, version, "WellKnownFolderName");
            }
        }
        else {
            _super.prototype.Validate.call(this);
        }
    };
    /**@internal */
    FolderId.prototype.WriteAttributesToXml = function (writer) {
        if (typeof this.folderName !== 'undefined' && this.FolderName >= 0) {
            writer.WriteAttributeValue(XmlAttributeNames.Id, WellKnownFolderName[this.FolderName].toLowerCase());
            if (this.Mailbox != null) {
                this.Mailbox.WriteToXml(writer, XmlElementNames.Mailbox);
            }
        }
        else {
            _super.prototype.WriteAttributesToXml.call(this, writer);
        }
    };
    return FolderId;
}(ServiceId));
exports.FolderId = FolderId;
var ItemId = (function (_super) {
    __extends(ItemId, _super);
    function ItemId(uniqueId) {
        var _this = this;
        if (arguments.length === 0) {
            _this = _super.call(this) || this;
            return;
        }
        _this = _super.call(this, uniqueId) || this;
        return _this;
    }
    ItemId.prototype.GetXmlElementName = function () { return XmlElementNames.ItemId; };
    return ItemId;
}(ServiceId));
exports.ItemId = ItemId;
var AppointmentOccurrenceId = (function (_super) {
    __extends(AppointmentOccurrenceId, _super);
    function AppointmentOccurrenceId(recurringMasterUniqueId, occurrenceIndex) {
        var _this = _super.call(this, recurringMasterUniqueId) || this;
        _this.OccurrenceIndex = occurrenceIndex;
        return _this;
    }
    Object.defineProperty(AppointmentOccurrenceId.prototype, "OccurrenceIndex", {
        get: function () {
            return this.occurrenceIndex;
        },
        set: function (value) {
            if (value < 1) {
                throw new ArgumentException(Strings.OccurrenceIndexMustBeGreaterThanZero);
            }
            this.occurrenceIndex = value;
        },
        enumerable: true,
        configurable: true
    });
    AppointmentOccurrenceId.prototype.GetXmlElementName = function () { return XmlElementNames.OccurrenceItemId; };
    AppointmentOccurrenceId.prototype.InternalToJson = function (service) { throw new Error("AppointmentOccurrenceId.ts - InternalToJson : Not implemented."); };
    /**@internal */
    AppointmentOccurrenceId.prototype.WriteAttributesToXml = function (writer) {
        writer.WriteAttributeValue(XmlAttributeNames.RecurringMasterId, this.UniqueId);
        writer.WriteAttributeValue(XmlAttributeNames.InstanceIndex, this.OccurrenceIndex);
    };
    return AppointmentOccurrenceId;
}(ItemId));
exports.AppointmentOccurrenceId = AppointmentOccurrenceId;
var RecurringAppointmentMasterId = (function (_super) {
    __extends(RecurringAppointmentMasterId, _super);
    function RecurringAppointmentMasterId(occurrenceId) {
        return _super.call(this, occurrenceId) || this;
    }
    RecurringAppointmentMasterId.prototype.GetXmlElementName = function () { return XmlElementNames.RecurringMasterItemId; };
    /**@internal */
    RecurringAppointmentMasterId.prototype.WriteAttributesToXml = function (writer) {
        writer.WriteAttributeValue(XmlAttributeNames.OccurrenceId, this.UniqueId);
        writer.WriteAttributeValue(XmlAttributeNames.ChangeKey, this.ChangeKey);
    };
    return RecurringAppointmentMasterId;
}(ItemId));
exports.RecurringAppointmentMasterId = RecurringAppointmentMasterId;
/**
 * Represents a collection of properties that can be sent to and retrieved from EWS.
 *
 * @type <TComplexProperty>   ComplexProperty type.
 */
var ComplexPropertyCollection = (function (_super) {
    __extends(ComplexPropertyCollection, _super);
    /**
     * @internal Initializes a new instance of the **ComplexPropertyCollection** class.
     *
     */
    function ComplexPropertyCollection() {
        var _this = _super.call(this) || this;
        _this.___typeGenerics = ["ComplexProperty"];
        _this.items = [];
        _this.addedItems = [];
        _this.modifiedItems = [];
        _this.removedItems = [];
        return _this;
    }
    Object.defineProperty(ComplexPropertyCollection.prototype, "Items", {
        /**
         * @internal Gets the items. (workaround for GetEnumerator)
         *
         * @return The items.
         */
        get: function () { return this.items; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComplexPropertyCollection.prototype, "AddedItems", {
        /**
         * @internal Gets the added items.
         *
         * @return The added items.
         */
        get: function () { return this.addedItems; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComplexPropertyCollection.prototype, "ModifiedItems", {
        /**
         * @internal Gets the modified items.
         *
         * @return The modified items
         */
        get: function () { return this.modifiedItems; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComplexPropertyCollection.prototype, "RemovedItems", {
        /**
         * @internal Gets the removed items.
         *
         * @return The removed items.
         */
        get: function () { return this.removedItems; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComplexPropertyCollection.prototype, "Count", {
        /**
         * Gets the total number of properties in the collection.
         */
        get: function () { return this.items.length; },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the property at the specified index.
     *
     * @param   {number}   index   The zero-based index of the property to get.
     * @return  {TComplexProperty}           The property at the specified index.
     */
    ComplexPropertyCollection.prototype._getItem = function (index) {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }
        return this.items[index];
    };
    /**
     * @internal Clears the change log.
     */
    ComplexPropertyCollection.prototype.ClearChangeLog = function () {
        this.removedItems.splice(0);
        this.addedItems.splice(0);
        this.modifiedItems.splice(0);
    };
    /**
     * Determines whether a specific property is in the collection.
     *
     * @param   {TComplexProperty}   complexProperty   The property to locate in the collection.
     * @return  {boolean}           True if the property was found in the collection, false otherwise.
     */
    ComplexPropertyCollection.prototype.Contains = function (complexProperty) { return this.items.indexOf(complexProperty) >= 0; };
    /**
     * @internal Loads from XMLJsObject collection to create a new collection item.
     *
     * @interface   IJsonCollectionDeserializer
     *
     * @param   {any}               jsObjectCollection   The json collection.
     * @param   {ExchangeService}   service          The service.
     */
    ComplexPropertyCollection.prototype.CreateFromXmlJsObjectCollection = function (jsObjectCollection, service) {
        var collection = jsObjectCollection;
        if (!ArrayHelper.isArray(collection)) {
            collection = [];
            var collectionElement = this.GetCollectionItemXmlElementName(null);
            var typeName = TypeSystem.GetJsObjectTypeName(jsObjectCollection);
            if (collectionElement === null || (typeName && collectionElement === typeName)) {
                collection = [jsObjectCollection];
            }
            else {
                for (var key in jsObjectCollection) {
                    if (key.indexOf("__") === 0)
                        continue;
                    var collectionObj = jsObjectCollection[key];
                    if (!ArrayHelper.isArray(collectionObj)) {
                        collectionObj = EwsServiceJsonReader.ReadAsArray(jsObjectCollection, key);
                    }
                    ArrayHelper.AddRange(collection, collectionObj);
                }
            }
        }
        for (var _a = 0, collection_3 = collection; _a < collection_3.length; _a++) {
            var jsonObject = collection_3[_a];
            var jsonProperty = jsonObject;
            if (jsonProperty != null) {
                var complexProperty = null;
                // If type property is present, use it. Otherwise create default property instance.
                // Note: polymorphic collections (such as Attachments) need a type property so
                // the CreateDefaultComplexProperty call will fail.
                if (TypeSystem.GetJsObjectTypeName(jsonProperty)) {
                    complexProperty = this.CreateComplexProperty(TypeSystem.GetJsObjectTypeName(jsonProperty));
                }
                else {
                    complexProperty = this.CreateDefaultComplexProperty();
                }
                if (complexProperty != null) {
                    complexProperty.LoadFromXmlJsObject(jsonProperty, service);
                    this.InternalAdd(complexProperty, true);
                }
            }
        }
    };
    /**
     *  Returns an enumerator that iterates through the collection. this case this.items
     */
    ComplexPropertyCollection.prototype.GetEnumerator = function () {
        return this.items;
    };
    /**
     * Searches for a specific property and return its zero-based index within the collection.
     *
     * @param   {TComplexProperty}   complexProperty   The property to locate in the collection.
     * @return  {number}                     The zero-based index of the property within the collection.
     */
    ComplexPropertyCollection.prototype.IndexOf = function (complexProperty) {
        return this.items.indexOf(complexProperty);
    };
    ComplexPropertyCollection.prototype.InternalAdd = function (complexProperty, loading) {
        if (loading === void 0) { loading = false; }
        EwsLogging.Assert(complexProperty != null, "ComplexPropertyCollection.InternalAdd", "complexProperty is null");
        if (this.items.indexOf(complexProperty) < 0) {
            this.items.push(complexProperty);
            if (!loading) {
                ArrayHelper.RemoveEntry(this.removedItems, complexProperty); // this.removedItems.Remove(complexProperty);
                this.addedItems.push(complexProperty);
            }
            complexProperty.OnChange.push(this.ItemChanged.bind(this));
            this.Changed();
        }
    };
    /**
     * @internal Clear collection.
     */
    ComplexPropertyCollection.prototype.InternalClear = function () {
        while (this.Count > 0) {
            this.InternalRemoveAt(0);
        }
    };
    /**
     * @internal Remove specified complex property.
     *
     * @param   {TComplexProperty}   complexProperty   The complex property.
     * @return  {boolean}           True if the complex property was successfully removed from the collection, false otherwise.
     */
    ComplexPropertyCollection.prototype.InternalRemove = function (complexProperty) {
        EwsLogging.Assert(complexProperty != null, "ComplexPropertyCollection.InternalRemove", "complexProperty is null");
        if (ArrayHelper.RemoveEntry(this.items, complexProperty)) {
            ArrayHelper.RemoveEntry(complexProperty.OnChange, this.ItemChanged); // complexProperty.OnChange -= this.ItemChanged;
            if (this.addedItems.indexOf(complexProperty) < 0) {
                this.removedItems.push(complexProperty);
            }
            else {
                ArrayHelper.RemoveEntry(this.addedItems, complexProperty); // this.addedItems.Remove(complexProperty);
            }
            ArrayHelper.RemoveEntry(this.modifiedItems, complexProperty); // this.modifiedItems.Remove(complexProperty);
            this.Changed();
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * @internal Remote entry at index.
     *
     * @param   {number}   index   The index.
     */
    ComplexPropertyCollection.prototype.InternalRemoveAt = function (index) {
        EwsLogging.Assert(index >= 0 && index < this.Count, "ComplexPropertyCollection.InternalRemoveAt", "index is out of range.");
        this.InternalRemove(this.items[index]);
    };
    /**
     * @internal Item changed.
     *
     * @param   {ComplexProperty}   complexProperty   The complex property.
     */
    ComplexPropertyCollection.prototype.ItemChanged = function (complexProperty) {
        //TComplexProperty property = complexProperty as TComplexProperty;
        var property = complexProperty;
        // EwsLogging.Assert(
        //     property != null,
        //     "ComplexPropertyCollection.ItemChanged",
        //     StringHelper.Format("ComplexPropertyCollection.ItemChanged: the type of the complexProperty argument ({0}) is not supported.", complexProperty.___typeName));
        if (this.addedItems.indexOf(property) < 0) {
            if (this.modifiedItems.indexOf(property) < 0) {
                this.modifiedItems.push(property);
                this.Changed();
            }
        }
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    ComplexPropertyCollection.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        EwsLogging.Assert(false, "ComplexPropertyCollection.LoadFromXmlJsObject", "LoadFromXmlJsObject was called, should not be calling. Fix it to direct to Create or Update call instad.");
        this.CreateFromXmlJsObjectCollection(jsObject, service);
    };
    /**
     * @internal Removes from change log.
     *
     * @param   {TComplexProperty}   complexProperty   The complex property.
     */
    ComplexPropertyCollection.prototype.RemoveFromChangeLog = function (complexProperty) {
        ArrayHelper.RemoveEntry(this.removedItems, complexProperty); //this.removedItems.Remove(complexProperty);
        ArrayHelper.RemoveEntry(this.modifiedItems, complexProperty); //this.modifiedItems.Remove(complexProperty);
        ArrayHelper.RemoveEntry(this.addedItems, complexProperty); //this.addedItems.Remove(complexProperty);
    };
    /**
     * @internal Determine whether we should write collection to XML or not.
     *
     * @return  {boolean}      True if collection contains at least one element.
     */
    ComplexPropertyCollection.prototype.ShouldWriteToRequest = function () {
        // Only write collection if it has at least one element.
        return this.Count > 0;
    };
    /**
     * @internal Loads from XMLJsObject collection to update collection Items.
     *
     * @interface   IJsonCollectionDeserializer
     *
     * @param   {any}               jsObjectCollection   The XMLJsObject collection.
     * @param   {ExchangeService}   service          The service.
     */
    ComplexPropertyCollection.prototype.UpdateFromXmlJsObjectCollection = function (jsObjectCollection, service) {
        var collection = jsObjectCollection;
        if (!ArrayHelper.isArray(collection)) {
            collection = [];
            var collectionElement = this.GetCollectionItemXmlElementName(null);
            var typeName = TypeSystem.GetJsObjectTypeName(jsObjectCollection);
            if (collectionElement === null || (typeName && collectionElement === typeName)) {
                collection = [jsObjectCollection];
            }
            else {
                for (var key in jsObjectCollection) {
                    if (key.indexOf("__") === 0)
                        continue;
                    var collectionObj = jsObjectCollection[key];
                    if (!ArrayHelper.isArray(collectionObj)) {
                        collectionObj = EwsServiceJsonReader.ReadAsArray(jsObjectCollection, key);
                    }
                    ArrayHelper.AddRange(collection, collectionObj);
                }
            }
        }
        if (this.Count != collection.length) {
            throw new ServiceLocalException(Strings.PropertyCollectionSizeMismatch);
        }
        var index = 0;
        for (var _a = 0, collection_4 = collection; _a < collection_4.length; _a++) {
            var jsonObject = collection_4[_a];
            var jsonProperty = jsonObject;
            if (jsonProperty != null) {
                var expectedComplexProperty = null;
                if (TypeSystem.GetJsObjectTypeName(jsonProperty)) {
                    expectedComplexProperty = this.CreateComplexProperty(TypeSystem.GetJsObjectTypeName(jsonProperty));
                }
                else {
                    expectedComplexProperty = this.CreateDefaultComplexProperty();
                }
                var actualComplexProperty = this._getItem(index++);
                if (expectedComplexProperty == null || !(actualComplexProperty instanceof expectedComplexProperty.constructor)) {
                    throw new ServiceLocalException(Strings.PropertyTypeIncompatibleWhenUpdatingCollection);
                }
                actualComplexProperty.LoadFromXmlJsObject(jsonProperty, service);
            }
            else {
                throw new ServiceLocalException();
            }
        }
    };
    /**
     * @internal Writes elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ComplexPropertyCollection.prototype.WriteElementsToXml = function (writer) {
        for (var _a = 0, _b = this.items; _a < _b.length; _a++) {
            var complexProperty = _b[_a];
            complexProperty.WriteToXml(writer, this.GetCollectionItemXmlElementName(complexProperty));
        }
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {XmlNamespace}          xmlNamespace     The XML namespace.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    ComplexPropertyCollection.prototype.WriteToXml = function (writer, xmlElementName, xmlNamespace) {
        if (xmlNamespace === void 0) { xmlNamespace = XmlNamespace.Types; }
        if (this.ShouldWriteToRequest()) {
            _super.prototype.WriteToXml.call(this, writer, xmlElementName, xmlNamespace);
        }
    };
    /**
     * @internal Writes the update to XML.
     * ICustomUpdateSerializer.WriteSetUpdateToXml
     *
     * @param   {EwsServiceXmlWriter}   writer               The writer.
     * @param   {ServiceObject}         ewsObject            The ews object.
     * @param   {PropertyDefinition}    propertyDefinition   Property definition.
     * @return  {boolean}               True if property generated serialization.
     */
    ComplexPropertyCollection.prototype.WriteSetUpdateToXml = function (writer, ewsObject, propertyDefinition) {
        // If the collection is empty, delete the property.
        if (this.Count == 0) {
            writer.WriteStartElement(XmlNamespace.Types, ewsObject.GetDeleteFieldXmlElementName());
            propertyDefinition.WriteToXml(writer);
            writer.WriteEndElement();
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * @internal Writes the deletion update to XML.
     * ICustomUpdateSerializer.WriteDeleteUpdateToXml
     *
     * @param   {EwsServiceXmlWriter}   writer      The writer.
     * @param   {ServiceObject}         ewsObject   The ews object.
     * @return  {boolean}               True if property generated serialization.
     */
    ComplexPropertyCollection.prototype.WriteDeleteUpdateToXml = function (writer, ewsObject) {
        // Use the default XML serializer.
        return false;
    };
    return ComplexPropertyCollection;
}(ComplexProperty));
exports.ComplexPropertyCollection = ComplexPropertyCollection;
/**
 * Represents a collection of AddressEntity objects.
 */
var AddressEntityCollection = (function (_super) {
    __extends(AddressEntityCollection, _super);
    function AddressEntityCollection(collection) {
        if (collection === void 0) { collection = null; }
        var _this = _super.call(this) || this;
        if (collection != null) {
            collection.forEach(function (address) { _this.InternalAdd(address); });
        }
        return _this;
    }
    /**
     * @internal Creates the complex property.
     *
     * @param   {string}            xmlElementName   Name of the XML element.
     * @return  {AddressEntity}     AddressEntity.
     */
    AddressEntityCollection.prototype.CreateComplexProperty = function (xmlElementName) { return new AddressEntity(); };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {AddressEntity}      AddressEntity.
     */
    AddressEntityCollection.prototype.CreateDefaultComplexProperty = function () { return new AddressEntity(); };
    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {AddressEntity}     complexProperty   The complex property.
     * @return  {string}            XML element name.
     */
    AddressEntityCollection.prototype.GetCollectionItemXmlElementName = function (complexProperty) { return XmlElementNames.NlgAddress; };
    return AddressEntityCollection;
}(ComplexPropertyCollection));
exports.AddressEntityCollection = AddressEntityCollection;
/**
 * Represents an item's attachment collection.
 */
var AttachmentCollection = (function (_super) {
    __extends(AttachmentCollection, _super);
    /**
     * @internal Initializes a new instance of AttachmentCollection.
     */
    function AttachmentCollection() {
        var _this = _super.call(this) || this;
        _this.___typeGenerics = ["ComplexProperty"];
        /**
         * The item owner that owns this attachment collection
         */
        _this.owner = null;
        return _this;
    }
    Object.defineProperty(AttachmentCollection.prototype, "Owner", {
        /**
         * @interface:IOwnedProperty The owner of this attachment collection.
         */
        get: function () { return this.owner; },
        set: function (value) {
            EwsLogging.Assert(value != null && (value instanceof TypeContainer.Item), // instanceof Item), //info: can not check instanceof to avoid circular dependency in js. TypeContainer is workaround
            "AttachmentCollection.IOwnedProperty.set_Owner", "value is not a descendant of ItemBase");
            this.owner = value;
        },
        enumerable: true,
        configurable: true
    });
    ;
    AttachmentCollection.prototype.AddFileAttachmentXXXXX = function (nameOrFileName, fileNameOrContent, isContent) {
        if (isContent === void 0) { isContent = false; }
        var argsLength = arguments.length;
        if (argsLength == 1) {
            var name_1 = nameOrFileName.split('\\').pop().split('/').pop();
            return this.AddFileAttachment(name_1, fileNameOrContent);
        }
        if (argsLength === 2) {
            throw new Error("AttachmentCollection.ts - Can only use this method with base64 content");
            var fileAttachment = new FileAttachment(this.owner);
            fileAttachment.Name = name;
            fileAttachment.FileName = fileNameOrContent;
            this.InternalAdd(fileAttachment);
            return fileAttachment;
        }
        if (argsLength == 3) {
            if (isContent === true) {
                var fileAttachment = new FileAttachment(this.owner);
                fileAttachment.Name = name;
                fileAttachment.Base64Content = fileNameOrContent;
                this.InternalAdd(fileAttachment);
                return fileAttachment;
            }
            else {
                return this.AddFileAttachment(nameOrFileName, fileNameOrContent);
            }
        }
        new Error("AttachmentCollection.ts - AddFileAttachment - incorrect count of parameters");
    };
    /**
     * Adds a file attachment to the collection. - isContent parameter is required to be true to be able to use bas64 content directly
     *
     * @param   {string}    name       The display name of the new attachment.
     * @param   {string}    fileContent   base64 ontent of the file representing the content of the attachment.
     * @return  {FileAttachment}      A FileAttachment instance.
     */
    AttachmentCollection.prototype.AddFileAttachment = function (name, content) {
        var fileAttachment = new FileAttachment(this.owner);
        fileAttachment.Name = name;
        fileAttachment.Base64Content = content;
        this.InternalAdd(fileAttachment);
        return fileAttachment;
    };
    /**
     * Adds an item attachment to the collection
     *
     * @type <TItem>    The type of the item to attach.
     *
     * @param   {any*}      TItem    Item type, not instance
     * @param   {string}    TItemElementName    XML Element Name of the Item class
     * @return  {ItemAttachmentOf<TItem>}      An ItemAttachment instance.
     */
    AttachmentCollection.prototype.AddItemAttachment = function (TItem, TItemElementName) {
        if (typeof TItem.Attachable === 'undefined' || TItem.Attachable === false) {
            throw new Error(StringHelper.Format("Items of type {0} are not supported as attachments.", TItem["name"])); //InvalidOperationException
        }
        var itemAttachment = new ItemAttachmentOf(this.owner); //ref: //info: ItemAttachment can not be generic when same name non generic version exhist. TypeScript limitation
        itemAttachment.Item = (new ItemInfo()).CreateItemFromItemClass(itemAttachment, TItemElementName, true); //todo: needs to implement Reflector metadata for Type to class creation map
        this.InternalAdd(itemAttachment);
        return itemAttachment;
    };
    /**
     * Removes all attachments from this collection.
     */
    AttachmentCollection.prototype.Clear = function () { this.InternalClear(); };
    /**
     * @internal Disables the change log clearing mechanism. Attachment collections are saved separately from the items they belong to.
     */
    AttachmentCollection.prototype.ClearChangeLog = function () { };
    /**
     * @internal Instantiate the appropriate attachment type depending on the current XML element name.
     *
     * @param   {string}   xmlElementName   The XML element name from which to determine the type of attachment to create.
     * @return  {Attachment}        An Attachment instance.
     */
    AttachmentCollection.prototype.CreateComplexProperty = function (xmlElementName) {
        switch (xmlElementName) {
            case XmlElementNames.FileAttachment:
                return new FileAttachment(this.owner);
            case XmlElementNames.ItemAttachment:
                return new ItemAttachment(this.owner);
            default:
                return null;
        }
    };
    //JsonDeserializationNotImplementedException
    AttachmentCollection.prototype.CreateDefaultComplexProperty = function () { EwsLogging.DebugLog("AttachmentCollection.ts - CreateDefaultComplexProperty : Not implemented."); return null; };
    /**
     * @internal Determines the name of the XML element associated with the complexProperty parameter.
     *
     * @param   {Attachment}   complexProperty   The attachment object for which to determine the XML element name with.
     * @return  {string}        The XML element name associated with the complexProperty parameter.
     */
    AttachmentCollection.prototype.GetCollectionItemXmlElementName = function (complexProperty) {
        if (complexProperty instanceof FileAttachment) {
            return XmlElementNames.FileAttachment;
        }
        else {
            return XmlElementNames.ItemAttachment;
        }
    };
    /**
     * @internal Determines whether there are any unsaved attachment collection changes.
     *
     * @return  {boolean}      True if attachment adds or deletes haven't been processed yet.
     */
    AttachmentCollection.prototype.HasUnprocessedChanges = function () {
        for (var _a = 0, _b = this.Items; _a < _b.length; _a++) {
            var attachment = _b[_a];
            if (attachment.IsNew) {
                return true;
            }
        }
        // Any pending deletions?
        for (var _c = 0, _d = this.RemovedItems; _c < _d.length; _c++) {
            var attachment = _d[_c];
            if (!attachment.IsNew) {
                return true;
            }
        }
        // Recurse: process item attachments to check for new or deleted sub-attachments.
        for (var _e = 0, _f = ArrayHelper.OfType(this.Items, function (attach) { return attach instanceof ItemAttachment; }); _e < _f.length; _e++) {
            var itemAttachment = _f[_e];
            if (itemAttachment.Item != null) {
                if (itemAttachment.Item.Attachments.HasUnprocessedChanges()) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Calls the CreateAttachment web method to create a list of attachments.
     *
     * @param   {string}        parentItemId   The Id of the parent item of the new attachments.
     * @param   {Attachment[]}  attachments    The attachments to create.
     */
    AttachmentCollection.prototype.InternalCreateAttachments = function (parentItemId, attachments) {
        var _this = this;
        return this.owner.Service.CreateAttachments(parentItemId, attachments)
            .then(function (responses) {
            for (var _a = 0, _b = responses.Responses; _a < _b.length; _a++) {
                var response = _b[_a];
                // We remove all attachments that were successfully deleted from the change log. We should never
                // receive a warning from EWS, so we ignore them.
                if (response.Result != ServiceResult.Error) {
                    _this.RemoveFromChangeLog(response.Attachment);
                }
            }
            // TODO : Should we throw for warnings as well?
            if (responses.OverallResult == ServiceResult.Error) {
                throw new CreateAttachmentException(responses, Strings.AttachmentCreationFailed);
            }
        });
    };
    /**
     * Calls the DeleteAttachment web method to delete a list of attachments.
     *
     * @param   {Attachment[]}   attachments   The attachments to delete.
     */
    AttachmentCollection.prototype.InternalDeleteAttachments = function (attachments) {
        var _this = this;
        return this.owner.Service.DeleteAttachments(attachments)
            .then(function (responses) {
            for (var _a = 0, _b = responses.Responses; _a < _b.length; _a++) {
                var response = _b[_a];
                // We remove all attachments that were successfully deleted from the change log. We should never
                // receive a warning from EWS, so we ignore them.
                if (response.Result != ServiceResult.Error) {
                    _this.RemoveFromChangeLog(response.Attachment);
                }
            }
            // TODO : Should we throw for warnings as well?
            if (responses.OverallResult == ServiceResult.Error) {
                throw new DeleteAttachmentException(responses, Strings.AtLeastOneAttachmentCouldNotBeDeleted);
            }
        });
    };
    /**
     * Removes the specified attachment.
     *
     * @param   {Attachment}    attachment   The attachment to remove.
     * @return  {boolean}       True if the attachment was successfully removed from the collection, false otherwise.
     */
    AttachmentCollection.prototype.Remove = function (attachment) {
        EwsUtilities.ValidateParam(attachment, "attachment");
        return this.InternalRemove(attachment);
    };
    /**
     * Removes the attachment at the specified index.
     *
     * @param   {number}   index   Index of the attachment to remove.
     */
    AttachmentCollection.prototype.RemoveAt = function (index) {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }
        this.InternalRemoveAt(index);
    };
    /**
     * @internal Saves this collection by creating new attachment and deleting removed ones.
     */
    AttachmentCollection.prototype.Save = function () {
        var _this = this;
        var attachments = [];
        // Retrieve a list of attachments that have to be deleted.
        for (var _a = 0, _b = this.RemovedItems; _a < _b.length; _a++) {
            var attachment = _b[_a];
            if (!attachment.IsNew) {
                attachments.push(attachment);
            }
        }
        // If any, delete them by calling the DeleteAttachment web method.
        //promise resolves with null to keep chaining
        return exports.Promise.resolve(attachments.length > 0 ? this.InternalDeleteAttachments(attachments) : void 0)
            .then(function () {
            attachments.splice(0);
        })
            .then(function () {
            // Retrieve a list of attachments that have to be created.
            for (var _a = 0, _b = _this.Items; _a < _b.length; _a++) {
                var attachment = _b[_a];
                if (attachment.IsNew) {
                    attachments.push(attachment);
                }
            }
            // If there are any, create them by calling the CreateAttachment web method.
            if (attachments.length > 0) {
                var parentId = _this.owner.IsAttachment ? _this.owner.ParentAttachment.Id : _this.owner.Id.UniqueId;
                return _this.InternalCreateAttachments(parentId, attachments);
            }
            else {
                return exports.Promise.resolve();
            }
        }).then(function () {
            // Process all of the item attachments in this collection.
            var itemAttachments = ArrayHelper.OfType(attachments, function (attachment) { return attachment instanceof ItemAttachment; });
            return itemAttachments.reduce(function (prev, curr, index) {
                return prev.then(function () {
                    return curr.Item.Attachments.Save().then(function () {
                        curr.Item.ClearChangeLog();
                    });
                });
            }, exports.Promise.resolve());
        }).then(function () {
            _super.prototype.ClearChangeLog.call(_this);
        });
    };
    /**
     * @internal Validates this instance.
     */
    AttachmentCollection.prototype.Validate = function () {
        // Validate all added attachments
        var contactPhotoFound = false;
        for (var attachmentIndex = 0; attachmentIndex < this.AddedItems.length; attachmentIndex++) {
            var attachment = this.AddedItems[attachmentIndex];
            if (attachment.IsNew) {
                // At the server side, only the last attachment with IsContactPhoto is kept, all other IsContactPhoto
                // attachments are removed. CreateAttachment will generate AttachmentId for each of such attachments (although
                // only the last one is valid).
                // 
                // With E14 SP2 CreateItemWithAttachment, such request will only return 1 AttachmentId; but the client
                // expects to see all, so let us prevent such "invalid" request in the first place. 
                // 
                // The IsNew check is to still let CreateAttachmentRequest allow multiple IsContactPhoto attachments.
                // 
                if (this.owner.IsNew && this.owner.Service.RequestedServerVersion >= ExchangeVersion.Exchange2010_SP2) {
                    var fileAttachment = attachment;
                    if (fileAttachment instanceof Attachment && fileAttachment.IsContactPhoto) {
                        if (contactPhotoFound) {
                            throw new ServiceValidationException(Strings.MultipleContactPhotosInAttachment);
                        }
                        contactPhotoFound = true;
                    }
                }
                attachment.Validate(attachmentIndex);
            }
        }
    };
    /**
     * @internal Validates and saves this instance. **Not in official EWS source, to workaround some promise errors with validate and save**
     */
    AttachmentCollection.prototype.ValidateAndSave = function () {
        this.Validate();
        return this.Save();
    };
    return AttachmentCollection;
}(ComplexPropertyCollection));
exports.AttachmentCollection = AttachmentCollection;
/**
 * Represents a collection of attendees.
 */
var AttendeeCollection = (function (_super) {
    __extends(AttendeeCollection, _super);
    /**
     * @internal Initializes a new instance of the **AttendeeCollection** class.
     */
    function AttendeeCollection() {
        return _super.call(this) || this;
    }
    AttendeeCollection.prototype.Add = function (nameOrSmtpAddressOrAttendee, smtpAddress) {
        var argsLength = arguments.length;
        var attendee = nameOrSmtpAddressOrAttendee;
        if (argsLength == 1) {
            if (typeof nameOrSmtpAddressOrAttendee === 'string') {
                attendee = new Attendee(nameOrSmtpAddressOrAttendee);
            }
            else {
                attendee = nameOrSmtpAddressOrAttendee;
            }
        }
        if (argsLength === 2) {
            attendee = new Attendee(nameOrSmtpAddressOrAttendee, smtpAddress);
        }
        this.InternalAdd(attendee);
        return attendee;
    };
    /**
     * Clears the collection.
     */
    AttendeeCollection.prototype.Clear = function () {
        this.InternalClear();
    };
    /**
     * @internal Creates an Attendee object from an XML element name.
     *
     * @param   {string}   xmlElementName   The XML element name from which to create the attendee.
     * @return  {Attendee}      An Attendee object.
     */
    AttendeeCollection.prototype.CreateComplexProperty = function (xmlElementName) {
        if (xmlElementName == XmlElementNames.Attendee) {
            return new Attendee();
        }
        else {
            return null;
        }
    };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {Attendee}      [description]
     */
    AttendeeCollection.prototype.CreateDefaultComplexProperty = function () { return new Attendee(); };
    /**
     * @internal Retrieves the XML element name corresponding to the provided Attendee object.
     *
     * @param   {Attendee}   attendee   The Attendee object from which to determine the XML element name.
     * @return  {string}        The XML element name corresponding to the provided Attendee object.
     */
    AttendeeCollection.prototype.GetCollectionItemXmlElementName = function (attendee) { return XmlElementNames.Attendee; };
    /**
     * Removes an attendee from the collection.
     *
     * @param   {Attendee}   attendee   The attendee to remove.
     * @return  {boolean}              True if the attendee was successfully removed from the collection, false otherwise.
     */
    AttendeeCollection.prototype.Remove = function (attendee) {
        EwsUtilities.ValidateParam(attendee, "attendee");
        return this.InternalRemove(attendee);
    };
    /**
     * Removes an attendee from the collection.
     *
     * @param   {number}   index   The index of the attendee to remove.
     */
    AttendeeCollection.prototype.RemoveAt = function (index) {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }
        this.InternalRemoveAt(index);
    };
    return AttendeeCollection;
}(ComplexPropertyCollection));
exports.AttendeeCollection = AttendeeCollection;
/**
 * Represents a collection of ContactEntity objects.
 */
var ContactEntityCollection = (function (_super) {
    __extends(ContactEntityCollection, _super);
    function ContactEntityCollection(collection) {
        if (collection === void 0) { collection = null; }
        var _this = _super.call(this) || this;
        if (collection != null) {
            collection.forEach(function (entity) { _this.InternalAdd(entity); });
        }
        return _this;
    }
    /**
     * @internal Creates the complex property.
     *
     * @param   {string}                xmlElementName   Name of the XML element.
     * @return  {ContactEntity}     ContactEntity.
     */
    ContactEntityCollection.prototype.CreateComplexProperty = function (xmlElementName) { return new ContactEntity(); };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {ContactEntity}      ContactEntity.
     */
    ContactEntityCollection.prototype.CreateDefaultComplexProperty = function () { return new ContactEntity(); };
    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {ContactEntity}     complexProperty   The complex property.
     * @return  {string}                XML element name.
     */
    ContactEntityCollection.prototype.GetCollectionItemXmlElementName = function (complexProperty) { return XmlElementNames.NlgContact; };
    return ContactEntityCollection;
}(ComplexPropertyCollection));
exports.ContactEntityCollection = ContactEntityCollection;
/**
 * Represents a collection of ContactPhoneEntity objects.
 */
var ContactPhoneEntityCollection = (function (_super) {
    __extends(ContactPhoneEntityCollection, _super);
    function ContactPhoneEntityCollection(collection) {
        if (collection === void 0) { collection = null; }
        var _this = _super.call(this) || this;
        if (collection != null) {
            collection.forEach(function (phone) { _this.InternalAdd(phone); });
        }
        return _this;
    }
    /**
     * @internal Creates the complex property.
     *
     * @param   {string}                xmlElementName   Name of the XML element.
     * @return  {ContactPhoneEntity}    ContactPhoneEntity.
     */
    ContactPhoneEntityCollection.prototype.CreateComplexProperty = function (xmlElementName) { return new ContactPhoneEntity(); };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {ContactPhoneEntity}    ContactPhoneEntity.
     */
    ContactPhoneEntityCollection.prototype.CreateDefaultComplexProperty = function () { return new ContactPhoneEntity(); };
    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {ContactPhoneEntity}    complexProperty   The complex property.
     * @return  {string}                XML element name.
     */
    ContactPhoneEntityCollection.prototype.GetCollectionItemXmlElementName = function (complexProperty) { return XmlElementNames.NlgPhone; };
    return ContactPhoneEntityCollection;
}(ComplexPropertyCollection));
exports.ContactPhoneEntityCollection = ContactPhoneEntityCollection;
/**
 * Represents a collection of conversation items.
 *
 * @sealed
 */
var ConversationNodeCollection = (function (_super) {
    __extends(ConversationNodeCollection, _super);
    /**
     * @internal Initializes a new instance of the **ConversationNodeCollection** class.
     *
     * @param   {PropertySet}   propertySet   The property set.
     */
    function ConversationNodeCollection(propertySet) {
        var _this = _super.call(this) || this;
        _this.propertySet = null;
        _this.propertySet = propertySet;
        return _this;
    }
    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {string}   complexProperty   The complex property.
     * @return  {ConversationNode}           XML element name.
     */
    ConversationNodeCollection.prototype.CreateComplexProperty = function (xmlElementName) {
        return new ConversationNode(this.propertySet);
    };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {ConversationNode}      ConversationItem.
     */
    ConversationNodeCollection.prototype.CreateDefaultComplexProperty = function () {
        return new ConversationNode(this.propertySet);
    };
    /**
     * @internal Loads from XMLjsObject.
     *
     * @interface   IJsonCollectionDeserializer
     *
     * @param   {any}               jsObjectCollection   The json collection.
     * @param   {ExchangeService}   service          The service.
     */
    ConversationNodeCollection.prototype.LoadFromXmlJsObject = function (jsObjectCollection, service) {
        var jsCollection = jsObjectCollection;
        if (!ArrayHelper.isArray(jsCollection)) {
            jsCollection = [jsObjectCollection];
        }
        for (var _a = 0, jsCollection_1 = jsCollection; _a < jsCollection_1.length; _a++) {
            var jsObject = jsCollection_1[_a];
            var jsEntry = jsObject;
            if (jsEntry != null) {
                var node = new ConversationNode(this.propertySet);
                node.LoadFromXmlJsObject(jsEntry, service);
                this.InternalAdd(node);
            }
        }
    };
    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {ConversationNode}  complexProperty   The complex property.
     * @return  {string}            XML element name.
     */
    ConversationNodeCollection.prototype.GetCollectionItemXmlElementName = function (complexProperty) {
        return complexProperty.GetXmlElementName();
    };
    return ConversationNodeCollection;
}(ComplexPropertyCollection));
exports.ConversationNodeCollection = ConversationNodeCollection;
/**
 * Represents a collection of deleted occurrence objects.
 */
var DeletedOccurrenceInfoCollection = (function (_super) {
    __extends(DeletedOccurrenceInfoCollection, _super);
    /**
     * @internal Initializes a new instance of the **OccurrenceInfoCollection** class.
     */
    function DeletedOccurrenceInfoCollection() {
        return _super.call(this) || this;
    }
    /**
     * @internal Creates the complex property.
     *
     * @param   {string}   xmlElementName   Name of the XML element.
     * @return  {DeletedOccurrenceInfo}     OccurenceInfo instance.
     */
    DeletedOccurrenceInfoCollection.prototype.CreateComplexProperty = function (xmlElementName) {
        if (xmlElementName == XmlElementNames.DeletedOccurrence) {
            return new DeletedOccurrenceInfo();
        }
        else {
            return null;
        }
    };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {DeletedOccurrenceInfo}     Default OccurenceInfo instance.
     */
    DeletedOccurrenceInfoCollection.prototype.CreateDefaultComplexProperty = function () { return new DeletedOccurrenceInfo(); };
    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {DeletedOccurrenceInfo}   complexProperty   The complex property.
     * @return  {string}        XML element name.
     */
    DeletedOccurrenceInfoCollection.prototype.GetCollectionItemXmlElementName = function (complexProperty) { return XmlElementNames.Occurrence; };
    return DeletedOccurrenceInfoCollection;
}(ComplexPropertyCollection));
exports.DeletedOccurrenceInfoCollection = DeletedOccurrenceInfoCollection;
/**
 * Represents a collection of e-mail addresses.
 */
var EmailAddressCollection = (function (_super) {
    __extends(EmailAddressCollection, _super);
    function EmailAddressCollection(collectionItemXmlElementName) {
        var _this = _super.call(this) || this;
        /**
         * XML element name
         */
        _this.collectionItemXmlElementName = null;
        _this.collectionItemXmlElementName = collectionItemXmlElementName || XmlElementNames.Mailbox;
        return _this;
    }
    EmailAddressCollection.prototype.Add = function (nameOrSmtpAddressOrEmailAddress, smtpAddress) {
        var argsLength = arguments.length;
        var emailAddress = nameOrSmtpAddressOrEmailAddress;
        if (argsLength == 1) {
            if (typeof nameOrSmtpAddressOrEmailAddress === 'string') {
                emailAddress = new EmailAddress(nameOrSmtpAddressOrEmailAddress);
            }
            else {
                emailAddress = nameOrSmtpAddressOrEmailAddress;
            }
        }
        if (argsLength === 2) {
            emailAddress = new EmailAddress(nameOrSmtpAddressOrEmailAddress, smtpAddress);
        }
        this.InternalAdd(emailAddress);
        return emailAddress;
    };
    EmailAddressCollection.prototype.AddRange = function (emailOrSmtpAddresses) {
        for (var _a = 0, emailOrSmtpAddresses_1 = emailOrSmtpAddresses; _a < emailOrSmtpAddresses_1.length; _a++) {
            var address = emailOrSmtpAddresses_1[_a];
            var emailAddress = address;
            if (typeof emailAddress === 'string') {
                emailAddress = new EmailAddress(address);
            }
            this.InternalAdd(emailAddress);
        }
    };
    /**
     * Clears the collection.
     */
    EmailAddressCollection.prototype.Clear = function () { this.InternalClear(); };
    /**
     * @internal Creates an EmailAddress object from an XML element name.
     *
     * @param   {string}   xmlElementName   The XML element name from which to create the e-mail address.
     * @return  {EmailAddress}              An EmailAddress object.
     */
    EmailAddressCollection.prototype.CreateComplexProperty = function (xmlElementName) {
        if (xmlElementName == this.collectionItemXmlElementName) {
            return new EmailAddress();
        }
        else {
            return null;
        }
    };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {EmailAddress}      default instance of EmailAddress
     */
    EmailAddressCollection.prototype.CreateDefaultComplexProperty = function () { return new EmailAddress(); };
    /**
     * @internal Retrieves the XML element name corresponding to the provided EmailAddress object.
     *
     * @param   {EmailAddress}   emailAddress   The EmailAddress object from which to determine the XML element name.
     * @return  {string}        The XML element name corresponding to the provided EmailAddress object.
     */
    EmailAddressCollection.prototype.GetCollectionItemXmlElementName = function (emailAddress) { return this.collectionItemXmlElementName; };
    /**
     * Removes an e-mail address from the collection.
     *
     * @param   {EmailAddress}  emailAddress   The e-mail address to remove.
     * @return  {boolean}       True if the email address was successfully removed from the collection, false otherwise.
     */
    EmailAddressCollection.prototype.Remove = function (emailAddress) {
        EwsUtilities.ValidateParam(emailAddress, "emailAddress");
        return this.InternalRemove(emailAddress);
    };
    /**
     * Removes an e-mail address from the collection.
     *
     * @param   {number}   index   The index of the e-mail address to remove.
     */
    EmailAddressCollection.prototype.RemoveAt = function (index) {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }
        this.InternalRemoveAt(index);
    };
    /**
     * @internal Determine whether we should write collection to XML or not.
     *
     * @return  {true}      Always true, even if the collection is empty.
     */
    EmailAddressCollection.prototype.ShouldWriteToRequest = function () { return true; };
    return EmailAddressCollection;
}(ComplexPropertyCollection));
exports.EmailAddressCollection = EmailAddressCollection;
/**
 * Represents a collection of EmailAddressEntity objects.
 */
var EmailAddressEntityCollection = (function (_super) {
    __extends(EmailAddressEntityCollection, _super);
    function EmailAddressEntityCollection(collection) {
        if (collection === void 0) { collection = null; }
        var _this = _super.call(this) || this;
        if (collection != null) {
            collection.forEach(function (entity) { _this.InternalAdd(entity); });
        }
        return _this;
    }
    /**
     * @internal Creates the complex property.
     *
     * @param   {string}                xmlElementName   Name of the XML element.
     * @return  {EmailAddressEntity}    EmailAddressEntity.
     */
    EmailAddressEntityCollection.prototype.CreateComplexProperty = function (xmlElementName) { return new EmailAddressEntity(); };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {EmailAddressEntity}      EmailAddressEntity.
     */
    EmailAddressEntityCollection.prototype.CreateDefaultComplexProperty = function () { return new EmailAddressEntity(); };
    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {EmailAddressEntity}    complexProperty   The complex property.
     * @return  {string}                XML element name.
     */
    EmailAddressEntityCollection.prototype.GetCollectionItemXmlElementName = function (complexProperty) { return XmlElementNames.NlgEmailAddress; };
    return EmailAddressEntityCollection;
}(ComplexPropertyCollection));
exports.EmailAddressEntityCollection = EmailAddressEntityCollection;
/**
 * Represents a collection of EmailUserEntity objects.
 */
var EmailUserEntityCollection = (function (_super) {
    __extends(EmailUserEntityCollection, _super);
    function EmailUserEntityCollection(collection) {
        if (collection === void 0) { collection = null; }
        var _this = _super.call(this) || this;
        if (collection != null) {
            collection.forEach(function (entity) { _this.InternalAdd(entity); });
        }
        return _this;
    }
    /**
     * @internal Creates the complex property.
     *
     * @param   {string}              xmlElementName   Name of the XML element.
     * @return  {EmailUserEntity}     EmailUserEntity.
     */
    EmailUserEntityCollection.prototype.CreateComplexProperty = function (xmlElementName) { return new EmailUserEntity(); };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {EmailUserEntity}      EmailUserEntity.
     */
    EmailUserEntityCollection.prototype.CreateDefaultComplexProperty = function () { return new EmailUserEntity(); };
    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {EmailUserEntity}       complexProperty   The complex property.
     * @return  {string}                XML element name.
     */
    EmailUserEntityCollection.prototype.GetCollectionItemXmlElementName = function (complexProperty) { return XmlElementNames.NlgEmailUser; };
    return EmailUserEntityCollection;
}(ComplexPropertyCollection));
exports.EmailUserEntityCollection = EmailUserEntityCollection;
var ExtendedPropertyCollection = (function (_super) {
    __extends(ExtendedPropertyCollection, _super);
    function ExtendedPropertyCollection() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ExtendedPropertyCollection.prototype.CreateComplexProperty = function (xmlElementName) { return new ExtendedProperty(); };
    ExtendedPropertyCollection.prototype.CreateDefaultComplexProperty = function () { return new ExtendedProperty(); };
    ExtendedPropertyCollection.prototype.GetCollectionItemXmlElementName = function (complexProperty) { return null; };
    ExtendedPropertyCollection.prototype.GetOrAddExtendedProperty = function (propertyDefinition) {
        var extendedProperty = { outValue: null };
        if (!this.TryGetProperty(propertyDefinition, extendedProperty)) {
            extendedProperty.outValue = new ExtendedProperty(propertyDefinition);
            this.InternalAdd(extendedProperty.outValue);
        }
        return extendedProperty.outValue;
    };
    ExtendedPropertyCollection.prototype.InternalToJson = function (service) { throw new Error("ExtendedPropertyCollection.ts - InternalToJson : Not implemented."); };
    ExtendedPropertyCollection.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        var extendedProperty = new ExtendedProperty();
        //debugger; //debug: //todo: check for need of local element -not tested
        extendedProperty.LoadFromXmlJsObject(jsObject, service);
        this.InternalAdd(extendedProperty);
    };
    ExtendedPropertyCollection.prototype.RemoveExtendedProperty = function (propertyDefinition) {
        //EwsUtilities.ValidateParam(propertyDefinition, "propertyDefinition");
        var extendedProperty = { outValue: null };
        if (this.TryGetProperty(propertyDefinition, extendedProperty)) {
            return this.InternalRemove(extendedProperty.outValue);
        }
        else {
            return false;
        }
    };
    ExtendedPropertyCollection.prototype.SetExtendedProperty = function (propertyDefinition, value) {
        var extendedProperty = this.GetOrAddExtendedProperty(propertyDefinition);
        extendedProperty.Value = value;
    };
    ExtendedPropertyCollection.prototype.TryGetProperty = function (propertyDefinition, extendedProperty) {
        extendedProperty.outValue = ArrayHelper.Find(this.Items, function (prop) { return prop.PropertyDefinition.Equals(propertyDefinition); });
        return extendedProperty.outValue != null;
    };
    ExtendedPropertyCollection.prototype.TryGetValue = function (propertyDefinition, propertyValue) {
        var extendedProperty = { outValue: null };
        if (this.TryGetProperty(propertyDefinition, extendedProperty)) {
            //debug: Verify that the type parameter and property definition's type are compatible.
            //if (!typeof (T).IsAssignableFrom(propertyDefinition.Type)) {
            // var errorMessage = StringHelper.Format(
            //     Strings.PropertyDefinitionTypeMismatch,
            //     EwsUtilities.GetPrintableTypeName(propertyDefinition.Type),
            //     EwsUtilities.GetPrintableTypeName("Y"));
            // throw new ArgumentException(errorMessage +  " - propertyDefinition");
            //}
            propertyValue.outValue = extendedProperty.outValue.Value;
            return true;
        }
        else {
            propertyValue.outValue = null; // default(T);
            return false;
        }
    };
    /**@internal */
    ExtendedPropertyCollection.prototype.WriteToXml = function (writer, xmlElementName) {
        for (var _a = 0, _b = this.Items; _a < _b.length; _a++) {
            var extendedProperty = _b[_a];
            extendedProperty.WriteToXml(writer, XmlElementNames.ExtendedProperty);
        }
    };
    return ExtendedPropertyCollection;
}(ComplexPropertyCollection));
exports.ExtendedPropertyCollection = ExtendedPropertyCollection;
/**
 * Represents a collection of folder Ids.
 *
 * @sealed
 */
var FolderIdCollection = (function (_super) {
    __extends(FolderIdCollection, _super);
    function FolderIdCollection(folderIds) {
        if (folderIds === void 0) { folderIds = null; }
        var _this = _super.call(this) || this;
        if (folderIds != null) {
            folderIds.forEach(function (folderId) { return _this.InternalAdd(folderId); });
        }
        return _this;
    }
    FolderIdCollection.prototype.Add = function (folderIdOrName) {
        var folderId = null;
        if (typeof folderIdOrName === 'number') {
            folderId = new FolderId(folderIdOrName);
            if (ArrayHelper.Find(this.Items, function (item) { return item.FolderName === folderIdOrName; })) {
                throw new ArgumentException(Strings.IdAlreadyInList, "folderName");
            }
        }
        else {
            EwsUtilities.ValidateParam(folderId, "folderId");
            folderId = folderIdOrName;
            if (this.Contains(folderId)) {
                throw new ArgumentException(Strings.IdAlreadyInList, "folderId");
            }
        }
        this.InternalAdd(folderId);
        return folderId;
    };
    /**
     * Clears the collection.
     */
    FolderIdCollection.prototype.Clear = function () {
        this.InternalClear();
    };
    /**
     * @internal Instantiate the appropriate attachment type depending on the current XML element name.
     *
     * @param   {string}   xmlElementName   Name of the XML element.
     * @return  {FolderId}        FolderId.
     */
    FolderIdCollection.prototype.CreateComplexProperty = function (xmlElementName) {
        return new FolderId();
    };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {FolderId}      FolderId.
     */
    FolderIdCollection.prototype.CreateDefaultComplexProperty = function () {
        return new FolderId();
    };
    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {FolderId}  complexProperty   The complex property.
     * @return  {string}    XML element name.
     */
    FolderIdCollection.prototype.GetCollectionItemXmlElementName = function (complexProperty) {
        return complexProperty.GetXmlElementName();
    };
    FolderIdCollection.prototype.Remove = function (folderIdOrName) {
        if (typeof folderIdOrName === 'number') {
            // can not simply use InternalRemove as javascript does not have c# List functionality
            var index = ArrayHelper.IndexOf(this.Items, function (item) { return item.FolderName === folderIdOrName; });
            if (index >= 0) {
                this.InternalRemoveAt(index);
                return true;
            }
        }
        else {
            EwsUtilities.ValidateParam(folderIdOrName, "folderId");
            return this.InternalRemove(folderIdOrName);
        }
        return false;
    };
    /**
     * Removes the folder Id at the specified index.
     *
     * @param   {number}   index   The zero-based index of the folder Id to remove.
     */
    FolderIdCollection.prototype.RemoveAt = function (index) {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }
        this.InternalRemoveAt(index);
    };
    return FolderIdCollection;
}(ComplexPropertyCollection));
exports.FolderIdCollection = FolderIdCollection;
/**
 * Represents a collection of folder permissions.
 *
 * @sealed
 */
var FolderPermissionCollection = (function (_super) {
    __extends(FolderPermissionCollection, _super);
    /**
     * Initializes a new instance of the **FolderPermissionCollection** class.
     *
     * @param   {Folder}   owner   The folder owner.
     */
    function FolderPermissionCollection(owner) {
        var _this = _super.call(this) || this;
        _this.unknownEntries = [];
        _this.isCalendarFolder = owner instanceof TypeContainer.CalendarFolder; // owner instanceof CalendarFolder;
        return _this;
    }
    Object.defineProperty(FolderPermissionCollection.prototype, "InnerCollectionXmlElementName", {
        /**
         * Gets the name of the inner collection XML element.
         *
         * @value   XML element name.
         */
        get: function () {
            return this.isCalendarFolder ? XmlElementNames.CalendarPermissions : XmlElementNames.Permissions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderPermissionCollection.prototype, "CollectionItemXmlElementName", {
        /**
         * Gets the name of the collection item XML element.
         *
         * @value   XML element name.
         */
        get: function () {
            return this.isCalendarFolder ? XmlElementNames.CalendarPermission : XmlElementNames.Permission;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderPermissionCollection.prototype, "UnknownEntries", {
        /**
         * Gets a list of unknown user Ids in the collection.
         */
        get: function () {
            return this.unknownEntries;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds a permission to the collection.
     *
     * @param   {FolderPermission}   permission   The permission to add.
     */
    FolderPermissionCollection.prototype.Add = function (permission) {
        this.InternalAdd(permission);
    };
    /**
     * Adds the specified permissions to the collection.
     *
     * @param   {FolderPermission[]}   permissions   The permissions to add.
     */
    FolderPermissionCollection.prototype.AddRange = function (permissions) {
        EwsUtilities.ValidateParam(permissions, "permissions");
        for (var _a = 0, permissions_1 = permissions; _a < permissions_1.length; _a++) {
            var permission = permissions_1[_a];
            this.Add(permission);
        }
    };
    /**
     * Clears this collection.
     */
    FolderPermissionCollection.prototype.Clear = function () {
        this.InternalClear();
    };
    /**
     * @internal Creates the complex property.
     *
     * @param   {string}   xmlElementName   Name of the XML element.
     * @return  {FolderPermission}          FolderPermission instance.
     */
    FolderPermissionCollection.prototype.CreateComplexProperty = function (xmlElementName) {
        return new FolderPermission();
    };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {FolderPermission}  FolderPermission instance.
     */
    FolderPermissionCollection.prototype.CreateDefaultComplexProperty = function () {
        return new FolderPermission();
    };
    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {FolderPermission}      complexProperty   The complex property.
     * @return  {string}                XML element name.
     */
    FolderPermissionCollection.prototype.GetCollectionItemXmlElementName = function (complexProperty) {
        return this.CollectionItemXmlElementName;
    };
    /**
     * @internal Loads from XMLJsObject collection to create a new collection item.
     *
     * @interface   IJsonCollectionDeserializer
     *
     * @param   {any}               jsObjectCollection   The json collection.
     * @param   {ExchangeService}   service          The service.
     */
    FolderPermissionCollection.prototype.CreateFromXmlJsObjectCollection = function (jsObjectCollection, service) {
        var jsonFolderPermissions = jsObjectCollection[this.InnerCollectionXmlElementName];
        if (jsonFolderPermissions && jsonFolderPermissions[this.CollectionItemXmlElementName])
            jsonFolderPermissions = jsonFolderPermissions[this.CollectionItemXmlElementName];
        if (!Array.isArray(jsonFolderPermissions)) {
            debugger;
            throw new Error("FolderPermissionCollection.ts - LoadFromXmlJsObject - Invalid xml parsing, jsonproperty must contain collectionxmlelementname and collectionitemelementname underneeth");
        }
        for (var _a = 0, jsonFolderPermissions_1 = jsonFolderPermissions; _a < jsonFolderPermissions_1.length; _a++) {
            var jsonFolderPermission = jsonFolderPermissions_1[_a];
            var permission = new FolderPermission();
            permission.LoadFromXmlJsObject(jsonFolderPermission, service);
            this.InternalAdd(permission);
        }
        if (jsObjectCollection[XmlElementNames.UnknownEntries]) {
            var jsonUnknownEntries = jsObjectCollection[XmlElementNames.UnknownEntries];
            if (typeof jsonUnknownEntries !== 'object' && !Array.isArray(jsonFolderPermissions)) {
                debugger;
                throw new Error("FolderPermissionCollection.ts - LoadFromXmlJsObject - Invalid xml returned - check for consistency, UnknownEntries must be array type");
            }
            for (var _b = 0, jsonUnknownEntries_1 = jsonUnknownEntries; _b < jsonUnknownEntries_1.length; _b++) {
                var jsonUnknownEntry = jsonUnknownEntries_1[_b];
                this.unknownEntries.push(jsonUnknownEntry);
            }
        }
    };
    /**
     * Removes a permission from the collection.
     *
     * @param   {FolderPermission}  permission   The permission to remove.
     * @return  {boolean}           True if the folder permission was successfully removed from the collection, false otherwise.
     */
    FolderPermissionCollection.prototype.Remove = function (permission) {
        return this.InternalRemove(permission);
    };
    /**
     * Removes a permission from the collection.
     *
     * @param   {number}   index   The zero-based index of the permission to remove.
     */
    FolderPermissionCollection.prototype.RemoveAt = function (index) {
        this.InternalRemoveAt(index);
    };
    /**
     * @internal Validates this instance.
     */
    FolderPermissionCollection.prototype.Validate = function () {
        for (var permissionIndex = 0; permissionIndex < this.Items.length; permissionIndex++) {
            var permission = this.Items[permissionIndex];
            permission.Validate(this.isCalendarFolder, permissionIndex);
        }
    };
    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    FolderPermissionCollection.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Types, this.InnerCollectionXmlElementName);
        for (var _a = 0, _b = this.Items; _a < _b.length; _a++) {
            var folderPermission = _b[_a];
            folderPermission.WriteToXml(writer, this.GetCollectionItemXmlElementName(folderPermission), undefined, //XmlNamespace - incorrect inheritance error with typesctipt in folderpermission class if removed xmlnamespace parameter
            this.isCalendarFolder);
        }
        writer.WriteEndElement(); // this.InnerCollectionXmlElementName
    };
    return FolderPermissionCollection;
}(ComplexPropertyCollection));
exports.FolderPermissionCollection = FolderPermissionCollection;
var GroupMemberCollection = (function (_super) {
    __extends(GroupMemberCollection, _super);
    function GroupMemberCollection() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GroupMemberCollection.prototype.Add = function (member) { throw new Error("GroupMemberCollection.ts - Add : Not implemented."); };
    GroupMemberCollection.prototype.AddContactEmailAddress = function (contact, emailAddressKey) { throw new Error("GroupMemberCollection.ts - AddContactEmailAddress : Not implemented."); };
    GroupMemberCollection.prototype.AddContactGroup = function (contactGroupId) { throw new Error("GroupMemberCollection.ts - AddContactGroup : Not implemented."); };
    GroupMemberCollection.prototype.AddDirectoryContact = function (address, routingType) { throw new Error("GroupMemberCollection.ts - AddDirectoryContact : Not implemented."); };
    //AddDirectoryContact(smtpAddress: string): any { throw new Error("GroupMemberCollection.ts - AddDirectoryContact : Not implemented."); }
    GroupMemberCollection.prototype.AddDirectoryPublicFolder = function (smtpAddress) { throw new Error("GroupMemberCollection.ts - AddDirectoryPublicFolder : Not implemented."); };
    GroupMemberCollection.prototype.AddDirectoryUser = function (address, routingType) { throw new Error("GroupMemberCollection.ts - AddDirectoryUser : Not implemented."); };
    //AddDirectoryUser(smtpAddress: string): any { throw new Error("GroupMemberCollection.ts - AddDirectoryUser : Not implemented."); }
    GroupMemberCollection.prototype.AddOneOff = function (displayName, address, routingType) { throw new Error("GroupMemberCollection.ts - AddOneOff : Not implemented."); };
    //AddOneOff(displayName: string, smtpAddress: string): any { throw new Error("GroupMemberCollection.ts - AddOneOff : Not implemented."); }
    GroupMemberCollection.prototype.AddPersonalContact = function (contactId) { throw new Error("GroupMemberCollection.ts - AddPersonalContact : Not implemented."); };
    //AddPersonalContact(contactId: ItemId, addressToLink: string): any { throw new Error("GroupMemberCollection.ts - AddPersonalContact : Not implemented."); }
    GroupMemberCollection.prototype.AddPublicGroup = function (smtpAddress) { throw new Error("GroupMemberCollection.ts - AddPublicGroup : Not implemented."); };
    GroupMemberCollection.prototype.AddRange = function (members /*System.Collections.Generic.IEnumerable<T>*/) { throw new Error("GroupMemberCollection.ts - AddRange : Not implemented."); };
    GroupMemberCollection.prototype.Clear = function () { throw new Error("GroupMemberCollection.ts - Clear : Not implemented."); };
    GroupMemberCollection.prototype.ClearChangeLog = function () { throw new Error("GroupMemberCollection.ts - ClearChangeLog : Not implemented."); };
    GroupMemberCollection.prototype.CreateComplexProperty = function (xmlElementName) { throw new Error("GroupMemberCollection.ts - CreateComplexProperty : Not implemented."); };
    GroupMemberCollection.prototype.CreateDefaultComplexProperty = function () { throw new Error("GroupMemberCollection.ts - CreateDefaultComplexProperty : Not implemented."); };
    GroupMemberCollection.prototype.Find = function (key) { throw new Error("GroupMemberCollection.ts - Find : Not implemented."); };
    GroupMemberCollection.prototype.GetCollectionItemXmlElementName = function (member) { throw new Error("GroupMemberCollection.ts - GetCollectionItemXmlElementName : Not implemented."); };
    GroupMemberCollection.prototype.InternalValidate = function () { throw new Error("GroupMemberCollection.ts - InternalValidate : Not implemented."); };
    GroupMemberCollection.prototype.Remove = function (member) { throw new Error("GroupMemberCollection.ts - Remove : Not implemented."); };
    GroupMemberCollection.prototype.RemoveAt = function (index) { throw new Error("GroupMemberCollection.ts - RemoveAt : Not implemented."); };
    /**@internal */
    GroupMemberCollection.prototype.WriteDeleteMembersCollectionToXml = function (writer) { throw new Error("GroupMemberCollection.ts - WriteDeleteMembersCollectionToXml : Not implemented."); };
    /**@internal */
    GroupMemberCollection.prototype.WriteDeleteMembersToXml = function (writer, members /* System.Collections.Generic.List<GroupMember>*/) { throw new Error("GroupMemberCollection.ts - WriteDeleteMembersToXml : Not implemented."); };
    /**@internal */
    GroupMemberCollection.prototype.WriteSetOrAppendMembersToXml = function (writer, members /*System.Collections.Generic.List<GroupMember>*/, setMode) { throw new Error("GroupMemberCollection.ts - WriteSetOrAppendMembersToXml : Not implemented."); };
    return GroupMemberCollection;
}(ComplexPropertyCollection));
exports.GroupMemberCollection = GroupMemberCollection;
//}
/**
 * Represents a collection of Internet message headers.
 */
var InternetMessageHeaderCollection = (function (_super) {
    __extends(InternetMessageHeaderCollection, _super);
    /**
     * @internal Initializes a new instance of the **InternetMessageHeaderCollection** class.
     */
    function InternetMessageHeaderCollection() {
        return _super.call(this) || this;
    }
    /**
     * @internal Creates the complex property.
     *
     * @param   {string}   xmlElementName   Name of the XML element.
     * @return  {InternetMessageHeader}     InternetMessageHeader instance.
     */
    InternetMessageHeaderCollection.prototype.CreateComplexProperty = function (xmlElementName) { return new InternetMessageHeader(); };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {InternetMessageHeader}      InternetMessageHeader instance.
     */
    InternetMessageHeaderCollection.prototype.CreateDefaultComplexProperty = function () { return new InternetMessageHeader(); };
    /**
     * Find a specific header in the collection.
     *
     * @param   {string}   name   The name of the header to locate.
     * @return  {InternetMessageHeader}     An InternetMessageHeader representing the header with the specified name; null if no header with the specified name was found.
     */
    InternetMessageHeaderCollection.prototype.Find = function (name) {
        for (var _a = 0, _b = this.Items; _a < _b.length; _a++) {
            var internetMessageHeader = _b[_a];
            if (name.toUpperCase() === internetMessageHeader.Name.toUpperCase()) {
                return internetMessageHeader;
            }
        }
        return null;
    };
    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {InternetMessageHeader}     complexProperty   The complex property.
     * @return  {string}                    XML element name.
     */
    InternetMessageHeaderCollection.prototype.GetCollectionItemXmlElementName = function (complexProperty) { return XmlElementNames.InternetMessageHeader; };
    return InternetMessageHeaderCollection;
}(ComplexPropertyCollection));
exports.InternetMessageHeaderCollection = InternetMessageHeaderCollection;
/**
 * Represents a collection of item Ids.
 *
 * @sealed
 */
var ItemIdCollection = (function (_super) {
    __extends(ItemIdCollection, _super);
    /**
     * @internal Initializes a new instance of the **ItemIdCollection** class.
     */
    function ItemIdCollection() {
        return _super.call(this) || this;
    }
    /**
     * @internal Creates the complex property.
     *
     * @param   {string}    xmlElementName   Name of the XML element.
     * @return  {ItemId}    ItemId.
     */
    ItemIdCollection.prototype.CreateComplexProperty = function (xmlElementName) {
        return new ItemId();
    };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {ItemId}      ItemId.
     */
    ItemIdCollection.prototype.CreateDefaultComplexProperty = function () {
        return new ItemId();
    };
    /**
     * @internal Loads from XMLJsObject collection to create a new collection item.
     *
     * @interface   IJsonCollectionDeserializer
     *
     * @param   {any}               jsObjectCollection   The json collection.
     * @param   {ExchangeService}   service          The service.
     */
    ItemIdCollection.prototype.CreateFromXmlJsObjectCollection = function (jsObjectCollection, service) {
        var collection = jsObjectCollection;
        if (!ArrayHelper.isArray(collection)) {
            if (jsObjectCollection[XmlElementNames.OccurrenceItemId]) {
                EwsLogging.Log("Fix needed for ItemIdCollection for element OccurrenceItemId", true, true);
                EwsLogging.Log(jsObjectCollection[XmlElementNames.OccurrenceItemId], true, true);
            }
            if (jsObjectCollection[XmlElementNames.RecurringMasterItemId]) {
                EwsLogging.Log("Fix needed for ItemIdCollection for element RecurringMasterItemId", true, true);
                EwsLogging.Log(jsObjectCollection[XmlElementNames.RecurringMasterItemId], true, true);
            }
            collection = EwsServiceJsonReader.ReadAsArray(collection, XmlElementNames.ItemId);
        }
        _super.prototype.CreateFromXmlJsObjectCollection.call(this, collection, service);
    };
    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {ItemId}   complexProperty   The complex property.
     * @return  {string}                     XML element name.
     */
    ItemIdCollection.prototype.GetCollectionItemXmlElementName = function (complexProperty) {
        return complexProperty.GetXmlElementName();
    };
    /**
     * @internal Loads from XMLJsObject collection to update collection Items.
     *
     * @interface   IJsonCollectionDeserializer
     *
     * @param   {any}               jsObjectCollection   The XMLJsObject collection.
     * @param   {ExchangeService}   service          The service.
     */
    ItemIdCollection.prototype.UpdateFromXmlJsObjectCollection = function (jsObjectCollection, service) {
        var collection = jsObjectCollection;
        if (!ArrayHelper.isArray(collection)) {
            collection = EwsServiceJsonReader.ReadAsArray(collection, XmlElementNames.ItemId);
        }
        _super.prototype.UpdateFromXmlJsObjectCollection.call(this, collection, service);
    };
    return ItemIdCollection;
}(ComplexPropertyCollection));
exports.ItemIdCollection = ItemIdCollection;
/**
 * Represents a collection of MeetingSuggestion objects.
 */
var MeetingSuggestionCollection = (function (_super) {
    __extends(MeetingSuggestionCollection, _super);
    function MeetingSuggestionCollection(collection) {
        if (collection === void 0) { collection = null; }
        var _this = _super.call(this) || this;
        if (collection != null) {
            collection.forEach(function (suggestion) { _this.InternalAdd(suggestion); });
        }
        return _this;
    }
    /**
     * @internal Creates the complex property.
     *
     * @param   {string}                xmlElementName   Name of the XML element.
     * @return  {MeetingSuggestion}     MeetingSuggestion.
     */
    MeetingSuggestionCollection.prototype.CreateComplexProperty = function (xmlElementName) { return new MeetingSuggestion(); };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {MeetingSuggestion}      MeetingSuggestion.
     */
    MeetingSuggestionCollection.prototype.CreateDefaultComplexProperty = function () { return new MeetingSuggestion(); };
    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {MeetingSuggestion}     complexProperty   The complex property.
     * @return  {string}                XML element name.
     */
    MeetingSuggestionCollection.prototype.GetCollectionItemXmlElementName = function (complexProperty) { return XmlElementNames.NlgMeetingSuggestion; };
    return MeetingSuggestionCollection;
}(ComplexPropertyCollection));
exports.MeetingSuggestionCollection = MeetingSuggestionCollection;
/**
 * Represents a collection of OccurrenceInfo objects.
 */
var OccurrenceInfoCollection = (function (_super) {
    __extends(OccurrenceInfoCollection, _super);
    /**
     * @internal Initializes a new instance of the **OccurrenceInfoCollection** class.
     */
    function OccurrenceInfoCollection() {
        return _super.call(this) || this;
    }
    /**
     * @internal Creates the complex property.
     *
     * @param   {string}   xmlElementName   Name of the XML element.
     * @return  {OccurrenceInfo}        OccurenceInfo instance.
     */
    OccurrenceInfoCollection.prototype.CreateComplexProperty = function (xmlElementName) {
        if (xmlElementName == XmlElementNames.Occurrence) {
            return new OccurrenceInfo();
        }
        else {
            return null;
        }
    };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {OccurrenceInfo}      OccurenceInfo instance.
     */
    OccurrenceInfoCollection.prototype.CreateDefaultComplexProperty = function () { return new OccurrenceInfo(); };
    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {OccurrenceInfo}    complexProperty   The complex property.
     * @return  {string}            XML element name.
     */
    OccurrenceInfoCollection.prototype.GetCollectionItemXmlElementName = function (complexProperty) { return XmlElementNames.Occurrence; };
    return OccurrenceInfoCollection;
}(ComplexPropertyCollection));
exports.OccurrenceInfoCollection = OccurrenceInfoCollection;
/**
 * Represents a collection of PhoneEntity objects.
 */
var PhoneEntityCollection = (function (_super) {
    __extends(PhoneEntityCollection, _super);
    function PhoneEntityCollection(collection) {
        if (collection === void 0) { collection = null; }
        var _this = _super.call(this) || this;
        if (collection != null) {
            collection.forEach(function (suggestion) { _this.InternalAdd(suggestion); });
        }
        return _this;
    }
    /**
     * @internal Creates the complex property.
     *
     * @param   {string}        xmlElementName   Name of the XML element.
     * @return  {PhoneEntity}   PhoneEntity.
     */
    PhoneEntityCollection.prototype.CreateComplexProperty = function (xmlElementName) { return new PhoneEntity(); };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {PhoneEntity}      PhoneEntity.
     */
    PhoneEntityCollection.prototype.CreateDefaultComplexProperty = function () { return new PhoneEntity(); };
    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {PhoneEntity}   complexProperty   The complex property.
     * @return  {string}        XML element name.
     */
    PhoneEntityCollection.prototype.GetCollectionItemXmlElementName = function (complexProperty) { return XmlElementNames.NlgPhone; };
    return PhoneEntityCollection;
}(ComplexPropertyCollection));
exports.PhoneEntityCollection = PhoneEntityCollection;
/**
 * @internal Represents a collection of rule validation errors.
 *
 * @sealed
 */
var RuleErrorCollection = (function (_super) {
    __extends(RuleErrorCollection, _super);
    /**
     * @internal Initializes a new instance of the **RuleErrorCollection** class.
     */
    function RuleErrorCollection() {
        return _super.call(this) || this;
    }
    /**
     * @internal Creates an RuleError object from an XML element name.
     *
     * @param   {string}   xmlElementName   The XML element name from which to create the RuleError object.
     * @return  {RuleError}        A RuleError object.
     */
    RuleErrorCollection.prototype.CreateComplexProperty = function (xmlElementName) {
        if (xmlElementName == XmlElementNames.Error) {
            return new RuleError();
        }
        else {
            return null;
        }
    };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {RuleError}      A RuleError object.
     */
    RuleErrorCollection.prototype.CreateDefaultComplexProperty = function () {
        return new RuleError();
    };
    /**
     * @internal Retrieves the XML element name corresponding to the provided RuleError object.
     *
     * @param   {RuleError}		ruleValidationError   The RuleError object from which to determine the XML element name.
     * @return  {string}		The XML element name corresponding to the provided RuleError object.
     */
    RuleErrorCollection.prototype.GetCollectionItemXmlElementName = function (ruleValidationError) {
        return XmlElementNames.Error;
    };
    return RuleErrorCollection;
}(ComplexPropertyCollection));
exports.RuleErrorCollection = RuleErrorCollection;
/**
 * Represents a collection of rule operation errors.
 *
 * @sealed
 */
var RuleOperationErrorCollection = (function (_super) {
    __extends(RuleOperationErrorCollection, _super);
    /**
     * @internal Initializes a new instance of the **RuleOperationErrorCollection** class.
     */
    function RuleOperationErrorCollection() {
        return _super.call(this) || this;
    }
    /**
     * @internal Creates an RuleOperationError object from an XML element name.
     *
     * @param   {string}   xmlElementName   The XML element name from which to create the RuleOperationError object.
     * @return  {RuleOperationError}        A RuleOperationError object.
     */
    RuleOperationErrorCollection.prototype.CreateComplexProperty = function (xmlElementName) {
        if (xmlElementName == XmlElementNames.RuleOperationError) {
            return new RuleOperationError();
        }
        else {
            return null;
        }
    };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {RuleOperationError}      A RuleOperationError object.
     */
    RuleOperationErrorCollection.prototype.CreateDefaultComplexProperty = function () {
        return new RuleOperationError();
    };
    /**
     * @internal Retrieves the XML element name corresponding to the provided RuleOperationError object.
     *
     * @param   {RuleOperationError}    operationError   The RuleOperationError object from which to determine the XML element name.
     * @return  {string}                The XML element name corresponding to the provided RuleOperationError object.
     */
    RuleOperationErrorCollection.prototype.GetCollectionItemXmlElementName = function (operationError) {
        return XmlElementNames.RuleOperationError;
    };
    return RuleOperationErrorCollection;
}(ComplexPropertyCollection));
exports.RuleOperationErrorCollection = RuleOperationErrorCollection;
/**
 * Represents a collection of TaskSuggestion objects.
 */
var TaskSuggestionCollection = (function (_super) {
    __extends(TaskSuggestionCollection, _super);
    function TaskSuggestionCollection(collection) {
        if (collection === void 0) { collection = null; }
        var _this = _super.call(this) || this;
        if (collection != null) {
            collection.forEach(function (suggestion) { _this.InternalAdd(suggestion); });
        }
        return _this;
    }
    /**
     * @internal Creates the complex property.
     *
     * @param   {string}            xmlElementName   Name of the XML element.
     * @return  {TaskSuggestion}    TaskSuggestion.
     */
    TaskSuggestionCollection.prototype.CreateComplexProperty = function (xmlElementName) { return new TaskSuggestion(); };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {TaskSuggestion}      TaskSuggestion.
     */
    TaskSuggestionCollection.prototype.CreateDefaultComplexProperty = function () { return new TaskSuggestion(); };
    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {TaskSuggestion}    complexProperty   The complex property.
     * @return  {string}            XML element name.
     */
    TaskSuggestionCollection.prototype.GetCollectionItemXmlElementName = function (complexProperty) { return XmlElementNames.NlgTaskSuggestion; };
    return TaskSuggestionCollection;
}(ComplexPropertyCollection));
exports.TaskSuggestionCollection = TaskSuggestionCollection;
/**
 * Represents a collection of UrlEntity objects.
 */
var UrlEntityCollection = (function (_super) {
    __extends(UrlEntityCollection, _super);
    function UrlEntityCollection(collection) {
        if (collection === void 0) { collection = null; }
        var _this = _super.call(this) || this;
        if (collection != null) {
            collection.forEach(function (entity) { _this.InternalAdd(entity); });
        }
        return _this;
    }
    /**
     * @internal Creates the complex property.
     *
     * @param   {string}        xmlElementName   Name of the XML element.
     * @return  {UrlEntity}     UrlEntity.
     */
    UrlEntityCollection.prototype.CreateComplexProperty = function (xmlElementName) { return new UrlEntity(); };
    /**
     * @internal Creates the default complex property.
     *
     * @return  {UrlEntity}      UrlEntity.
     */
    UrlEntityCollection.prototype.CreateDefaultComplexProperty = function () { return new UrlEntity(); };
    /**
     * @internal Gets the name of the collection item XML element.
     *
     * @param   {UrlEntity}     complexProperty   The complex property.
     * @return  {string}        XML element name.
     */
    UrlEntityCollection.prototype.GetCollectionItemXmlElementName = function (complexProperty) { return XmlElementNames.NlgUrl; };
    return UrlEntityCollection;
}(ComplexPropertyCollection));
exports.UrlEntityCollection = UrlEntityCollection;
/**
 * Represents the base class for all property definitions.
 */
var PropertyDefinitionBase = (function () {
    /**
     * @internal Initializes a new instance of the **PropertyDefinitionBase** class.
     */
    function PropertyDefinitionBase() {
    }
    Object.defineProperty(PropertyDefinitionBase.prototype, "Type", {
        /**
         * Gets the type of the property.
         */
        get: function () { return PropertyDefinitionBase; } //System.Type;
        ,
        enumerable: true,
        configurable: true
    });
    PropertyDefinitionBase.prototype.ToString = function () { return this.GetPrintableName(); };
    //TryLoadFromJson(jsonObject: JsonObject): PropertyDefinitionBase{ throw new Error("PropertyDefinitionBase.ts - TryLoadFromJson : Not implemented.");}
    /**
     * @internal load from XMLJsObject.
     *
     * @param   {any}   jsonObject   The json object.
     * @return  {PropertyDefinitionBase}        True if property was loaded.
     */
    PropertyDefinitionBase.LoadFromXmlJsObject = function (jsObject) {
        for (var key in jsObject) {
            if (key.indexOf("__") === 0) {
                continue;
            }
            switch (key) {
                case XmlElementNames.FieldURI:
                    return TypeContainer.ServiceObjectSchema.FindPropertyDefinition(XmlAttributeNames.FieldURI);
                case XmlElementNames.IndexedFieldURI:
                    return new TypeContainer.IndexedPropertyDefinition(jsObject[XmlAttributeNames.FieldURI], jsObject[XmlAttributeNames.FieldIndex]);
                case XmlElementNames.ExtendedFieldURI:
                    var propertyDefiniton = new TypeContainer.ExtendedPropertyDefinition();
                    propertyDefiniton.LoadPropertyValueFromXmlJsObject(jsObject);
                    return propertyDefiniton;
                default:
                    break;
            }
        }
        return null;
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    PropertyDefinitionBase.prototype.WriteToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Types, this.GetXmlElementName());
        this.WriteAttributesToXml(writer);
        writer.WriteEndElement();
    };
    return PropertyDefinitionBase;
}());
exports.PropertyDefinitionBase = PropertyDefinitionBase;
/**
 * Represents the definition of an extended property.
 */
var ExtendedPropertyDefinition = (function (_super) {
    __extends(ExtendedPropertyDefinition, _super);
    function ExtendedPropertyDefinition(mapiTypeTagPropertySetOrPropertySetId, mapiTypeNameOrId, mapiType) {
        var _this = _super.call(this) || this;
        var argsLength = arguments.length;
        _this.mapiType = MapiPropertyType.String;
        switch (argsLength) {
            case 1:
                _this.mapiType = mapiTypeTagPropertySetOrPropertySetId;
                break;
            case 2:
                _this.mapiType = mapiTypeNameOrId;
                if (mapiTypeTagPropertySetOrPropertySetId < 0 || mapiTypeTagPropertySetOrPropertySetId > 65535 /*UInt16.MaxValue*/) {
                    throw new ArgumentOutOfRangeException("tag", Strings.TagValueIsOutOfRange);
                }
                _this.tag = mapiTypeTagPropertySetOrPropertySetId;
                break;
            case 3:
                _this.mapiType = mapiType;
                typeof mapiTypeNameOrId === 'string' ? _this.name = mapiTypeNameOrId : _this.id = mapiTypeNameOrId;
                typeof mapiTypeTagPropertySetOrPropertySetId === 'number' ? _this.propertySet = mapiTypeTagPropertySetOrPropertySetId : _this.propertySetId = mapiTypeTagPropertySetOrPropertySetId;
                break;
            default:
                break;
        }
        return _this;
    }
    Object.defineProperty(ExtendedPropertyDefinition.prototype, "Id", {
        /**
         * @Nullable Gets the Id of the extended property.
         */
        get: function () { return this.id; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExtendedPropertyDefinition.prototype, "MapiType", {
        /**
         * Gets the MAPI type of the extended property.
         */
        get: function () { return this.mapiType; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExtendedPropertyDefinition.prototype, "Name", {
        /**
         * Gets the name of the extended property.
         */
        get: function () { return this.name || ((typeof this.tag === 'undefined') ? null : this.tag.toString()); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExtendedPropertyDefinition.prototype, "PropertySet", {
        /**
         * @Nullable Gets the property set of the extended property.
         */
        get: function () { return this.propertySet; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExtendedPropertyDefinition.prototype, "PropertySetId", {
        /**
         * @Nullable Gets the property set Id or the extended property.
         * */
        get: function () { return this.propertySetId; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExtendedPropertyDefinition.prototype, "Tag", {
        /**
         * @Nullable Gets the extended property's tag.
         */
        get: function () { return this.tag; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExtendedPropertyDefinition.prototype, "Version", {
        /**
         * Gets the minimum Exchange version that supports this extended property.
         *
         * @value {ExchangeVersion} The version.
         */
        get: function () { return ExchangeVersion.Exchange2007_SP1; },
        enumerable: true,
        configurable: true
    });
    /**
     * Determines whether a given extended property definition is equal to this extended property definition.
     *
     * @param   {any}   obj   The object to check for equality.
     * @return  {boolean}         True if the properties definitions define the same extended property.
     */
    ExtendedPropertyDefinition.prototype.Equals = function (obj) {
        var propertyDefinition = obj;
        return ExtendedPropertyDefinition.IsEqualTo(propertyDefinition, this);
    };
    /**
     * @internal Formats the field.
     *
     * @type    <T>        Type of field value.
     * @param   {string}   name         The name.
     * @param   {string}   fieldValue   The field value.
     * @return  {string}                Formatted value.
     */
    ExtendedPropertyDefinition.prototype.FormatField = function (name, fieldValue) {
        debugger;
        return (fieldValue != null)
            ? StringHelper.Format(ExtendedPropertyDefinition.FieldFormat, name, fieldValue)
            : "";
    };
    /**
     * Serves as a hash function for a particular type.
     *
     * @return  {number}      A hash code for the current System.Object.
     */
    ExtendedPropertyDefinition.prototype.GetHashCode = function () { throw new Error("ExtendedPropertyDefinition.ts - GetHashCode : Not implemented."); };
    /**
     * @internal Gets the property definition's printable name.
     *
     * @return  {string}      The property definition's printable name.
     */
    ExtendedPropertyDefinition.prototype.GetPrintableName = function () {
        var sb = "";
        sb += "{";
        sb += this.FormatField(ExtendedPropertyDefinition.NameFieldName, this.Name);
        sb += this.FormatField(ExtendedPropertyDefinition.MapiTypeFieldName, MapiPropertyType[this.MapiType]);
        sb += this.FormatField(ExtendedPropertyDefinition.IdFieldName, this.Id.toString());
        sb += this.FormatField(ExtendedPropertyDefinition.PropertySetFieldName, DefaultExtendedPropertySet[this.PropertySet]);
        sb += this.FormatField(ExtendedPropertyDefinition.PropertySetIdFieldName, this.PropertySetId != null ? this.PropertySetId.ToString() : "");
        sb += this.FormatField(ExtendedPropertyDefinition.TagFieldName, this.Tag.toString());
        sb += "}";
        return sb;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    ExtendedPropertyDefinition.prototype.GetXmlElementName = function () { return XmlElementNames.ExtendedFieldURI; };
    /**
     * @internal Determines whether two specified instances of ExtendedPropertyDefinition are equal.
     *
     * @param   {ExtendedPropertyDefinition}    extPropDef1   First extended property definition.
     * @param   {ExtendedPropertyDefinition}    extPropDef2   Second extended property definition.
     * @return  {boolean}                       True if extended property definitions are equal.
     */
    ExtendedPropertyDefinition.IsEqualTo = function (extPropDef1, extPropDef2) {
        return (extPropDef1 === extPropDef2) ||
            (extPropDef1 && extPropDef2 &&
                (extPropDef1.Id === extPropDef2.Id) &&
                (extPropDef1.MapiType === extPropDef2.MapiType) &&
                (extPropDef1.Tag === extPropDef2.Tag) &&
                (extPropDef1.Name === extPropDef2.Name) &&
                (extPropDef1.PropertySet === extPropDef2.PropertySet) &&
                (String(extPropDef1.propertySetId) === String(extPropDef2.propertySetId)));
    };
    /**
     * @internal Loads from XMLJsObject.
     *
     * @param   {any}   jsObject   The json object.
     */
    ExtendedPropertyDefinition.prototype.LoadPropertyValueFromXmlJsObject = function (jsObject) {
        for (var key in jsObject) {
            switch (key) {
                case XmlAttributeNames.DistinguishedPropertySetId:
                    debugger;
                    this.propertySet = isNaN(jsObject[key]) ? DefaultExtendedPropertySet[jsObject[key]] : +(jsObject[key]); // jsObject.ReadEnumValue<DefaultExtendedPropertySet>(key);
                    break;
                case XmlAttributeNames.PropertySetId:
                    debugger;
                    this.propertySetId = new Guid(jsObject[key]); // new Guid(jsObject.ReadAsString(key));
                    break;
                case XmlAttributeNames.PropertyTag:
                    this.tag = Convert.toNumber(jsObject[key]); //Convert.ToUInt16(jsObject.ReadAsString(key), 16);
                    break;
                case XmlAttributeNames.PropertyName:
                    this.name = jsObject[key]; //jsObject.ReadAsString(key);
                    break;
                case XmlAttributeNames.PropertyId:
                    this.id = Convert.toInt(jsObject[key]); //jsObject.ReadAsInt(key);
                    break;
                case XmlAttributeNames.PropertyType:
                    this.mapiType = isNaN(jsObject[key]) ? MapiPropertyType[jsObject[key]] : +(jsObject[key]); // jsObject.ReadEnumValue<MapiPropertyType>(key);
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ExtendedPropertyDefinition.prototype.WriteAttributesToXml = function (writer) {
        if (this.propertySet) {
            writer.WriteAttributeValue(XmlAttributeNames.DistinguishedPropertySetId, DefaultExtendedPropertySet[this.propertySet]);
        }
        if (this.propertySetId) {
            writer.WriteAttributeValue(XmlAttributeNames.PropertySetId, this.propertySetId.ToString());
        }
        if (this.tag) {
            writer.WriteAttributeValue(XmlAttributeNames.PropertyTag, this.tag);
        }
        if (!StringHelper.IsNullOrEmpty(this.name)) {
            writer.WriteAttributeValue(XmlAttributeNames.PropertyName, this.name);
        }
        if (this.id) {
            writer.WriteAttributeValue(XmlAttributeNames.PropertyId, this.id);
        }
        writer.WriteAttributeValue(XmlAttributeNames.PropertyType, MapiPropertyType[this.mapiType]);
    };
    ExtendedPropertyDefinition.FieldFormat = "{0}: {1} ";
    ExtendedPropertyDefinition.PropertySetFieldName = "PropertySet";
    ExtendedPropertyDefinition.PropertySetIdFieldName = "PropertySetId";
    ExtendedPropertyDefinition.TagFieldName = "Tag";
    ExtendedPropertyDefinition.NameFieldName = "Name";
    ExtendedPropertyDefinition.IdFieldName = "Id";
    ExtendedPropertyDefinition.MapiTypeFieldName = "MapiType";
    return ExtendedPropertyDefinition;
}(PropertyDefinitionBase));
exports.ExtendedPropertyDefinition = ExtendedPropertyDefinition;
/**
 * Represents a property definition for a service object.
 */
var ServiceObjectPropertyDefinition = (function (_super) {
    __extends(ServiceObjectPropertyDefinition, _super);
    function ServiceObjectPropertyDefinition(uri) {
        if (uri === void 0) { uri = null; }
        var _this = _super.call(this) || this;
        _this.uri = null;
        if (arguments.length == 1) {
            EwsLogging.Assert(!StringHelper.IsNullOrEmpty(uri), "ServiceObjectPropertyDefinition.ctor", "uri is null or empty");
            _this.uri = uri;
        }
        return _this;
    }
    Object.defineProperty(ServiceObjectPropertyDefinition.prototype, "Version", {
        /**
         * Gets the minimum Exchange version that supports this property.
         *
         * @value {ExchangeVersion} The version.
         */
        get: function () { return ExchangeVersion.Exchange2007_SP1; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServiceObjectPropertyDefinition.prototype, "Uri", {
        /**
         * @internal Gets the URI of the property definition.
         */
        get: function () { return this.uri; },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    ServiceObjectPropertyDefinition.prototype.GetXmlElementName = function () { return XmlElementNames.FieldURI; };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ServiceObjectPropertyDefinition.prototype.WriteAttributesToXml = function (writer) {
        writer.WriteAttributeValue(XmlAttributeNames.FieldURI, this.Uri);
    };
    return ServiceObjectPropertyDefinition;
}(PropertyDefinitionBase));
exports.ServiceObjectPropertyDefinition = ServiceObjectPropertyDefinition;
/**
 * @internal Represents the definition of the GroupMember property.
 */
var GroupMemberPropertyDefinition = (function (_super) {
    __extends(GroupMemberPropertyDefinition, _super);
    function GroupMemberPropertyDefinition(key) {
        var _this = _super.call(this, GroupMemberPropertyDefinition.FieldUri) || this;
        /**
         * Member key. Maps to the Index attribute of IndexedFieldURI element.
         */
        _this.key = null;
        if (arguments.length === 1) {
            _this.key = key;
        }
        return _this;
    }
    Object.defineProperty(GroupMemberPropertyDefinition.prototype, "Key", {
        /**
         * Gets or sets the member's key.
         */
        get: function () {
            return this.key;
        },
        set: function (value) {
            this.key = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GroupMemberPropertyDefinition.prototype, "Type", {
        /**
         * Gets the property type.
         */
        get: function () {
            return "String";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets the property definition's printable name.
     *
     * @return  {string}      The property definition's printable name.
     */
    GroupMemberPropertyDefinition.prototype.GetPrintableName = function () { return StringHelper.Format("{0}:{1}", GroupMemberPropertyDefinition.FieldUri, this.Key); };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GroupMemberPropertyDefinition.prototype.GetXmlElementName = function () { return XmlElementNames.IndexedFieldURI; };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GroupMemberPropertyDefinition.prototype.WriteAttributesToXml = function (writer) {
        _super.prototype.WriteAttributesToXml.call(this, writer);
        writer.WriteAttributeValue(XmlAttributeNames.FieldIndex, this.Key);
    };
    /**
     * FieldUri of IndexedFieldURI for a group member.
     */
    GroupMemberPropertyDefinition.FieldUri = "distributionlist:Members:Member";
    return GroupMemberPropertyDefinition;
}(ServiceObjectPropertyDefinition));
exports.GroupMemberPropertyDefinition = GroupMemberPropertyDefinition;
/**
 * Represents an indexed property definition.
 */
var IndexedPropertyDefinition = (function (_super) {
    __extends(IndexedPropertyDefinition, _super);
    /**
     * @internal Initializes a new instance of the **IndexedPropertyDefinition** class.
     *
     * @param   {string}   uri     The FieldURI attribute of the IndexedFieldURI element.
     * @param   {string}   index   The Index attribute of the IndexedFieldURI element.
     */
    function IndexedPropertyDefinition(uri, index) {
        var _this = _super.call(this, uri) || this;
        _this.index = index;
        return _this;
    }
    Object.defineProperty(IndexedPropertyDefinition.prototype, "Index", {
        /**
         * Gets the index of the property.
         */
        get: function () { return this.index; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IndexedPropertyDefinition.prototype, "Type", {
        get: function () { return 'string'; /*return typeof string;*/ } //System.Type;
        ,
        enumerable: true,
        configurable: true
    });
    /**
     * Determines whether a given indexed property definition is equal to this indexed property definition.
     *
     * @param   {any}   obj   The object to check for equality.
     * @return  {boolean}         True if the properties definitions define the same indexed property.
     */
    IndexedPropertyDefinition.prototype.Equals = function (obj) {
        var propertyDefinition = obj;
        return IndexedPropertyDefinition.IsEqualTo(propertyDefinition, this);
    };
    /**
     * Serves as a hash function for a particular type.
     *
     * @return  {number}      A hash code for the current System.Object.
     */
    IndexedPropertyDefinition.prototype.GetHashCode = function () { throw new Error("IndexedPropertyDefinition.ts - GetHashCode : Not implemented."); };
    /**
     * @internal Gets the property definition's printable name.
     *
     * @return  {string}      The property definition's printable name.
     */
    IndexedPropertyDefinition.prototype.GetPrintableName = function () { return StringHelper.Format("{0}:{1}", this.Uri, this.Index); };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    IndexedPropertyDefinition.prototype.GetXmlElementName = function () { return XmlElementNames.IndexedFieldURI; };
    /**
     * @internal Determines whether two specified instances of IndexedPropertyDefinition are equal.
     *
     * @param   {IndexedPropertyDefinition}    extPropDef1   First extended property definition.
     * @param   {IndexedPropertyDefinition}    extPropDef2   Second extended property definition.
     * @return  {boolean}                      True if extended property definitions are equal.
     */
    IndexedPropertyDefinition.IsEqualTo = function (idxPropDef1, idxPropDef2) {
        return idxPropDef1 === idxPropDef2 ||
            (idxPropDef1.Uri == idxPropDef2.Uri &&
                idxPropDef1.Index == idxPropDef2.Index);
    };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    IndexedPropertyDefinition.prototype.WriteAttributesToXml = function (writer) {
        _super.prototype.WriteAttributesToXml.call(this, writer);
        writer.WriteAttributeValue(XmlAttributeNames.FieldIndex, this.Index);
    };
    return IndexedPropertyDefinition;
}(ServiceObjectPropertyDefinition));
exports.IndexedPropertyDefinition = IndexedPropertyDefinition;
/**
 * Represents the definition of a folder or item property.
 */
var PropertyDefinition = (function (_super) {
    __extends(PropertyDefinition, _super);
    function PropertyDefinition(propertyName, xmlElementName, uriOrFlags, versionOrFlags, version) {
        var _this = this;
        typeof uriOrFlags === 'string' ? _this = _super.call(this, uriOrFlags) || this : _this = _super.call(this) || this;
        _this.name = propertyName;
        _this.xmlElementName = xmlElementName;
        _this.flags = typeof uriOrFlags === 'string' ? PropertyDefinitionFlags.None : uriOrFlags;
        switch (arguments.length) {
            case 4:
                _this.version = versionOrFlags;
                break;
            case 5:
                _this.version = version;
                _this.flags = versionOrFlags;
                break;
            default:
                break;
        }
        return _this;
    }
    Object.defineProperty(PropertyDefinition.prototype, "IsNullable", {
        /**
         * @internal Gets a value indicating whether this property definition is for a nullable type (ref, int?, bool?...).
         */
        get: function () { return true; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertyDefinition.prototype, "Name", {
        /**
         * Gets the name of the property.
         */
        get: function () {
            if (StringHelper.IsNullOrEmpty(this.name)) {
                throw new Error("PropertyDefinition.Name - incorrectly registered propertynames - info: fixed by initializing names in respective serviceobjectschema static properties. fix if receive this error");
                //todo:fix: can not use this to initialize names, ServiceObjectSchema creates circular loops in modules.
                //ServiceObjectSchema.InitializeSchemaPropertyNames(); //info: fixed by initializing names in respective serviceobjectschema static properties. fix if receive this error
                //fix - did not work , shifted to statically initialize by constructer in this class ServiceObjectSchemaExtension.InitializeSchemaPropertyNames(); //info: fixed by initializing names in respective serviceobjectschema static properties. fix if receive this error
            }
            return this.name;
        },
        set: function (value) { this.name = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertyDefinition.prototype, "Version", {
        /**
         * Gets the minimum Exchange version that supports this property.
         *
         * @value {ExchangeVersion} The version.
         */
        get: function () { return this.version; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertyDefinition.prototype, "XmlElementName", {
        /**
         * @internal Gets the name of the XML element.
         *
         * @value {string}  The name of the XML element.
         */
        get: function () { return this.xmlElementName; },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets a list of associated internal properties.
     *
     * /remarks/    This is a hack. It is here (currently) solely to help the API register the MeetingTimeZone property definition that is internal.
     * @return  {PropertyDefinition[]}      A list of PropertyDefinition objects.
     */
    PropertyDefinition.prototype.GetAssociatedInternalProperties = function () {
        var properties = [];
        this.RegisterAssociatedInternalProperties(properties);
        return properties;
    };
    /**
     * @internal Gets the property definition's printable name.
     *
     * @return  {string}      The property definition's printable name.
     */
    PropertyDefinition.prototype.GetPrintableName = function () { return this.Name; };
    PropertyDefinition.prototype.HasFlag = function (flag, version) {
        return (this.flags & flag) == flag;
    };
    /**
     * @internal Registers associated internal properties.
     *
     * @param   {PropertyDefinition[]}   properties   The list in which to add the associated properties.
     */
    PropertyDefinition.prototype.RegisterAssociatedInternalProperties = function (properties) {
    };
    return PropertyDefinition;
}(ServiceObjectPropertyDefinition));
exports.PropertyDefinition = PropertyDefinition;
/**
 * @internal Represents effective rights property definition.
 */
var EffectiveRightsPropertyDefinition = (function (_super) {
    __extends(EffectiveRightsPropertyDefinition, _super);
    /**
     * @internal Initializes a new instance of the **EffectiveRightsPropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    function EffectiveRightsPropertyDefinition(propertyName, xmlElementName, uri, flags, version) {
        return _super.call(this, propertyName, xmlElementName, uri, flags, version) || this;
    }
    /**
     * @internal Loads the property value from XMLJsObject.
     *
     * @param   {any}               value         The JSON value.  Can be a JsonObject, string, number, bool, array, or null.
     * @param   {ExchangeService}   service       The service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    EffectiveRightsPropertyDefinition.prototype.LoadPropertyValueFromXmlJsObject = function (jsObject, service, propertyBag) {
        var effectiveRightsValue = EffectiveRights.None;
        if (jsObject != null) {
            for (var key in jsObject) {
                switch (key) {
                    case XmlElementNames.CreateAssociated:
                        if (Convert.toBool(jsObject[key])) {
                            effectiveRightsValue |= EffectiveRights.CreateAssociated;
                        }
                        break;
                    case XmlElementNames.CreateContents:
                        if (Convert.toBool(jsObject[key])) {
                            effectiveRightsValue |= EffectiveRights.CreateContents;
                        }
                        break;
                    case XmlElementNames.CreateHierarchy:
                        if (Convert.toBool(jsObject[key])) {
                            effectiveRightsValue |= EffectiveRights.CreateHierarchy;
                        }
                        break;
                    case XmlElementNames.Delete:
                        if (Convert.toBool(jsObject[key])) {
                            effectiveRightsValue |= EffectiveRights.Delete;
                        }
                        break;
                    case XmlElementNames.Modify:
                        if (Convert.toBool(jsObject[key])) {
                            effectiveRightsValue |= EffectiveRights.Modify;
                        }
                        break;
                    case XmlElementNames.Read:
                        if (Convert.toBool(jsObject[key])) {
                            effectiveRightsValue |= EffectiveRights.Read;
                        }
                        break;
                    case XmlElementNames.ViewPrivateItems:
                        if (Convert.toBool(jsObject[key])) {
                            effectiveRightsValue |= EffectiveRights.ViewPrivateItems;
                        }
                        break;
                }
            }
        }
        propertyBag._setItem(this, jsObject);
    };
    /**
     * @internal Writes the property value to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the context is an update operation.
     */
    EffectiveRightsPropertyDefinition.prototype.WritePropertyValueToXml = function (writer, propertyBag, isUpdateOperation) {
        // EffectiveRights is a read-only property, no need to implement this.
    };
    return EffectiveRightsPropertyDefinition;
}(PropertyDefinition));
exports.EffectiveRightsPropertyDefinition = EffectiveRightsPropertyDefinition;
/**
 * @internal Represents the definition for the meeting time zone property.
 */
var MeetingTimeZonePropertyDefinition = (function (_super) {
    __extends(MeetingTimeZonePropertyDefinition, _super);
    /**
     * @internal Initializes a new instance of the **MeetingTimeZonePropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    function MeetingTimeZonePropertyDefinition(propertyName, xmlElementName, uri, flags, version) {
        return _super.call(this, propertyName, xmlElementName, uri, flags, version) || this;
    }
    /**
     * @internal Loads the property value from json.
     *
     * @param   {any}               jsObject         The JSON value.  Can be a JsonObject, string, number, bool, array, or null.
     * @param   {ExchangeService}   service       The service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    MeetingTimeZonePropertyDefinition.prototype.LoadPropertyValueFromXmlJsObject = function (jsObject, service, propertyBag) {
        EwsLogging.Assert(false, "MeetingTimeZonePropertyDefinition.LoadPropertyValueFromXmlJsObject", "This is not properly validate, need to validate with example");
        if (jsObject != null) {
            var meetingTimeZone = new MeetingTimeZone();
            meetingTimeZone.LoadFromXmlJsObject(jsObject, service);
            propertyBag._setItem(Schemas.AppointmentSchema.StartTimeZone, meetingTimeZone.ToTimeZoneInfo());
        }
    };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    MeetingTimeZonePropertyDefinition.prototype.WritePropertyValueToXml = function (writer, propertyBag, isUpdateOperation) {
        var value = propertyBag._getItem(this);
        if (value) {
            value.WriteToXml(writer, this.XmlElementName);
        }
    };
    return MeetingTimeZonePropertyDefinition;
}(PropertyDefinition));
exports.MeetingTimeZonePropertyDefinition = MeetingTimeZonePropertyDefinition;
/**
 * @internal Represenrs recurrence property definition.
 */
var RecurrencePropertyDefinition = (function (_super) {
    __extends(RecurrencePropertyDefinition, _super);
    /**
     * @internal Initializes a new instance of the **RecurrencePropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    function RecurrencePropertyDefinition(propertyName, xmlElementName, uri, flags, version) {
        return _super.call(this, propertyName, xmlElementName, uri, flags, version) || this;
    }
    /**
     * Gets the recurrence from string.
     *
     * @param   {string}   recurranceString   The recurrance string.
     * @return  {Recurrence}    Recurrence
     */
    RecurrencePropertyDefinition.GetRecurrenceFromString = function (recurranceString) {
        var recurrence;
        switch (recurranceString) {
            case XmlElementNames.RelativeYearlyRecurrence:
                recurrence = new Recurrence.RelativeYearlyPattern();
                break;
            case XmlElementNames.AbsoluteYearlyRecurrence:
                recurrence = new Recurrence.YearlyPattern();
                break;
            case XmlElementNames.RelativeMonthlyRecurrence:
                recurrence = new Recurrence.RelativeMonthlyPattern();
                break;
            case XmlElementNames.AbsoluteMonthlyRecurrence:
                recurrence = new Recurrence.MonthlyPattern();
                break;
            case XmlElementNames.DailyRecurrence:
                recurrence = new Recurrence.DailyPattern();
                break;
            case XmlElementNames.DailyRegeneration:
                recurrence = new Recurrence.DailyRegenerationPattern();
                break;
            case XmlElementNames.WeeklyRecurrence:
                recurrence = new Recurrence.WeeklyPattern();
                break;
            case XmlElementNames.WeeklyRegeneration:
                recurrence = new Recurrence.WeeklyRegenerationPattern();
                break;
            case XmlElementNames.MonthlyRegeneration:
                recurrence = new Recurrence.MonthlyRegenerationPattern();
                break;
            case XmlElementNames.YearlyRegeneration:
                recurrence = new Recurrence.YearlyRegenerationPattern();
                break;
            default:
                //info: //ref: cannot throw, need to keep null/undefined to successfully parse XMLJsObject
                //throw new ServiceXmlDeserializationException(StringHelper.Format(Strings.InvalidRecurrencePattern, recurranceString));
                break;
        }
        return recurrence;
    };
    /**
     * Gets the recurrence range.
     *
     * @param   {string}            recurrenceRangeString   The recurrence range string.
     * @return  {RecurrenceRange}   RecurrenceRange
     */
    RecurrencePropertyDefinition.GetRecurrenceRange = function (recurrenceRangeString) {
        var range;
        switch (recurrenceRangeString) {
            case XmlElementNames.NoEndRecurrence:
                range = new NoEndRecurrenceRange();
                break;
            case XmlElementNames.EndDateRecurrence:
                range = new EndDateRecurrenceRange();
                break;
            case XmlElementNames.NumberedRecurrence:
                range = new NumberedRecurrenceRange();
                break;
            default:
                //info: //ref: cannot throw, need to keep null/undefined to successfully parse XMLJsObject
                //throw new ServiceXmlDeserializationException(StringHelper.Format(Strings.InvalidRecurrenceRange, recurrenceRangeString)); 
                break;
        }
        return range;
    };
    /**
     * @internal Loads the property value from json.
     *
     * @param   {any}               jsObject         The JSON value.  Can be a JsonObject, string, number, bool, array, or null.
     * @param   {ExchangeService}   service       The service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    RecurrencePropertyDefinition.prototype.LoadPropertyValueFromXmlJsObject = function (jsObject, service, propertyBag) {
        var recurrence;
        var range;
        var props = "";
        for (var key in jsObject) {
            if (key.indexOf("__") === 0)
                continue;
            if (RecurrencePropertyDefinition.recurrences.indexOf(key) >= 0) {
                recurrence = RecurrencePropertyDefinition.GetRecurrenceFromString(key);
                recurrence.LoadFromXmlJsObject(jsObject[key], service);
            }
            if (RecurrencePropertyDefinition.recurrenceRanges.indexOf(key) >= 0) {
                range = RecurrencePropertyDefinition.GetRecurrenceRange(key);
                range.LoadFromXmlJsObject(jsObject[key], service);
            }
            props += key + ",";
        }
        if (props.length > 1 && props.lastIndexOf(",") === props.length - 1) {
            props = props.substr(0, props.length - 1);
        }
        if (!recurrence) {
            throw new ServiceXmlDeserializationException(StringHelper.Format(Strings.InvalidRecurrencePattern, props));
        }
        if (!range) {
            throw new ServiceXmlDeserializationException(StringHelper.Format(Strings.InvalidRecurrenceRange, props));
        }
        range.SetupRecurrence(recurrence);
        propertyBag._setItem(this, recurrence);
    };
    /**
     * @internal Writes the property value to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the context is an update operation.
     */
    RecurrencePropertyDefinition.prototype.WritePropertyValueToXml = function (writer, propertyBag, isUpdateOperation) {
        var value = propertyBag._getItem(this);
        if (value) {
            value.WriteToXml(writer, XmlElementNames.Recurrence);
        }
    };
    /**
     * not in ews-managed-api - use to find which recurrence is being used.
     */
    RecurrencePropertyDefinition.recurrences = [XmlElementNames.AbsoluteMonthlyRecurrence, XmlElementNames.AbsoluteYearlyRecurrence, XmlElementNames.DailyRecurrence, XmlElementNames.DailyRegeneration, XmlElementNames.MonthlyRegeneration, XmlElementNames.RelativeMonthlyRecurrence, XmlElementNames.RelativeYearlyRecurrence, XmlElementNames.WeeklyRecurrence, XmlElementNames.WeeklyRegeneration, XmlElementNames.YearlyRegeneration];
    /**
     * not in ews-managed-api - use to find which recurrence range is being used.
     */
    RecurrencePropertyDefinition.recurrenceRanges = [XmlElementNames.NoEndRecurrence, XmlElementNames.EndDateRecurrence, XmlElementNames.NumberedRecurrence];
    return RecurrencePropertyDefinition;
}(PropertyDefinition));
exports.RecurrencePropertyDefinition = RecurrencePropertyDefinition;
var ResponseObjectsPropertyDefinition = (function (_super) {
    __extends(ResponseObjectsPropertyDefinition, _super);
    function ResponseObjectsPropertyDefinition() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ResponseObjectsPropertyDefinition.prototype, "IsNullable", {
        /**
         * @internal Gets a value indicating whether this property definition is for a nullable type (ref, int?, bool?...).
         */
        get: function () { return false; },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the response action.
     *
     * @param   {string}   responseActionString   The response action string.
     * @return  {ResponseActions}       ResponseActions
     */
    ResponseObjectsPropertyDefinition.GetResponseAction = function (responseActionString) {
        var value = ResponseActions.None;
        switch (responseActionString) {
            case XmlElementNames.AcceptItem:
                value = ResponseActions.Accept;
                break;
            case XmlElementNames.TentativelyAcceptItem:
                value = ResponseActions.TentativelyAccept;
                break;
            case XmlElementNames.DeclineItem:
                value = ResponseActions.Decline;
                break;
            case XmlElementNames.ReplyToItem:
                value = ResponseActions.Reply;
                break;
            case XmlElementNames.ForwardItem:
                value = ResponseActions.Forward;
                break;
            case XmlElementNames.ReplyAllToItem:
                value = ResponseActions.ReplyAll;
                break;
            case XmlElementNames.CancelCalendarItem:
                value = ResponseActions.Cancel;
                break;
            case XmlElementNames.RemoveItem:
                value = ResponseActions.RemoveFromCalendar;
                break;
            case XmlElementNames.SuppressReadReceipt:
                value = ResponseActions.SuppressReadReceipt;
                break;
            case XmlElementNames.PostReplyItem:
                value = ResponseActions.PostReply;
                break;
        }
        return value;
    };
    /**
     * @internal Loads the property value from json.
     *
     * @param   {any}               jsObject         The JSON value.  Can be a JsonObject, string, number, bool, array, or null.
     * @param   {ExchangeService}   service       The service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    ResponseObjectsPropertyDefinition.prototype.LoadPropertyValueFromXmlJsObject = function (jsObject, service, propertyBag) {
        var responseActionValue = ResponseActions.None;
        for (var key in jsObject) {
            if (key.indexOf("__") === 0)
                continue;
            if (jsObject.hasOwnProperty(key)) {
                responseActionValue |= ResponseObjectsPropertyDefinition.GetResponseAction(key);
            }
        }
        propertyBag._setItem(this, responseActionValue);
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the context is an update operation.
     */
    ResponseObjectsPropertyDefinition.prototype.WritePropertyValueToXml = function (writer, propertyBag, isUpdateOperation) { };
    return ResponseObjectsPropertyDefinition;
}(PropertyDefinition));
exports.ResponseObjectsPropertyDefinition = ResponseObjectsPropertyDefinition;
/**
 * @internal Represents DateTime property definition.
 */
var DateTimePropertyDefinition = (function (_super) {
    __extends(DateTimePropertyDefinition, _super);
    function DateTimePropertyDefinition(propertyName, xmlElementName, uri, versionOrFlags, version, isNullable) {
        var _this = this;
        switch (arguments.length) {
            case 4:
                _this = _super.call(this, propertyName, xmlElementName, uri, versionOrFlags) || this;
                break;
            case 5:
            case 6:
                _this = _super.call(this, propertyName, xmlElementName, uri, versionOrFlags, version) || this;
                break;
            default:
                break;
        }
        _this.isNullable = isNullable || false;
        return _this;
    }
    Object.defineProperty(DateTimePropertyDefinition.prototype, "IsNullable", {
        /**
         * @internal Gets a value indicating whether this property definition is for a nullable type (ref, int?, bool?...).
         */
        get: function () { return this.isNullable; },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the converted date time.
     *
     * @param   {ExchangeServiceBase}   service             The service.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   if set to true [is update operation].
     * @param   {any}                   value               The value.
     * @return  {DateTime}      Converted DateTime value
     */
    DateTimePropertyDefinition.prototype.GetConvertedDateTime = function (service, propertyBag, isUpdateOperation, value) {
        EwsLogging.Assert(false, "DateTimePropertyDefinition.GetConvertedDateTime", "TimeZone info could be misleading, It should be used as UTC in all cases until fixed");
        var dateTime = DateTime.Parse(value);
        var convertedDateTime;
        //debug: //todo: find datetimekind
        // If the date/time is unspecified, we may need to scope it to time zone.
        if (dateTime.Kind == DateTimeKind.Unspecified) {
            convertedDateTime = this.ScopeToTimeZone(service, value, propertyBag, isUpdateOperation);
        }
        else {
            convertedDateTime = dateTime;
        }
        return convertedDateTime;
    };
    /**
     * @internal Loads the property value from XMLJsObject.
     *
     * @param   {any}               value         The JSON value.  Can be a JsonObject, string, number, bool, array, or null.
     * @param   {ExchangeService}   service       The service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    DateTimePropertyDefinition.prototype.LoadPropertyValueFromXmlJsObject = function (jsObject, service, propertyBag) {
        var stringValue = jsObject; //.toString();
        //debug: //ref: check for datetime value
        if (!StringHelper.IsNullOrEmpty(stringValue)) {
            var value = service.ConvertUniversalDateTimeStringToLocalDateTime(stringValue);
            propertyBag._setItem(this, service.ConvertUniversalDateTimeStringToLocalDateTime(stringValue));
        }
    };
    /**
     * @internal Scopes the date time property to the appropriate time zone, if necessary.
     *
     * @param   {ExchangeServiceBase}   service             The service emitting the request.
     * @param   {DateTime}              dateTime            The date time.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the scoping is to be performed in the context of an update operation.
     * @return  {DateTime}              The converted DateTime.
     */
    DateTimePropertyDefinition.prototype.ScopeToTimeZone = function (service, dateTime, propertyBag, isUpdateOperation) {
        EwsLogging.Assert(false, "DateTimePropertyDefinition.ScopeToTimeZone", "TimeZone info could be misleading, It should be used as UTC in all cases until fixed");
        try {
            var convertedDateTime = EwsUtilities.ConvertTime(dateTime, service.TimeZone, TimeZoneInfo.Utc);
            return new DateTime(convertedDateTime.TotalMilliSeconds, DateTimeKind.Utc);
        }
        catch (e) {
            throw new PropertyException(StringHelper.Format(Strings.InvalidDateTime, dateTime), this.Name, e);
        }
    };
    /**
     * @internal Writes the property value to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the context is an update operation.
     */
    DateTimePropertyDefinition.prototype.WritePropertyValueToXml = function (writer, propertyBag, isUpdateOperation) {
        var value = propertyBag._getItem(this);
        if (value != null) {
            writer.WriteStartElement(XmlNamespace.Types, this.XmlElementName);
            var convertedDateTime = this.GetConvertedDateTime(writer.Service, propertyBag, isUpdateOperation, value);
            writer.WriteValue(EwsUtilities.DateTimeToXSDateTime(convertedDateTime), this.Name);
            writer.WriteEndElement();
        }
    };
    return DateTimePropertyDefinition;
}(PropertyDefinition));
exports.DateTimePropertyDefinition = DateTimePropertyDefinition;
/**
 * @internal Represents a property definition for DateTime values scoped to a specific time zone property.
 */
var ScopedDateTimePropertyDefinition = (function (_super) {
    __extends(ScopedDateTimePropertyDefinition, _super);
    /**
     * @internal Initializes a new instance of the **ScopedDateTimePropertyDefinition** class.
     *
     * @param   {string}                            propertyName                    Name of the property.
     * @param   {string}                            xmlElementName                  Name of the XML element.
     * @param   {ExchangeVersion}                   version                         The version.
     * @param   {string}                            uri                             The URI.
     * @param   {PropertyDefinitionFlags}           flags                           The flags.
     * @param   {GetPropertyDefinitionCallback}     getPropertyDefinitionCallback   The callback that will be used to retrieve the time zone property.
     */
    function ScopedDateTimePropertyDefinition(propertyName, xmlElementName, uri, flags, version, getPropertyDefinitionCallback) {
        var _this = _super.call(this, propertyName, xmlElementName, uri, flags, version) || this;
        EwsLogging.Assert(getPropertyDefinitionCallback != null, "ScopedDateTimePropertyDefinition.ctor", "getPropertyDefinitionCallback is null.");
        _this.getPropertyDefinitionCallback = getPropertyDefinitionCallback;
        return _this;
    }
    /**
     * Gets the time zone property to which to scope times.
     *
     * @param   {ExchangeVersion}   version   The EWS version for which the property is to be retrieved.
     * @return  {PropertyDefinition}             The PropertyDefinition of the scoping time zone property.
     */
    ScopedDateTimePropertyDefinition.prototype.GetTimeZoneProperty = function (version) {
        var timeZoneProperty = this.getPropertyDefinitionCallback(version);
        EwsLogging.Assert(timeZoneProperty != null, "ScopedDateTimePropertyDefinition.GetTimeZoneProperty", "timeZoneProperty is null.");
        return timeZoneProperty;
    };
    /**
     * @internal Scopes the date time property to the appropriate time zone, if necessary.
     *
     * @param   {ExchangeServiceBase}   service             The service emitting the request.
     * @param   {DateTime}              dateTime            The date time.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the scoping is to be performed in the context of an update operation.
     * @return  {DateTime}              The converted DateTime.
     */
    ScopedDateTimePropertyDefinition.prototype.ScopeToTimeZone = function (service, dateTime, propertyBag, isUpdateOperation) {
        EwsLogging.Assert(false, "ScopedDateTimePropertyDefinition.ScopeToTimeZone", "[Info]:  TimeZone info has been updated, Please report any bugs to github", true);
        if (!propertyBag.Owner.GetIsCustomDateTimeScopingRequired()) {
            // Most item types do not require a custom scoping mechanism. For those item types,
            // use the default scoping mechanism.
            return _super.prototype.ScopeToTimeZone.call(this, service, dateTime, propertyBag, isUpdateOperation);
        }
        else {
            // Appointment, however, requires a custom scoping mechanism which is based on an
            // associated time zone property.
            var timeZoneProperty = this.GetTimeZoneProperty(service.RequestedServerVersion);
            var timeZonePropertyValue = { outValue: null };
            var timeZonePropertyIsSet = propertyBag.TryGetProperty(timeZoneProperty, timeZonePropertyValue);
            if (timeZonePropertyValue.outValue != null && propertyBag.IsPropertyUpdated(timeZoneProperty)) {
                // If we have the associated time zone property handy and if it has been updated locally,
                // then we scope the date time to that time zone.
                try {
                    var convertedDateTime = EwsUtilities.ConvertTime(dateTime, timeZonePropertyValue.outValue, TimeZoneInfo.Utc);
                    // This is necessary to stamp the date/time with the Local kind.
                    return new DateTime(convertedDateTime.TotalMilliSeconds, DateTimeKind.Utc);
                }
                catch (e) {
                    throw new PropertyException(StringHelper.Format(Strings.InvalidDateTime, dateTime), this.Name, e);
                }
            }
            else {
                if (isUpdateOperation) {
                    // In an update operation, what we do depends on what version of EWS
                    // we are targeting.
                    if (service.RequestedServerVersion == ExchangeVersion.Exchange2007_SP1) {
                        // For Exchange 2007 SP1, we still need to scope to the service's time zone.
                        return _super.prototype.ScopeToTimeZone.call(this, service, dateTime, propertyBag, isUpdateOperation);
                    }
                    else {
                        // Otherwise, we let the server scope to the appropriate time zone.
                        return dateTime;
                    }
                }
                else {
                    // In a Create operation, always scope to the service's time zone.
                    return _super.prototype.ScopeToTimeZone.call(this, service, dateTime, propertyBag, isUpdateOperation);
                }
            }
        }
    };
    return ScopedDateTimePropertyDefinition;
}(DateTimePropertyDefinition));
exports.ScopedDateTimePropertyDefinition = ScopedDateTimePropertyDefinition;
/**
 * @internal Represents typed property definition.
 */
var TypedPropertyDefinition = (function (_super) {
    __extends(TypedPropertyDefinition, _super);
    function TypedPropertyDefinition(propertyName, xmlElementName, uri, versionOrFlags, version, isNullable) {
        var _this = this;
        switch (arguments.length) {
            case 4:
                _this = _super.call(this, propertyName, xmlElementName, uri, versionOrFlags) || this;
                break;
            case 5:
            case 6:
                _this = _super.call(this, propertyName, xmlElementName, uri, versionOrFlags, version) || this;
                break;
            default:
                break;
        }
        _this.isNullable = isNullable || false;
        return _this;
    }
    Object.defineProperty(TypedPropertyDefinition.prototype, "IsNullable", {
        /**
         * @internal Gets a value indicating whether this property definition is for a nullable type (ref, int?, bool?...).
         *
         */
        get: function () { return this.isNullable; },
        enumerable: true,
        configurable: true
    });
    ;
    /**
     * @internal Loads the property value from XMLJsObject.
     *
     * @param   {any}               value         The JsObject value.  Can be a JsonObject, string, number, bool, array, or null.
     * @param   {ExchangeService}   service       The service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    TypedPropertyDefinition.prototype.LoadPropertyValueFromXmlJsObject = function (jsObject, service, propertyBag) {
        if (jsObject) {
            propertyBag._setItem(this, this.Parse(jsObject));
        }
        // if (typeof jsObject === 'string' || jsObject instanceof String) {
        //     propertyBag._setItem(this, this.Parse(jsObject));
        // }
        // else if (jsObject != null) { //undefined == null returns true, false for === comparison.
        //     propertyBag._setItem(this, this.Parse(jsObject));
        // }
    };
    /**
     * @internal Convert instance to string.
     *
     * @param   {any}   value   The value.
     * @return  {string}        String representation of property value.
     */
    TypedPropertyDefinition.prototype.ToString = function (value) {
        if (value !== null && typeof value !== 'undefined')
            return value.toString();
        throw new Error("TypedPropertydefinition: incorrect call of ToString(value): value is undefined");
    };
    TypedPropertyDefinition.prototype.toString = function (value) {
        if (arguments.length > 0) {
            return this.ToString(value);
        }
        else {
            return this.ToString();
        }
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the context is an update operation.
     */
    TypedPropertyDefinition.prototype.WritePropertyValueToXml = function (writer, propertyBag, isUpdateOperation) {
        var value = propertyBag._getItem(this);
        if (typeof value !== 'undefined') {
            writer.WriteElementValue(XmlNamespace.Types, this.XmlElementName, this.Name, this.ToString(value));
        }
    };
    return TypedPropertyDefinition;
}(PropertyDefinition));
exports.TypedPropertyDefinition = TypedPropertyDefinition;
/**
 * @internal Represents byte array property definition.
 */
var ByteArrayPropertyDefinition = (function (_super) {
    __extends(ByteArrayPropertyDefinition, _super);
    /**
     * @internal Initializes a new instance of the **ByteArrayPropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    function ByteArrayPropertyDefinition(propertyName, xmlElementName, uri, flags, version) {
        return _super.call(this, propertyName, xmlElementName, uri, flags, version) || this;
    }
    Object.defineProperty(ByteArrayPropertyDefinition.prototype, "IsNullable", {
        /**
         * @internal Gets a value indicating whether this property definition is for a nullable type (ref, int?, bool?...).
         */
        get: function () { return true; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ByteArrayPropertyDefinition.prototype, "Type", {
        /**
         * @internal Gets the property type.
         */
        get: function () { return ByteArrayPropertyDefinition; } //System.Type;
        ,
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Parses the specified value.
     *
     * @param   {string}   value   The value.
     * @return  {any}           Byte array value.
     */
    ByteArrayPropertyDefinition.prototype.Parse = function (value) {
        //ref: storing original base64 data base64Helper.atob(value); }
        EwsLogging.Assert(false, "ByteArrayPropertyDefinition.Parse", "ByteArrayPropertyDefinition needs to be improved");
        return value;
    };
    /**
     * @internal Converts byte array property to a string.
     *
     * @param   {any}       value   The value.
     * @return  {string}    Byte array value.
     */
    ByteArrayPropertyDefinition.prototype.ToString = function (value) {
        EwsLogging.Assert(false, "ByteArrayPropertyDefinition.Parse", "ByteArrayPropertyDefinition needs to be improved");
        if (value)
            return value; //ref: using original value. base64Helper.btoa(value);
        throw new Error("ByteArrayPropertyDefinition: incorrect call of ToString(value): value is undefined");
    };
    return ByteArrayPropertyDefinition;
}(TypedPropertyDefinition));
exports.ByteArrayPropertyDefinition = ByteArrayPropertyDefinition;
/**
 * @internal Represents String property definition.
 */
var StringPropertyDefinition = (function (_super) {
    __extends(StringPropertyDefinition, _super);
    /**
     * @internal Initializes a new instance of the **StringPropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    function StringPropertyDefinition(propertyName, xmlElementName, uri, flags, version) {
        return _super.call(this, propertyName, xmlElementName, uri, flags, version) || this;
    }
    Object.defineProperty(StringPropertyDefinition.prototype, "IsNullable", {
        /**
         * @internal Gets a value indicating whether this property definition is for a nullable type (ref, int?, bool?...).
         */
        get: function () { return true; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StringPropertyDefinition.prototype, "Type", {
        /**
         * @internal Gets the property type.
         */
        get: function () { return StringPropertyDefinition; } //System.Type;
        ,
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Parses the specified value.
     *
     * @param   {string}   value   The value.
     * @return  {any}           String value.
     */
    StringPropertyDefinition.prototype.Parse = function (value) { return value; };
    return StringPropertyDefinition;
}(TypedPropertyDefinition));
exports.StringPropertyDefinition = StringPropertyDefinition;
/**
 * @internal Represents generic property definition.
 */
var GenericPropertyDefinition = (function (_super) {
    __extends(GenericPropertyDefinition, _super);
    function GenericPropertyDefinition(propertyName, xmlElementName, uri, versionOrFlags, version, isNullableOrEnumType) {
        if (isNullableOrEnumType === void 0) { isNullableOrEnumType = false; }
        var _this = this;
        switch (arguments.length) {
            case 4:
                _this = _super.call(this, propertyName, xmlElementName, uri, versionOrFlags) || this;
                break;
            case 6:
                if (typeof isNullableOrEnumType === 'boolean') {
                    _this = _super.call(this, propertyName, xmlElementName, uri, versionOrFlags, version, isNullableOrEnumType) || this;
                }
                else {
                    _this = _super.call(this, propertyName, xmlElementName, uri, versionOrFlags, version) || this;
                    _this.enumType = isNullableOrEnumType;
                }
                break;
            default:
                break;
        }
        return _this;
    }
    /**
     * @internal Parses the specified value.
     *
     * @param   {string}    value   The value.
     * @return  {any}       Value of string.
     */
    GenericPropertyDefinition.prototype.Parse = function (value) {
        //todo: fix converting generictype
        if (TypeGuards.hasEwsEnumAttribute(this.enumType)) {
            return this.enumType.FromEwsEnumString(value);
        }
        EwsLogging.Assert(false, "GenericPropertyDefinition<TPropertyValue>.Parse", "GenericPropertyDefinition<TPropertyValue> needs to be improved");
        return value;
    };
    /**
     * @internal Convert instance to string.
     *
     * @param   {any}   value   The value.
     * @return  {string}        String representation of property value.
     */
    GenericPropertyDefinition.prototype.ToString = function (value) {
        if (value) {
            if (TypeGuards.hasEwsEnumAttribute(this.enumType)) {
                this.enumType.ToEwsEnumString(value);
            }
            else
                return value.toString();
        }
        throw new Error("GenericPropertyDefinition: incorrect call of ToString(value): value is undefined");
    };
    GenericPropertyDefinition.prototype.toString = function (value) {
        return this.ToString(value);
    };
    return GenericPropertyDefinition;
}(TypedPropertyDefinition));
exports.GenericPropertyDefinition = GenericPropertyDefinition;
/**
 * @internal Represents Boolean property definition
 */
var BoolPropertyDefinition = (function (_super) {
    __extends(BoolPropertyDefinition, _super);
    function BoolPropertyDefinition(propertyName, xmlElementName, uri, versionOrFlags, version, isNullable) {
        var _this = this;
        switch (arguments.length) {
            case 4:
                _this = _super.call(this, propertyName, xmlElementName, uri, versionOrFlags) || this;
                break;
            case 5:
                _this = _super.call(this, propertyName, xmlElementName, uri, versionOrFlags, version, false) || this;
                break;
            case 6:
                _this = _super.call(this, propertyName, xmlElementName, uri, versionOrFlags, version, isNullable) || this;
                break;
            default:
                break;
        }
        return _this;
    }
    /**
     * @internal Parses the specified value (added to workaround Generic based value conversion in c#).
     *
     * @param   {string}    value   The value.
     * @return  {any}       Value of string.
     */
    BoolPropertyDefinition.prototype.Parse = function (value) {
        return Convert.toBool(value);
    };
    /**
     * Convert instance to string.
     *
     * @param   {any}       value   The value.
     * @return  {string}    String representation of Boolean property.
     */
    BoolPropertyDefinition.prototype.ToString = function (value) {
        if (typeof value !== 'undefined')
            return EwsUtilities.BoolToXSBool(value);
        throw new Error("BoolPropertyDefinition: incorrect call of ToString(value): value is undefined");
    };
    return BoolPropertyDefinition;
}(GenericPropertyDefinition));
exports.BoolPropertyDefinition = BoolPropertyDefinition;
/**
 * @internal Represents double-precision floating point property definition.
 */
var DoublePropertyDefinition = (function (_super) {
    __extends(DoublePropertyDefinition, _super);
    /**
     * @internal Initializes a new instance of the **DoublePropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    function DoublePropertyDefinition(propertyName, xmlElementName, uri, flags, version) {
        return _super.call(this, propertyName, xmlElementName, uri, flags, version, false) || this;
    }
    /**
     * @internal Parses the specified value (added to workaround Generic based value conversion in c#).
     *
     * @param   {string}    value   The value.
     * @return  {any}       Value of string.
     */
    DoublePropertyDefinition.prototype.Parse = function (value) {
        return Convert.toNumber(value);
    };
    return DoublePropertyDefinition;
}(GenericPropertyDefinition));
exports.DoublePropertyDefinition = DoublePropertyDefinition;
/**
 * @internal Represents Integer property defintion.
 */
var IntPropertyDefinition = (function (_super) {
    __extends(IntPropertyDefinition, _super);
    function IntPropertyDefinition(propertyName, xmlElementName, uri, versionOrFlags, version, isNullable) {
        var _this = this;
        switch (arguments.length) {
            case 4:
                _this = _super.call(this, propertyName, xmlElementName, uri, versionOrFlags) || this;
                break;
            case 5:
                _this = _super.call(this, propertyName, xmlElementName, uri, versionOrFlags, version, false) || this;
                break;
            case 6:
                _this = _super.call(this, propertyName, xmlElementName, uri, versionOrFlags, version, isNullable) || this;
                break;
            default:
                break;
        }
        return _this;
    }
    /**
     * @internal Parses the specified value (added to workaround Generic based value conversion in c#).
     *
     * @param   {string}    value   The value.
     * @return  {any}       Value of string.
     */
    IntPropertyDefinition.prototype.Parse = function (value) {
        return Convert.toNumber(value);
    };
    return IntPropertyDefinition;
}(GenericPropertyDefinition));
exports.IntPropertyDefinition = IntPropertyDefinition;
/** @internal */
var ListValuePropertyDefinition = (function (_super) {
    __extends(ListValuePropertyDefinition, _super);
    function ListValuePropertyDefinition() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ListValuePropertyDefinition.prototype.Parse = function (value) {
        throw new Error("ListValuePropertyDefinition - Parse: Not implemented.");
        // xs:list values are sent as a space-separated list; convert to comma-separated for EwsUtilities.Parse.
        var commaSeparatedValue = value ? value : value.replace(' ', ',');
        //return EwsUtilities.Parse<TPropertyValue>(commaSeparatedValue);
    };
    return ListValuePropertyDefinition;
}(GenericPropertyDefinition));
exports.ListValuePropertyDefinition = ListValuePropertyDefinition;
/**
 * @internal Represents a task delegation property definition.
 */
var TaskDelegationStatePropertyDefinition = (function (_super) {
    __extends(TaskDelegationStatePropertyDefinition, _super);
    /**
     * @internal Initializes a new instance of the **TaskDelegationStatePropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    function TaskDelegationStatePropertyDefinition(propertyName, xmlElementName, uri, flags, version) {
        return _super.call(this, propertyName, xmlElementName, uri, flags, version, false) || this;
    }
    /**
     * @internal Parses the specified value (added to workaround Generic based value conversion in c#).
     *
     * @param   {string}    value   The value.
     * @return  {any}       Value of string.
     */
    TaskDelegationStatePropertyDefinition.prototype.Parse = function (value) {
        switch (value) {
            case TaskDelegationStatePropertyDefinition.NoMatch:
                return TaskDelegationState.NoDelegation;
            case TaskDelegationStatePropertyDefinition.OwnNew:
                return TaskDelegationState.Unknown;
            case TaskDelegationStatePropertyDefinition.Owned:
                return TaskDelegationState.Accepted;
            case TaskDelegationStatePropertyDefinition.Accepted:
                return TaskDelegationState.Declined;
            default:
                EwsLogging.Assert(false, "TaskDelegationStatePropertyDefinition.Parse", StringHelper.Format("TaskDelegationStatePropertyDefinition.Parse(): value {0} cannot be handled.", value));
                return null; // To keep the compiler happy
        }
    };
    /**
     * Convert instance to string.
     *
     * @param   {any}       value   The value.
     * @return  {string}    TaskDelegationState value.
     */
    TaskDelegationStatePropertyDefinition.prototype.ToString = function (value) {
        var taskDelegationState = value;
        switch (taskDelegationState) {
            case TaskDelegationState.NoDelegation:
                return TaskDelegationStatePropertyDefinition.NoMatch;
            case TaskDelegationState.Unknown:
                return TaskDelegationStatePropertyDefinition.OwnNew;
            case TaskDelegationState.Accepted:
                return TaskDelegationStatePropertyDefinition.Owned;
            case TaskDelegationState.Declined:
                return TaskDelegationStatePropertyDefinition.Accepted;
            default:
                EwsLogging.Assert(false, "TaskDelegationStatePropertyDefinition.ToString", "Invalid TaskDelegationState value.");
                return null; // To keep the compiler happy
        }
    };
    TaskDelegationStatePropertyDefinition.NoMatch = "NoMatch";
    TaskDelegationStatePropertyDefinition.OwnNew = "OwnNew";
    TaskDelegationStatePropertyDefinition.Owned = "Owned";
    TaskDelegationStatePropertyDefinition.Accepted = "Accepted";
    return TaskDelegationStatePropertyDefinition;
}(GenericPropertyDefinition));
exports.TaskDelegationStatePropertyDefinition = TaskDelegationStatePropertyDefinition;
/**
 * @internal Represents TimeSpan property definition. based on moment Duration
 */
var TimeSpanPropertyDefinition = (function (_super) {
    __extends(TimeSpanPropertyDefinition, _super);
    /**
     * @internal Initializes a new instance of the **TimeSpanPropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    function TimeSpanPropertyDefinition(propertyName, xmlElementName, uri, flags, version) {
        return _super.call(this, propertyName, xmlElementName, uri, flags, version, false) || this;
    }
    /**
     * @internal Parses the specified value (added to workaround Generic based value conversion in c#).
     *
     * @param   {string}    value   The value.
     * @return  {any}       Value of string.
     */
    TimeSpanPropertyDefinition.prototype.Parse = function (value) {
        return EwsUtilities.XSDurationToTimeSpan(value);
    };
    /**
     * Convert instance to string.
     *
     * @param   {any}       value   The value.
     * @return  {string}    TimeSpan value.
     */
    TimeSpanPropertyDefinition.prototype.ToString = function (value) {
        if (value)
            return EwsUtilities.TimeSpanToXSDuration(value);
        throw new Error("TimeSpanPropertyDefinition: incorrect call of ToString(value): value is undefined");
    };
    return TimeSpanPropertyDefinition;
}(GenericPropertyDefinition));
exports.TimeSpanPropertyDefinition = TimeSpanPropertyDefinition;
/**
 * @internal Represents abstract complex property definition.
 */
var ComplexPropertyDefinitionBase = (function (_super) {
    __extends(ComplexPropertyDefinitionBase, _super);
    function ComplexPropertyDefinitionBase(propertyName, xmlElementName, uriOrFlags, versionOrFlags, version) {
        var _this = this;
        switch (arguments.length) {
            case 4:
                _this = _super.call(this, propertyName, xmlElementName, uriOrFlags, versionOrFlags) || this;
                break;
            case 5:
                _this = _super.call(this, propertyName, xmlElementName, uriOrFlags, versionOrFlags, version) || this;
                break;
            default:
                break;
        }
        return _this;
    }
    /**
     * Gets the property instance.
     *
     * @param   {PropertyBag}       propertyBag       The property bag.
     * @param   {complexProperty}   complexProperty   The property instance.
     * @return  {boolean}    True if the instance is newly created.
     */
    ComplexPropertyDefinitionBase.prototype.GetPropertyInstance = function (propertyBag, complexProperty) {
        complexProperty.outValue = null;
        if (!propertyBag.TryGetValue(this, complexProperty) || !this.HasFlag(PropertyDefinitionFlags.ReuseInstance, propertyBag.Owner.Service.RequestedServerVersion)) {
            complexProperty.outValue = this.CreatePropertyInstance(propertyBag.Owner);
            return true;
        }
        return false;
    };
    /**
     * @internal Internals the load from XMlJsObject.
     *
     * @param   {any}               jsObject    The json object.
     * @param   {ExchangeService}   service       The service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    ComplexPropertyDefinitionBase.prototype.InternalLoadFromXmlJsObject = function (jsObject, service, propertyBag) {
        var outComplexproperty = { outValue: null };
        var justCreated = this.GetPropertyInstance(propertyBag, outComplexproperty);
        //assume collection type
        var complexPropertyCollection = outComplexproperty.outValue;
        //check for collection type //todo: implement better ComplexPropertyCollection detection
        if (complexPropertyCollection.Items) {
            if (!justCreated && this.HasFlag(PropertyDefinitionFlags.UpdateCollectionItems, propertyBag.Owner.Service.RequestedServerVersion)) {
                complexPropertyCollection.UpdateFromXmlJsObjectCollection(jsObject, service);
            }
            else {
                complexPropertyCollection.CreateFromXmlJsObjectCollection(jsObject, service);
            }
        }
        else {
            //var typename = TypeSystem.GetJsObjectTypeName(jsObject);
            outComplexproperty.outValue.LoadFromXmlJsObject(jsObject, service);
        }
        propertyBag._setItem(this, outComplexproperty.outValue);
    };
    /**
     * @internal Loads the property value from XMLJsObject.
     *
     * @param   {any}               jsObject         The JSON value.  Can be a JsonObject, string, number, bool, array, or null.
     * @param   {ExchangeService}   service       The service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    ComplexPropertyDefinitionBase.prototype.LoadPropertyValueFromXmlJsObject = function (jsObject, service, propertyBag) {
        // check for null value from empty element
        if (jsObject) {
            //debugger;//update: array type detection in next call, can not call GetPropertyInstance multiple time
            this.InternalLoadFromXmlJsObject(jsObject, service, propertyBag);
        }
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the context is an update operation.
     */
    ComplexPropertyDefinitionBase.prototype.WritePropertyValueToXml = function (writer, propertyBag, isUpdateOperation) {
        var complexProperty = propertyBag._getItem(this);
        debugger;
        if (complexProperty) {
            complexProperty.WriteToXml(writer, this.XmlElementName);
        }
    };
    return ComplexPropertyDefinitionBase;
}(PropertyDefinition));
exports.ComplexPropertyDefinitionBase = ComplexPropertyDefinitionBase;
/**
 * @internal Represents base complex property type.
 *
 * @type <TComplexProperty> The type of the complex property.
 */
var ComplexPropertyDefinition = (function (_super) {
    __extends(ComplexPropertyDefinition, _super);
    function ComplexPropertyDefinition(propertyName, xmlElementName, uriOrFlags, versionOrFlags, versionOrDelegate, propertyCreationDelegate) {
        var _this = this;
        switch (arguments.length) {
            case 5:
                _this = _super.call(this, propertyName, xmlElementName, uriOrFlags, versionOrFlags) || this;
                _this.propertyCreationDelegate = versionOrDelegate;
                EwsLogging.Assert(_this.propertyCreationDelegate != null, "ComplexPropertyDefinition ctor", "CreateComplexPropertyDelegate cannot be null");
                break;
            case 6:
                _this = _super.call(this, propertyName, xmlElementName, uriOrFlags, versionOrFlags, versionOrDelegate) || this;
                _this.propertyCreationDelegate = propertyCreationDelegate;
                break;
            default:
                break;
        }
        return _this;
    }
    /**
     * @internal Creates the property instance.
     *
     * @param   {ServiceObject}   owner   The owner.
     * @return  {ComplexProperty}       ComplexProperty instance.
     */
    ComplexPropertyDefinition.prototype.CreatePropertyInstance = function (owner) {
        var complexProperty = this.propertyCreationDelegate();
        if (TypeGuards.isIOwnedProperty(complexProperty)) {
            complexProperty.Owner = owner;
        }
        if (complexProperty)
            return complexProperty;
    };
    return ComplexPropertyDefinition;
}(ComplexPropertyDefinitionBase));
exports.ComplexPropertyDefinition = ComplexPropertyDefinition;
/**
 * @internal Represents base Attachments property type.
 */
var AttachmentsPropertyDefinition = (function (_super) {
    __extends(AttachmentsPropertyDefinition, _super);
    /**
     * Initializes a new instance of the **AttachmentsPropertyDefinition** class.
     *
     * @param   {string}    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     */
    function AttachmentsPropertyDefinition(propertyName) {
        return _super.call(this, propertyName, XmlElementNames.Attachments, "item:Attachments", PropertyDefinitionFlags.AutoInstantiateOnRead, ExchangeVersion.Exchange2007_SP1, function () { return new AttachmentCollection(); }) || this;
    }
    /**
     * @internal Determines whether the specified flag is set.
     *
     * @param   {PropertyDefinitionFlags}   flag      The flag.
     * @param   {ExchangeVersion}           version   Requested version.
     * @return  {boolean}                   true if the specified flag is set; otherwise, false.
     */
    AttachmentsPropertyDefinition.prototype.HasFlag = function (flag, version) {
        if (version && version >= ExchangeVersion.Exchange2010_SP2) {
            return (flag & AttachmentsPropertyDefinition.Exchange2010SP2PropertyDefinitionFlags) == flag;
        }
        return _super.prototype.HasFlag.call(this, flag, version);
    };
    AttachmentsPropertyDefinition.Exchange2010SP2PropertyDefinitionFlags = PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.ReuseInstance | PropertyDefinitionFlags.UpdateCollectionItems;
    return AttachmentsPropertyDefinition;
}(ComplexPropertyDefinition));
exports.AttachmentsPropertyDefinition = AttachmentsPropertyDefinition;
/**
 * @internal Represents contained property definition.
 *
 * @type    <TComplexProperty>  ComplexProperty
 */
var ContainedPropertyDefinition = (function (_super) {
    __extends(ContainedPropertyDefinition, _super);
    /**
     * @internal Initializes a new instance of the **ContainedPropertyDefinition<TComplexProperty>** class.
     *
     * @param   {string}                                            propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                                            xmlElementName             Name of the XML element.
     * @param   {string}                                            uri                        The URI.
     * @param   {string}                                            containedXmlElementName    Name of the contained XML element.
     * @param   {PropertyDefinitionFlags}                           flags                      The flags.
     * @param   {ExchangeVersion}                                   version                    The version.
     * @param   {CreateComplexPropertyDelegate<TComplexProperty>}   propertyCreationDelegate   Delegate used to create instances of ComplexProperty.
     */
    function ContainedPropertyDefinition(propertyName, xmlElementName, uri, containedXmlElementName, flags, version, propertyCreationDelegate) {
        var _this = _super.call(this, propertyName, xmlElementName, uri, flags, version, propertyCreationDelegate) || this;
        _this.containedXmlElementName = containedXmlElementName;
        return _this;
    }
    /**
     * @internal Load from XMLJsObject.
     *
     * @param   {any}               reader        The reader.
     * @param   {ExchangeService}   service        The Service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    ContainedPropertyDefinition.prototype.InternalLoadFromXmlJsObject = function (jsObject, service, propertyBag) {
        //debug: //check for correct contained element name
        if (jsObject[this.containedXmlElementName]) {
            jsObject = jsObject[this.containedXmlElementName];
        }
        _super.prototype.InternalLoadFromXmlJsObject.call(this, jsObject, service, propertyBag);
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the context is an update operation.
     */
    ContainedPropertyDefinition.prototype.WritePropertyValueToXml = function (writer, propertyBag, isUpdateOperation) {
        var complexProperty = propertyBag._getItem(this);
        if (complexProperty) {
            writer.WriteStartElement(XmlNamespace.Types, this.XmlElementName);
            complexProperty.WriteToXml(writer, this.containedXmlElementName);
            writer.WriteEndElement(); // this.XmlElementName
        }
    };
    return ContainedPropertyDefinition;
}(ComplexPropertyDefinition));
exports.ContainedPropertyDefinition = ContainedPropertyDefinition;
// /**
//  * @internal Represents permission set property definition.
//  */
// export class PermissionSetPropertyDefinition extends ComplexPropertyDefinitionBase {
//     /**
//      * Gets the property type.
//      */
//     get Type(): any {//} Type {
//         return undefined;// new Type("FolderPermissionCollection");
//     }
//     /**
//      * @internal Initializes a new instance of the **PermissionSetPropertyDefinition** class.
//      *
//      * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
//      * @param   {string}                    xmlElementName   Name of the XML element.
//      * @param   {string}                    uri              The URI.
//      * @param   {PropertyDefinitionFlags}   flags            The flags.
//      * @param   {ExchangeVersion}           version          The version.
//      */
//     constructor(propertyName: string, xmlElementName: string, uri: string, flags: PropertyDefinitionFlags, version: ExchangeVersion){
//         super(propertyName, xmlElementName, uri, flags, version);
//     }
//     /**
//      * @internal Creates the property instance.
//      *
//      * @param   {ServiceObject}   owner   The owner.
//      * @return  {ComplexProperty}       ComplexProperty.
//      */
//     CreatePropertyInstance(owner: ServiceObject): ComplexProperty {
//         var folder: Folder = owner instanceof TypeContainer.Folder ? <Folder>owner : null;
//         EwsLogging.Assert(folder !== null, "PermissionCollectionPropertyDefinition.CreatePropertyInstance", "The owner parameter is not of type Folder or a derived class.");
//         return new FolderPermissionCollection(folder);
//     }
// }
/**
 * @internal Represents permission set property definition.
 */
var PermissionSetPropertyDefinition = (function (_super) {
    __extends(PermissionSetPropertyDefinition, _super);
    /**
     * @internal Initializes a new instance of the **PermissionSetPropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    function PermissionSetPropertyDefinition(propertyName, xmlElementName, uri, flags, version) {
        return _super.call(this, propertyName, xmlElementName, uri, flags, version) || this;
    }
    Object.defineProperty(PermissionSetPropertyDefinition.prototype, "Type", {
        /**
         * Gets the property type.
         */
        get: function () {
            return undefined; // new Type("FolderPermissionCollection");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the property instance.
     *
     * @param   {ServiceObject}   owner   The owner.
     * @return  {ComplexProperty}       ComplexProperty.
     */
    PermissionSetPropertyDefinition.prototype.CreatePropertyInstance = function (owner) {
        var folder = owner instanceof TypeContainer.Folder ? owner : null;
        EwsLogging.Assert(folder !== null, "PermissionCollectionPropertyDefinition.CreatePropertyInstance", "The owner parameter is not of type Folder or a derived class.");
        return new FolderPermissionCollection(folder);
    };
    return PermissionSetPropertyDefinition;
}(ComplexPropertyDefinitionBase));
exports.PermissionSetPropertyDefinition = PermissionSetPropertyDefinition;
/**
 * @internal Represents a property definition for properties of type TimeZoneInfo.
 */
var TimeZonePropertyDefinition = (function (_super) {
    __extends(TimeZonePropertyDefinition, _super);
    /**
     * @internal Initializes a new instance of the **TimeZonePropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    function TimeZonePropertyDefinition(propertyName, xmlElementName, uri, flags, version) {
        return _super.call(this, propertyName, xmlElementName, uri, flags, version) || this;
    }
    /**
     * @internal Loads the property value from json.
     *
     * @param   {any}               jsObject         The JSON value.  Can be a JsonObject, string, number, bool, array, or null.
     * @param   {ExchangeService}   service       The service.
     * @param   {PropertyBag}       propertyBag   The property bag.
     */
    TimeZonePropertyDefinition.prototype.LoadPropertyValueFromXmlJsObject = function (jsObject, service, propertyBag) {
        EwsLogging.Assert(false, "TimeZonePropertyDefinition.LoadPropertyValueFromXmlJsObject", "TimeZone info has been updated, Please report any bugs to github");
        var timeZoneDefinition = new TimeZoneDefinition();
        if (jsObject) {
            timeZoneDefinition.LoadFromXmlJsObject(jsObject, service);
        }
        propertyBag._setItem(this, timeZoneDefinition.ToTimeZoneInfo(service));
    };
    /**
     * @internal Writes the property value to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the context is an update operation.
     */
    TimeZonePropertyDefinition.prototype.WritePropertyValueToXml = function (writer, propertyBag, isUpdateOperation) {
        EwsLogging.Assert(false, "TimeZonePropertyDefinition.WritePropertyValueToXml", "[Info]:  TimeZone info has been updated, Please report any bugs to github", true);
        var value = propertyBag._getItem(this);
        if (value != null) {
            // We emit time zone properties only if we have not emitted the time zone SOAP header
            // or if this time zone is different from that of the service through which the request
            // is being emitted.
            if (!writer.IsTimeZoneHeaderEmitted || value != writer.Service.TimeZone) {
                var timeZoneDefinition = new TimeZoneDefinition(value);
                timeZoneDefinition.WriteToXml(writer);
            }
        }
    };
    return TimeZonePropertyDefinition;
}(PropertyDefinition));
exports.TimeZonePropertyDefinition = TimeZonePropertyDefinition;
/**
 * @internal Represents a property definition for properties of type TimeZoneInfo.
 */
var StartTimeZonePropertyDefinition = (function (_super) {
    __extends(StartTimeZonePropertyDefinition, _super);
    /**
     * @internal Initializes a new instance of the **StartTimeZonePropertyDefinition** class.
     *
     * @param   {string}                    propertyName     Name of the property (added to workaround reflection based initialization of Names).
     * @param   {string}                    xmlElementName   Name of the XML element.
     * @param   {string}                    uri              The URI.
     * @param   {PropertyDefinitionFlags}   flags            The flags.
     * @param   {ExchangeVersion}           version          The version.
     */
    function StartTimeZonePropertyDefinition(propertyName, xmlElementName, uri, flags, version) {
        return _super.call(this, propertyName, xmlElementName, uri, flags, version) || this;
    }
    /**
     * @internal Determines whether the specified flag is set.
     *
     * @param   {PropertyDefinitionFlags}   flag      The flag.
     * @param   {ExchangeVersion}           version   Requested version.
     * @return  {boolean}                   true if the specified flag is set; otherwise, false.
     */
    StartTimeZonePropertyDefinition.prototype.HasFlag = function (flag, version) {
        if (version && (version === ExchangeVersion.Exchange2007_SP1)) {
            return Schemas.AppointmentSchema.MeetingTimeZone.HasFlag(flag, version);
        }
        else {
            return _super.prototype.HasFlag.call(this, flag, version);
        }
    };
    /**
     * @internal Registers associated internal properties.
     *
     * @param   {PropertyDefinition[]}   properties   The list in which to add the associated properties.
     */
    StartTimeZonePropertyDefinition.prototype.RegisterAssociatedInternalProperties = function (properties) {
        _super.prototype.RegisterAssociatedInternalProperties.call(this, properties);
        properties.push(Schemas.AppointmentSchema.MeetingTimeZone);
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer.
     * @param   {PropertyBag}           propertyBag         The property bag.
     * @param   {boolean}               isUpdateOperation   Indicates whether the context is an update operation.
     */
    StartTimeZonePropertyDefinition.prototype.WritePropertyValueToXml = function (writer, propertyBag, isUpdateOperation) {
        var value = propertyBag._getItem(this);
        if (value != null) {
            if (writer.Service.RequestedServerVersion == ExchangeVersion.Exchange2007_SP1) {
                var service = writer.Service;
                if (service != null && service.Exchange2007CompatibilityMode == false) {
                    var meetingTimeZone = new MeetingTimeZone(value);
                    meetingTimeZone.WriteToXml(writer, XmlElementNames.MeetingTimeZone);
                }
            }
            else {
                _super.prototype.WritePropertyValueToXml.call(this, writer, propertyBag, isUpdateOperation);
            }
        }
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    StartTimeZonePropertyDefinition.prototype.WriteToXml = function (writer) {
        if (writer.Service.RequestedServerVersion == ExchangeVersion.Exchange2007_SP1) {
            Schemas.AppointmentSchema.MeetingTimeZone.WriteToXml(writer);
        }
        else {
            _super.prototype.WriteToXml.call(this, writer);
        }
    };
    return StartTimeZonePropertyDefinition;
}(TimeZonePropertyDefinition));
exports.StartTimeZonePropertyDefinition = StartTimeZonePropertyDefinition;
var isNode = (typeof window === 'undefined');
var util = undefined;
// if (isNode) {
//     util = require('util');
// }
// else {
util = {
    inspect: function (obj, option) { return obj; }
};
// }
var EwsLogging = (function () {
    function EwsLogging() {
    }
    EwsLogging.Assert = function (condition, caller, message, always) {
        if (always === void 0) { always = false; }
        if ((this.DebugLogEnabled || always) && !condition)
            console.log(StringHelper.Format("[{0}] {1}", caller, message));
    };
    EwsLogging.Log = function (message, always, expandObject) {
        if (always === void 0) { always = false; }
        if (expandObject === void 0) { expandObject = false; }
        if (this.DebugLogEnabled || always) {
            if (expandObject)
                console.log(util.inspect(message, { showHidden: false, depth: null, colors: true }));
            else
                console.log(message);
        }
    };
    EwsLogging.DebugLog = function (message, expandObject) {
        if (expandObject === void 0) { expandObject = false; }
        if (this.DebugLogEnabled) {
            if (expandObject)
                console.log(util.inspect(message, { showHidden: false, depth: null, colors: true }));
            else
                console.log(message);
        }
    };
    EwsLogging.DebugLogEnabled = true;
    return EwsLogging;
}());
exports.EwsLogging = EwsLogging;
var EwsServiceJsonReader = (function () {
    function EwsServiceJsonReader() {
    }
    //Service: ExchangeService;
    // constructor(service: ExchangeService){
    // 	this.Service = service;
    // }
    EwsServiceJsonReader.ReadAsArray = function (jsObject, xmlElementName) {
        if (!jsObject || !jsObject[xmlElementName]) {
            return [];
            //throw new Error("EwsServiceJsonReader - ReadAsArray - json property not found");
        }
        var collectionItems = jsObject[xmlElementName];
        if (!Array.isArray(collectionItems)) {
            collectionItems = [collectionItems];
        }
        return collectionItems;
    };
    EwsServiceJsonReader.ReadBase64ElementValue = function (obj) {
        return base64Helper.atob(obj);
    };
    EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson = function (jsonResponse /*JsonObject*/, service, collectionJsonElementName, getObjectInstanceDelegate, clearPropertyBag, requestedPropertySet, summaryPropertiesOnly) {
        var serviceObjects = [];
        var serviceObject = null;
        var collectionItems = jsonResponse[collectionJsonElementName];
        for (var key in collectionItems) {
            if (key.indexOf("__") === 0)
                continue;
            var jsonServiceObjects = collectionItems[key];
            if (!Array.isArray(jsonServiceObjects)) {
                jsonServiceObjects = [jsonServiceObjects];
            }
            for (var _a = 0, jsonServiceObjects_1 = jsonServiceObjects; _a < jsonServiceObjects_1.length; _a++) {
                var jsonServiceObject = jsonServiceObjects_1[_a];
                if (jsonServiceObject != null) {
                    var typeName = TypeSystem.GetJsObjectTypeName(jsonServiceObject);
                    if (StringHelper.IsNullOrEmpty(typeName))
                        debugger; //check why typeName is empty - may be invalid xml parsing by xml2js
                    serviceObject = getObjectInstanceDelegate(service, typeName || key);
                    if (serviceObject != null) {
                        if ((typeName || key) !== serviceObject.GetXmlElementName()) {
                            throw new ServiceLocalException(StringHelper.Format("The type of the object in the store ({0}) does not match that of the local object ({1}).", typeName, serviceObject.GetXmlElementName()));
                        }
                        serviceObject.LoadFromXmlJsObject(jsonServiceObject, service, clearPropertyBag, requestedPropertySet, summaryPropertiesOnly);
                        serviceObjects.push(serviceObject);
                    }
                    else
                        debugger;
                }
            }
        }
        return serviceObjects;
    };
    return EwsServiceJsonReader;
}());
exports.EwsServiceJsonReader = EwsServiceJsonReader;
//todo: ix this - import Xml = require("System.Xml");
/** @internal */
var EwsXmlReader = (function () {
    //#endregion
    //#region Constructor
    function EwsXmlReader(rawXML) {
        this.eof = false;
        var parser = new exports.DOMParser();
        this.xmlDoc = parser.parseFromString(rawXML, "text/xml");
        //this.treeWalker = this.xmlDoc.createTreeWalker(this.xmlDoc, NodeFilter.SHOW_ELEMENT, null, false);
        //this.currentNode = this.treeWalker.root;
        var xml2js = new xml2JsObject();
        this.jsObject = xml2js.parseXMLNode(this.xmlDoc.documentElement, true);
        EwsLogging.DebugLog(this.JsObject, true);
    }
    Object.defineProperty(EwsXmlReader.prototype, "HasAttributes", {
        get: function () { return this.currentNode ? this.currentNode.hasAttributes() : false; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EwsXmlReader.prototype, "IsEmptyElement", {
        get: function () { return this.currentNode.nodeType == Node.ELEMENT_NODE /*System.Xml.XmlNodeType.Element*/ && !this.currentNode.hasChildNodes(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EwsXmlReader.prototype, "LocalName", {
        get: function () { return this.currentNode ? this.currentNode.localName : undefined; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EwsXmlReader.prototype, "NamespacePrefix", {
        get: function () { return this.currentNode ? this.currentNode.prefix : undefined; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EwsXmlReader.prototype, "NamespaceUri", {
        get: function () { return this.currentNode ? this.currentNode.namespaceURI : undefined; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EwsXmlReader.prototype, "NodeType", {
        get: function () { return this.currentNode ? this.currentNode.nodeType : undefined; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EwsXmlReader.prototype, "IsRoot", {
        //get PrevNodeType(): System.Xml.XmlNodeType { return this.prevNodeType; }
        get: function () { return this.currentNode == this.treeWalker.root; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EwsXmlReader.prototype, "ParentNode", {
        get: function () { return this.currentNode ? this.currentNode.parentNode : undefined; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EwsXmlReader.prototype, "CurrentNode", {
        get: function () { return this.currentNode; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EwsXmlReader.prototype, "Eof", {
        get: function () { return this.eof; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EwsXmlReader.prototype, "JsObject", {
        //#region xml2JS logic
        get: function () { return this.jsObject; },
        enumerable: true,
        configurable: true
    });
    //#endregion
    EwsXmlReader.prototype.EnsureCurrentNodeIsEndElement = function (xmlNamespace, localName) { throw new Error("EwsXmlReader.ts - EnsureCurrentNodeIsEndElement : Not implemented."); };
    //EnsureCurrentNodeIsStartElement(xmlNamespace: XmlNamespace, localName: string): any { throw new Error("EwsXmlReader.ts - EnsureCurrentNodeIsStartElement : Not implemented."); }
    //EnsureCurrentNodeIsStartElement(): any { throw new Error("EwsXmlReader.ts - EnsureCurrentNodeIsStartElement : Not implemented."); }
    EwsXmlReader.prototype.FormatElementName = function (namespacePrefix, localElementName) { throw new Error("EwsXmlReader.ts - FormatElementName : Not implemented."); };
    EwsXmlReader.prototype.GetXmlReaderForNode = function () { throw new Error("EwsXmlReader.ts - GetXmlReaderForNode : Not implemented."); };
    EwsXmlReader.prototype.InitializeXmlReader = function (stream /*System.IO.Stream*/) { throw new Error("EwsXmlReader.ts - InitializeXmlReader : Not implemented."); };
    //InternalReadElement(namespacePrefix: string, localName: string, nodeType: System.Xml.XmlNodeType): any;// { throw new Error("EwsXmlReader.ts - InternalReadElement : Not implemented."); }
    EwsXmlReader.prototype.InternalReadElement = function (xmlNamespace, localName, nodeType /*Xml.XmlNodeType*/) {
        if (this.LocalName === localName && this.NamespaceUri == EwsUtilities.GetNamespaceUri(xmlNamespace))
            return;
        this.Read(nodeType);
        if (localName && nodeType)
            if ((this.LocalName != localName) || (this.NamespaceUri != EwsUtilities.GetNamespaceUri(xmlNamespace))) {
                throw new Error(StringHelper.Format("unexpected element, {0}:{1}, {2}, {3}, {4}", EwsUtilities.GetNamespacePrefix(xmlNamespace), localName, nodeType, this.xmlReader.Name, this.NodeType));
            }
    };
    EwsXmlReader.prototype.HasRecursiveParent = function (localName, node) {
        if (node === void 0) { node = this.currentNode; }
        if (node === null || node.parentNode === null)
            return false;
        if (node.parentNode.localName == localName)
            return true;
        else
            return this.HasRecursiveParent(localName, node.parentNode);
    };
    EwsXmlReader.prototype.HasRecursiveParentNode = function (parentNode, parentName, node) {
        if (node === void 0) { node = this.currentNode; }
        if (node === null || node.parentNode === null)
            return false;
        if (node.parentNode.localName == parentName && node.parentNode != parentNode)
            return false;
        if (node.parentNode == parentNode)
            return true;
        else
            return this.HasRecursiveParentNode(parentNode, parentName, node.parentNode);
    };
    //IsEndElement(xmlNamespace: XmlNamespace, localName: string): boolean { throw new Error("EwsXmlReader.ts - IsEndElement : Not implemented."); }
    //IsEndElement(namespacePrefix: string, localName: string): boolean { throw new Error("EwsXmlReader.ts - IsEndElement : Not implemented."); }
    //IsStartElement(namespacePrefix: string, localName: string): boolean { throw new Error("EwsXmlReader.ts - IsStartElement : Not implemented."); }
    //IsStartElement(): boolean { throw new Error("EwsXmlReader.ts - IsStartElement : Not implemented."); }
    //IsStartElement(xmlNamespace: XmlNamespace, localName: string): boolean { throw new Error("EwsXmlReader.ts - IsStartElement : Not implemented."); }
    EwsXmlReader.prototype.IsElement = function (xmlNamespace, localName) {
        return (this.LocalName == localName) &&
            ((this.NamespacePrefix == EwsUtilities.GetNamespacePrefix(xmlNamespace)) ||
                (this.NamespaceUri == EwsUtilities.GetNamespaceUri(xmlNamespace)));
    };
    //Read(): any { throw new Error("EwsXmlReader.ts - Read : Not implemented."); }
    EwsXmlReader.prototype.Read = function (nodeType /*Xml.XmlNodeType*/) {
        this.currentNode = this.treeWalker.nextNode();
        if (this.currentNode == null)
            this.eof = true;
        if (nodeType) {
            if (this.NodeType !== nodeType)
                throw new Error("unexpected element type");
        }
        return this.currentNode != null;
    };
    //ReadAttributeValue(attributeName: string): string;// { throw new Error("EwsXmlReader.ts - ReadAttributeValue : Not implemented."); }
    //ReadAttributeValue(attributeName: string): any { throw new Error("EwsXmlReader.ts - ReadAttributeValue : Not implemented."); }
    EwsXmlReader.prototype.ReadAttributeValue = function (xmlNamespace, attributeName) {
        if (this.currentNode == null || this.currentNode.nodeType != this.currentNode.ELEMENT_NODE || !this.currentNode.hasAttributes())
            return null;
        var elem = this.currentNode;
        var val = elem.getAttributeNS(EwsUtilities.GetNamespaceUri(xmlNamespace), attributeName);
        return val;
    };
    //ReadBase64ElementValue(outputStream: System.IO.Stream): any { throw new Error("EwsXmlReader.ts - ReadBase64ElementValue : Not implemented."); }
    EwsXmlReader.prototype.ReadBase64ElementValue = function () { throw new Error("EwsXmlReader.ts - ReadBase64ElementValue : Not implemented."); };
    EwsXmlReader.prototype.ReadElementValue = function () {
        return this.currentNode.textContent;
    };
    //ReadElementValue(): any { throw new Error("EwsXmlReader.ts - ReadElementValue : Not implemented."); }
    //ReadElementValue(xmlNamespace: XmlNamespace, localName: string): any { throw new Error("EwsXmlReader.ts - ReadElementValue : Not implemented."); }
    //ReadElementValue(namespacePrefix: string, localName: string): string { throw new Error("EwsXmlReader.ts - ReadElementValue : Not implemented."); }
    //ReadElementValue(xmlNamespace: XmlNamespace, localName: string): string { throw new Error("EwsXmlReader.ts - ReadElementValue : Not implemented."); }
    //ReadEndElement(namespacePrefix: string, elementName: string): any { throw new Error("EwsXmlReader.ts - ReadEndElement : Not implemented."); }
    EwsXmlReader.prototype.ReadEndElement = function (xmlNamespace, localName) {
        this.InternalReadElement(xmlNamespace, localName, Node.ELEMENT_NODE /*System.Xml.XmlNodeType.Element*/);
    };
    EwsXmlReader.prototype.ReadEndElementIfNecessary = function (xmlNamespace, localName) {
        if (!(this.IsElement(xmlNamespace, localName) && this.IsEmptyElement)) {
            //if (!this.IsEndElement(xmlNamespace, localName)) {
            this.ReadEndElement(xmlNamespace, localName);
            //}
        }
    };
    EwsXmlReader.prototype.ReadInnerXml = function () { throw new Error("EwsXmlReader.ts - ReadInnerXml : Not implemented."); };
    EwsXmlReader.prototype.ReadNullableAttributeValue = function (attributeName) { throw new Error("EwsXmlReader.ts - ReadNullableAttributeValue : Not implemented."); };
    EwsXmlReader.prototype.ReadOuterXml = function () { throw new Error("EwsXmlReader.ts - ReadOuterXml : Not implemented."); };
    //ReadStartElement(namespacePrefix: string, localName: string): any { throw new Error("EwsXmlReader.ts - ReadStartElement : Not implemented."); }
    EwsXmlReader.prototype.ReadStartElement = function (xmlNamespace, localName) {
        this.InternalReadElement(xmlNamespace, localName, Node.ELEMENT_NODE /*System.Xml.XmlNodeType.Element*/);
    };
    EwsXmlReader.prototype.ReadToDescendant = function (xmlNamespace, localName) { throw new Error("EwsXmlReader.ts - ReadToDescendant : Not implemented."); };
    EwsXmlReader.prototype.ReadValue = function () { throw new Error("EwsXmlReader.ts - ReadValue : Not implemented."); };
    //ReadValue(): any { throw new Error("EwsXmlReader.ts - ReadValue : Not implemented."); }
    EwsXmlReader.prototype.SeekLast = function () {
        if (!this.eof)
            this.currentNode = this.treeWalker.previousNode();
    };
    EwsXmlReader.prototype.SkipCurrentElement = function () {
        //debug:
        var parentNode = this.CurrentNode;
        do {
            this.Read();
        } while (this.HasRecursiveParentNode(parentNode, parentNode.localName));
        this.SeekLast();
    };
    EwsXmlReader.prototype.SkipElement = function (xmlNamespace, localName) { throw new Error("EwsXmlReader.ts - SkipElement : Not implemented."); };
    //SkipElement(namespacePrefix: string, localName: string): any { throw new Error("EwsXmlReader.ts - SkipElement : Not implemented."); }
    EwsXmlReader.prototype.TryReadValue = function (value) { throw new Error("EwsXmlReader.ts - TryReadValue : Not implemented."); };
    EwsXmlReader.ReadWriteBufferSize = 4096;
    return EwsXmlReader;
}());
exports.EwsXmlReader = EwsXmlReader;
/**@internal */
var EwsServiceXmlReader = (function (_super) {
    __extends(EwsServiceXmlReader, _super);
    //#region Constructor
    function EwsServiceXmlReader(rawXML, service) {
        var _this = _super.call(this, rawXML) || this;
        _this.service = service;
        return _this;
    }
    Object.defineProperty(EwsServiceXmlReader.prototype, "Service", {
        get: function () { return this.service; },
        enumerable: true,
        configurable: true
    });
    //#endregion
    EwsServiceXmlReader.prototype.ConvertStringToDateTime = function (dateTimeString) { throw new Error("EwsServiceXmlReader.ts - ConvertStringToDateTime : Not implemented."); };
    EwsServiceXmlReader.prototype.ConvertStringToUnspecifiedDate = function (dateTimeString) { throw new Error("EwsServiceXmlReader.ts - ConvertStringToUnspecifiedDate : Not implemented."); };
    EwsServiceXmlReader.prototype.ReadElementValueAsDateTime = function () { throw new Error("EwsServiceXmlReader.ts - ReadElementValueAsDateTime : Not implemented."); };
    //ReadElementValueAsDateTime(xmlNamespace: XmlNamespace, localName: string): Date { throw new Error("EwsServiceXmlReader.ts - ReadElementValueAsDateTime : Not implemented."); }
    EwsServiceXmlReader.prototype.ReadElementValueAsUnbiasedDateTimeScopedToServiceTimeZone = function () { throw new Error("EwsServiceXmlReader.ts - ReadElementValueAsUnbiasedDateTimeScopedToServiceTimeZone : Not implemented."); };
    EwsServiceXmlReader.prototype.ReadElementValueAsUnspecifiedDate = function () { throw new Error("EwsServiceXmlReader.ts - ReadElementValueAsUnspecifiedDate : Not implemented."); };
    return EwsServiceXmlReader;
}(EwsXmlReader));
exports.EwsServiceXmlReader = EwsServiceXmlReader;
/**@internal */
var EwsServiceMultiResponseXmlReader = (function (_super) {
    __extends(EwsServiceMultiResponseXmlReader, _super);
    function EwsServiceMultiResponseXmlReader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EwsServiceMultiResponseXmlReader.prototype.Create = function (stream /*System.IO.Stream*/, service) { throw new Error("EwsServiceMultiResponseXmlReader.ts - Create : Not implemented."); };
    EwsServiceMultiResponseXmlReader.prototype.CreateXmlReader = function (stream /*System.IO.Stream*/) { throw new Error("EwsServiceMultiResponseXmlReader.ts - CreateXmlReader : Not implemented."); };
    EwsServiceMultiResponseXmlReader.prototype.InitializeXmlReader = function (stream /*System.IO.Stream*/) { throw new Error("EwsServiceMultiResponseXmlReader.ts - InitializeXmlReader : Not implemented."); };
    return EwsServiceMultiResponseXmlReader;
}(EwsServiceXmlReader));
exports.EwsServiceMultiResponseXmlReader = EwsServiceMultiResponseXmlReader;
/**
 * @internal XML writer
 */
var EwsServiceXmlWriter = (function () {
    //#endregion
    /**
     * Initializes a new instance of the **EwsServiceXmlWriter** class.
     *
     * @param   {ExchangeServiceBase}   service   The service.
     */
    function EwsServiceXmlWriter(service) {
        //#region custome XML writer data;
        this.xmlElements = [];
        this.pendingElementData = "";
        this.pendingXMLTagClosure = false;
        this.soapData = "";
        this.rootUris = [];
        this.rootLevel = false;
        this.currentLevel = 0;
        this.service = service;
    }
    Object.defineProperty(EwsServiceXmlWriter.prototype, "Service", {
        //get InternalWriter(): System.Xml.XmlWriter;
        get: function () { return this.service; },
        enumerable: true,
        configurable: true
    });
    EwsServiceXmlWriter.prototype.Dispose = function () { throw new Error("EwsServiceXmlWriter.ts - Dispose : Not implemented."); };
    EwsServiceXmlWriter.prototype.Flush = function () {
    };
    /**
     * Gets the xml created by EWS XMl Writer.
     *
     * @param   {boolean}   keep   removes internal cache of XML data if false, otherwise keep the data.
     */
    EwsServiceXmlWriter.prototype.GetXML = function (keep) {
        if (keep === void 0) { keep = false; }
        var returnVal = this.soapData.trim();
        if (!keep)
            this.soapData = "";
        return returnVal;
    };
    /**
     * Closes XMl tag
     */
    EwsServiceXmlWriter.prototype.CloseTag = function () {
        if (this.pendingXMLTagClosure) {
            this.soapData += ">";
            this.pendingXMLTagClosure = false;
            this.rootLevel = false;
        }
    };
    /**
     * Pushes xml uri to internal tracker of used xml uris
     *
     * @param   {string}   prefix     Prefix of uri.
     * @param   {string}   uri        uri itself.
     */
    EwsServiceXmlWriter.prototype.PushUris = function (prefix, uri) {
        if (this.rootLevel) {
            this.rootUris.push(prefix + ":" + uri);
        }
    };
    /**
     * check if an uri exist in internal tracker
     *
     * @param   {string}   prefix     Prefix of uri.
     * @param   {string}   uri        uri itself.
     */
    EwsServiceXmlWriter.prototype.CheckRootUri = function (prefix, uri) {
        return this.rootUris.indexOf(prefix + ":" + uri) >= 0;
    };
    //TryConvertObjectToString(value: any, strValue: any): boolean { throw new Error("EwsServiceXmlWriter.ts - TryConvertObjectToString : Not implemented."); }
    /**
     * convert object to a string. transformed TryConvertObjectToString metho from c#
     *
     * @param   {any}     value      The value.
     * @return  {string}  The string representation of value.
     */
    EwsServiceXmlWriter.prototype.ConvertObjectToString = function (value) {
        var strValue = null;
        if (value === null)
            return null;
        if (value != null) {
            switch (typeof (value)) {
                case "boolean":
                    strValue = EwsUtilities.BoolToXSBool(value);
                    break;
                case "number":
                    strValue = value;
                    //todo check for datetime
                    //strValue = this.Service.ConvertDateTimeToUniversalDateTimeString((DateTime) value);
                    break;
                case "string":
                    return value;
                default:
                    if (value instanceof DateTime) {
                        return this.service.ConvertDateTimeToUniversalDateTimeString(value);
                        //return EwsUtilities.DateTimeToXSDateTime(value as DateTime);
                    }
                    try {
                        if (TypeGuards.isISearchStringProvider(value))
                            return value.GetSearchString();
                        else
                            throw new Error("value can not be of type object");
                    }
                    catch (e) {
                        throw e;
                    }
                    break;
            }
            return strValue;
        }
        //return converted;
        return undefined;
    };
    EwsServiceXmlWriter.prototype.WriteAttributeString = function (localNameOrNamespacePrefix, localNameOrStringValue, stringValueToWrite) {
        var namespacePrefix = "";
        var localName = localNameOrNamespacePrefix;
        var stringValue = localNameOrStringValue;
        if (arguments.length === 3) {
            namespacePrefix = localNameOrNamespacePrefix;
            localName = localNameOrStringValue;
            stringValue = stringValueToWrite;
        }
        if (namespacePrefix !== "")
            namespacePrefix += ":";
        this.soapData += " " + namespacePrefix + localName + "=\"" + stringValue + "\"";
        if (namespacePrefix == "xmlns:")
            this.PushUris(localName, stringValue);
        //try {
        //    this.xmlWriter.WriteAttributeString(
        //        namespacePrefix,
        //        localName,
        //        null,
        //        stringValue);
        //}
        //catch (ex) {
        //    // XmlTextWriter will throw ArgumentException if string includes invalid characters.
        //    //throw new ServiceXmlSerializationException(
        //    //    string.Format(Strings.InvalidAttributeValue, stringValue, localName),
        //    //    ex);
        //}
    };
    EwsServiceXmlWriter.prototype.WriteAttributeValue = function (localNameOrNamespacePrefix, localNameOrAlwaysWriteEmptyStringOrValue, valueToWrite) {
        var argsLength = arguments.length;
        var localName = localNameOrNamespacePrefix;
        var value = valueToWrite;
        var alwaysWriteEmptyString = false;
        var namespacePrefix = null;
        var callWithNameSpacePrifix = false;
        if (argsLength === 2) {
            value = localNameOrAlwaysWriteEmptyStringOrValue;
        }
        if (argsLength === 3) {
            if (typeof localNameOrAlwaysWriteEmptyStringOrValue === "boolean") {
                localName = localNameOrNamespacePrefix;
                alwaysWriteEmptyString = localNameOrAlwaysWriteEmptyStringOrValue;
            }
            else {
                namespacePrefix = localNameOrNamespacePrefix;
                localName = localNameOrAlwaysWriteEmptyStringOrValue;
                callWithNameSpacePrifix = true;
            }
        }
        var stringValue = this.ConvertObjectToString(value);
        if (!StringHelper.IsNullOrEmpty(stringValue) || alwaysWriteEmptyString) {
            this.WriteAttributeString(callWithNameSpacePrifix ? namespacePrefix : "", localName, stringValue);
        }
    };
    //WriteBase64ElementValue(buffer: System.Byte[]): any{ throw new Error("EwsServiceXmlWriter.ts - WriteBase64ElementValue : Not implemented.");}
    //WriteBase64ElementValue(stream: System.IO.Stream): any{ throw new Error("EwsServiceXmlWriter.ts - WriteBase64ElementValue : Not implemented.");}
    /**
     * Writes the base64-encoded element value.
     *
     * @param   {any}   buffer   The buffer.
     */
    EwsServiceXmlWriter.prototype.WriteBase64ElementValue = function (buffer) {
        this.WriteValue(base64Helper.btoa(buffer), null);
    };
    EwsServiceXmlWriter.prototype.WriteElementValue = function (xmlNamespace, localName, displayNameOrValue, valueToWrite) {
        var value = displayNameOrValue;
        var displayName = localName;
        if (arguments.length === 4) {
            value = valueToWrite;
            displayName = displayNameOrValue;
        }
        var stringValue = this.ConvertObjectToString(value);
        if (stringValue != undefined) {
            this.WriteStartElement(xmlNamespace, localName);
            this.WriteValue(stringValue, displayName);
            this.WriteEndElement();
        }
        else {
            EwsLogging.Assert(stringValue !== 'undefined', 'WriteElementValue', StringHelper.Format(Strings.ElementValueCannotBeSerialized, typeof (value), localName));
            // throw new Error(StringHelper.Format(
            //     Strings.ElementValueCannotBeSerialized,
            //     typeof (value), localName));
        }
    };
    /**
     * Writes the end element.
     */
    EwsServiceXmlWriter.prototype.WriteEndElement = function () {
        //this.xmlWriter.WriteEndElement();
        var element = "</" + this.xmlElements.pop() + ">";
        this.CloseTag();
        this.soapData += element;
    };
    //WriteNode(xmlNode: System.Xml.XmlNode): any{ throw new Error("EwsServiceXmlWriter.ts - WriteNode : Not implemented.");}
    /**
     * Writes the start element.
     *
     * @param   {XmlNamespace}    xmlNamespace   The XML namespace.
     * @param   {string}          localName      The local name of the element.
     */
    EwsServiceXmlWriter.prototype.WriteStartElement = function (xmlNamespace, localName) {
        this.CloseTag();
        if (this.soapData == "")
            this.rootLevel = true;
        else
            this.soapData += ""; //\r\n";
        var prefix = EwsUtilities.GetNamespacePrefix(xmlNamespace);
        this.soapData += "<" + prefix + ":" + localName;
        var uri = EwsUtilities.GetNamespaceUri(xmlNamespace);
        if (!this.CheckRootUri(prefix, uri)) {
            this.soapData += " xmlns:" + prefix + "=\"" + uri + "\"";
        }
        this.PushUris(prefix, uri);
        this.xmlElements.push(prefix + ":" + localName);
        this.pendingXMLTagClosure = true;
        //this.xmlWriter.WriteStartElement(
        //    EwsUtilities.GetNamespacePrefix(xmlNamespace),
        //    localName,
        //    EwsUtilities.GetNamespaceUri(xmlNamespace));
    };
    /**
     * Writes string value.
     *
     * @param   {string}   value   The value.
     * @param   {string}   name    Element name (used for error handling)
     */
    EwsServiceXmlWriter.prototype.WriteValue = function (value, name) {
        //var closeElement = this.soapData.charAt(this.soapData.length - 1) !== ">";
        //if (closeElement) this.soapData += ">";
        this.CloseTag();
        this.soapData += value;
        //todo: validate invalid characters
        // name is used for exception with invalid characters
    };
    /**
     * Buffer size for writing Base64 encoded content.
     *
     */
    EwsServiceXmlWriter.BufferSize = 4096;
    return EwsServiceXmlWriter;
}());
exports.EwsServiceXmlWriter = EwsServiceXmlWriter;
/**
 * @internal EWS utilities
 *
 * @static
 */
var EwsUtilities = (function () {
    function EwsUtilities() {
    }
    // private static serviceObjectInfo: LazyMember<ServiceObjectInfo> = new LazyMember<ServiceObjectInfo>(
    //     () => {
    //         //return new ServiceObjectInfo();
    //     });
    //private static buildVersion: LazyMember<T>;
    // private static enumVersionDictionaries: LazyMember<EnumToExhcangeVersionDelegateDictionary> = new LazyMember<EnumToExhcangeVersionDelegateDictionary>(
    //     () => {
    //         var e2evmh = EnumToExchangeVersionMappingHelper;
    //         var dict: EnumToExhcangeVersionDelegateDictionary = {};
    //         dict[e2evmh[e2evmh.WellKnownFolderName]] = EwsUtilities.BuildEnumDict(e2evmh.WellKnownFolderName);
    //         dict[e2evmh[e2evmh.ItemTraversal]] = EwsUtilities.BuildEnumDict(e2evmh.ItemTraversal);
    //         dict[e2evmh[e2evmh.ConversationQueryTraversal]] = EwsUtilities.BuildEnumDict(e2evmh.ConversationQueryTraversal);
    //         dict[e2evmh[e2evmh.FileAsMapping]] = EwsUtilities.BuildEnumDict(e2evmh.FileAsMapping);
    //         dict[e2evmh[e2evmh.EventType]] = EwsUtilities.BuildEnumDict(e2evmh.EventType);
    //         dict[e2evmh[e2evmh.MeetingRequestsDeliveryScope]] = EwsUtilities.BuildEnumDict(e2evmh.MeetingRequestsDeliveryScope);
    //         dict[e2evmh[e2evmh.ViewFilter]] = EwsUtilities.BuildEnumDict(e2evmh.ViewFilter);
    //         dict[e2evmh[e2evmh.MailboxType]] = EwsUtilities.BuildEnumDict(e2evmh.MailboxType);
    //         return dict;
    //     });
    // private static schemaToEnumDictionaries: LazyMember<DictionaryWithNumericKey<DictionaryWithStringKey<number>>> = new LazyMember<DictionaryWithNumericKey<DictionaryWithStringKey<number>>>(
    //     () => {
    //         var dict = new DictionaryWithNumericKey<DictionaryWithStringKey<number>>();
    //         dict.addUpdate(EnumToSchemaMappingHelper.WellKnownFolderName, EwsUtilities.BuildSchemaToEnumDict(EnumToSchemaMappingHelper.WellKnownFolderName));
    //         dict.addUpdate(EnumToSchemaMappingHelper.ItemTraversal, EwsUtilities.BuildSchemaToEnumDict(EnumToSchemaMappingHelper.ItemTraversal));
    //         dict.addUpdate(EnumToSchemaMappingHelper.ConversationQueryTraversal, EwsUtilities.BuildSchemaToEnumDict(EnumToSchemaMappingHelper.ConversationQueryTraversal));
    //         dict.addUpdate(EnumToSchemaMappingHelper.FileAsMapping, EwsUtilities.BuildSchemaToEnumDict(EnumToSchemaMappingHelper.FileAsMapping));
    //         dict.addUpdate(EnumToSchemaMappingHelper.EventType, EwsUtilities.BuildSchemaToEnumDict(EnumToSchemaMappingHelper.EventType));
    //         dict.addUpdate(EnumToSchemaMappingHelper.MeetingRequestsDeliveryScope, EwsUtilities.BuildSchemaToEnumDict(EnumToSchemaMappingHelper.MeetingRequestsDeliveryScope));
    //         dict.addUpdate(EnumToSchemaMappingHelper.ViewFilter, EwsUtilities.BuildSchemaToEnumDict(EnumToSchemaMappingHelper.ViewFilter));
    //         dict.addUpdate(EnumToSchemaMappingHelper.MailboxType, EwsUtilities.BuildSchemaToEnumDict(EnumToSchemaMappingHelper.EventType));
    //         return dict;
    //     });
    // private static enumToSchemaDictionaries: LazyMember<DictionaryWithNumericKey<DictionaryWithNumericKey<string>>>;
    //private static typeNameToShortNameMap: LazyMember<T>;
    EwsUtilities.BoolToXSBool = function (value) {
        var boolvalue = Convert.toBool(value);
        return boolvalue ? EwsUtilities.XSTrue : EwsUtilities.XSFalse;
        //throw new Error("EwsUtilities.ts - static BoolToXSBool : Not implemented.");
    };
    //static BuildEnumDict(enumType: System.Type): System.Collections.Generic.Dictionary<TKey, TValue>{ throw new Error("EwsUtilities.ts - static BuildEnumDict : Not implemented.");}
    //deviation - need to work with static data for enum to exchange version dict, there is no Attribute type system in javascript.
    // static BuildEnumDict(enumType: EnumToExchangeVersionMappingHelper): EnumVersionDelegate {
    //     var enumDelegate = (value: any) => { return ExchangeVersion.Exchange2007_SP1 };
    //     switch (enumType) {
    //         //TODO: fix numbering to named enum value if possible
    //         case EnumToExchangeVersionMappingHelper.WellKnownFolderName:
    //             enumDelegate = (value) => {
    //                 var enumVersion = ExchangeVersion.Exchange2007_SP1;
    //                 if (value <= 15) //<= WellKnownFolderName.VoiceMail
    //                     enumVersion = ExchangeVersion.Exchange2007_SP1;
    //                 else if (value >= 16 && value <= 26) //>= RecoverableItemsRoot && <= ArchiveRecoverableItemsPurges
    //                     enumVersion = ExchangeVersion.Exchange2010_SP1;
    //                 else if (value >= 27 && value <= 34) //>= SyncIssues && <= ToDoSearch
    //                     enumVersion = ExchangeVersion.Exchange2013;
    //                 else
    //                     enumVersion = ExchangeVersion.Exchange_Version_Not_Updated;
    //                 return enumVersion;
    //             };
    //             break;
    //         case EnumToExchangeVersionMappingHelper.ItemTraversal:
    //             enumDelegate = (value) => {
    //                 if (value <= 1) //<= ItemTraversal.SoftDeleted
    //                     return ExchangeVersion.Exchange2007_SP1;
    //                 else if (value == 2) // === Associated
    //                     return ExchangeVersion.Exchange2010;
    //                 return ExchangeVersion.Exchange_Version_Not_Updated;
    //             };
    //             break;
    //         case EnumToExchangeVersionMappingHelper.ConversationQueryTraversal:
    //             enumDelegate = (value) => {
    //                 if (value <= 1) //<= ConversationQueryTraversal.Deep
    //                     return ExchangeVersion.Exchange2013;
    //                 return ExchangeVersion.Exchange_Version_Not_Updated;
    //             };
    //             break;
    //         case EnumToExchangeVersionMappingHelper.FileAsMapping:
    //             enumDelegate = (value) => {
    //                 if (value <= 12) //<= FileAsMapping.SurnameSpaceGivenName
    //                     return ExchangeVersion.Exchange2007_SP1;
    //                 else if (value >= 13 && value <= 17) // >= DisplayName && <=Empty
    //                     return ExchangeVersion.Exchange2010;
    //                 return ExchangeVersion.Exchange_Version_Not_Updated;
    //             };
    //             break;
    //         case EnumToExchangeVersionMappingHelper.EventType:
    //             enumDelegate = (value) => {
    //                 if (value <= 6) //<= EventType.Created
    //                     return ExchangeVersion.Exchange2007_SP1;
    //                 else if (value == 7) // == FreeBusyChanged
    //                     return ExchangeVersion.Exchange2010_SP1;
    //                 return ExchangeVersion.Exchange_Version_Not_Updated;
    //             };
    //             break;
    //         case EnumToExchangeVersionMappingHelper.MeetingRequestsDeliveryScope:
    //             enumDelegate = (value) => {
    //                 if (value <= 2) //<= MeetingRequestsDeliveryScope.DelegatesAndSendInformationToMe
    //                     return ExchangeVersion.Exchange2007_SP1;
    //                 else if (value == 3) // == NoForward
    //                     return ExchangeVersion.Exchange2010_SP1;
    //                 return ExchangeVersion.Exchange_Version_Not_Updated;
    //             };
    //             break;
    //         case EnumToExchangeVersionMappingHelper.ViewFilter:
    //             enumDelegate = (value) => {
    //                 if (value <= 10) //<=ViewFilter.SuggestionsDelete
    //                     return ExchangeVersion.Exchange2013;
    //                 return ExchangeVersion.Exchange_Version_Not_Updated;
    //             };
    //             break;
    //         case EnumToExchangeVersionMappingHelper.MailboxType:
    //             enumDelegate = (value) => {
    //                 if (value <= 1) //<=MailboxType.OneOff
    //                     return ExchangeVersion.Exchange2010;
    //                 if (value <= 6) //<=MailboxType.Contact
    //                     return ExchangeVersion.Exchange2007_SP1;
    //                 if (value <= 7) //<=MailboxType.GroupMailbox
    //                     return ExchangeVersion.Exchange2015;
    //                 return ExchangeVersion.Exchange_Version_Not_Updated;
    //             };
    //             break;
    //         default:
    //             throw new Error("EwsUtilities.ts - BuildEnumDict - no mapping available for this enumtype" + EnumToExchangeVersionMappingHelper[<number>enumType]);
    //     }
    //     return enumDelegate;
    // }
    /**@internal */
    //deviation - need to work with static data for enum to exchange version dict, there is no Attribute type system in javascript.
    EwsUtilities.BuildEnumToSchemaDict = function (enumType) { throw new Error("EwsUtilities.ts - static BuildEnumToSchemaDict : Not implemented."); };
    /**@internal */
    //deviation - need to work with static data for enum to exchange version dict, there is no Attribute type system in javascript.
    EwsUtilities.BuildSchemaToEnumDict = function (enumType) { throw new Error("EwsUtilities.ts - static BuildSchemaToEnumDict : Not implemented."); };
    EwsUtilities.GetDictionaryKeyTypeEnum = function (dictionaryKeyType) {
        switch (dictionaryKeyType) {
            case DictionaryKeyType.EmailAddressKey:
                return EmailAddressKey;
            case DictionaryKeyType.ImAddressKey:
                return ImAddressKey;
            case DictionaryKeyType.PhoneNumberKey:
                return PhoneNumberKey;
            case DictionaryKeyType.PhysicalAddressKey:
                return PhysicalAddressKey;
            default:
                throw new Error("EwsUtilities.ts - GetDictionaryKeyTypeEnum - invalid value: " + dictionaryKeyType);
        }
    };
    // private static GetExchangeVersionFromEnumDelegate(enumType: EnumToExchangeVersionMappingHelper, enumValue: number): ExchangeVersion {
    //     var delegate = this.enumVersionDictionaries.Member[EnumToExchangeVersionMappingHelper[enumType]];
    //     if (delegate && typeof delegate === 'function') {
    //         try {
    //             return delegate(enumValue);
    //         }
    //         catch (ex) { }
    //     }
    //     return ExchangeVersion.Exchange2007_SP1;
    // }
    EwsUtilities.ConvertTime = function (dateTime, sourceTimeZone, destinationTimeZone) {
        try {
            return TimeZoneInfo.ConvertTime(dateTime, sourceTimeZone, destinationTimeZone);
        }
        catch (ex) {
            throw new TimeZoneConversionException(StringHelper.Format(Strings.CannotConvertBetweenTimeZones, EwsUtilities.DateTimeToXSDateTime(dateTime), sourceTimeZone.DisplayName, destinationTimeZone.DisplayName), ex);
        }
    };
    //static CopyStream(source: System.IO.Stream, target: System.IO.Stream): any{ throw new Error("EwsUtilities.ts - static CopyStream : Not implemented.");}
    EwsUtilities.CountMatchingChars = function (str, charPredicate) { throw new Error("EwsUtilities.ts - static CountMatchingChars : Not implemented."); };
    EwsUtilities.CreateEwsObjectFromXmlElementName = function (service, xmlElementName) {
        throw new Error("EwsUtilities - CreateEwsObjectFromXmlElementName: - this is moved in folderinfo/iteminfo classes to avoid circular loop caused by serviceobjectinfo class");
        //     //var itemClass = TypeSystem.GetObjectByClassName("Microsoft.Exchange.WebServices.Data." + xmlElementName
        //     debugger;
        //     //        var creationDelegate = EwsUtilities.serviceObjectInfo.Member.ServiceObjectConstructorsWithServiceParam[xmlElementName];
        //     //
        //     //        if (creationDelegate) {
        //     //            return creationDelegate(service);
        //     //        }
        //     //        else return null;
        //     //var itemClass = EwsUtilities.serviceObjectInfo.Member.XmlElementNameToServiceObjectClassMap[xmlElementName];
        //     //if (itemClass) {
        //     //    //return new itemClass(service);
        //     //    creationDelegate: CreateServiceObjectWithServiceParam;
        //     //    //if (EwsUtilities.serviceObjectInfo.Member.ServiceObjectConstructorsWithServiceParam.TryGetValue(itemClass, out creationDelegate)) {
        //     //    //    return (TServiceObject)creationDelegate(service);
        //     //    //}
        //     //    //else {
        //     //    //    throw new ArgumentException(Strings.NoAppropriateConstructorForItemClass);
        //     //    //}
        //     //}
        //     //else {
        //     //    return null; //default(TServiceObject);
        //     //}
    };
    //static CreateItemFromItemClass(itemAttachment: ItemAttachment, itemClass: System.Type, isNew: boolean): Item{ throw new Error("EwsUtilities.ts - static CreateItemFromItemClass : Not implemented.");}
    EwsUtilities.CreateItemFromXmlElementName = function (itemAttachment, xmlElementName) { throw new Error("EwsUtilities.ts - static CreateItemFromXmlElementName : Not implemented."); };
    EwsUtilities.DateTimeToXSDate = function (date) { return DateTime.DateTimeToXSDate(date); };
    EwsUtilities.DateTimeToXSDateTime = function (dateTime) { return DateTime.DateTimeToXSDateTime(dateTime); };
    EwsUtilities.DomainFromEmailAddress = function (emailAddress) {
        var emailAddressParts = emailAddress.split('@');
        if (emailAddressParts.length != 2 || StringHelper.IsNullOrEmpty(emailAddressParts[1])) {
            throw new Error(Strings.InvalidEmailAddress);
        }
        return emailAddressParts[1];
    };
    EwsUtilities.EwsToSystemDayOfWeek = function (dayOfTheWeek) {
        if (dayOfTheWeek == DayOfTheWeek.Day ||
            dayOfTheWeek == DayOfTheWeek.Weekday ||
            dayOfTheWeek == DayOfTheWeek.WeekendDay) {
            throw new ArgumentException(StringHelper.Format("Cannot convert {0} to System.DayOfWeek enum value", dayOfTheWeek), "dayOfTheWeek");
        }
        else {
            return dayOfTheWeek;
        }
    };
    EwsUtilities.FindFirstItemOfType = function (items, type) {
        for (var _a = 0, items_2 = items; _a < items_2.length; _a++) {
            var item = items_2[_a];
            if (item instanceof type) {
                return item;
            }
        }
    };
    //static ForEach(collection: System.Collections.Generic.IEnumerable<T>, action: any): any{ throw new Error("EwsUtilities.ts - static ForEach : Not implemented.");}
    //static FormatHttpHeaders(headers: System.Net.WebHeaderCollection): string{ throw new Error("EwsUtilities.ts - static FormatHttpHeaders : Not implemented.");}
    //static FormatHttpHeaders(sb: any, headers: System.Net.WebHeaderCollection): any{ throw new Error("EwsUtilities.ts - static FormatHttpHeaders : Not implemented.");}
    //static FormatHttpRequestHeaders(request: IEwsHttpWebRequest): string{ throw new Error("EwsUtilities.ts - static FormatHttpRequestHeaders : Not implemented.");}
    //static FormatHttpRequestHeaders(request: any): string{ throw new Error("EwsUtilities.ts - static FormatHttpRequestHeaders : Not implemented.");}
    EwsUtilities.FormatHttpResponseHeaders = function (response /*IEwsHttpWebResponse*/) { throw new Error("EwsUtilities.ts - static FormatHttpResponseHeaders : Not implemented."); };
    EwsUtilities.FormatLogMessage = function (entryKind, logEntry) { throw new Error("EwsUtilities.ts - static FormatLogMessage : Not implemented."); };
    EwsUtilities.FormatLogMessageWithXmlContent = function (entryKind, memoryStream) { throw new Error("EwsUtilities.ts - static FormatLogMessageWithXmlContent : Not implemented."); };
    EwsUtilities.GetEnumeratedObjectAt = function (objects, index) { throw new Error("EwsUtilities.ts - static GetEnumeratedObjectAt : Not implemented."); };
    EwsUtilities.GetEnumeratedObjectCount = function (objects) { throw new Error("EwsUtilities.ts - static GetEnumeratedObjectCount : Not implemented."); };
    //static GetEnumSchemaName(enumType: System.Type, enumName: string): string{ throw new Error("EwsUtilities.ts - static GetEnumSchemaName : Not implemented.");}
    //static GetEnumVersion(enumType: System.Type, enumName: string): ExchangeVersion{ throw new Error("EwsUtilities.ts - static GetEnumVersion : Not implemented.");}
    //static GetItemTypeFromXmlElementName(xmlElementName: string): System.Type{ throw new Error("EwsUtilities.ts - static GetItemTypeFromXmlElementName : Not implemented.");}
    EwsUtilities.GetNamespaceFromUri = function (namespaceUri) {
        switch (namespaceUri) {
            case this.EwsErrorsNamespace:
                return XmlNamespace.Errors;
            case this.EwsTypesNamespace:
                return XmlNamespace.Types;
            case this.EwsMessagesNamespace:
                return XmlNamespace.Messages;
            case this.EwsSoapNamespace:
                return XmlNamespace.Soap;
            case this.EwsSoap12Namespace:
                return XmlNamespace.Soap12;
            case this.EwsXmlSchemaInstanceNamespace:
                return XmlNamespace.XmlSchemaInstance;
            case this.PassportSoapFaultNamespace:
                return XmlNamespace.PassportSoapFault;
            case this.WSTrustFebruary2005Namespace:
                return XmlNamespace.WSTrustFebruary2005;
            case this.WSAddressingNamespace:
                return XmlNamespace.WSAddressing;
            default:
                return XmlNamespace.NotSpecified;
        }
    };
    EwsUtilities.GetNamespacePrefix = function (xmlNamespace) {
        switch (xmlNamespace) {
            case XmlNamespace.Types:
                return EwsUtilities.EwsTypesNamespacePrefix;
            case XmlNamespace.Messages:
                return EwsUtilities.EwsMessagesNamespacePrefix;
            case XmlNamespace.Errors:
                return EwsUtilities.EwsErrorsNamespacePrefix;
            case XmlNamespace.Soap:
            case XmlNamespace.Soap12:
                return EwsUtilities.EwsSoapNamespacePrefix;
            case XmlNamespace.XmlSchemaInstance:
                return EwsUtilities.EwsXmlSchemaInstanceNamespacePrefix;
            case XmlNamespace.PassportSoapFault:
                return EwsUtilities.PassportSoapFaultNamespacePrefix;
            case XmlNamespace.WSTrustFebruary2005:
                return EwsUtilities.WSTrustFebruary2005NamespacePrefix;
            case XmlNamespace.WSAddressing:
                return EwsUtilities.WSAddressingNamespacePrefix;
            case XmlNamespace.Autodiscover:
                return EwsUtilities.AutodiscoverSoapNamespacePrefix;
            default:
                return "";
        }
    };
    EwsUtilities.GetNamespaceUri = function (xmlNamespace) {
        switch (xmlNamespace) {
            case XmlNamespace.Types:
                return EwsUtilities.EwsTypesNamespace;
            case XmlNamespace.Messages:
                return EwsUtilities.EwsMessagesNamespace;
            case XmlNamespace.Errors:
                return EwsUtilities.EwsErrorsNamespace;
            case XmlNamespace.Soap:
                return EwsUtilities.EwsSoapNamespace;
            case XmlNamespace.Soap12:
                return EwsUtilities.EwsSoap12Namespace;
            case XmlNamespace.XmlSchemaInstance:
                return EwsUtilities.EwsXmlSchemaInstanceNamespace;
            case XmlNamespace.PassportSoapFault:
                return EwsUtilities.PassportSoapFaultNamespace;
            case XmlNamespace.WSTrustFebruary2005:
                return EwsUtilities.WSTrustFebruary2005Namespace;
            case XmlNamespace.WSAddressing:
                return EwsUtilities.WSAddressingNamespace;
            case XmlNamespace.Autodiscover:
                return EwsUtilities.AutodiscoverSoapNamespace;
            default:
                return "";
        }
    };
    EwsUtilities.GetPrintableTypeName = function (type /*instance */) {
        var typename = typeof type;
        if (typename.indexOf("object") >= 0) {
            try {
                typename = type.__proto__.constructor.name;
            }
            catch (error) {
                typename += " - Error getting name";
            }
        }
        return typename;
        //         if (type.IsGenericType)
        //             {
        //                 // Convert generic type to printable form (e.g. List<Item>)
        //                 string genericPrefix = type.Name.Substring(0, type.Name.IndexOf('`'));
        //                 StringBuilder nameBuilder = new StringBuilder(genericPrefix);
        // 
        //                 // Note: building array of generic parameters is done recursively. Each parameter could be any type.
        //                 string[] genericArgs = type.GetGenericArguments().ToList<Type>().ConvertAll<string>(t => GetPrintableTypeName(t)).ToArray<string>();
        // 
        //                 nameBuilder.Append("<");
        //                 nameBuilder.Append(string.Join(",", genericArgs));
        //                 nameBuilder.Append(">");
        //                 return nameBuilder.ToString();
        //             }
        //             else if (type.IsArray)
        //             {
        //                 // Convert array type to printable form.
        //                 string arrayPrefix = type.Name.Substring(0, type.Name.IndexOf('['));
        //                 StringBuilder nameBuilder = new StringBuilder(EwsUtilities.GetSimplifiedTypeName(arrayPrefix));
        //                 for (int rank = 0; rank < type.GetArrayRank(); rank++)
        //                 {
        //                     nameBuilder.Append("[]");
        //                 }
        //                 return nameBuilder.ToString();
        //             }
        //             else
        //             {
        //                 return EwsUtilities.GetSimplifiedTypeName(type.Name);
        //             }
    };
    //static GetSimplifiedTypeName(typeName: string): string{ throw new Error("EwsUtilities.ts - static GetSimplifiedTypeName : Not implemented.");}
    EwsUtilities.IsLocalTimeZone = function (timeZone) {
        return (TimeZoneInfo.Local == timeZone) || (TimeZoneInfo.Local.Id == timeZone.Id && TimeZoneInfo.Local.HasSameRules(timeZone));
    };
    //static Parse(value: string): any{ throw new Error("EwsUtilities.ts - static Parse : Not implemented.");}
    EwsUtilities.ParseEnum = function (value, ewsenum) { throw new Error("EwsUtilities.ts - static Parse : Not implemented."); };
    EwsUtilities.ParseAsUnbiasedDatetimescopedToServicetimeZone = function (dateString, service) {
        // Convert the element's value to a DateTime with no adjustment.
        //var tempDate: DateTime = DateTime.Parse(dateString + "Z");
        // Set the kind according to the service's time zone
        if (service.TimeZone == TimeZoneInfo.Utc) {
            return DateTime.Parse(dateString, DateTimeKind.Utc);
        }
        else if (EwsUtilities.IsLocalTimeZone(service.TimeZone)) {
            return DateTime.Parse(dateString, DateTimeKind.Local);
        }
        else {
            return DateTime.DateimeStringToTimeZone(dateString, service.TimeZone.IanaId);
            //return DateTime.Parse(dateString, DateTimeKind.Unspecified);
        }
    };
    EwsUtilities.ParseEnumValueList = function (list, value, separators, enumType) {
        // EwsLogging.Assert(
        //         typeof(T).IsEnum,
        //         "EwsUtilities.ParseEnumValueList",
        //         "T is not an enum type.");
        var enumValues = value.split(separators);
        for (var _a = 0, enumValues_1 = enumValues; _a < enumValues_1.length; _a++) {
            var enumValue = enumValues_1[_a];
            var enumValueParsed = enumType[enumValue];
            if (typeof enumValueParsed !== 'undefined')
                list.push(enumValueParsed);
        }
    };
    //static SerializeEnum(value: any): string{ throw new Error("EwsUtilities.ts - static SerializeEnum : Not implemented.");}
    EwsUtilities.SystemToEwsDayOfTheWeek = function (dayOfWeek) {
        return dayOfWeek;
    };
    EwsUtilities.TimeSpanToXSDuration = function (timeSpan) {
        // Optional '-' offset
        var offsetStr = (timeSpan.TotalSeconds < 0) ? "-" : StringHelper.Empty;
        // The TimeSpan structure does not have a Year or Month 
        // property, therefore we wouldn't be able to return an xs:duration
        // string from a TimeSpan that included the nY or nM components.
        return StringHelper.Format("{0}P{1}DT{2}H{3}M{4}S", offsetStr, Math.abs(timeSpan.Days), Math.abs(timeSpan.Hours), Math.abs(timeSpan.Minutes), Math.abs(timeSpan.Seconds) + "." + Math.abs(timeSpan.Milliseconds));
    };
    EwsUtilities.numPad = function (num, length) {
        var str = num.toString();
        while (str.length < length)
            str = "0" + str;
        return str;
    };
    EwsUtilities.TimeSpanToXSTime = function (timeSpan) {
        return StringHelper.Format("{0}:{1}:{2}", this.numPad(timeSpan.Hours, 2), this.numPad(timeSpan.Minutes, 2), this.numPad(timeSpan.Seconds, 2));
    };
    EwsUtilities.XSDurationToTimeSpan = function (xsDuration) {
        var regex = /(-)?P(([0-9]+)Y)?(([0-9]+)M)?(([0-9]+)D)?(T(([0-9]+)H)?(([0-9]+)M)?(([0-9]+)(\.([0-9]+))?S)?)?/; //ref: info: not using \\, may be a bug in EWS managed api. does not match "-P2Y6M5DT12H35M30.4S" with \\ //old /(-)?P([0-9]+)Y?([0-9]+)M?([0-9]+)D?T([0-9]+)H?([0-9]+)M?([0-9]+\.[0-9]+)?S?/;
        if (xsDuration.match(regex) === null) {
            throw new ArgumentException(Strings.XsDurationCouldNotBeParsed);
        }
        return new TimeSpan(xsDuration); //using moment, it recognize the format.
    };
    //static TrueForAll(collection: System.Collections.Generic.IEnumerable<T>, predicate: any): boolean{ throw new Error("EwsUtilities.ts - static TrueForAll : Not implemented.");}
    EwsUtilities.ValidateClassVersion = function (service, minimumServerVersion, className) {
        if (service.RequestedServerVersion < minimumServerVersion) {
            throw new ServiceVersionException(StringHelper.Format(Strings.ClassIncompatibleWithRequestVersion, className, ExchangeVersion[minimumServerVersion]));
        }
    };
    EwsUtilities.ValidateDomainNameAllowNull = function (domainName, paramName) {
        //todo: validate domain names per ews managed api
        //if (domainName != null) {
        //    Regex regex = new Regex(DomainRegex);
        //    if (!regex.IsMatch(domainName)) {
        //        throw new ArgumentException(string.Format(Strings.InvalidDomainName, domainName), paramName);
        //    }
        //}
    };
    /**
     * Validates the enum value against the request version.
     *
     * @param   {RequiredServerVersionEnums}   enumType        one of Enum type which has RequiredServerVersionAttrubute
     * @param   {number}            enumValue        The enum value.
     * @param   {ExchangeVersion}   requestVersion   The request version.
     * @param   {string}            name   The request version.
     */
    EwsUtilities.ValidateEnumVersionValue = function (enumType, enumValue, requestVersion, name) {
        //default is 2007_SP1
        var enumVersion = ExchangeVersion.Exchange2007_SP1;
        //if it has RequiredServerVersionAttrubute (ews-javascript-api, those enums has static function named 'RequiredServerVersion' )
        if (TypeGuards.hasRequiredServerVersionAttribute(enumType)) {
            enumVersion = enumType.RequiredServerVersion(enumValue);
        }
        if (requestVersion < enumVersion) {
            throw new ServiceVersionException(StringHelper.Format(Strings.EnumValueIncompatibleWithRequestVersion, enumType[enumValue], name, ExchangeVersion[enumVersion]));
        }
    };
    EwsUtilities.ValidateMethodVersion = function (service, minimumServerVersion, methodName) {
        if (service.RequestedServerVersion < minimumServerVersion) {
            throw new ServiceVersionException(StringHelper.Format(Strings.MethodIncompatibleWithRequestVersion, methodName, ExchangeVersion[minimumServerVersion]));
        }
    };
    /**
     * Validates string parameter to be non-empty string (null value not allowed).
     *
     * @param   {string}   param       The string parameter.
     * @param   {string}   paramName   Name of the parameter.
     */
    EwsUtilities.ValidateNonBlankStringParam = function (param, paramName) {
        if (param == null) {
            throw new ArgumentNullException(paramName);
        }
        this.ValidateNonBlankStringParamAllowNull(param, paramName);
    };
    /**
     * Validates string parameter to be non-empty string (null value allowed).
     *
     * @param   {string}   param       The string parameter.
     * @param   {string}   paramName   Name of the parameter.
     */
    EwsUtilities.ValidateNonBlankStringParamAllowNull = function (param, paramName) {
        if (param) {
            // Non-empty string has at least one character which is *not* a whitespace character
            if (param.replace(/\s*/g, '').length === 0) {
                throw new ArgumentException(Strings.ArgumentIsBlankString, paramName);
            }
        }
    };
    /**
     * Validates parameter (null value not allowed).
     *
     * @param   {any}       param       The param.
     * @param   {string}    paramName   Name of the param.
     */
    EwsUtilities.ValidateParam = function (param, paramName) {
        var isValid = false;
        if (typeof (param) == "string") {
            isValid = !StringHelper.IsNullOrEmpty(param);
        }
        else {
            isValid = param != null && typeof (param) !== 'undefined';
        }
        if (!isValid) {
            throw new ArgumentNullException(paramName);
        }
        this.ValidateParamAllowNull(param, paramName);
    };
    /**
     * Validates parameter (and allows null value).
     *
     * @param   {any}       param       The param.
     * @param   {string}    paramName   Name of the param.
     */
    EwsUtilities.ValidateParamAllowNull = function (param, paramName) {
        var selfValidate = param;
        // look for null/undefined
        if (TypeGuards.isISelfValidate(selfValidate)) {
            try {
                selfValidate.Validate();
            }
            catch (e) {
                throw new ArgumentException(Strings.ValidationFailed, paramName, e);
            }
        }
        var ewsObject = param;
        if (ewsObject instanceof TypeContainer.ServiceObject) {
            if (ewsObject.IsNew) {
                throw new ArgumentException(Strings.ObjectDoesNotHaveId, paramName);
            }
        }
    };
    /**
     * Validates parameter collection.
     *
     * @param   {any[]}     collection   The collection.
     * @param   {string}    paramName    Name of the param.
     */
    EwsUtilities.ValidateParamCollection = function (collection, paramName) {
        this.ValidateParam(collection, paramName);
        var count = 0;
        for (var _a = 0, collection_5 = collection; _a < collection_5.length; _a++) {
            var obj = collection_5[_a];
            try {
                this.ValidateParam(obj, StringHelper.Format("collection[{0}]", count));
            }
            catch (e) {
                throw new ArgumentException(StringHelper.Format("The element at position {0} is invalid", count), paramName, e);
            }
            count++;
        }
        if (count == 0) {
            throw new ArgumentException(Strings.CollectionIsEmpty, paramName);
        }
    };
    /**
     * Validates property version against the request version.
     *
     * @param   {ExchangeService}   service                The Exchange service.
     * @param   {ExchangeVersion}   minimumServerVersion   The minimum server version that supports the property.
     * @param   {string}            propertyName           Name of the property.
     */
    EwsUtilities.ValidatePropertyVersion = function (service, minimumServerVersion, propertyName) {
        if (service.RequestedServerVersion < minimumServerVersion) {
            throw new ServiceVersionException(StringHelper.Format(Strings.PropertyIncompatibleWithRequestVersion, propertyName, ExchangeVersion[minimumServerVersion]));
        }
    };
    EwsUtilities.ValidateServiceObjectVersion = function (serviceObject, requestVersion) { throw new Error("EwsUtilities.ts - static ValidateServiceObjectVersion : Not implemented."); };
    //#region constants in c# - typescript static
    EwsUtilities.XSFalse = "false";
    EwsUtilities.XSTrue = "true";
    EwsUtilities.EwsTypesNamespacePrefix = "t";
    EwsUtilities.EwsMessagesNamespacePrefix = "m";
    EwsUtilities.EwsErrorsNamespacePrefix = "e";
    EwsUtilities.EwsSoapNamespacePrefix = "soap";
    EwsUtilities.EwsXmlSchemaInstanceNamespacePrefix = "xsi";
    EwsUtilities.PassportSoapFaultNamespacePrefix = "psf";
    EwsUtilities.WSTrustFebruary2005NamespacePrefix = "wst";
    EwsUtilities.WSAddressingNamespacePrefix = "wsa";
    EwsUtilities.AutodiscoverSoapNamespacePrefix = "a";
    EwsUtilities.WSSecurityUtilityNamespacePrefix = "wsu";
    EwsUtilities.WSSecuritySecExtNamespacePrefix = "wsse";
    EwsUtilities.EwsTypesNamespace = "http://schemas.microsoft.com/exchange/services/2006/types";
    EwsUtilities.EwsMessagesNamespace = "http://schemas.microsoft.com/exchange/services/2006/messages";
    EwsUtilities.EwsErrorsNamespace = "http://schemas.microsoft.com/exchange/services/2006/errors";
    EwsUtilities.EwsSoapNamespace = "http://schemas.xmlsoap.org/soap/envelope/";
    EwsUtilities.EwsSoap12Namespace = "http://www.w3.org/2003/05/soap-envelope";
    EwsUtilities.EwsXmlSchemaInstanceNamespace = "http://www.w3.org/2001/XMLSchema-instance";
    EwsUtilities.PassportSoapFaultNamespace = "http://schemas.microsoft.com/Passport/SoapServices/SOAPFault";
    EwsUtilities.WSTrustFebruary2005Namespace = "http://schemas.xmlsoap.org/ws/2005/02/trust";
    EwsUtilities.WSAddressingNamespace = "http://www.w3.org/2005/08/addressing";
    EwsUtilities.AutodiscoverSoapNamespace = "http://schemas.microsoft.com/exchange/2010/Autodiscover";
    EwsUtilities.WSSecurityUtilityNamespace = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd";
    EwsUtilities.WSSecuritySecExtNamespace = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd";
    /// <summary>
    /// Regular expression for legal domain names.
    /// </summary>
    EwsUtilities.DomainRegex = "^[-a-zA-Z0-9_.]+$";
    return EwsUtilities;
}());
exports.EwsUtilities = EwsUtilities;
// todo: should be done
var ExchangeServerInfo = (function () {
    function ExchangeServerInfo() {
    }
    //private majorVersion: number;
    //private minorVersion: number;
    //private majorBuildNumber: number;
    //private minorBuildNumber: number;
    //private versionString: string;
    ExchangeServerInfo.Parse = function (jsObject /*JsonObject*/) {
        var exchangeServerInfo = new ExchangeServerInfo();
        exchangeServerInfo.MajorVersion = Convert.toInt(jsObject["MajorVersion"]);
        exchangeServerInfo.MinorVersion = Convert.toInt(jsObject["MinorVersion"]);
        exchangeServerInfo.MajorBuildNumber = Convert.toInt(jsObject["MajorBuildNumber"]);
        exchangeServerInfo.MinorBuildNumber = Convert.toInt(jsObject["MinorBuildNumber"]);
        exchangeServerInfo.VersionString = jsObject["Version"];
        return exchangeServerInfo;
    };
    //    static Parse(reader: EwsServiceXmlReader): ExchangeServerInfo {
    //        EwsLogging.Assert(
    //            reader.HasAttributes,
    //            "ExchangeServerVersion.Parse",
    //            "Current element doesn't have attributes");
    //
    //        var info = new ExchangeServerInfo();
    //        info.MajorVersion = +(reader.ReadAttributeValue(XmlNamespace.Types, "MajorVersion"));
    //        info.MinorVersion = +(reader.ReadAttributeValue(XmlNamespace.Types, "MinorVersion"));
    //        info.MajorBuildNumber = +(reader.ReadAttributeValue(XmlNamespace.Types, "MajorBuildNumber"));
    //        info.MinorBuildNumber = +(reader.ReadAttributeValue(XmlNamespace.Types, "MinorBuildNumber"));
    //        info.VersionString = reader.ReadAttributeValue(XmlNamespace.Types, "Version");
    //        return info;
    //    }
    ExchangeServerInfo.prototype.ToString = function () {
        //return string.Format("{0:d}.{1:d2}.{2:d4}.{3:d3}",
        return StringHelper.Format("{0}.{1}.{2}.{3}", this.MajorVersion, this.MinorVersion, this.MajorBuildNumber, this.MinorBuildNumber);
    };
    return ExchangeServerInfo;
}());
exports.ExchangeServerInfo = ExchangeServerInfo;
var ExchangeServiceBase = (function () {
    function ExchangeServiceBase(versionServiceorTZ, versionOrTZ) {
        this.requestedServerVersion = ExchangeVersion.Exchange2013_SP1;
        this.timeZone = TimeZoneInfo.Local;
        this.xhrApi = null;
        var argsLength = arguments.length;
        if (argsLength > 2) {
            throw new Error("ExchangeServiceBase.ts - ctor with " + argsLength + " parameters, invalid number of arguments, check documentation and try again.");
        }
        var timeZone = null;
        var requestedServerVersion = ExchangeVersion.Exchange2013_SP1;
        var service = null;
        if (argsLength >= 1) {
            if (versionServiceorTZ instanceof TimeZoneInfo) {
                timeZone = versionServiceorTZ;
            }
            else if (versionServiceorTZ instanceof ExchangeServiceBase) {
                service = versionServiceorTZ;
            }
            else if (typeof versionServiceorTZ === 'number') {
                requestedServerVersion = versionServiceorTZ;
            }
        }
        if (argsLength == 2) {
            if (versionOrTZ instanceof TimeZoneInfo) {
                if (typeof versionServiceorTZ !== 'number') {
                    throw new Error("ExchangeServiceBase.ts - ctor with " + argsLength + " parameters - incorrect uses of parameter at 1st position, it must be ExchangeVersion when using TimeZoneInfo at 2nd place");
                }
                timeZone = versionOrTZ;
            }
            else if (typeof versionOrTZ === 'number') {
                if (!(versionServiceorTZ instanceof ExchangeServiceBase)) {
                    throw new Error("ExchangeServiceBase.ts - ctor with " + argsLength + " parameters - incorrect uses of parameter at 1st position, it must be ExchangeServiceBase when using ExchangeVersion at 2nd place");
                }
                requestedServerVersion = versionOrTZ;
            }
        }
        this.requestedServerVersion = requestedServerVersion;
        if (service !== null && typeof service !== 'undefined') {
            this.useDefaultCredentials = service.useDefaultCredentials;
            this.credentials = service.credentials;
            this.traceEnabled = service.traceEnabled;
            this.traceListener = service.traceListener;
            this.traceFlags = service.traceFlags;
            this.timeout = service.timeout;
            this.preAuthenticate = service.preAuthenticate;
            this.userAgent = service.userAgent;
            //this.acceptGzipEncoding = service.acceptGzipEncoding;
            this.keepAlive = service.keepAlive;
            this.connectionGroupName = service.connectionGroupName;
            this.timeZone = service.timeZone;
            this.httpHeaders = service.httpHeaders;
            this.ewsHttpWebRequestFactory = service.ewsHttpWebRequestFactory;
        }
        if (timeZone !== null && typeof timeZone !== 'undefined') {
            this.timeZone = timeZone;
            //this.useDefaultCredentials = true; //ref: no default credential in node.js
        }
    }
    Object.defineProperty(ExchangeServiceBase.prototype, "RequestedServerVersion", {
        get: function () { return this.requestedServerVersion; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExchangeServiceBase.prototype, "TimeZone", {
        get: function () {
            return this.timeZone;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExchangeServiceBase.prototype, "TimeZoneDefinition", {
        /**@internal */
        get: function () {
            if (this.timeZoneDefinition == null) {
                this.timeZoneDefinition = new TimeZoneDefinition(this.TimeZone);
            }
            return this.timeZoneDefinition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExchangeServiceBase.prototype, "XHRApi", {
        get: function () {
            return this.xhrApi || XHRFactory.XHRApi;
        },
        set: function (xhrApi) {
            this.xhrApi = xhrApi || XHRFactory.XHRApi;
        },
        enumerable: true,
        configurable: true
    });
    ExchangeServiceBase.prototype.ConvertDateTimeToUniversalDateTimeString = function (value) {
        var dateTime;
        switch (value.Kind) {
            case DateTimeKind.Unspecified:
                dateTime = EwsUtilities.ConvertTime(value, this.TimeZone, TimeZoneInfo.Utc);
                break;
            case DateTimeKind.Local:
                dateTime = EwsUtilities.ConvertTime(value, TimeZoneInfo.Local, TimeZoneInfo.Utc);
                break;
            default:
                // The date is already in UTC, no need to convert it.
                dateTime = value;
                break;
        }
        //debug://todo:iso string should work
        return dateTime.ToISOString(); // ISO string should work .ToString("yyyy-MM-ddTHH:mm:ss.fffZ", CultureInfo.InvariantCulture);
    };
    ExchangeServiceBase.prototype.ConvertStartDateToUnspecifiedDateTime = function (value) {
        //EwsLogging.Log("ExchangeServiceBase.ConvConvertStartDateToUnspecifiedDateTime : DateTimeOffset not implemented, check date values")
        value = value.substring(0, 10); //info: //ref: for DateTimeOffset substitution, this is being called only from recurring datetime StartDate and 
        if (StringHelper.IsNullOrEmpty(value)) {
            return null;
        }
        else {
            return DateTime.Parse(value);
            //let dateTimeOffset:DateTimeOffset = DateTimeOffset.Parse(value, CultureInfo.InvariantCulture);
            // Return only the date part with the kind==Unspecified.
            //return dateTimeOffset.Date;
        }
    };
    ExchangeServiceBase.prototype.ConvertUniversalDateTimeStringToLocalDateTime = function (value) {
        if (StringHelper.IsNullOrEmpty(value)) {
            return null;
        }
        else {
            // Assume an unbiased date/time is in UTC. Convert to UTC otherwise.
            //ref: //fix: hard convert to UTC date as no request contains TZ information.
            if (value.toLowerCase().indexOf("z") < 0)
                value += "Z";
            var dateTime = DateTime.Parse(value);
            // CultureInfo.InvariantCulture,
            // DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal);
            if (this.TimeZone == TimeZoneInfo.Utc) {
                // This returns a DateTime with Kind.Utc
                return dateTime;
            }
            else {
                var localTime = EwsUtilities.ConvertTime(dateTime, TimeZoneInfo.Utc, this.TimeZone);
                if (EwsUtilities.IsLocalTimeZone(this.TimeZone)) {
                    // This returns a DateTime with Kind.Local
                    return new DateTime(localTime.TotalMilliSeconds, DateTimeKind.Local);
                }
                else {
                    // This returns a DateTime with Kind.Unspecified
                    return localTime;
                }
            }
        }
    };
    ExchangeServiceBase.prototype.DoOnSerializeCustomSoapHeaders = function (writer /*System.Xml.XmlWriter*/) {
        EwsLogging.Assert(writer != null, "ExchangeServiceBase.DoOnSerializeCustomSoapHeaders", "writer is null");
        if (this.OnSerializeCustomSoapHeaders != null) {
            this.OnSerializeCustomSoapHeaders(writer);
        }
    };
    /**
     * @internal Processes an HTTP error response
     *
     * /remarks/    This method doesn't handle 500 ISE errors. This is handled by the caller since 500 ISE typically indicates that a SOAP fault has occurred and the handling of a SOAP fault is currently service specific.
     * @param   {XMLHttpRequest}    httpWebResponse            The HTTP web response.
     * @param   {SoapFaultDetails}  webException               The web exception.
     * @param   {TraceFlags}        responseHeadersTraceFlag   The trace flag for response headers.
     * @param   {TraceFlags}        responseTraceFlag          The trace flag for responses.
     *
     */
    ExchangeServiceBase.prototype.InternalProcessHttpErrorResponse = function (httpWebResponse, soapFault, responseHeadersTraceFlag, responseTraceFlag) {
        EwsLogging.Assert(httpWebResponse.status != 500, // HttpStatusCode.InternalServerError,
        "ExchangeServiceBase.InternalProcessHttpErrorResponse", "InternalProcessHttpErrorResponse does not handle 500 ISE errors, the caller is supposed to handle this.");
        this.ProcessHttpResponseHeaders(responseHeadersTraceFlag, httpWebResponse);
        var exception = null;
        // Deal with new HTTP error code indicating that account is locked.
        // The "unlock" URL is returned as the status description in the response.
        if (httpWebResponse.status == ExchangeServiceBase.AccountIsLocked) {
            EwsLogging.Assert(false, "ExchangeServiceBase.InternalProcessHttpErrorResponse", "Please report back to ews-javascript-api with example or response XML for future improvements of this code.");
            var location_1 = httpWebResponse.getResponseHeader("StatusDescription");
            var accountUnlockUrl = null;
            //if (Uri.IsWellFormedUriString(location, UriKind.Absolute)) {
            if (Uri.ParseString(location_1).authority) {
                accountUnlockUrl = new Uri(location_1);
            }
            this.TraceMessage(responseTraceFlag, StringHelper.Format("Account is locked. Unlock URL is {0}", accountUnlockUrl.ToString()));
            exception = new AccountIsLockedException(StringHelper.Format(Strings.AccountIsLocked, accountUnlockUrl), accountUnlockUrl, null);
        }
        else if (httpWebResponse.status === 401 /*Unauthorized*/) {
            exception = new ServiceRequestUnauthorizedException("401 Unauthorized");
        }
        if (exception) {
            if (soapFault !== null) {
                soapFault.Exception = exception;
                if (StringHelper.IsNullOrEmpty(soapFault.message) && !StringHelper.IsNullOrEmpty(exception.message)) {
                    soapFault.message = exception.message;
                }
            }
            else {
                throw exception;
            }
        }
    };
    ExchangeServiceBase.prototype.IsTraceEnabledFor = function (traceFlags) { return this.TraceEnabled && ((this.TraceFlags & traceFlags) != 0); };
    ExchangeServiceBase.prototype.PrepareHttpWebRequestForUrl = function (url, acceptGzipEncoding, allowAutoRedirect) {
        // Verify that the protocol is something that we can handle
        if ((url.Scheme != Uri.UriSchemeHttp) && (url.Scheme != Uri.UriSchemeHttps)) {
            throw new ServiceLocalException("unsupported web protocol" + url); //string.Format(Strings.UnsupportedWebProtocol, url.Scheme));
        }
        var request = { url: url.ToString() };
        request.headers = {};
        //request.PreAuthenticate = this.PreAuthenticate;
        //request.Timeout = this.Timeout; //todo: implement this within IPromise
        this.SetContentType(request);
        request.type = "POST";
        //request.headers["User-Agent"] = this.UserAgent || ExchangeServiceBase.defaultUserAgent; //todo:fix -> Noje.js is refusing to set this unsafe header -//
        //request.AllowAutoRedirect = allowAutoRedirect;
        //todo: figure out next 3 lines
        //request.CookieContainer = this.CookieContainer;
        //request.KeepAlive = this.keepAlive;
        //request.ConnectionGroupName = this.connectionGroupName;
        if (acceptGzipEncoding) {
            request.headers["Accept-Encoding"] = "gzip,deflate";
        }
        if (!StringHelper.IsNullOrEmpty(this.clientRequestId)) {
            request.headers["client-request-id"] = this.clientRequestId;
            if (this.returnClientRequestId) {
                request.headers["return-client-request-id"] = "true";
            }
        }
        //if (this.webProxy != null) {
        //    request.Proxy = this.webProxy;
        //}
        if (this.HttpHeaders) {
            for (var kv in this.HttpHeaders) {
                request.headers[kv] = this.HttpHeaders[kv];
            }
        }
        //request.UseDefaultCredentials = this.UseDefaultCredentials;
        if (!this.UseDefaultCredentials) {
            var serviceCredentials = this.Credentials;
            if (serviceCredentials == null) {
                throw new ServiceLocalException(Strings.CredentialsRequired);
            }
            // Make sure that credentials have been authenticated if required
            //serviceCredentials.PreAuthenticate(); //todo: fix preauthenticate if possible
            // Apply credentials to the request
            serviceCredentials.PrepareWebRequest(request);
        }
        else
            debugger;
        this.httpResponseHeaders = {};
        return request;
    };
    ExchangeServiceBase.prototype.ProcessHttpErrorResponse = function (httpWebResponse /*IEwsHttpWebResponse*/, webException) { throw new Error("ExchangeServiceBase.ts - ProcessHttpErrorResponse : Not implemented."); };
    ExchangeServiceBase.prototype.ProcessHttpResponseHeaders = function (traceType, response) {
        return;
        //todo: implement tracing
        this.TraceHttpResponseHeaders(traceType, response);
        this.SaveHttpResponseHeaders(response.Headers);
    };
    ExchangeServiceBase.prototype.SaveHttpResponseHeaders = function (headers /* System.Net.WebHeaderCollection*/) {
        //debug:
        this.httpResponseHeaders = {};
        for (var key in headers.headers) {
            this.httpResponseHeaders[key] = headers.headers[key];
        }
        if (this.OnResponseHeadersCaptured != null) {
            this.OnResponseHeadersCaptured(headers);
        }
    };
    ExchangeServiceBase.prototype.SetContentType = function (request /*IEwsHttpWebRequest*/) {
        request.headers["Content-Type"] = "text/xml; charset=utf-8";
        request.headers["Accept"] = "text/xml";
    };
    ExchangeServiceBase.prototype.SetCustomUserAgent = function (userAgent) { };
    ExchangeServiceBase.prototype.TraceHttpRequestHeaders = function (traceType, request) { throw new Error("ExchangeServiceBase.ts - TraceHttpRequestHeaders : Not implemented."); };
    ExchangeServiceBase.prototype.TraceHttpResponseHeaders = function (traceType, response) { throw new Error("ExchangeServiceBase.ts - TraceHttpResponseHeaders : Not implemented."); };
    ExchangeServiceBase.prototype.TraceMessage = function (traceType, logEntry) { EwsLogging.Log(logEntry); /*throw new Error("Not implemented."); */ };
    ExchangeServiceBase.prototype.TraceXml = function (traceType, stream) { throw new Error("ExchangeServiceBase.ts - TraceXml : Not implemented."); };
    ExchangeServiceBase.prototype.Validate = function () { };
    ExchangeServiceBase.AccountIsLocked = 456;
    return ExchangeServiceBase;
}());
exports.ExchangeServiceBase = ExchangeServiceBase;
/**
 * Represents a binding to the **Exchange Web Services**.
 *
 */
var ExchangeService = (function (_super) {
    __extends(ExchangeService, _super);
    function ExchangeService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /* #endregion Constants */
        /* #region Fields */
        _this.url = null;
        //private preferredCulture: any = null;// System.Globalization.CultureInfo;
        //private dateTimePrecision: DateTimePrecision = DateTimePrecision.Default;
        //private impersonatedUserId: ImpersonatedUserId = null;
        //private privilegedUserId: PrivilegedUserId = null;
        //private managementRoles: ManagementRoles = null;
        //private fileAttachmentContentHandler: IFileAttachmentContentHandler = null;
        _this.unifiedMessaging = null;
        //private enableScpLookup: boolean = false; //false for javascript, AD Lookup not implemented 
        _this.renderingMode = RenderingMode.Xml;
        //private traceEnablePrettyPrinting: boolean = true;
        _this.targetServerVersion = null;
        _this.ImpersonatedUserId = null;
        /**@internal */
        _this.PrivilegedUserId = null;
        _this.ManagementRoles = null;
        _this.PreferredCulture = null; //System.Globalization.CultureInfo;
        _this.DateTimePrecision = DateTimePrecision.Default;
        _this.FileAttachmentContentHandler = null;
        _this.Exchange2007CompatibilityMode = false;
        _this.TraceEnablePrettyPrinting = true;
        return _this;
        /* #endregion Utilities */
    }
    Object.defineProperty(ExchangeService.prototype, "TimeZone", {
        get: function () {
            return this.timeZone;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExchangeService.prototype, "UnifiedMessaging", {
        get: function () {
            if (this.unifiedMessaging === null) {
                this.unifiedMessaging = new UnifiedMessaging(this);
            }
            return this.unifiedMessaging;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExchangeService.prototype, "EnableScpLookup", {
        get: function () { return false; } //false for javascript, AD Lookup not implemented
        ,
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExchangeService.prototype, "RenderingMethod", {
        get: function () { return this.renderingMode; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExchangeService.prototype, "TargetServerVersion", {
        get: function () {
            return this.targetServerVersion;
        },
        set: function (value) {
            ExchangeService.ValidateTargetVersion(value);
            this.targetServerVersion = value;
        },
        enumerable: true,
        configurable: true
    });
    /* #region Properties */
    /* #region Response object operations */
    /**
     * @internal Create response object.
     *
     * @param   {ServiceObject}          responseObject       The response object.
     * @param   {FolderId}               parentFolderId       The parent folder id.
     * @param   {MessageDisposition}     messageDisposition   The message disposition.
     * @return  {Promise<Item[]>}        The list of items created or modified as a result of the "creation" of the response object :Promise.
     */
    ExchangeService.prototype.InternalCreateResponseObject = function (responseObject, parentFolderId, messageDisposition) {
        var request = new CreateResponseObjectRequest(this, ServiceErrorHandling.ThrowOnError);
        request.ParentFolderId = parentFolderId;
        request.Items = [responseObject];
        request.MessageDisposition = messageDisposition;
        return request.Execute().then(function (responses) {
            return responses.__thisIndexer(0).Items;
        });
    };
    ExchangeService.prototype.BindToFolder = function (folderId, propertySet, /** pass Folder or subclass itself, not an instance */ folderType) {
        if (folderType === void 0) { folderType = null; }
        EwsUtilities.ValidateParam(folderId, "folderId");
        EwsUtilities.ValidateParam(propertySet, "propertySet");
        var request = new GetFolderRequest(this, ServiceErrorHandling.ThrowOnError);
        request.FolderIds.Add(folderId);
        request.PropertySet = propertySet;
        return request.Execute().then(function (responses) {
            var result = responses.__thisIndexer(0).Folder;
            if (folderType != null && !(result instanceof folderType)) {
                throw new ServiceLocalException(StringHelper.Format(Strings.FolderTypeNotCompatible, "Type detection not implemented - ExchangeService.ts - BindToFolder<TFolder>", "Type detection not implemented"));
            }
            return result;
        });
    };
    /**
     * @internal Copies a folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}           folderId              The folder id.
     * @param   {FolderId}           destinationFolderId   The destination folder id.
     * @return  {Promise<Folder>}    Copy of folder :Promise.
     */
    ExchangeService.prototype.CopyFolder = function (folderId, destinationFolderId) {
        var request = new CopyFolderRequest(this, ServiceErrorHandling.ThrowOnError);
        request.DestinationFolderId = destinationFolderId;
        request.FolderIds.Add(folderId);
        return request.Execute().then(function (responses) {
            return responses.__thisIndexer(0).Folder;
        });
    };
    /**
     * @internal Creates a folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}   folder           The folder.
     * @param   {FolderId}   parentFolderId   The parent folder id.
     */
    ExchangeService.prototype.CreateFolder = function (folder, parentFolderId) {
        var request = new CreateFolderRequest(this, ServiceErrorHandling.ThrowOnError);
        request.Folders = [folder];
        request.ParentFolderId = parentFolderId;
        return request.Execute();
    };
    /**
     * @internal Deletes a folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}      folderId     The folder id.
     * @param   {DeleteMode}    deleteMode   The delete mode.
     */
    ExchangeService.prototype.DeleteFolder = function (folderId, deleteMode) {
        EwsUtilities.ValidateParam(folderId, "folderId");
        var request = new DeleteFolderRequest(this, ServiceErrorHandling.ThrowOnError);
        request.FolderIds.Add(folderId);
        request.DeleteMode = deleteMode;
        return request.Execute();
    };
    /**
     * @internal Empties a folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}      folderId           The folder id.
     * @param   {DeleteMode}    deleteMode         The delete mode.
     * @param   {boolean}       deleteSubFolders   if set to true empty folder should also delete sub folders.
     */
    ExchangeService.prototype.EmptyFolder = function (folderId, deleteMode, deleteSubFolders) {
        EwsUtilities.ValidateParam(folderId, "folderId");
        var request = new EmptyFolderRequest(this, ServiceErrorHandling.ThrowOnError);
        request.FolderIds.Add(folderId);
        request.DeleteMode = deleteMode;
        request.DeleteSubFolders = deleteSubFolders;
        return request.Execute();
    };
    ExchangeService.prototype.FindFolders = function (parentFolderIdOrName, viewOrSearchFilter, folderView) {
        //todo: better argument check with ewsutilities
        //EwsUtilities.ValidateParam(parentFolderId, "parentFolderId");
        //EwsUtilities.ValidateParam(view, "view");
        //EwsUtilities.ValidateParamAllowNull(searchFilter, "searchFilter");
        var argsLength = arguments.length;
        if (argsLength < 2 && argsLength > 3) {
            throw new Error("ExchangeService.ts - FindFolders - invalid number of arguments, check documentation and try again.");
        }
        //position 1 - parentFolderIdOrName
        var parentFolderIds = [];
        if (typeof parentFolderIdOrName === 'number') {
            parentFolderIds.push(new FolderId(parentFolderIdOrName));
        }
        else if (parentFolderIdOrName instanceof FolderId) {
            parentFolderIds.push(parentFolderIdOrName);
        }
        else {
            throw new Error("ExchangeService.ts - FindFolders - incorrect use of parameters, 1st argument must be Folder ID or WellKnownFolderName");
        }
        var searchFilter = null;
        var view = null;
        //position 2 - viewOrSearchFilter
        if (viewOrSearchFilter instanceof SearchFilter) {
            if (!(folderView instanceof FolderView)) {
                throw new Error("ExchangeService.ts - FindFolders with " + argsLength + " parameters - incorrect uses of parameter at 3nd position, it must be FolderView when using SearchFilter at 2nd place");
            }
            searchFilter = viewOrSearchFilter;
        }
        else if (viewOrSearchFilter instanceof FolderView) {
            view = viewOrSearchFilter;
        }
        else {
            throw new Error("ExchangeService.ts - FindFolders - incorrect uses of parameters at 2nd position, must be FolderView or SearchFilter");
        }
        //position 3 - folderView
        if (argsLength == 3) {
            view = folderView;
        }
        return this.InternalFindFolders(parentFolderIds, searchFilter, /* searchFilter */ view, ServiceErrorHandling.ThrowOnError).then(function (responses) {
            return responses.__thisIndexer(0).Results;
        });
    };
    /**
     * Finds folders.
     *
     * @param   {FolderId[]}             parentFolderIds     The parent folder ids.
     * @param   {SearchFilter}           searchFilter        The search filter. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection
     * @param   {FolderView}             view                The view controlling the number of folders returned.
     * @param   {ServiceErrorHandling}   errorHandlingMode   Indicates the type of error handling should be done.
     * @return  {Promise<ServiceResponseCollection<FindFolderResponse>>}     Collection of service responses :Promise.
     */
    ExchangeService.prototype.InternalFindFolders = function (parentFolderIds, searchFilter, view, errorHandlingMode) {
        var request = new FindFolderRequest(this, errorHandlingMode);
        request.ParentFolderIds.AddRange(parentFolderIds);
        request.SearchFilter = searchFilter;
        request.View = view;
        return request.Execute();
    };
    /**
     * @internal Load specified properties for a folder.
     *
     * @param   {Folder}         folder        The folder.
     * @param   {PropertySet}    propertySet   The property set.
     */
    ExchangeService.prototype.LoadPropertiesForFolder = function (folder, propertySet) {
        EwsUtilities.ValidateParam(folder, "folder");
        EwsUtilities.ValidateParam(propertySet, "propertySet");
        var request = new GetFolderRequestForLoad(this, ServiceErrorHandling.ThrowOnError);
        request.FolderIds.Add(folder);
        request.PropertySet = propertySet;
        return request.Execute();
    };
    /**
     * @internal Marks all items in folder as read/unread. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}      folderId               The folder id.
     * @param   {boolean}       readFlag               If true, items marked as read, otherwise unread.
     * @param   {boolean}       suppressReadReceipts   If true, suppress read receipts for items.
     */
    ExchangeService.prototype.MarkAllItemsAsRead = function (folderId, readFlag, suppressReadReceipts) {
        EwsUtilities.ValidateParam(folderId, "folderId");
        EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2013, "MarkAllItemsAsRead");
        var request = new MarkAllItemsAsReadRequest(this, ServiceErrorHandling.ThrowOnError);
        request.FolderIds.Add(folderId);
        request.ReadFlag = readFlag;
        request.SuppressReadReceipts = suppressReadReceipts;
        return request.Execute();
    };
    /**
     * @internal Move a folder.
     *
     * @param   {FolderId}           folderId              The folder id.
     * @param   {FolderId}           destinationFolderId   The destination folder id.
     * @return  {Promise<Folder>}    Moved folder :Promise.
     */
    ExchangeService.prototype.MoveFolder = function (folderId, destinationFolderId) {
        var request = new MoveFolderRequest(this, ServiceErrorHandling.ThrowOnError);
        request.DestinationFolderId = destinationFolderId;
        request.FolderIds.Add(folderId);
        return request.Execute().then(function (responses) {
            return responses.__thisIndexer(0).Folder;
        });
    };
    /**
     * @internal Updates a folder.
     *
     * @param   {Folder}   folder   The folder.
     */
    ExchangeService.prototype.UpdateFolder = function (folder) {
        var request = new UpdateFolderRequest(this, ServiceErrorHandling.ThrowOnError);
        request.Folders.push(folder);
        return request.Execute().then(function (value) {
            return null;
        });
    };
    /* #endregion Folder operations */
    /* #region Item operations */
    /**
     * Archives multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}   itemIds          The Ids of the items to move.
     * @param   {FolderId}   sourceFolderId   The Id of the folder in primary corresponding to which items are being archived to.
     * @return  {Promise<ServiceResponseCollection<ArchiveItemResponse>>}                     A ServiceResponseCollection providing copy results for each of the specified item Ids :Promise.
     */
    ExchangeService.prototype.ArchiveItems = function (itemIds, sourceFolderId) {
        var request = new ArchiveItemRequest(this, ServiceErrorHandling.ReturnErrors);
        request.Ids.AddRange(itemIds);
        request.SourceFolderId = sourceFolderId;
        return request.Execute();
    };
    /* //ref: new method, //todo: implement other newer code from ews managed api repo  */
    /**
     * Binds to multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}      itemIds         The Ids of the items to bind to.
     * @param   {PropertySet}   propertySet     The set of properties to load.
     * @param   {string}        anchorMailbox   The SmtpAddress of mailbox that hosts all items we need to bind to
     * @return  {Promise<ServiceResponseCollection<GetItemResponse>>}                    A ServiceResponseCollection providing results for each of the specified item Ids :Promise.
     */
    ExchangeService.prototype.BindToGroupItems = function (itemIds, propertySet, anchorMailbox) {
        EwsUtilities.ValidateParamCollection(itemIds, "itemIds");
        EwsUtilities.ValidateParam(propertySet, "propertySet");
        EwsUtilities.ValidateParam(propertySet, "anchorMailbox");
        return this.InternalBindToItems(itemIds, propertySet, anchorMailbox, ServiceErrorHandling.ReturnErrors);
    };
    ExchangeService.prototype.BindToItem = function (itemId, propertySet, /** pass Item or subclass itself, not an instance */ itemType) {
        if (itemType === void 0) { itemType = null; }
        EwsUtilities.ValidateParam(itemId, "itemId");
        EwsUtilities.ValidateParam(propertySet, "propertySet");
        return this.InternalBindToItems([itemId], propertySet, null, /* anchorMailbox */ ServiceErrorHandling.ThrowOnError).then(function (response) {
            var result = response.__thisIndexer(0).Item;
            if (itemType != null && !(result instanceof itemType)) {
                throw new ServiceLocalException(StringHelper.Format(Strings.ItemTypeNotCompatible, "Type detection not implemented - ExchangeService.ts - BindToItem<TItem>", "Type detection not implemented"));
            }
            return result;
        });
    };
    /**
     * Binds to multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}      itemIds       The Ids of the items to bind to.
     * @param   {PropertySet}   propertySet   The set of properties to load.
     * @return  {Promise<ServiceResponseCollection<GetItemResponse>>}                  A ServiceResponseCollection providing results for each of the specified item Ids :Promise.
     */
    ExchangeService.prototype.BindToItems = function (itemIds, propertySet) {
        EwsUtilities.ValidateParamCollection(itemIds, "itemIds");
        EwsUtilities.ValidateParam(propertySet, "propertySet");
        return this.InternalBindToItems(itemIds, propertySet, null, /* anchorMailbox */ ServiceErrorHandling.ReturnErrors);
    };
    /**
     * @internal Copies an item. Calling this method results in a call to EWS.
     *
     * @param   {ItemId}        itemId                The Id of the item to copy.
     * @param   {FolderId}      destinationFolderId   The Id of the folder to copy the item to.
     * @return  {Promise<Item>}     The copy of the item :Promise.
     */
    ExchangeService.prototype.CopyItem = function (itemId, destinationFolderId) {
        return this.InternalCopyItems([itemId], destinationFolderId, null, ServiceErrorHandling.ThrowOnError).then(function (response) {
            return response.__thisIndexer(0).Item;
        });
    };
    ExchangeService.prototype.CopyItems = function (itemIds, destinationFolderId, returnNewItemIds) {
        if (returnNewItemIds === void 0) { returnNewItemIds = null; }
        EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2010_SP1, "CopyItems");
        return this.InternalCopyItems(itemIds, destinationFolderId, returnNewItemIds, ServiceErrorHandling.ReturnErrors);
    };
    /**
     * @internal Creates an item. Calling this method results in a call to EWS.
     *
     * @param   {Item}                  item                  The item to create.
     * @param   {FolderId}              parentFolderId        The Id of the folder in which to place the newly created item. If null, the item is created in its default folders.
     * @param   {MessageDisposition}    messageDisposition    Indicates the disposition mode for items of type EmailMessage. Required if item is an EmailMessage instance.
     * @param   {SendInvitationsMode}   sendInvitationsMode   Indicates if and how invitations should be sent for item of type Appointment. Required if item is an Appointment instance.
     */
    ExchangeService.prototype.CreateItem = function (item, parentFolderId, messageDisposition, sendInvitationsMode) {
        return this.InternalCreateItems([item], parentFolderId, messageDisposition, sendInvitationsMode, ServiceErrorHandling.ThrowOnError);
    };
    /**
     * Creates multiple items in a single EWS call. Supported item classes are EmailMessage, Appointment, Contact, PostItem, Task and Item. CreateItems does not support items that have unsaved attachments.
     *
     * @param   {Item[]}                items                 The items to create.
     * @param   {FolderId}              parentFolderId        The Id of the folder in which to place the newly created items. If null, items are created in their default folders.
     * @param   {MessageDisposition}    messageDisposition    Indicates the disposition mode for items of type EmailMessage. Required if items contains at least one EmailMessage instance.
     * @param   {SendInvitationsMode}   sendInvitationsMode   Indicates if and how invitations should be sent for items of type Appointment. Required if items contains at least one Appointment instance.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}                          A ServiceResponseCollection providing creation results for each of the specified items :Promise.
     */
    ExchangeService.prototype.CreateItems = function (items, parentFolderId, messageDisposition, sendInvitationsMode) {
        // All items have to be new.
        if (!items.every(function (item) { return item.IsNew; })) {
            throw new ServiceValidationException(Strings.CreateItemsDoesNotHandleExistingItems);
        }
        // Make sure that all items do *not* have unprocessed attachments.
        if (!items.every(function (item) { return !item.HasUnprocessedAttachmentChanges(); })) {
            throw new ServiceValidationException(Strings.CreateItemsDoesNotAllowAttachments);
        }
        return this.InternalCreateItems(items, parentFolderId, messageDisposition, sendInvitationsMode, ServiceErrorHandling.ReturnErrors);
    };
    ExchangeService.prototype.DeleteItem = function (itemId, deleteMode, sendCancellationsMode, affectedTaskOccurrences, suppressReadReceipts) {
        if (suppressReadReceipts === void 0) { suppressReadReceipts = false; }
        EwsUtilities.ValidateParam(itemId, "itemId");
        return this.InternalDeleteItems([itemId], deleteMode, sendCancellationsMode, affectedTaskOccurrences, ServiceErrorHandling.ThrowOnError, suppressReadReceipts);
    };
    ExchangeService.prototype.DeleteItems = function (itemIds, deleteMode, sendCancellationsMode, affectedTaskOccurrences, suppressReadReceipt) {
        if (suppressReadReceipt === void 0) { suppressReadReceipt = false; }
        EwsUtilities.ValidateParamCollection(itemIds, "itemIds");
        return this.InternalDeleteItems(itemIds, deleteMode, sendCancellationsMode, affectedTaskOccurrences, ServiceErrorHandling.ReturnErrors, suppressReadReceipt);
    };
    ExchangeService.prototype.FindAppointments = function (parentFolderIdOrName, calendarView) {
        var parentFolderId = parentFolderIdOrName;
        if (typeof parentFolderIdOrName === 'number') {
            parentFolderId = new FolderId(parentFolderIdOrName);
        }
        return this.FindItems([parentFolderId], null, /* searchFilter */ null, /* queryString */ calendarView, null, /* groupBy */ ServiceErrorHandling.ThrowOnError).then(function (response) {
            return response.__thisIndexer(0).Results;
        });
    };
    //skipped: not needed, no calls coming in to this internal function in ews managed api, future use possible until them keep it muted   - 
    //FindItems<TItem extends Item>(parentFolderId: FolderId, searchFilter: SearchFilter, view: ViewBase, groupBy: Grouping): Promise<ServiceResponseCollection<FindItemResponse<TItem>>>;
    ExchangeService.prototype.FindItems = function (nameIdOrIds, viewQueryStringOrSearchFilter, groupByViewRHTOrQueryString, groupByOrView, groupBy, errorHandlingMode) {
        //todo: better argument check with ewsutilities
        if (errorHandlingMode === void 0) { errorHandlingMode = ServiceErrorHandling.ThrowOnError; }
        //EwsUtilities.ValidateParamAllowNull(searchFilter, "searchFilter");
        //EwsUtilities.ValidateParam(groupBy, "groupBy");
        //EwsUtilities.ValidateParamAllowNull(queryString, "queryString");
        //EwsUtilities.ValidateParamCollection(parentFolderIds, "parentFolderIds");
        //EwsUtilities.ValidateParam(view, "view");
        //EwsUtilities.ValidateParam(groupBy, "groupBy");
        //EwsUtilities.ValidateParamAllowNull(queryString, "queryString");
        //EwsUtilities.ValidateParamAllowNull(returnHighlightTerms, "returnHighlightTerms");
        //EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2013, "FindItems");
        var argsLength = arguments.length;
        if (argsLength < 2 && argsLength > 6) {
            throw new Error("ExchangeService.ts - FindItems - invalid number of arguments, check documentation and try again.");
        }
        //position 1 - nameIdOrIds
        var parentIds = [];
        if (typeof nameIdOrIds === 'number') {
            parentIds.push(new FolderId(nameIdOrIds));
        }
        else if (nameIdOrIds instanceof FolderId) {
            parentIds.push(nameIdOrIds);
        }
        else if (Array.isArray(nameIdOrIds)) {
            parentIds = nameIdOrIds;
        }
        var queryString = null;
        var searchFilter = null;
        var view = null;
        //position 2 - viewQueryStringOrSearchFilter
        if (argsLength >= 2)
            if (typeof viewQueryStringOrSearchFilter === 'string') {
                queryString = viewQueryStringOrSearchFilter;
            }
            else if (viewQueryStringOrSearchFilter instanceof SearchFilter) {
                searchFilter = viewQueryStringOrSearchFilter;
            }
            else if (viewQueryStringOrSearchFilter instanceof ViewBase) {
                view = viewQueryStringOrSearchFilter;
            }
            else if (viewQueryStringOrSearchFilter) {
                throw new Error("ExchangeService.ts - FindItems - incorrect uses of parameters at 2nd position, must be string, ViewBase or SearchFilter");
            }
        var groupResultBy = null;
        var returnHighlightTerms = false;
        var isGroupped = false; // to resturn GroupedFindItemsResults<Item>
        //position 3 - groupByViewRHTOrQueryString
        if (argsLength >= 3) {
            if (groupByViewRHTOrQueryString instanceof Grouping) {
                if (!(viewQueryStringOrSearchFilter instanceof ViewBase)) {
                    throw new Error("ExchangeService.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 3nd position, it must be ViewBase when using Grouping at 4th place");
                }
                groupResultBy = groupByViewRHTOrQueryString;
                isGroupped = true;
            }
            else if (groupByViewRHTOrQueryString instanceof ViewBase) {
                view = groupByViewRHTOrQueryString;
            }
            else if (typeof groupByViewRHTOrQueryString === 'string') {
                queryString = groupByViewRHTOrQueryString;
            }
            else if (typeof groupByViewRHTOrQueryString === 'boolean') {
                returnHighlightTerms = groupByViewRHTOrQueryString;
                EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2013, "FindItems");
            }
            else if (groupByViewRHTOrQueryString) {
                throw new Error("ExchangeService.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 3rd position, must be string, boolean, ViewBase or Grouping");
            }
        }
        //position 4 - groupByOrView
        if (argsLength >= 4) {
            if (groupByOrView instanceof Grouping) {
                if (!(groupByViewRHTOrQueryString instanceof ViewBase)) {
                    throw new Error("ExchangeService.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 3rd position, it must be ViewBase when using Grouping at 3rd place");
                }
                groupResultBy = groupByOrView;
                isGroupped = true;
            }
            else if (groupByOrView instanceof ViewBase) {
                view = groupByOrView;
            }
            else if (groupByOrView) {
                throw new Error("ExchangeService.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 4th  position, must be  ViewBase or Grouping");
            }
        }
        //position 5 - groupBy
        if (argsLength >= 5) {
            if (groupByOrView && !(groupByOrView instanceof ViewBase)) {
                throw new Error("ExchangeService.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 4th position, it must be ViewBase when using Grouping at 5th place");
            }
            groupResultBy = groupBy;
            isGroupped = true;
        }
        var isRaw = false; // to return ServiceResponseCollection<FindItemResponse<TItem>>
        //position 6 - errorHandlingMode
        if (argsLength === 6) {
            isRaw = true;
        }
        var request = new FindItemRequest(this, errorHandlingMode | ServiceErrorHandling.ThrowOnError);
        request.ParentFolderIds.AddRange(parentIds);
        request.SearchFilter = searchFilter;
        request.QueryString = queryString;
        request.View = view;
        request.GroupBy = groupResultBy;
        return request.Execute().then(function (responses) {
            if (isRaw) {
                return responses;
            }
            if (isGroupped) {
                return responses.__thisIndexer(0).GroupedFindResults;
            }
            return responses.__thisIndexer(0).Results;
        });
    };
    /**
     * Binds to multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}              itemIds         The Ids of the items to bind to.
     * @param   {PropertySet}           propertySet     The set of properties to load.
     * @param   {string}                anchorMailbox   The SmtpAddress of mailbox that hosts all items we need to bind to
     * @param   {ServiceErrorHandling}  errorHandling   Type of error handling to perform.
     * @return  {Promise<ServiceResponseCollection<GetItemResponse>>}       A ServiceResponseCollection providing results for each of the specified item Ids :Promise.
     */
    ExchangeService.prototype.InternalBindToItems = function (itemIds, propertySet, anchorMailbox, errorHandling) {
        var request = new GetItemRequest(this, errorHandling);
        request.ItemIds.AddRange(itemIds);
        request.PropertySet = propertySet;
        request.AnchorMailbox = anchorMailbox;
        return request.Execute();
    };
    /**
     * Copies multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}              itemIds                 The Ids of the items to bind to.
     * @param   {FolderId}              destinationFolderId     The Id of the folder to copy the items to.
     * @param   {boolean}               returnNewItemIds        Flag indicating whether service should return new ItemIds or not.
     * @param   {ServiceErrorHandling}  errorHandling           What type of error handling should be performed.
     * @return  {Promise<ServiceResponseCollection<MoveCopyItemResponse>>}      A ServiceResponseCollection providing copy results for each of the specified item Ids :Promise.
     */
    ExchangeService.prototype.InternalCopyItems = function (itemIds, destinationFolderId, returnNewItemIds, errorHandling) {
        var request = new CopyItemRequest(this, errorHandling);
        request.ItemIds.AddRange(itemIds);
        request.DestinationFolderId = destinationFolderId;
        request.ReturnNewItemIds = returnNewItemIds;
        return request.Execute();
    };
    /**
     * Creates multiple items in a single EWS call. Supported item classes are EmailMessage, Appointment, Contact, PostItem, Task and Item. CreateItems does not support items that have unsaved attachments.
     *
     * @param   {Item[]}                items                 The items to create.
     * @param   {FolderId}              parentFolderId        The Id of the folder in which to place the newly created items. If null, items are created in their default folders.
     * @param   {MessageDisposition}    messageDisposition    Indicates the disposition mode for items of type EmailMessage. Required if items contains at least one EmailMessage instance.
     * @param   {SendInvitationsMode}   sendInvitationsMode   Indicates if and how invitations should be sent for items of type Appointment. Required if items contains at least one Appointment instance.
     * @param   {ServiceErrorHandling}  errorHandling         What type of error handling should be performed.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       A ServiceResponseCollection providing creation results for each of the specified items :Promise.
     */
    ExchangeService.prototype.InternalCreateItems = function (items, parentFolderId, messageDisposition, sendInvitationsMode, errorHandling) {
        var request = new CreateItemRequest(this, errorHandling);
        request.ParentFolderId = parentFolderId;
        request.Items = items;
        request.MessageDisposition = messageDisposition;
        request.SendInvitationsMode = sendInvitationsMode;
        return request.Execute();
    };
    /**
     * Deletes multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}                  itemIds                   The Ids of the items to delete.
     * @param   {DeleteMode}                deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}     sendCancellationsMode     Indicates whether cancellation messages should be sent. Required if any of the item Ids represents an Appointment.
     * @param   {AffectedTaskOccurrence}    affectedTaskOccurrences   Indicates which instance of a recurring task should be deleted. Required if any of the item Ids represents a Task.
     * @param   {ServiceErrorHandling}      errorHandling             Type of error handling to perform.
     * @param   {boolean}                   suppressReadReceipts      Whether to suppress read receipts
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       A ServiceResponseCollection providing deletion results for each of the specified item Ids :Promise.
     */
    ExchangeService.prototype.InternalDeleteItems = function (itemIds, deleteMode, sendCancellationsMode, affectedTaskOccurrences, errorHandling, suppressReadReceipts) {
        var request = new DeleteItemRequest(this, errorHandling);
        request.ItemIds.AddRange(itemIds);
        request.DeleteMode = deleteMode;
        request.SendCancellationsMode = sendCancellationsMode;
        request.AffectedTaskOccurrences = affectedTaskOccurrences;
        request.SuppressReadReceipts = suppressReadReceipts;
        return request.Execute();
    };
    /**
     * @internal Loads the properties of multiple items in a single call to EWS.
     *
     * @param   {Item[]}                items           The items to load the properties of.
     * @param   {PropertySet}           propertySet     The set of properties to load.
     * @param   {ServiceErrorHandling}  errorHandling   Indicates the type of error handling should be done.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       A ServiceResponseCollection providing results for each of the specified items :Promise.
     */
    ExchangeService.prototype.InternalLoadPropertiesForItems = function (items, propertySet, errorHandling) {
        var request = new GetItemRequestForLoad(this, errorHandling);
        request.ItemIds.AddRange(items);
        request.PropertySet = propertySet;
        return request.Execute();
    };
    /**
     * Moves multiple items in a single call to EWS.
     *
     * @param   {ItemId[]}              itemIds               The Ids of the items to move.
     * @param   {FolderId}              destinationFolderId   The Id of the folder to move the items to.
     * @param   {boolean}               returnNewItemIds      Flag indicating whether service should return new ItemIds or not.
     * @param   {ServiceErrorHandling}  errorHandling         What type of error handling should be performed.
     * @return  {Promise<ServiceResponseCollection<MoveCopyItemResponse>>}      A ServiceResponseCollection providing copy results for each of the specified item Ids :Promise.
     */
    ExchangeService.prototype.InternalMoveItems = function (itemIds, destinationFolderId, returnNewItemIds, errorHandling) {
        var request = new MoveItemRequest(this, errorHandling);
        request.ItemIds.AddRange(itemIds);
        request.DestinationFolderId = destinationFolderId;
        request.ReturnNewItemIds = returnNewItemIds;
        return request.Execute();
    };
    /**
     * Updates multiple items in a single EWS call. UpdateItems does not support items that have unsaved attachments.
     *
     * @param   {Item[]}                                items                                The items to update.
     * @param   {FolderId}                              savedItemsDestinationFolderId        The folder in which to save sent messages, meeting invitations or cancellations. If null, the messages, meeting invitation or cancellations are saved in the Sent Items folder.
     * @param   {ConflictResolutionMode}                conflictResolution                   The conflict resolution mode.
     * @param   {MessageDisposition}                    messageDisposition                   Indicates the disposition mode for items of type EmailMessage. Required if items contains at least one EmailMessage instance.
     * @param   {SendInvitationsOrCancellationsMode}    sendInvitationsOrCancellationsMode   Indicates if and how invitations and/or cancellations should be sent for items of type Appointment. Required if items contains at least one Appointment instance.
     * @param   {ServiceErrorHandling}                  errorHandling                        What type of error handling should be performed.
     * @param   {boolean}                               suppressReadReceipt                  Whether to suppress read receipts
     * @return  {Promise<ServiceResponseCollection<UpdateItemResponse>>}                     A ServiceResponseCollection providing update results for each of the specified items :Promise.
     */
    ExchangeService.prototype.InternalUpdateItems = function (items, savedItemsDestinationFolderId, conflictResolution, messageDisposition, sendInvitationsOrCancellationsMode, errorHandling, suppressReadReceipt) {
        var request = new UpdateItemRequest(this, errorHandling);
        //request.Items.AddRange(items);
        ArrayHelper.AddRange(request.Items, items);
        request.SavedItemsDestinationFolder = savedItemsDestinationFolderId;
        request.MessageDisposition = messageDisposition;
        request.ConflictResolutionMode = conflictResolution;
        request.SendInvitationsOrCancellationsMode = sendInvitationsOrCancellationsMode;
        request.SuppressReadReceipts = suppressReadReceipt;
        return request.Execute();
    };
    /**
     * Loads the properties of multiple items in a single call to EWS. **Unstable for Extended Properties**
     *
     * @param   {Item[]}        items         The items to load the properties of.
     * @param   {PropertySet}   propertySet   The set of properties to load.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       A ServiceResponseCollection providing results for each of the specified items :Promise.
     */
    ExchangeService.prototype.LoadPropertiesForItems = function (items, propertySet) {
        EwsUtilities.ValidateParamCollection(items, "items");
        EwsUtilities.ValidateParam(propertySet, "propertySet");
        return this.InternalLoadPropertiesForItems(items, propertySet, ServiceErrorHandling.ReturnErrors);
    };
    /**
     * Mark items as junk.
     *
     * @param   {ItemId[]}      itemIds    ItemIds for the items to mark
     * @param   {boolean}       isJunk     Whether the items are junk.  If true, senders are add to blocked sender list. If false, senders are removed.
     * @param   {boolean}       moveItem   Whether to move the item.  Items are moved to junk folder if isJunk is true, inbox if isJunk is false.
     * @return  {Promise<ServiceResponseCollection<MarkAsJunkResponse>>}        A ServiceResponseCollection providing itemIds for each of the moved items :Promise.
     */
    ExchangeService.prototype.MarkAsJunk = function (itemIds, isJunk, moveItem) {
        var request = new MarkAsJunkRequest(this, ServiceErrorHandling.ReturnErrors);
        request.ItemIds.AddRange(itemIds);
        request.IsJunk = isJunk;
        request.MoveItem = moveItem;
        return request.Execute();
    };
    /**
     * @internal Move an item.
     *
     * @param   {ItemId}    itemId                The Id of the item to move.
     * @param   {FolderId}  destinationFolderId   The Id of the folder to move the item to.
     * @return  {Promise<Item>}                   The moved item :Promise.
     */
    ExchangeService.prototype.MoveItem = function (itemId, destinationFolderId) {
        return this.InternalMoveItems([itemId], destinationFolderId, null, ServiceErrorHandling.ThrowOnError).then(function (responses) {
            return responses.__thisIndexer(0).Item;
        });
    };
    ExchangeService.prototype.MoveItems = function (itemIds, destinationFolderId, returnNewItemIds) {
        if (returnNewItemIds === void 0) { returnNewItemIds = null; }
        EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2010_SP1, "MoveItems");
        return this.InternalMoveItems(itemIds, destinationFolderId, returnNewItemIds, ServiceErrorHandling.ReturnErrors);
    };
    /**
     * @internal Sends an item.
     *
     * @param   {Item}      item                           The item.
     * @param   {FolderId}  savedCopyDestinationFolderId   The saved copy destination folder id.
     */
    ExchangeService.prototype.SendItem = function (item, savedCopyDestinationFolderId) {
        var request = new SendItemRequest(this, ServiceErrorHandling.ThrowOnError);
        request.Items = [item];
        request.SavedCopyDestinationFolderId = savedCopyDestinationFolderId;
        return request.Execute();
    };
    ExchangeService.prototype.UpdateItem = function (item, savedItemsDestinationFolderId, conflictResolution, messageDisposition, sendInvitationsOrCancellationsMode, suppressReadReceipts) {
        if (suppressReadReceipts === void 0) { suppressReadReceipts = false; }
        return this.InternalUpdateItems([item], savedItemsDestinationFolderId, conflictResolution, messageDisposition, sendInvitationsOrCancellationsMode, ServiceErrorHandling.ThrowOnError, suppressReadReceipts).then(function (responses) {
            return responses.__thisIndexer(0).ReturnedItem;
        });
    };
    ExchangeService.prototype.UpdateItems = function (items, savedItemsDestinationFolderId, conflictResolution, messageDisposition, sendInvitationsOrCancellationsMode, suppressReadReceipts) {
        if (suppressReadReceipts === void 0) { suppressReadReceipts = false; }
        // All items have to exist on the server (!new) and modified (dirty)
        if (!items.every(function (item) { return (!item.IsNew && item.IsDirty); })) {
            throw new ServiceValidationException(Strings.UpdateItemsDoesNotSupportNewOrUnchangedItems);
        }
        // Make sure that all items do *not* have unprocessed attachments.
        if (!items.every(function (item) { return !item.HasUnprocessedAttachmentChanges(); })) {
            throw new ServiceValidationException(Strings.UpdateItemsDoesNotAllowAttachments);
        }
        return this.InternalUpdateItems(items, savedItemsDestinationFolderId, conflictResolution, messageDisposition, sendInvitationsOrCancellationsMode, ServiceErrorHandling.ReturnErrors, suppressReadReceipts);
    };
    /* #endregion Item operations 47*/
    /* #region Attachment operations */
    /**
     * @internal Creates attachments.
     *
     * @param   {string}            parentItemId   The parent item id.
     * @param   {Attachment[]}      attachments            The attachments.
     * @return  {Promise<ServiceResponseCollection<CreateAttachmentResponse>>}      Service response collection :Promise.
     */
    ExchangeService.prototype.CreateAttachments = function (parentItemId, attachments) {
        var request = new CreateAttachmentRequest(this, ServiceErrorHandling.ReturnErrors);
        request.ParentItemId = parentItemId;
        ArrayHelper.AddRange(request.Attachments, attachments); //request.Attachments.AddRange(attachments);
        return request.Execute();
    };
    /**
     * @internal Deletes attachments.
     *
     * @param   {Attachment[]}   attachments   The attachments.
     * @return  {Promise<ServiceResponseCollection<DeleteAttachmentResponse>>}      Service response collection :Promise.
     */
    ExchangeService.prototype.DeleteAttachments = function (attachments) {
        var request = new DeleteAttachmentRequest(this, ServiceErrorHandling.ReturnErrors);
        ArrayHelper.AddRange(request.Attachments, attachments); //request.Attachments.AddRange(attachments);
        return request.Execute();
    };
    /**
     * @internal Gets an attachment.
     *
     * @param   {Attachment}                    attachment             The attachment.
     * @param   {BodyType}                      bodyType               Type of the body.
     * @param   {PropertyDefinitionBase[]}      additionalProperties   The additional properties.
     */
    ExchangeService.prototype.GetAttachment = function (attachment, bodyType, additionalProperties) {
        return this.InternalGetAttachments([attachment], bodyType, additionalProperties, ServiceErrorHandling.ThrowOnError);
    };
    ExchangeService.prototype.GetAttachments = function (attachmentsOrIds, bodyType, additionalProperties) {
        var ids = ArrayHelper.OfType(attachmentsOrIds, function (attachment) { return typeof attachment === 'string'; });
        if (ids && ids.length > 0) {
            var request = new GetAttachmentRequest(this, ServiceErrorHandling.ReturnErrors);
            ArrayHelper.AddRange(request.AttachmentIds, attachmentsOrIds);
            request.BodyType = bodyType;
            if (additionalProperties != null) {
                ArrayHelper.AddRange(request.AdditionalProperties, additionalProperties);
                //request.AdditionalProperties.AddRange(additionalProperties);
            }
            return request.Execute();
        }
        else {
            return this.InternalGetAttachments(attachmentsOrIds, bodyType, additionalProperties, ServiceErrorHandling.ReturnErrors);
        }
    };
    /**
     * Gets attachments.
     *
     * @param   {string[]}                      attachmentIds          The attachment ids.
     * @param   {BodyType}                      bodyType               Type of the body.
     * @param   {PropertyDefinitionBase[]}      additionalProperties   The additional properties.
     * @return  {Promise<ServiceResponseCollection<GetAttachmentResponse>>}         Service response collection :Promise.
     */
    ExchangeService.prototype.InternalGetAttachments = function (attachments, bodyType, additionalProperties, errorHandling) {
        var request = new GetAttachmentRequest(this, errorHandling);
        ArrayHelper.AddRange(request.Attachments, attachments);
        request.BodyType = bodyType;
        if (additionalProperties != null) {
            ArrayHelper.AddRange(request.AdditionalProperties, additionalProperties);
            //request.AdditionalProperties.AddRange(additionalProperties);
        }
        return request.Execute();
    };
    ExchangeService.prototype.ExpandGroup = function (emailAddressOrsmtpAddressOrGroupId, routingType) {
        // EwsUtilities.ValidateParam(emailAddressOrsmtpAddressOrGroupId, "address");
        // EwsUtilities.ValidateParam(routingType, "routingType");
        //EwsUtilities.ValidateParam(emailAddress, "emailAddress");
        var emailAddress = new EmailAddress();
        if (emailAddressOrsmtpAddressOrGroupId instanceof EmailAddress) {
            emailAddress = emailAddressOrsmtpAddressOrGroupId;
        }
        else if (emailAddressOrsmtpAddressOrGroupId instanceof ItemId) {
            emailAddress.Id = emailAddressOrsmtpAddressOrGroupId;
        }
        else if (typeof emailAddressOrsmtpAddressOrGroupId === 'string') {
            emailAddress = new EmailAddress(emailAddressOrsmtpAddressOrGroupId);
        }
        if (routingType) {
            emailAddress.RoutingType = routingType;
        }
        var request = new ExpandGroupRequest(this);
        request.EmailAddress = emailAddress;
        return request.Execute().then(function (response) {
            return response.__thisIndexer(0).Members;
        });
    };
    /**
     * Get the password expiration date
     *
     * @param   {string}   mailboxSmtpAddress   The e-mail address of the user.
     * @return  {Promise<DateTime>}             The password expiration date :Promise.
     */
    ExchangeService.prototype.GetPasswordExpirationDate = function (mailboxSmtpAddress) {
        var request = new GetPasswordExpirationDateRequest(this);
        request.MailboxSmtpAddress = mailboxSmtpAddress;
        return request.Execute().then(function (response) {
            return response.PasswordExpirationDate;
        });
    };
    ExchangeService.prototype.ResolveName = function (nameToResolve, parentFolderIdsOrSearchScope, searchScopeOrReturnContactDetails, returnContactDetailsOrContactDataPropertySet, contactDataPropertySet) {
        if (contactDataPropertySet === void 0) { contactDataPropertySet = null; }
        var argsLength = arguments.length;
        if (argsLength < 1 && argsLength > 5) {
            throw new Error("ExchangeService.ts - ResolveName - invalid number of arguments, check documentation and try again.");
        }
        //position 1 - nameToResolve - no change, same for all overload
        var searchScope = null;
        var parentFolderIds = null;
        //position 2 - parentFolderIdsOrSearchScope
        if (argsLength >= 2) {
            if (typeof parentFolderIdsOrSearchScope === 'number') {
                searchScope = parentFolderIdsOrSearchScope;
            }
            else if (Array.isArray(parentFolderIdsOrSearchScope)) {
                parentFolderIds = parentFolderIdsOrSearchScope;
            }
            //could be null        
            // else {
            //     throw new Error("ExchangeService.ts - FindItems - incorrect uses of parameters at 2nd position, must be string, ViewBase or SearchFilter");
            // }
        }
        var returnContactDetails = false;
        //position 3 - searchScopeOrReturnContactDetails
        if (argsLength >= 3) {
            if (typeof searchScopeOrReturnContactDetails === 'boolean') {
                if (typeof parentFolderIdsOrSearchScope !== 'number') {
                    throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 2nd position, it must be ResolveNameSearchLocation when using boolean at 3rd place");
                }
                returnContactDetails = searchScopeOrReturnContactDetails;
            }
            else if (typeof searchScopeOrReturnContactDetails === 'number') {
                if (!Array.isArray(parentFolderIdsOrSearchScope)) {
                    throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 2nd position, it must be FolderId[] when using ResolveNameSearchLocation at 3rd place");
                }
                searchScope = searchScopeOrReturnContactDetails;
            }
            else {
                throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 3rd position, must be boolean, or ResolveNameSearchLocation");
            }
        }
        //position 4 - returnContactDetailsOrContactDataPropertySet
        if (argsLength >= 4) {
            if (returnContactDetailsOrContactDataPropertySet instanceof PropertySet) {
                if (typeof searchScopeOrReturnContactDetails !== 'boolean') {
                    throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 3rd position, it must be boolean when using PropertySet at 4th place");
                }
                contactDataPropertySet = returnContactDetailsOrContactDataPropertySet;
            }
            else if (typeof returnContactDetailsOrContactDataPropertySet === 'boolean') {
                if (typeof searchScopeOrReturnContactDetails !== 'number') {
                    throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 3rd position, it must be ResolveNameSearchLocation when using boolean at 4th place");
                }
                returnContactDetails = returnContactDetailsOrContactDataPropertySet;
            }
            else {
                throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 4th  position, must be  PropertySet or boolean");
            }
        }
        //position 5 - contactDataPropertySet
        if (argsLength >= 5) {
            if (typeof returnContactDetailsOrContactDataPropertySet !== 'boolean') {
                throw new Error("ExchangeService.ts - ResolveName with " + argsLength + " parameters - incorrect uses of parameter at 4th position, it must be boolean when using PropertySet at 5th place");
            }
        }
        var request = new ResolveNamesRequest(this);
        request.NameToResolve = nameToResolve;
        request.ReturnFullContactData = returnContactDetails;
        request.ParentFolderIds.AddRange(parentFolderIds);
        request.SearchLocation = searchScope;
        request.ContactDataPropertySet = contactDataPropertySet;
        return request.Execute().then(function (response) {
            return response.__thisIndexer(0).Resolutions;
        });
    };
    /* #endregion AD related operations */
    /* #region Notification operations */
    // BeginGetEvents(callback: Function /*System.AsyncCallback*/, state: any, subscriptionId: string, watermark: string): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginGetEvents : Not implemented."); }
    // BeginSubscribeToPullNotifications(callback: Function /*System.AsyncCallback*/, state: any, folderIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, timeout: number, watermark: string, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToPullNotifications : Not implemented."); }
    // BeginSubscribeToPullNotificationsOnAllFolders(callback: Function /*System.AsyncCallback*/, state: any, timeout: number, watermark: string, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToPullNotificationsOnAllFolders : Not implemented."); }
    // BeginSubscribeToPushNotifications(callback: Function /*System.AsyncCallback*/, state: any, folderIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, url: Uri, frequency: number, watermark: string, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToPushNotifications : Not implemented."); }
    // //BeginSubscribeToPushNotifications(callback: Function /*System.AsyncCallback*/, state: any, folderIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, url: Uri, frequency: number, watermark: string, callerData: string, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToPushNotifications : Not implemented."); }
    // BeginSubscribeToPushNotificationsOnAllFolders(callback: Function /*System.AsyncCallback*/, state: any, url: Uri, frequency: number, watermark: string, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToPushNotificationsOnAllFolders : Not implemented."); }
    // //BeginSubscribeToPushNotificationsOnAllFolders(callback: Function /*System.AsyncCallback*/, state: any, url: Uri, frequency: number, watermark: string, callerData: string, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToPushNotificationsOnAllFolders : Not implemented."); }
    // BeginSubscribeToStreamingNotifications(callback: Function /*System.AsyncCallback*/, state: any, folderIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToStreamingNotifications : Not implemented."); }
    // BeginSubscribeToStreamingNotificationsOnAllFolders(callback: Function /*System.AsyncCallback*/, state: any, eventTypes: any): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSubscribeToStreamingNotificationsOnAllFolders : Not implemented."); }
    // BeginUnsubscribe(callback: Function /*System.AsyncCallback*/, state: any, subscriptionId: string): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginUnsubscribe : Not implemented."); }
    /**
     * Builds an request to retrieve the latests events associated with a pull subscription.
     *
     * @param   {string}   subscriptionId   The Id of the pull subscription for which to get the events.
     * @param   {string}   watermark        The watermark representing the point in time where to start receiving events.
     * @return  {GetEventsRequest}          An request to retrieve the latests events associated with a pull subscription.
     */
    ExchangeService.prototype.BuildGetEventsRequest = function (subscriptionId, watermark) {
        EwsUtilities.ValidateParam(subscriptionId, "subscriptionId");
        EwsUtilities.ValidateParam(watermark, "watermark");
        var request = new GetEventsRequest(this);
        request.SubscriptionId = subscriptionId;
        request.Watermark = watermark;
        return request;
    };
    /**
     * Builds a request to subscribe to pull notifications in the authenticated user's mailbox.
     *
     * @param   {FolderId[]}    folderIds    The Ids of the folder to subscribe to.
     * @param   {number}        timeout      The timeout, in minutes, after which the subscription expires. Timeout must be between 1 and 1440.
     * @param   {string}        watermark    An optional watermark representing a previously opened subscription.
     * @param   {EventType[]}   eventTypes   The event types to subscribe to.
     * @return  {SubscribeToPullNotificationsRequest}   A request to subscribe to pull notifications in the authenticated user's mailbox.
     */
    ExchangeService.prototype.BuildSubscribeToPullNotificationsRequest = function (folderIds, timeout, watermark, eventTypes) {
        if (timeout < 1 || timeout > 1440) {
            throw new ArgumentOutOfRangeException("timeout", Strings.TimeoutMustBeBetween1And1440);
        }
        EwsUtilities.ValidateParamCollection(eventTypes, "eventTypes");
        var request = new SubscribeToPullNotificationsRequest(this);
        if (folderIds != null) {
            request.FolderIds.AddRange(folderIds);
        }
        request.Timeout = timeout;
        ArrayHelper.AddRange(request.EventTypes, eventTypes); //request.EventTypes.AddRange(eventTypes);
        request.Watermark = watermark;
        return request;
    };
    /**
     * Builds an request to request to subscribe to push notifications in the authenticated user's mailbox.
     *
     * @param   {FolderId[]}    folderIds    The Ids of the folder to subscribe to.
     * @param   {Uri}           url          The URL of the Web Service endpoint the Exchange server should push events to.
     * @param   {number}        frequency    The frequency, in minutes, at which the Exchange server should contact the Web Service endpoint. Frequency must be between 1 and 1440.
     * @param   {string}        watermark    An optional watermark representing a previously opened subscription.
     * @param   {string}        callerData   Optional caller data that will be returned the call back.
     * @param   {EventType[]}   eventTypes   The event types to subscribe to.
     * @return  {SubscribeToPushNotificationsRequest}       A request to request to subscribe to push notifications in the authenticated user's mailbox.
     */
    ExchangeService.prototype.BuildSubscribeToPushNotificationsRequest = function (folderIds, url, frequency, watermark, callerData, eventTypes) {
        EwsUtilities.ValidateParam(url, "url");
        if (frequency < 1 || frequency > 1440) {
            throw new ArgumentOutOfRangeException("frequency", Strings.FrequencyMustBeBetween1And1440);
        }
        EwsUtilities.ValidateParamCollection(eventTypes, "eventTypes");
        var request = new SubscribeToPushNotificationsRequest(this);
        if (folderIds != null) {
            request.FolderIds.AddRange(folderIds);
        }
        request.Url = url;
        request.Frequency = frequency;
        ArrayHelper.AddRange(request.EventTypes, eventTypes); //request.EventTypes.AddRange(eventTypes);
        request.Watermark = watermark;
        request.CallerData = callerData;
        return request;
    };
    /**
     * Builds request to subscribe to streaming notifications in the authenticated user's mailbox.
     *
     * @param   {FolderId[]}    folderIds    The Ids of the folder to subscribe to.
     * @param   {EventType[]}   eventTypes   The event types to subscribe to.
     * @return  {SubscribeToStreamingNotificationsRequest}      A request to subscribe to streaming notifications in the authenticated user's mailbox.
     */
    ExchangeService.prototype.BuildSubscribeToStreamingNotificationsRequest = function (folderIds, eventTypes) {
        EwsUtilities.ValidateParamCollection(eventTypes, "eventTypes");
        var request = new SubscribeToStreamingNotificationsRequest(this);
        if (folderIds != null) {
            request.FolderIds.AddRange(folderIds);
        }
        ArrayHelper.AddRange(request.EventTypes, eventTypes); //request.EventTypes.AddRange(eventTypes);
        return request;
    };
    /**
     * Buids a request to unsubscribe from a subscription.
     *
     * @param   {string}   subscriptionId   The Id of the subscription for which to get the events.
     * @return  {UnsubscribeRequest}        A request to unsubscribe from a subscription.
     */
    ExchangeService.prototype.BuildUnsubscribeRequest = function (subscriptionId) {
        EwsUtilities.ValidateParam(subscriptionId, "subscriptionId");
        var request = new UnsubscribeRequest(this);
        request.SubscriptionId = subscriptionId;
        return request;
    };
    //EndGetEvents(asyncResult: Function /*System.IAsyncResult*/): GetEventsResults { throw new Error("ExchangeService.ts - EndGetEvents : Not implemented."); }
    //EndSubscribeToPullNotifications(asyncResult: Function /*System.IAsyncResult*/): PullSubscription { throw new Error("ExchangeService.ts - EndSubscribeToPullNotifications : Not implemented."); }
    //EndSubscribeToPushNotifications(asyncResult: Function /*System.IAsyncResult*/): PushSubscription { throw new Error("ExchangeService.ts - EndSubscribeToPushNotifications : Not implemented."); }
    //EndSubscribeToStreamingNotifications(asyncResult: Function /*System.IAsyncResult*/): StreamingSubscription { throw new Error("ExchangeService.ts - EndSubscribeToStreamingNotifications : Not implemented."); }
    //EndUnsubscribe(asyncResult: Function /*System.IAsyncResult*/): any { throw new Error("ExchangeService.ts - EndUnsubscribe : Not implemented."); }
    /**
     * Retrieves the latests events associated with a pull subscription. Calling this method results in a call to EWS.
     *
     * @param   {string}   subscriptionId   The Id of the pull subscription for which to get the events.
     * @param   {string}   watermark        The watermark representing the point in time where to start receiving events.
     * @return  {Promise<GetEventsResults>}     A GetEventsResults containing a list of events associated with the subscription.
     */
    ExchangeService.prototype.GetEvents = function (subscriptionId, watermark) {
        return this.BuildGetEventsRequest(subscriptionId, watermark).Execute().then(function (response) {
            return response.__thisIndexer(0).Results;
        });
    };
    /**
     * Set a TeamMailbox
     *
     * @param   {EmailAddress}                  emailAddress        TeamMailbox email address
     * @param   {Uri}                           sharePointSiteUrl   SharePoint site URL
     * @param   {TeamMailboxLifecycleState}     state               TeamMailbox lifecycle state
     * @return  {Promise<void>}     Promise.
     */
    ExchangeService.prototype.SetTeamMailbox = function (emailAddress, sharePointSiteUrl, state) {
        EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2013, "SetTeamMailbox");
        if (emailAddress == null) {
            throw new ArgumentNullException("emailAddress");
        }
        if (sharePointSiteUrl == null) {
            throw new ArgumentNullException("sharePointSiteUrl");
        }
        var request = new SetTeamMailboxRequest(this, emailAddress, sharePointSiteUrl, state);
        return request.Execute();
    };
    /**
     * Subscribes to pull notifications. Calling this method results in a call to EWS   :Promise.
     *
     * @param   {FolderId[]}        folderIds    The Ids of the folder to subscribe to.
     * @param   {number}            timeout      The timeout, in minutes, after which the subscription expires. Timeout must be between 1 and 1440.
     * @param   {string}            watermark    An optional watermark representing a previously opened subscription.
     * @param   {...EventType[]}    eventTypes   The event types to subscribe to.
     * @return  {Promise<PullSubscription>}      A PullSubscription representing the new subscription.
     */
    ExchangeService.prototype.SubscribeToPullNotifications = function (folderIds, timeout, watermark) {
        var eventTypes = [];
        for (var _a = 3; _a < arguments.length; _a++) {
            eventTypes[_a - 3] = arguments[_a];
        }
        EwsUtilities.ValidateParamCollection(folderIds, "folderIds");
        return this.BuildSubscribeToPullNotificationsRequest(folderIds, timeout, watermark, eventTypes).Execute().then(function (response) {
            return response.__thisIndexer(0).Subscription;
        });
    };
    /**
     * Subscribes to pull notifications on all folders in the authenticated user's mailbox. Calling this method results in a call to EWS.   :Promise.
     *
     * @param   {FolderId[]}        folderIds    The Ids of the folder to subscribe to.
     * @param   {number}            timeout      The timeout, in minutes, after which the subscription expires. Timeout must be between 1 and 1440.
     * @param   {string}            watermark    An optional watermark representing a previously opened subscription.
     * @param   {...EventType[]}    eventTypes   The event types to subscribe to.
     * @return  {Promise<PullSubscription>}      A PullSubscription representing the new subscription.
     */
    ExchangeService.prototype.SubscribeToPullNotificationsOnAllFolders = function (timeout, watermark) {
        var eventTypes = [];
        for (var _a = 2; _a < arguments.length; _a++) {
            eventTypes[_a - 2] = arguments[_a];
        }
        EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2010, "SubscribeToPullNotificationsOnAllFolders");
        return this.BuildSubscribeToPullNotificationsRequest(null, timeout, watermark, eventTypes).Execute().then(function (response) {
            return response.__thisIndexer(0).Subscription;
        });
    };
    ExchangeService.prototype.SubscribeToPushNotifications = function (folderIds, url, frequency, watermark, callerDataOrEventTypes) {
        var eventTypes = [];
        for (var _a = 5; _a < arguments.length; _a++) {
            eventTypes[_a - 5] = arguments[_a];
        }
        EwsUtilities.ValidateParamCollection(folderIds, "folderIds");
        var callerData = null;
        if (typeof callerDataOrEventTypes === 'string') {
            callerData = callerDataOrEventTypes;
        }
        else {
            eventTypes.push(callerDataOrEventTypes); //info: ref: typescript generates eventTypes from arguments.length, need to push to it.
        }
        return this.BuildSubscribeToPushNotificationsRequest(folderIds, url, frequency, watermark, callerData, eventTypes).Execute().then(function (response) {
            return response.__thisIndexer(0).Subscription;
        });
    };
    ExchangeService.prototype.SubscribeToPushNotificationsOnAllFolders = function (url, frequency, watermark, callerDataOrEventTypes) {
        var eventTypes = [];
        for (var _a = 4; _a < arguments.length; _a++) {
            eventTypes[_a - 4] = arguments[_a];
        }
        EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2010, "SubscribeToPushNotificationsOnAllFolders");
        var callerData = null;
        if (typeof callerDataOrEventTypes === 'string') {
            callerData = callerDataOrEventTypes;
        }
        else {
            eventTypes.push(callerDataOrEventTypes); //info: ref: typescript generates eventTypes from arguments.length, need to push to it.
        }
        return this.BuildSubscribeToPushNotificationsRequest(null, url, frequency, watermark, callerData, eventTypes).Execute().then(function (response) {
            return response.__thisIndexer(0).Subscription;
        });
    };
    /**
     * Subscribes to streaming notifications. Calling this method results in a call to EWS.
     *
     * @param   {FolderId[]}   folderIds    The Ids of the folder to subscribe to.
     * @param   {EventType[]}   eventTypes   The event types to subscribe to.
     * @return  {Promise<StreamingSubscription>}        A StreamingSubscription representing the new subscription   :Promise.
     */
    ExchangeService.prototype.SubscribeToStreamingNotifications = function (folderIds) {
        var eventTypes = [];
        for (var _a = 1; _a < arguments.length; _a++) {
            eventTypes[_a - 1] = arguments[_a];
        }
        EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2010_SP1, "SubscribeToStreamingNotifications");
        EwsUtilities.ValidateParamCollection(folderIds, "folderIds");
        return this.BuildSubscribeToStreamingNotificationsRequest(folderIds, eventTypes).Execute().then(function (responses) {
            return responses.__thisIndexer(0).Subscription;
        });
    };
    /**
     * Subscribes to streaming notifications on all folders in the authenticated user's mailbox. Calling this method results in a call to EWS.
     *
     * @param   {EventType[]}   eventTypes   The event types to subscribe to.
     * @return  {Promise<StreamingSubscription>}        A StreamingSubscription representing the new subscription   :Promise.
     */
    ExchangeService.prototype.SubscribeToStreamingNotificationsOnAllFolders = function () {
        var eventTypes = [];
        for (var _a = 0; _a < arguments.length; _a++) {
            eventTypes[_a] = arguments[_a];
        }
        EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2010_SP1, "SubscribeToStreamingNotificationsOnAllFolders");
        return this.BuildSubscribeToStreamingNotificationsRequest(null, eventTypes).Execute().then(function (responses) {
            return responses.__thisIndexer(0).Subscription;
        });
    };
    /**
     * Unpin a TeamMailbox
     *
     * @param   {EmailAddress}      emailAddress        TeamMailbox email address
     * @return  {Promise<void>}     Promise.
     */
    ExchangeService.prototype.UnpinTeamMailbox = function (emailAddress) {
        EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2013, "UnpinTeamMailbox");
        if (emailAddress == null) {
            throw new ArgumentNullException("emailAddress");
        }
        var request = new UnpinTeamMailboxRequest(this, emailAddress);
        return request.Execute();
    };
    /**
     * @internal Unsubscribes from a subscription. Calling this method results in a call to EWS.
     *
     * @param   {string}   subscriptionId   The Id of the pull subscription to unsubscribe from.
     */
    ExchangeService.prototype.Unsubscribe = function (subscriptionId) {
        return this.BuildUnsubscribeRequest(subscriptionId).Execute();
    };
    /* #endregion Notification operations */
    /* #region Synchronization operations */
    // BeginSyncFolderItems(callback: Function /*System.AsyncCallback*/, state: any, syncFolderId: FolderId, propertySet: PropertySet, ignoredItemIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, maxChangesReturned: number, syncScope: SyncFolderItemsScope, syncState: string): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSyncFolderItems : Not implemented."); }
    // BeginSyncFolderItems(callback: Function /*System.AsyncCallback*/, state: any, syncFolderId: FolderId, propertySet: PropertySet, ignoredItemIds: any[] /*System.Collections.Generic.IEnumerable<T>*/, maxChangesReturned: number, numberOfDays: number, syncScope: SyncFolderItemsScope, syncState: string): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSyncFolderItems : Not implemented."); }
    /**
     * Builds a request to synchronize the items of a specific folder.
     *
     * @param   {FolderId}              syncFolderId         The Id of the folder containing the items to synchronize with.
     * @param   {PropertySet}           propertySet          The set of properties to retrieve for synchronized items.
     * @param   {ItemId[]}              ignoredItemIds       The optional list of item Ids that should be ignored.
     * @param   {number}                maxChangesReturned   The maximum number of changes that should be returned.
     * @param   {number}                numberOfDays         Limit the changes returned to this many days ago; 0 means no limit.
     * @param   {SyncFolderItemsScope}  syncScope            The sync scope identifying items to include in the ChangeCollection.
     * @param   {string}                syncState            The optional sync state representing the point in time when to start the synchronization.
     * @return  {SyncFolderItemsRequest}        A request to synchronize the items of a specific folder.
     */
    ExchangeService.prototype.BuildSyncFolderItemsRequest = function (syncFolderId, propertySet, ignoredItemIds, maxChangesReturned, numberOfDays, syncScope, syncState) {
        EwsUtilities.ValidateParam(syncFolderId, "syncFolderId");
        EwsUtilities.ValidateParam(propertySet, "propertySet");
        var request = new SyncFolderItemsRequest(this);
        request.SyncFolderId = syncFolderId;
        request.PropertySet = propertySet;
        if (ignoredItemIds != null) {
            request.IgnoredItemIds.AddRange(ignoredItemIds);
        }
        request.MaxChangesReturned = maxChangesReturned;
        request.NumberOfDays = numberOfDays;
        request.SyncScope = syncScope;
        request.SyncState = syncState;
        return request;
    };
    ExchangeService.prototype.SyncFolderItems = function (syncFolderId, propertySet, ignoredItemIds, maxChangesReturned, numberOfDaysOrSyncScope, syncScopeOrSyncState, syncState) {
        if (syncState === void 0) { syncState = null; }
        var numberOfDays = 0;
        var syncScope;
        if (arguments.length === 6) {
            syncState = syncScopeOrSyncState;
            syncScope = numberOfDaysOrSyncScope;
        }
        else {
            numberOfDays = numberOfDaysOrSyncScope;
            syncScope = syncScopeOrSyncState;
        }
        return this.BuildSyncFolderItemsRequest(syncFolderId, propertySet, ignoredItemIds, maxChangesReturned, numberOfDays, syncScope, syncState).Execute().then(function (responses) {
            return responses.__thisIndexer(0).Changes;
        });
    };
    // BeginSyncFolderHierarchy(callback: Function /*System.AsyncCallback*/, state: any, propertySet: PropertySet, syncState: string): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSyncFolderHierarchy : Not implemented."); }
    // //BeginSyncFolderHierarchy(callback: Function /*System.AsyncCallback*/, state: any, syncFolderId: FolderId, propertySet: PropertySet, syncState: string): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSyncFolderHierarchy : Not implemented."); }
    /**
     * Builds a request to synchronize the specified folder hierarchy of the mailbox this Service is connected to.
     *
     * @param   {FolderId}      syncFolderId   The Id of the folder containing the items to synchronize with. A null value indicates the root folder of the mailbox.
     * @param   {PropertySet}   propertySet    The set of properties to retrieve for synchronized items.
     * @param   {string}        syncState      The optional sync state representing the point in time when to start the synchronization.
     * @return  {SyncFolderHierarchyRequest}        A request to synchronize the specified folder hierarchy of the mailbox this Service is connected to.
     */
    ExchangeService.prototype.BuildSyncFolderHierarchyRequest = function (syncFolderId, propertySet, syncState) {
        EwsUtilities.ValidateParamAllowNull(syncFolderId, "syncFolderId"); // Null syncFolderId is allowed
        EwsUtilities.ValidateParam(propertySet, "propertySet");
        var request = new SyncFolderHierarchyRequest(this);
        request.PropertySet = propertySet;
        request.SyncFolderId = syncFolderId;
        request.SyncState = syncState;
        return request;
    };
    ExchangeService.prototype.SyncFolderHierarchy = function (syncFolderIdOrPropertySet, propertySetOrSyncState, syncState) {
        if (syncState === void 0) { syncState = null; }
        var syncFolderId = null;
        var propertySet;
        if (arguments.length === 2) {
            propertySet = syncFolderIdOrPropertySet;
            syncState = propertySetOrSyncState;
        }
        else {
            syncFolderId = syncFolderIdOrPropertySet;
            propertySet = propertySetOrSyncState;
        }
        return this.BuildSyncFolderHierarchyRequest(syncFolderId, propertySet, syncState).Execute().then(function (responses) {
            return responses.__thisIndexer(0).Changes;
        });
    };
    /* #endregion Synchronization operations */
    /* #region Availability operations */
    /**
     * Retrieves a collection of all room lists in the organization.
     *
     * @return  {Promise<EmailAddressCollection[]>}     A collection of EmailAddress objects representing all the rooms within the specifed room list   :Promise.
     */
    ExchangeService.prototype.GetRoomLists = function () {
        var request = new GetRoomListsRequest(this);
        return request.Execute().then(function (response) {
            return response.RoomLists;
        });
    };
    /**
     * Retrieves a collection of all rooms in the specified room list in the organization.
     *
     * @param   {EmailAddress}   emailAddress   The e-mail address of the room list.
     * @return  {Promise<EmailAddress[]>}       A collection of EmailAddress objects representing all the rooms within the specifed room list   :Promise.
     */
    ExchangeService.prototype.GetRooms = function (emailAddress) {
        EwsUtilities.ValidateParam(emailAddress, "emailAddress");
        var request = new GetRoomsRequest(this);
        request.RoomList = emailAddress;
        return request.Execute().then(function (response) {
            return response.Rooms;
        });
    };
    ExchangeService.prototype.GetUserAvailability = function (attendees, timeWindow, requestedData, options) {
        if (options === void 0) { options = new AvailabilityOptions(); }
        EwsUtilities.ValidateParamCollection(attendees, "attendees");
        EwsUtilities.ValidateParam(timeWindow, "timeWindow");
        EwsUtilities.ValidateParam(options, "options");
        var request = new GetUserAvailabilityRequest(this);
        request.Attendees = attendees;
        request.TimeWindow = timeWindow;
        request.RequestedData = requestedData;
        request.Options = options;
        return request.Execute().then(function (responses) {
            return responses;
        });
    };
    /**
     * Gets Out of Office (OOF) settings for a specific user. Calling this method results in a call to EWS.
     *
     * @param   {string}   smtpAddress   The SMTP address of the user for which to retrieve OOF settings.
     * @return  {Promise<OofSettings>}   An OofSettings instance containing OOF information for the specified user.
     */
    ExchangeService.prototype.GetUserOofSettings = function (smtpAddress) {
        EwsUtilities.ValidateParam(smtpAddress, "smtpAddress");
        var request = new GetUserOofSettingsRequest(this);
        request.SmtpAddress = smtpAddress;
        return request.Execute().then(function (response) {
            return response.OofSettings;
        });
    };
    /**
     * Sets the Out of Office (OOF) settings for a specific mailbox. Calling this method results in a call to EWS.
     *
     * @param   {string}        smtpAddress   The SMTP address of the user for which to set OOF settings.
     * @param   {OofSettings}   oofSettings   The OOF settings.
     * @return  {Promise<void>}      Promise.
     */
    ExchangeService.prototype.SetUserOofSettings = function (smtpAddress, oofSettings) {
        EwsUtilities.ValidateParam(smtpAddress, "smtpAddress");
        EwsUtilities.ValidateParam(oofSettings, "oofSettings");
        var request = new SetUserOofSettingsRequest(this);
        request.SmtpAddress = smtpAddress;
        request.OofSettings = oofSettings;
        return request.Execute();
    };
    /* #endregion Availability operations */
    /* #region Conversation */
    /**
     * Applies ConversationAction on the specified conversation.
     *
     * @param   {ConversationActionType}    actionType            ConversationAction
     * @param   {ConversationId[]}          conversationIds       The conversation ids.
     * @param   {boolean}                   processRightAway      True to process at once . This is blocking and false to let the Assistant process it in the back ground
     * @param   {StringList}                categories            Catgories that need to be stamped can be null or empty
     * @param   {boolean}                   enableAlwaysDelete    True moves every current and future messages in the conversation to deleted items folder. False stops the alwasy delete action. This is applicable only if the action is AlwaysDelete
     * @param   {FolderId}                  destinationFolderId   Applicable if the action is AlwaysMove. This moves every current message and future  message in the conversation to the specified folder. Can be null if tis is then it stops the always move action
     * @param   {ServiceErrorHandling}      errorHandlingMode     The error handling mode.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    ExchangeService.prototype.ApplyConversationAction = function (actionType, conversationIds, processRightAway, categories, enableAlwaysDelete, destinationFolderId, errorHandlingMode) {
        EwsLogging.Assert(actionType == ConversationActionType.AlwaysCategorize ||
            actionType == ConversationActionType.AlwaysMove ||
            actionType == ConversationActionType.AlwaysDelete, "ApplyConversationAction", "Invalic actionType");
        EwsUtilities.ValidateParam(conversationIds, "conversationId");
        EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2010_SP1, "ApplyConversationAction");
        var request = new ApplyConversationActionRequest(this, errorHandlingMode);
        var action = new ConversationAction();
        for (var _a = 0, conversationIds_1 = conversationIds; _a < conversationIds_1.length; _a++) {
            var conversationId = conversationIds_1[_a];
            action.Action = actionType;
            action.ConversationId = conversationId;
            action.ProcessRightAway = processRightAway;
            action.Categories = categories;
            action.EnableAlwaysDelete = enableAlwaysDelete;
            action.DestinationFolderId = destinationFolderId != null ? new FolderIdWrapper(destinationFolderId) : null;
            request.ConversationActions.push(action);
        }
        return request.Execute();
    };
    /**
     * Applies one time conversation action on items in specified folder inside the conversation.
     *
     * @param   {ConversationActionType}                        actionType             The action.
     * @param   {KeyValuePair<ConversationId, DateTime?>[]}     idTimePairs            The id time pairs.
     * @param   {FolderId}                                      contextFolderId        The context folder id.
     * @param   {FolderId}                                      destinationFolderId    The destination folder id.
     * @param   {DeleteMode}                                    deleteType             Type of the delete.
     * @param   {boolean}                                       isRead                 The is read.
     * @param   {RetentionType}                                 retentionPolicyType    Retention policy type.
     * @param   {Guid}                                          retentionPolicyTagId   Retention policy tag id.  Null will clear the policy.
     * @param   {Flag}                                          flag                   Flag status.
     * @param   {boolean}                                       suppressReadReceipts   Suppress read receipts flag.
     * @param   {ServiceErrorHandling}                          errorHandlingMode      The error handling mode.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    ExchangeService.prototype.ApplyConversationOneTimeAction = function (actionType, idTimePairs, // IEnumerable<KeyValuePair<ConversationId, DateTime?>> idTimePairs,
        contextFolderId, destinationFolderId, deleteType, isRead, retentionPolicyType, retentionPolicyTagId, flag, suppressReadReceipts, errorHandlingMode) {
        EwsLogging.Assert(actionType == ConversationActionType.Move ||
            actionType == ConversationActionType.Delete ||
            actionType == ConversationActionType.SetReadState ||
            actionType == ConversationActionType.SetRetentionPolicy ||
            actionType == ConversationActionType.Copy ||
            actionType == ConversationActionType.Flag, "ApplyConversationOneTimeAction", "Invalid actionType");
        EwsUtilities.ValidateParamCollection(idTimePairs, "idTimePairs");
        EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2010_SP1, "ApplyConversationAction");
        var request = new ApplyConversationActionRequest(this, errorHandlingMode);
        for (var _a = 0, idTimePairs_1 = idTimePairs; _a < idTimePairs_1.length; _a++) {
            var idTimePair = idTimePairs_1[_a];
            var action = new ConversationAction();
            action.Action = actionType;
            action.ConversationId = idTimePair.key;
            action.ContextFolderId = contextFolderId != null ? new FolderIdWrapper(contextFolderId) : null;
            action.DestinationFolderId = destinationFolderId != null ? new FolderIdWrapper(destinationFolderId) : null;
            action.ConversationLastSyncTime = idTimePair.value;
            action.IsRead = isRead;
            action.DeleteType = deleteType;
            action.RetentionPolicyType = retentionPolicyType;
            action.RetentionPolicyTagId = retentionPolicyTagId;
            action.Flag = flag;
            action.SuppressReadReceipts = suppressReadReceipts;
            request.ConversationActions.push(action);
        }
        return request.Execute();
    };
    /**
     * Sets up a conversation so that any item received within that conversation is no longer categorized. Calling this method results in a call to EWS.
     *
     * @param   {ConversationId[]}  conversationId         The id of the conversation.
     * @param   {boolean}           processSynchronously   Indicates whether the method should return only once disabling this rule and removing the categories from existing items in the conversation is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    ExchangeService.prototype.DisableAlwaysCategorizeItemsInConversations = function (conversationId, processSynchronously) {
        return this.ApplyConversationAction(ConversationActionType.AlwaysCategorize, conversationId, processSynchronously, null, false, null, ServiceErrorHandling.ReturnErrors);
    };
    /**
     * Sets up a conversation so that any item received within that conversation is no longer moved to Deleted Items folder. Calling this method results in a call to EWS.
     *
     * @param   {ConversationId[]}  conversationId         The id of the conversation.
     * @param   {boolean}           processSynchronously   Indicates whether the method should return only once disabling this rule and restoring the items in the conversation is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    ExchangeService.prototype.DisableAlwaysDeleteItemsInConversations = function (conversationId, processSynchronously) {
        return this.ApplyConversationAction(ConversationActionType.AlwaysDelete, conversationId, processSynchronously, null, false, null, ServiceErrorHandling.ReturnErrors);
    };
    /**
     * Sets up a conversation so that any item received within that conversation is no longer moved to a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {ConversationId[]}  conversationIds        The conversation ids.
     * @param   {boolean}           processSynchronously   Indicates whether the method should return only once disabling this rule is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    ExchangeService.prototype.DisableAlwaysMoveItemsInConversations = function (conversationIds, processSynchronously) {
        return this.ApplyConversationAction(ConversationActionType.AlwaysMove, conversationIds, processSynchronously, null, false, null, ServiceErrorHandling.ReturnErrors);
    };
    /**
     * Sets up a conversation so that any item received within that conversation is always categorized. Calling this method results in a call to EWS.
     *
     * @param   {ConversationId[]}  conversationId         The id of the conversation.
     * @param   {string[]}          categories             The categories that should be stamped on items in the conversation.
     * @param   {boolean}           processSynchronously   Indicates whether the method should return only once enabling this rule and stamping existing items in the conversation is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    ExchangeService.prototype.EnableAlwaysCategorizeItemsInConversations = function (conversationId, categories, processSynchronously) {
        EwsUtilities.ValidateParamCollection(categories, "categories");
        return this.ApplyConversationAction(ConversationActionType.AlwaysCategorize, conversationId, processSynchronously, new StringList(categories), false, null, ServiceErrorHandling.ReturnErrors);
    };
    /**
     * Sets up a conversation so that any item received within that conversation is always moved to Deleted Items folder. Calling this method results in a call to EWS.
     *
     * @param   {ConversationId[]}  conversationId         The id of the conversation.
     * @param   {boolean}           processSynchronously   Indicates whether the method should return only once enabling this rule and deleting existing items in the conversation is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    ExchangeService.prototype.EnableAlwaysDeleteItemsInConversations = function (conversationId, processSynchronously) {
        return this.ApplyConversationAction(ConversationActionType.AlwaysDelete, conversationId, processSynchronously, null, true, null, ServiceErrorHandling.ReturnErrors);
    };
    /**
     * Sets up a conversation so that any item received within that conversation is always moved to a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {ConversationId[]}  conversationId         The id of the conversation.
     * @param   {FolderId}          destinationFolderId    The Id of the folder to which conversation items should be moved.
     * @param   {boolean}           processSynchronously   Indicates whether the method should return only once enabling this rule and moving existing items in the conversation is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    ExchangeService.prototype.EnableAlwaysMoveItemsInConversations = function (conversationId, destinationFolderId, processSynchronously) {
        EwsUtilities.ValidateParam(destinationFolderId, "destinationFolderId");
        return this.ApplyConversationAction(ConversationActionType.AlwaysMove, conversationId, processSynchronously, null, false, destinationFolderId, ServiceErrorHandling.ReturnErrors);
    };
    ExchangeService.prototype.FindConversation = function (view, folderId, queryString, returnHighlightTerms, mailboxScope) {
        if (queryString === void 0) { queryString = null; }
        if (returnHighlightTerms === void 0) { returnHighlightTerms = null; }
        if (mailboxScope === void 0) { mailboxScope = null; }
        var argsLength = arguments.length;
        EwsUtilities.ValidateParam(view, "view");
        EwsUtilities.ValidateParam(folderId, "folderId");
        var request = new FindConversationRequest(this);
        request.View = view;
        request.FolderId = new FolderIdWrapper(folderId);
        if (argsLength > 2) {
            EwsUtilities.ValidateParamAllowNull(queryString, "queryString");
            request.QueryString = queryString;
        }
        if (argsLength > 3) {
            EwsUtilities.ValidateParam(returnHighlightTerms, "returnHighlightTerms");
            request.ReturnHighlightTerms = returnHighlightTerms;
            EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2013, // This method is only applicable for Exchange2013
            "FindConversation");
        }
        if (argsLength > 4) {
            request.MailboxScope = mailboxScope;
        }
        return request.Execute().then(function (responses) {
            if (argsLength > 3) {
                return responses.Results; // based on arguments it can return this or either Results.
            }
            else {
                return responses.Conversations;
            }
        });
    };
    /**
     * Retrieves a collection of all Conversations in the specified Folder.
     *
     * @param   {ViewBase}  view            The view controlling the number of conversations returned.
     * @param   {FolderId}  folderId        The Id of the folder in which to search for conversations.
     * @param   {string}    anchorMailbox   The anchorMailbox Smtp address to route the request directly to group mailbox.
     * @return  {Promise<Conversation[]>}   Collection of conversations :Promise.
     */
    ExchangeService.prototype.FindGroupConversation = function (view, folderId, anchorMailbox) {
        EwsUtilities.ValidateParam(view, "view");
        EwsUtilities.ValidateParam(folderId, "folderId");
        EwsUtilities.ValidateParam(anchorMailbox, "anchorMailbox");
        EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2015, "FindConversation");
        var request = new FindConversationRequest(this);
        request.View = view;
        request.FolderId = new FolderIdWrapper(folderId);
        request.AnchorMailbox = anchorMailbox;
        return request.Execute().then(function (responses) {
            return responses.Conversations;
        });
    };
    ExchangeService.prototype.GetConversationItems = function (conversationsOrConversationId, propertySet, foldersToIgnoreOrSyncState, sortOrderOrFoldersToIgnore, mailboxScopeOrSortOrder) {
        if (mailboxScopeOrSortOrder === void 0) { mailboxScopeOrSortOrder = null; }
        var conversations = [];
        var foldersToIgnore = [];
        var syncState = null;
        var sortOrder = null;
        var mailboxScope = null;
        var returnConversationResponse = false;
        if (conversationsOrConversationId instanceof ConversationId) {
            conversations.push(new ConversationRequest(conversationsOrConversationId, foldersToIgnoreOrSyncState));
            foldersToIgnore = sortOrderOrFoldersToIgnore;
            sortOrder = mailboxScopeOrSortOrder;
            returnConversationResponse = true;
        }
        else {
            conversations = conversationsOrConversationId;
            foldersToIgnore = foldersToIgnoreOrSyncState;
            sortOrder = sortOrderOrFoldersToIgnore;
            mailboxScope = mailboxScopeOrSortOrder;
        }
        return this.InternalGetConversationItems(conversations, propertySet, foldersToIgnore, sortOrder, //todo: check why official repo has passed sortOrder as nulll when requested with ConversationRequest[] varient
        mailboxScope, /* mailboxScope */ null, /* maxItemsToReturn */ null, /* anchorMailbox */ ServiceErrorHandling.ThrowOnError).then(function (responses) {
            return returnConversationResponse ? responses.__thisIndexer(0).Conversation : responses;
        });
    };
    /**
     * Gets the items for a conversation.
     *
     * /remarks/    This API designed to be used primarily in groups scenarios where we want to set the anchor mailbox header so that request is routed directly to the group mailbox backend server.
     * @param   {ConversationId}            conversationId    The conversation id.
     * @param   {PropertySet}               propertySet       The set of properties to load.
     * @param   {string}                    syncState         The optional sync state representing the point in time when to start the synchronization.
     * @param   {FolderId[]}                foldersToIgnore   The folders to ignore.
     * @param   {ConversationSortOrder}     sortOrder         Conversation item sort order.
     * @param   {string}                    anchorMailbox     The smtp address of the mailbox hosting the conversations
     * @return  {Promise<ConversationResponse>}               ConversationResponseType response :Promise.
     */
    ExchangeService.prototype.GetGroupConversationItems = function (conversationId, propertySet, syncState, foldersToIgnore, sortOrder /* Nullable */, anchorMailbox) {
        EwsUtilities.ValidateParam(anchorMailbox, "anchorMailbox");
        var conversations = [];
        conversations.push(new ConversationRequest(conversationId, syncState));
        return this.InternalGetConversationItems(conversations, propertySet, foldersToIgnore, sortOrder, null, /* mailboxScope */ null, /* maxItemsToReturn */ anchorMailbox, /* anchorMailbox */ ServiceErrorHandling.ThrowOnError).then(function (responses) {
            return responses.__thisIndexer(0).Conversation;
        });
    };
    /**
     * @internal Gets the items for a set of conversations.
     *
     * @param   {ConversationRequest[]}     conversations      Conversations with items to load.
     * @param   {PropertySet}               propertySet        The set of properties to load.
     * @param   {FolderId[]}                foldersToIgnore    The folders to ignore.
     * @param   {ConversationSortOrder?}    sortOrder          Sort order of conversation tree nodes.
     * @param   {MailboxSearchLocation?}    mailboxScope       The mailbox scope to reference.
     * @param   {number?}                   maxItemsToReturn   Maximum number of items to return.
     * @param   {string}                    anchorMailbox      The smtpaddress of the mailbox that hosts the conversations
     * @param   {ServiceErrorHandling}      errorHandling      What type of error handling should be performed.
     * @return  {Promise<ServiceResponseCollection<GetConversationItemsResponse>>}      GetConversationItems response.
     */
    ExchangeService.prototype.InternalGetConversationItems = function (conversations, propertySet, foldersToIgnore, sortOrder, //Nullable
        mailboxScope, //Nullable
        maxItemsToReturn, //nullable
        anchorMailbox, errorHandling) {
        EwsUtilities.ValidateParam(conversations, "conversations");
        EwsUtilities.ValidateParam(propertySet, "itemProperties");
        EwsUtilities.ValidateParamAllowNull(foldersToIgnore, "foldersToIgnore");
        EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2013, "GetConversationItems");
        var request = new GetConversationItemsRequest(this, errorHandling);
        request.ItemProperties = propertySet;
        request.FoldersToIgnore = new FolderIdCollection(foldersToIgnore);
        request.SortOrder = sortOrder;
        request.MailboxScope = mailboxScope;
        request.MaxItemsToReturn = maxItemsToReturn;
        request.AnchorMailbox = anchorMailbox;
        request.Conversations = conversations;
        return request.Execute();
    };
    /**
     * Copies the items in the specified conversation to the specified destination folder. Calling this method results in a call to EWS.
     *
     * @param   {KeyValuePair<ConversationId, DateTime?>[]}     idLastSyncTimePairs   The pairs of Id of conversation whose items should be copied and the date and time conversation was last synced (Items received after that date will not be copied).
     * @param   {FolderId}                                      contextFolderId       The context folder id.
     * @param   {FolderId}                                      destinationFolderId   The destination folder id.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    ExchangeService.prototype.CopyItemsInConversations = function (idLastSyncTimePairs, // IEnumerable<KeyValuePair<ConversationId, DateTime?>> idTimePairs, - DateTime is Nullable
        contextFolderId, destinationFolderId) {
        EwsUtilities.ValidateParam(destinationFolderId, "destinationFolderId");
        return this.ApplyConversationOneTimeAction(ConversationActionType.Copy, idLastSyncTimePairs, contextFolderId, destinationFolderId, null, null, null, null, null, null, ServiceErrorHandling.ReturnErrors);
    };
    /**
     * Deletes the items in the specified conversation. Calling this method results in a call to EWS.
     *
     * @param   {KeyValuePair<ConversationId, DateTime?>[]}     idLastSyncTimePairs   The pairs of Id of conversation whose items should be deleted and the date and time conversation was last synced (Items received after that date will not be deleted).
     * @param   {FolderId}                                      contextFolderId       The Id of the folder that contains the conversation.
     * @param   {DeleteMode}                                    deleteMode            The deletion mode.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    ExchangeService.prototype.DeleteItemsInConversations = function (idLastSyncTimePairs, // IEnumerable<KeyValuePair<ConversationId, DateTime?>> idTimePairs, - DateTime is Nullable
        contextFolderId, deleteMode) {
        return this.ApplyConversationOneTimeAction(ConversationActionType.Delete, idLastSyncTimePairs, contextFolderId, null, deleteMode, null, null, null, null, null, ServiceErrorHandling.ReturnErrors);
    };
    /**
     * Moves the items in the specified conversation to the specified destination folder. Calling this method results in a call to EWS.
     *
     * @param   {KeyValuePair<ConversationId, DateTime?>[]}     idLastSyncTimePairs   The pairs of Id of conversation whose items should be moved and the dateTime conversation was last synced (Items received after that dateTime will not be moved).
     * @param   {FolderId}                                      contextFolderId       The Id of the folder that contains the conversation.
     * @param   {FolderId}                                      destinationFolderId   The Id of the destination folder.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    ExchangeService.prototype.MoveItemsInConversations = function (idLastSyncTimePairs, // IEnumerable<KeyValuePair<ConversationId, DateTime?>> idTimePairs, - DateTime is Nullable
        contextFolderId, destinationFolderId) {
        EwsUtilities.ValidateParam(destinationFolderId, "destinationFolderId");
        return this.ApplyConversationOneTimeAction(ConversationActionType.Move, idLastSyncTimePairs, contextFolderId, destinationFolderId, null, null, null, null, null, null, ServiceErrorHandling.ReturnErrors);
    };
    /**
     * Sets flag status for items in conversation. Calling this method would result in call to EWS.
     *
     * @param   {KeyValuePair<ConversationId, DateTime?>[]}   idLastSyncTimePairs   The pairs of Id of conversation whose items should have their read state set and the date and time conversation was last synced (Items received after that date will not have their read state set).
     * @param   {FolderId}   contextFolderId       The Id of the folder that contains the conversation.
     * @param   {Flag}   flagStatus            Flag status to apply to conversation items.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    ExchangeService.prototype.SetFlagStatusForItemsInConversations = function (idLastSyncTimePairs, // IEnumerable<KeyValuePair<ConversationId, DateTime?>> idTimePairs, - DateTime is Nullable
        contextFolderId, flagStatus) {
        EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2013, "SetFlagStatusForItemsInConversations");
        return this.ApplyConversationOneTimeAction(ConversationActionType.Flag, idLastSyncTimePairs, contextFolderId, null, null, null, null, null, flagStatus, null, ServiceErrorHandling.ReturnErrors);
    };
    ExchangeService.prototype.SetReadStateForItemsInConversations = function (idLastSyncTimePairs, // IEnumerable<KeyValuePair<ConversationId, DateTime?>> idTimePairs, - DateTime is Nullable
        contextFolderId, isRead, suppressReadReceipts) {
        if (suppressReadReceipts === void 0) { suppressReadReceipts = null; }
        if (arguments.length === 4) {
            EwsUtilities.ValidateMethodVersion(this, ExchangeVersion.Exchange2013, "SetReadStateForItemsInConversations");
        }
        return this.ApplyConversationOneTimeAction(ConversationActionType.SetReadState, idLastSyncTimePairs, contextFolderId, null, null, isRead, null, null, null, suppressReadReceipts, //null when not included in call
        ServiceErrorHandling.ReturnErrors);
    };
    /**
     * Sets the retention policy for items in conversation. Calling this method would result in call to EWS.
     *
     * @param   {KeyValuePair<ConversationId, DateTime?>[]}     idLastSyncTimePairs    The pairs of Id of conversation whose items should have their retention policy set and the date and time conversation was last synced (Items received after that date will not have their retention policy set).
     * @param   {FolderId}                                      contextFolderId        The Id of the folder that contains the conversation.
     * @param   {RetentionType}                                 retentionPolicyType    Retention policy type.
     * @param   {Guid?}                                         retentionPolicyTagId   Retention policy tag id.  Null will clear the policy.
     * @return  {Promise<ServiceResponseCollection<ServiceResponse>>}       :Promise
     */
    ExchangeService.prototype.SetRetentionPolicyForItemsInConversations = function (idLastSyncTimePairs, // IEnumerable<KeyValuePair<ConversationId, DateTime?>> idTimePairs, - DateTime is Nullable
        contextFolderId, retentionPolicyType, retentionPolicyTagId) {
        return this.ApplyConversationOneTimeAction(ConversationActionType.SetRetentionPolicy, idLastSyncTimePairs, contextFolderId, null, null, null, retentionPolicyType, retentionPolicyTagId, null, null, ServiceErrorHandling.ReturnErrors);
    };
    /* #end region Conversation */
    /* #region Id conversion operations */
    /**
     * Converts Id from one format to another in a single call to EWS.
     *
     * @param   {AlternateIdBase}   id                 The Id to convert.
     * @param   {IdFormat}          destinationFormat   The destination format.
     * @return  {Promise<AlternateIdBase>}     The converted Id :Promise.
     */
    ExchangeService.prototype.ConvertId = function (id, destinationFormat) {
        EwsUtilities.ValidateParam(id, "id");
        return this.InternalConvertIds([id], destinationFormat, ServiceErrorHandling.ThrowOnError).then(function (responses) {
            return responses.__thisIndexer(0).ConvertedId;
        });
    };
    /**
     * Converts multiple Ids from one format to another in a single call to EWS.
     *
     * @param   {AlternateIdBase[]}     ids                 The Ids to convert.
     * @param   {IdFormat}              destinationFormat   The destination format.
     * @return  {Promise<ServiceResponseCollection<ConvertIdResponse>>}     A ServiceResponseCollection providing conversion results for each specified Ids :Promise.
     */
    ExchangeService.prototype.ConvertIds = function (ids, destinationFormat) {
        EwsUtilities.ValidateParamCollection(ids, "ids");
        return this.InternalConvertIds(ids, destinationFormat, ServiceErrorHandling.ReturnErrors);
    };
    /**
     * Converts multiple Ids from one format to another in a single call to EWS.
     *
     * @param   {AlternateIdBase[]}     ids                 The Ids to convert.
     * @param   {IdFormat}              destinationFormat   The destination format.
     * @param   {ServiceErrorHandling}  errorHandling       Type of error handling to perform.
     * @return  {Promise<ServiceResponseCollection<ConvertIdResponse>>}     A ServiceResponseCollection providing conversion results for each specified Ids :Promise.
     */
    ExchangeService.prototype.InternalConvertIds = function (ids, destinationFormat, errorHandling) {
        EwsUtilities.ValidateParamCollection(ids, "ids");
        var request = new ConvertIdRequest(this, errorHandling);
        ArrayHelper.AddRange(request.Ids, ids); //request.Ids.AddRange(ids);
        request.DestinationFormat = destinationFormat;
        return request.Execute();
    };
    ExchangeService.prototype.AddDelegates = function (mailbox, meetingRequestsDeliveryScope, delegateUser) {
        var delegateUsers = [];
        for (var _a = 3; _a < arguments.length; _a++) {
            delegateUsers[_a - 3] = arguments[_a];
        }
        if (delegateUser) {
            if (ArrayHelper.isArray(delegateUser)) {
                ArrayHelper.AddRange(delegateUsers, delegateUser);
            }
            else {
                delegateUsers.push(delegateUser);
            }
        }
        EwsUtilities.ValidateParam(mailbox, "mailbox");
        EwsUtilities.ValidateParamCollection(delegateUsers, "delegateUsers");
        var request = new AddDelegateRequest(this);
        request.Mailbox = mailbox;
        ArrayHelper.AddRange(request.DelegateUsers, delegateUsers); //request.DelegateUsers.AddRange(delegateUsers);
        request.MeetingRequestsDeliveryScope = meetingRequestsDeliveryScope;
        return request.Execute().then(function (response) {
            return response.DelegateUserResponses;
        });
    };
    ExchangeService.prototype.GetDelegates = function (mailbox, includePermissions, userId) {
        var userIds = [];
        for (var _a = 3; _a < arguments.length; _a++) {
            userIds[_a - 3] = arguments[_a];
        }
        if (userId) {
            if (ArrayHelper.isArray(userId)) {
                ArrayHelper.AddRange(userIds, userId);
            }
            else {
                userIds.push(userId);
            }
        }
        EwsUtilities.ValidateParam(mailbox, "mailbox");
        var request = new GetDelegateRequest(this);
        request.Mailbox = mailbox;
        ArrayHelper.AddRange(request.UserIds, userIds); //request.UserIds.AddRange(userIds);
        request.IncludePermissions = includePermissions;
        return request.Execute().then(function (response) {
            var delegateInformation = new DelegateInformation(response.DelegateUserResponses, response.MeetingRequestsDeliveryScope);
            return delegateInformation;
        });
    };
    ExchangeService.prototype.RemoveDelegates = function (mailbox, userId) {
        var userIds = [];
        for (var _a = 2; _a < arguments.length; _a++) {
            userIds[_a - 2] = arguments[_a];
        }
        if (userId) {
            if (ArrayHelper.isArray(userId)) {
                ArrayHelper.AddRange(userIds, userId);
            }
            else {
                userIds.push(userId);
            }
        }
        EwsUtilities.ValidateParam(mailbox, "mailbox");
        EwsUtilities.ValidateParamCollection(userIds, "userIds");
        var request = new RemoveDelegateRequest(this);
        request.Mailbox = mailbox;
        ArrayHelper.AddRange(request.UserIds, userIds); //request.UserIds.AddRange(userIds);
        return request.Execute().then(function (response) {
            return response.DelegateUserResponses;
        });
    };
    ExchangeService.prototype.UpdateDelegates = function (mailbox, meetingRequestsDeliveryScope, delegateUser) {
        var delegateUsers = [];
        for (var _a = 3; _a < arguments.length; _a++) {
            delegateUsers[_a - 3] = arguments[_a];
        }
        if (delegateUser) {
            if (ArrayHelper.isArray(delegateUser)) {
                ArrayHelper.AddRange(delegateUsers, delegateUser);
            }
            else {
                delegateUsers.push(delegateUser);
            }
        }
        EwsUtilities.ValidateParam(mailbox, "mailbox");
        EwsUtilities.ValidateParamCollection(delegateUsers, "delegateUsers");
        var request = new UpdateDelegateRequest(this);
        request.Mailbox = mailbox;
        ArrayHelper.AddRange(request.DelegateUsers, delegateUsers); //request.DelegateUsers.AddRange(delegateUsers);
        request.MeetingRequestsDeliveryScope = meetingRequestsDeliveryScope;
        return request.Execute().then(function (response) {
            return response.DelegateUserResponses;
        });
    };
    /* #endregion Delegate management operations */
    /* #region UserConfiguration operations */
    /**
     * Creates a UserConfiguration.
     *
     * @param   {UserConfiguration}   userConfiguration   The UserConfiguration.
     * @return  {Promise<void>}       :Promise.
     */
    ExchangeService.prototype.CreateUserConfiguration = function (userConfiguration) {
        EwsUtilities.ValidateParam(userConfiguration, "userConfiguration");
        var request = new CreateUserConfigurationRequest(this);
        request.UserConfiguration = userConfiguration;
        return request.Execute();
    };
    /**
     * Deletes a UserConfiguration.
     *
     * @param   {string}    name             Name of the UserConfiguration to retrieve.
     * @param   {FolderId}  parentFolderId   Id of the folder containing the UserConfiguration.
     * @return  {Promise<void>}     :Promise.
     */
    ExchangeService.prototype.DeleteUserConfiguration = function (name, parentFolderId) {
        EwsUtilities.ValidateParam(name, "name");
        EwsUtilities.ValidateParam(parentFolderId, "parentFolderId");
        var request = new DeleteUserConfigurationRequest(this);
        request.Name = name;
        request.ParentFolderId = parentFolderId;
        return request.Execute();
    };
    /**
     * Gets a UserConfiguration.
     *
     * @param   {string}                        name             Name of the UserConfiguration to retrieve.
     * @param   {FolderId}                      parentFolderId   Id of the folder containing the UserConfiguration.
     * @param   {UserConfigurationProperties}   properties       Properties to retrieve.
     * @return  {Promise<UserConfiguration>}    A UserConfiguration.
     */
    ExchangeService.prototype.GetUserConfiguration = function (name, parentFolderId, properties) {
        EwsUtilities.ValidateParam(name, "name");
        EwsUtilities.ValidateParam(parentFolderId, "parentFolderId");
        var request = new GetUserConfigurationRequest(this);
        request.Name = name;
        request.ParentFolderId = parentFolderId;
        request.Properties = properties;
        return request.Execute().then(function (response) {
            return response.__thisIndexer(0).UserConfiguration;
        });
    };
    /**
     * Loads the properties of the specified userConfiguration.
     *
     * @param   {UserConfiguration}             userConfiguration   The userConfiguration containing properties to load.
     * @param   {UserConfigurationProperties}   properties          Properties to retrieve.
     * @return  {Promise<void>}                 :Promise.
     */
    ExchangeService.prototype.LoadPropertiesForUserConfiguration = function (userConfiguration, properties) {
        EwsLogging.Assert(userConfiguration != null, "ExchangeService.LoadPropertiesForUserConfiguration", "userConfiguration is null");
        var request = new GetUserConfigurationRequest(this);
        request.UserConfiguration = userConfiguration;
        request.Properties = properties;
        return request.Execute();
    };
    /**
     * Updates a UserConfiguration.
     *
     * @param   {UserConfiguration}   userConfiguration   The UserConfiguration.
     * @return  {Promise<void>}       :Promise.
     */
    ExchangeService.prototype.UpdateUserConfiguration = function (userConfiguration) {
        EwsUtilities.ValidateParam(userConfiguration, "userConfiguration");
        var request = new UpdateUserConfigurationRequest(this);
        request.UserConfiguration = userConfiguration;
        return request.Execute();
    };
    ExchangeService.prototype.GetInboxRules = function (mailboxSmtpAddress) {
        if (mailboxSmtpAddress === void 0) { mailboxSmtpAddress = null; }
        var request = new GetInboxRulesRequest(this);
        if (arguments.length > 0) {
            EwsUtilities.ValidateParam(mailboxSmtpAddress, "MailboxSmtpAddress");
            request.MailboxSmtpAddress = mailboxSmtpAddress;
        }
        return request.Execute().then(function (response) {
            return response.Rules;
        });
    };
    ExchangeService.prototype.UpdateInboxRules = function (operations, removeOutlookRuleBlob, mailboxSmtpAddress) {
        var request = new UpdateInboxRulesRequest(this);
        request.InboxRuleOperations = operations;
        request.RemoveOutlookRuleBlob = removeOutlookRuleBlob;
        if (arguments.length > 2) {
            request.MailboxSmtpAddress = mailboxSmtpAddress;
        }
        return request.Execute();
    };
    /* #endregion InboxRule operations */
    /* #region eDiscovery/Compliance operations */
    //// BeginGetNonIndexableItemDetails(callback: Function /*System.AsyncCallback*/, state: any, parameters: GetNonIndexableItemDetailsParameters): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginGetNonIndexableItemDetails : Not implemented."); }
    //// BeginGetNonIndexableItemStatistics(callback: Function /*System.AsyncCallback*/, state: any, parameters: GetNonIndexableItemStatisticsParameters): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginGetNonIndexableItemStatistics : Not implemented."); }
    //// BeginSearchMailboxes(callback: Function /*System.AsyncCallback*/, state: any, searchParameters: SearchMailboxesParameters): Function /*System.IAsyncResult*/ { throw new Error("ExchangeService.ts - BeginSearchMailboxes : Not implemented."); }
    //// EndGetNonIndexableItemDetails(asyncResult: Function /*System.IAsyncResult*/): GetNonIndexableItemDetailsResponse { throw new Error("ExchangeService.ts - EndGetNonIndexableItemDetails : Not implemented."); }
    //// EndGetNonIndexableItemStatistics(asyncResult: Function /*System.IAsyncResult*/): GetNonIndexableItemStatisticsResponse { throw new Error("ExchangeService.ts - EndGetNonIndexableItemStatistics : Not implemented."); }
    //// EndSearchMailboxes(asyncResult: Function /*System.IAsyncResult*/): ServiceResponseCollection<TResponse> { throw new Error("ExchangeService.ts - EndSearchMailboxes : Not implemented."); }
    /**
     * Create get non indexable item details request
     *
     * @param   {GetNonIndexableItemDetailsParameters}   parameters   Get non indexable item details parameters
     * @return  {GetNonIndexableItemDetailsRequest}      GetNonIndexableItemDetails request
     */
    ExchangeService.prototype.CreateGetNonIndexableItemDetailsRequest = function (parameters) {
        EwsUtilities.ValidateParam(parameters, "parameters");
        EwsUtilities.ValidateParam(parameters.Mailboxes, "parameters.Mailboxes");
        var request = new GetNonIndexableItemDetailsRequest(this);
        request.Mailboxes = parameters.Mailboxes;
        request.PageSize = parameters.PageSize;
        request.PageItemReference = parameters.PageItemReference;
        request.PageDirection = parameters.PageDirection;
        request.SearchArchiveOnly = parameters.SearchArchiveOnly;
        return request;
    };
    /**
     * Create get non indexable item statistics request
     *
     * @param   {GetNonIndexableItemStatisticsParameters}   parameters   Get non indexable item statistics parameters
     * @return  {GetNonIndexableItemStatisticsRequest}      Service response object
     */
    ExchangeService.prototype.CreateGetNonIndexableItemStatisticsRequest = function (parameters) {
        EwsUtilities.ValidateParam(parameters, "parameters");
        EwsUtilities.ValidateParam(parameters.Mailboxes, "parameters.Mailboxes");
        var request = new GetNonIndexableItemStatisticsRequest(this);
        request.Mailboxes = parameters.Mailboxes;
        request.SearchArchiveOnly = parameters.SearchArchiveOnly;
        return request;
    };
    /**
     * Creates SearchMailboxesRequest from SearchMailboxesParameters
     *
     * @param   {SearchMailboxesParameters}   searchParameters   search parameters
     * @return  {SearchMailboxesRequest}      request object
     */
    ExchangeService.prototype.CreateSearchMailboxesRequest = function (searchParameters) {
        var request = new SearchMailboxesRequest(this, ServiceErrorHandling.ReturnErrors);
        ArrayHelper.AddRange(request.SearchQueries, searchParameters.SearchQueries); //request.SearchQueries.AddRange(searchParameters.SearchQueries);
        request.ResultType = searchParameters.ResultType;
        request.PreviewItemResponseShape = searchParameters.PreviewItemResponseShape;
        request.SortByProperty = searchParameters.SortBy;
        request.SortOrder = searchParameters.SortOrder;
        request.Language = searchParameters.Language;
        request.PerformDeduplication = searchParameters.PerformDeduplication;
        request.PageSize = searchParameters.PageSize;
        request.PageDirection = searchParameters.PageDirection;
        request.PageItemReference = searchParameters.PageItemReference;
        return request;
    };
    /**
     * Get dicovery search configuration
     *
     * @param   {string}    searchId                       Search Id
     * @param   {boolean}   expandGroupMembership          True if want to expand group membership
     * @param   {boolean}   inPlaceHoldConfigurationOnly   True if only want the inplacehold configuration
     * @return  {Promise<GetDiscoverySearchConfigurationResponse>}      Service response object    :Promise.
     */
    ExchangeService.prototype.GetDiscoverySearchConfiguration = function (searchId, expandGroupMembership, inPlaceHoldConfigurationOnly) {
        var request = new GetDiscoverySearchConfigurationRequest(this);
        request.SearchId = searchId;
        request.ExpandGroupMembership = expandGroupMembership;
        request.InPlaceHoldConfigurationOnly = inPlaceHoldConfigurationOnly;
        return request.Execute();
    };
    /**
     * Get hold on mailboxes
     *
     * @param   {string}   holdId   Hold id
     * @return  {Promise<GetHoldOnMailboxesResponse>}       Service response object
     */
    ExchangeService.prototype.GetHoldOnMailboxes = function (holdId) {
        var request = new GetHoldOnMailboxesRequest(this);
        request.HoldId = holdId;
        return request.Execute();
    };
    ExchangeService.prototype.GetNonIndexableItemDetails = function (mailboxesOrParameters, pageSize, pageItemReference, pageDirection) {
        if (pageSize === void 0) { pageSize = null; }
        if (pageItemReference === void 0) { pageItemReference = null; }
        if (pageDirection === void 0) { pageDirection = null; }
        var parameters = null;
        if (mailboxesOrParameters instanceof GetNonIndexableItemDetailsParameters) {
            parameters = mailboxesOrParameters;
        }
        else {
            parameters = new GetNonIndexableItemDetailsParameters();
            parameters.Mailboxes = mailboxesOrParameters;
            parameters.PageSize = pageSize;
            parameters.PageItemReference = pageItemReference;
            parameters.PageDirection = pageDirection;
            parameters.SearchArchiveOnly = false;
        }
        var request = this.CreateGetNonIndexableItemDetailsRequest(parameters);
        return request.Execute();
    };
    ExchangeService.prototype.GetNonIndexableItemStatistics = function (mailboxesOrParameters) {
        var parameters = null;
        if (mailboxesOrParameters instanceof GetNonIndexableItemStatisticsParameters) {
            parameters = mailboxesOrParameters;
        }
        else {
            parameters = new GetNonIndexableItemStatisticsParameters();
            parameters.Mailboxes = mailboxesOrParameters;
            parameters.SearchArchiveOnly = false;
        }
        var request = this.CreateGetNonIndexableItemStatisticsRequest(parameters);
        return request.Execute();
    };
    /**
     * Get searchable mailboxes
     *
     * @param   {string}    searchFilter            Search filter
     * @param   {boolean}   expandGroupMembership   True if want to expand group membership
     * @return  {Promise<GetSearchableMailboxesResponse>}       Service response object :Promise
     */
    ExchangeService.prototype.GetSearchableMailboxes = function (searchFilter, expandGroupMembership) {
        var request = new GetSearchableMailboxesRequest(this);
        request.SearchFilter = searchFilter;
        request.ExpandGroupMembership = expandGroupMembership;
        return request.Execute();
    };
    ExchangeService.prototype.SearchMailboxes = function (mailboxQueriesOrSearchParameters, resultType, sortByProperty, sortOrder, pageSize, pageDirection, pageItemReference) {
        if (resultType === void 0) { resultType = SearchResultType.PreviewOnly; }
        if (sortByProperty === void 0) { sortByProperty = null; }
        if (sortOrder === void 0) { sortOrder = SortDirection.Ascending; }
        if (pageSize === void 0) { pageSize = 0; }
        if (pageDirection === void 0) { pageDirection = SearchPageDirection.Next; }
        if (pageItemReference === void 0) { pageItemReference = null; }
        var request = null;
        if (mailboxQueriesOrSearchParameters instanceof SearchMailboxesParameters) {
            var searchParameters = null;
            searchParameters = mailboxQueriesOrSearchParameters;
            EwsUtilities.ValidateParam(searchParameters, "searchParameters");
            EwsUtilities.ValidateParam(searchParameters.SearchQueries, "searchParameters.SearchQueries");
            request = this.CreateSearchMailboxesRequest(searchParameters);
        }
        else {
            request = new SearchMailboxesRequest(this, ServiceErrorHandling.ReturnErrors);
            if (mailboxQueriesOrSearchParameters != null) {
                ArrayHelper.AddRange(request.SearchQueries, mailboxQueriesOrSearchParameters);
            }
            request.ResultType = resultType;
            if (arguments.length > 2) {
                request.SortByProperty = sortByProperty;
                request.SortOrder = sortOrder;
                request.PageSize = pageSize;
                request.PageDirection = pageDirection;
                request.PageItemReference = pageItemReference;
            }
        }
        return request.Execute();
    };
    ExchangeService.prototype.SetHoldOnMailboxes = function (holdIdOrParameters, _actionType, _query, mailboxesOrInPlaceHoldIdentity, _itemHoldPeriod) {
        if (_actionType === void 0) { _actionType = null; }
        if (_query === void 0) { _query = null; }
        if (mailboxesOrInPlaceHoldIdentity === void 0) { mailboxesOrInPlaceHoldIdentity = null; }
        if (_itemHoldPeriod === void 0) { _itemHoldPeriod = null; }
        var holdId = holdIdOrParameters;
        var actionType = _actionType;
        var query = _query;
        var mailboxes = mailboxesOrInPlaceHoldIdentity;
        var inPlaceHoldIdentity = mailboxesOrInPlaceHoldIdentity;
        var itemHoldPeriod = _itemHoldPeriod;
        var request = new SetHoldOnMailboxesRequest(this);
        var argsLength = arguments.length;
        if (argsLength === 1) {
            var parameters = holdIdOrParameters;
            EwsUtilities.ValidateParam(parameters, "parameters");
            holdId = parameters.HoldId;
            actionType = parameters.ActionType;
            query = parameters.Query;
            mailboxes = parameters.Mailboxes;
            request.Language = parameters.Language;
            inPlaceHoldIdentity = parameters.InPlaceHoldIdentity;
            /** per #120 */
            itemHoldPeriod = request.ItemHoldPeriod;
            request.PerformDeduplication = parameters.PerformDeduplication;
            request.IncludeNonIndexableItems = parameters.IncludeNonIndexableItems;
        }
        else {
            if (ArrayHelper.isArray(mailboxesOrInPlaceHoldIdentity)) {
                inPlaceHoldIdentity = null;
            }
            else {
                mailboxes = null;
            }
        }
        request.HoldId = holdId;
        request.ActionType = actionType;
        request.Query = query;
        request.Mailboxes = mailboxes;
        request.InPlaceHoldIdentity = inPlaceHoldIdentity;
        request.ItemHoldPeriod = itemHoldPeriod;
        return request.Execute();
    };
    /* #endregion eDiscovery/Compliance operations */
    /* #region MRM operations */
    /**
     * Get user retention policy tags.
     *
     * @return  {Promise<GetUserRetentionPolicyTagsResponse>}       Service response object.
     */
    ExchangeService.prototype.GetUserRetentionPolicyTags = function () {
        var request = new GetUserRetentionPolicyTagsRequest(this);
        return request.Execute();
    };
    /* #endregion MRM operations */
    /* #region Autodiscover */
    /**
     * Adjusts the service URI based on the current type of credentials.
     *
     * @param   {Uri}   uri   The URI.
     * @return  {Uri}         Adjusted URL.
     */
    ExchangeService.prototype.AdjustServiceUriFromCredentials = function (uri) {
        return (this.Credentials != null)
            ? this.Credentials.AdjustUrl(uri)
            : uri;
    };
    ExchangeService.prototype.AutodiscoverUrl = function (emailAddress, validateRedirectionUrlCallback) {
        //validateRedirectionUrlCallback = validateRedirectionUrlCallback || this.DefaultAutodiscoverRedirectionUrlValidationCallback;
        var _this = this;
        if (validateRedirectionUrlCallback === void 0) { validateRedirectionUrlCallback = this.DefaultAutodiscoverRedirectionUrlValidationCallback; }
        var exchangeServiceUrl = null;
        if (this.RequestedServerVersion > ExchangeVersion.Exchange2007_SP1) {
            return this.GetAutodiscoverUrl(emailAddress, this.RequestedServerVersion, validateRedirectionUrlCallback).then(function (url) {
                exchangeServiceUrl = url;
                _this.Url = _this.AdjustServiceUriFromCredentials(exchangeServiceUrl);
                //return;
            }, function (err) {
                //catch (AutodiscoverLocalException ex)
                _this.TraceMessage(TraceFlags.AutodiscoverResponse, StringHelper.Format("Autodiscover service call failed with error '{0}'. Will try legacy service", err));
                //catch (ServiceRemoteException ex)
                // Special case: if the caller's account is locked we want to return this exception, not continue.
                //        if (ex is AccountIsLockedException)
                //{
                //    throw;
                //}
                //this.TraceMessage(
                //    TraceFlags.AutodiscoverResponse,
                //    string.Format("Autodiscover service call failed with error '{0}'. Will try legacy service", ex.Message));
                // Try legacy Autodiscover provider
                var exchangeServiceUrl = _this.GetAutodiscoverUrl(emailAddress, ExchangeVersion.Exchange2007_SP1, validateRedirectionUrlCallback).then(function (url) {
                    _this.Url = _this.AdjustServiceUriFromCredentials(url);
                });
            });
        }
    };
    /**
     * Default implementation of AutodiscoverRedirectionUrlValidationCallback. Always returns true indicating that the URL can be used.
     *
     * @param   {string}   redirectionUrl   The redirection URL.
     * @return  {boolean}                    Returns true.
     */
    ExchangeService.prototype.DefaultAutodiscoverRedirectionUrlValidationCallback = function (redirectionUrl) {
        throw new AutodiscoverLocalException(StringHelper.Format(Strings.AutodiscoverRedirectBlocked, redirectionUrl));
    };
    /**
     * Gets the EWS URL from Autodiscover.
     *
     * @param   {string}                                        emailAddress                     The email address.
     * @param   {ExchangeVersion}                               requestedServerVersion           Exchange version.
     * @param   {AutodiscoverRedirectionUrlValidationCallback}  validateRedirectionUrlCallback   The validate redirection URL callback.
     * @return  {Promise<Uri>}                                  Ews URL :Promise.
     */
    ExchangeService.prototype.GetAutodiscoverUrl = function (emailAddress, requestedServerVersion, validateRedirectionUrlCallback) {
        var _this = this;
        var autodiscoverService = new AutodiscoverService(null, null, requestedServerVersion);
        autodiscoverService.Credentials = this.Credentials;
        autodiscoverService.RedirectionUrlValidationCallback = validateRedirectionUrlCallback,
            autodiscoverService.EnableScpLookup = this.EnableScpLookup;
        return autodiscoverService.GetUserSettings(emailAddress, UserSettingName.InternalEwsUrl, UserSettingName.ExternalEwsUrl)
            .then(function (response) {
            switch (response.ErrorCode) {
                case AutodiscoverErrorCode.NoError:
                    return _this.GetEwsUrlFromResponse(response, autodiscoverService.IsExternal);
                case AutodiscoverErrorCode.InvalidUser:
                    throw new ServiceRemoteException(StringHelper.Format(Strings.InvalidUser, emailAddress));
                case AutodiscoverErrorCode.InvalidRequest:
                    throw new ServiceRemoteException(StringHelper.Format(Strings.InvalidAutodiscoverRequest, response.ErrorMessage));
                default:
                    _this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("No EWS Url returned for user {0}, error code is {1}", emailAddress, response.ErrorCode));
                    throw new ServiceRemoteException(response.ErrorMessage);
            }
        }, function (err) {
            throw err;
        });
    };
    /**
     * Gets the EWS URL from Autodiscover GetUserSettings response.
     *
     * @param   {GetUserSettingsResponse}   response     The response.
     * @param   {boolean}                   isExternal   If true, Autodiscover call was made externally.
     * @return  {Uri}                       EWS URL.
     */
    ExchangeService.prototype.GetEwsUrlFromResponse = function (response, isExternal) {
        var uriString = response.GetSettingValue(UserSettingName.ExternalEwsUrl);
        // Figure out which URL to use: Internal or External.
        // AutoDiscover may not return an external protocol. First try external, then internal.
        // Either protocol may be returned without a configured URL.
        if ((isExternal &&
            uriString) &&
            !StringHelper.IsNullOrEmpty(uriString)) {
            return new Uri(uriString);
        }
        else {
            uriString = response.GetSettingValue(UserSettingName.InternalEwsUrl) || uriString;
            if (!StringHelper.IsNullOrEmpty(uriString)) {
                return new Uri(uriString);
            }
        }
        // If Autodiscover doesn't return an internal or external EWS URL, throw an exception.
        throw new AutodiscoverLocalException(Strings.AutodiscoverDidNotReturnEwsUrl);
    };
    ExchangeService.prototype.GetClientAccessToken = function (tokenRequestsOrIdAndTypes) {
        if (!tokenRequestsOrIdAndTypes && tokenRequestsOrIdAndTypes.length === 0) {
            throw new ArgumentOutOfRangeException(Strings.IndexIsOutOfRange);
        }
        var requestList = [];
        if (tokenRequestsOrIdAndTypes[0] instanceof ClientAccessTokenRequest) {
            requestList = tokenRequestsOrIdAndTypes;
        }
        else {
            for (var _a = 0, _b = tokenRequestsOrIdAndTypes; _a < _b.length; _a++) {
                var idAndType = _b[_a];
                var clientAccessTokenRequest = new ClientAccessTokenRequest(idAndType.key, idAndType.value);
                requestList.push(clientAccessTokenRequest);
            }
        }
        var request = new GetClientAccessTokenRequest(this, ServiceErrorHandling.ReturnErrors);
        request.TokenRequests = requestList;
        return request.Execute();
    };
    ExchangeService.prototype.GetAppManifests = function (apiVersionSupported, schemaVersionSupported) {
        if (apiVersionSupported === void 0) { apiVersionSupported = null; }
        if (schemaVersionSupported === void 0) { schemaVersionSupported = null; }
        var argsLength = arguments.length;
        var request = new GetAppManifestsRequest(this);
        if (argsLength !== 0) {
            request.ApiVersionSupported = apiVersionSupported;
            request.SchemaVersionSupported = schemaVersionSupported;
        }
        return request.Execute().then(function (response) {
            if (argsLength !== 0) {
                return response.Apps;
            }
            else {
                return response.Manifests;
            }
        });
    };
    ExchangeService.prototype.GetAppMarketplaceUrl = function (apiVersionSupported, schemaVersionSupported) {
        if (apiVersionSupported === void 0) { apiVersionSupported = null; }
        if (schemaVersionSupported === void 0) { schemaVersionSupported = null; }
        var request = new GetAppMarketplaceUrlRequest(this);
        request.ApiVersionSupported = apiVersionSupported;
        request.SchemaVersionSupported = schemaVersionSupported;
        return request.Execute().then(function (response) {
            return response.AppMarketplaceUrl;
        });
    };
    /**
     * Disable an App.
     *
     * /remarks/    Exception will be thrown for errors.
     * @param   {string}                id              App ID
     * @param   {DisableReasonType}     disableReason   Disable reason
     * @return  {Promise<void>}         :Promise.
     */
    ExchangeService.prototype.DisableApp = function (id, disableReason) {
        EwsUtilities.ValidateParam(id, "id");
        EwsUtilities.ValidateParam(disableReason, "disableReason");
        var request = new DisableAppRequest(this, id, disableReason);
        return request.Execute();
    };
    /**
     * Install an App.
     *
     * /remarks/    Exception will be thrown for errors.
     * @param   {string}   manifestStream   The manifest's plain text XML as base64 encoded string.
     * @return  {Promise<void>}     :Promise.
     */
    ExchangeService.prototype.InstallApp = function (manifestStream) {
        EwsUtilities.ValidateParam(manifestStream, "manifestStream");
        var request = new InstallAppRequest(this, manifestStream);
        return request.Execute();
    };
    /**
     * Uninstall an App.
     *
     * /remarks/    Exception will be thrown for errors.
     * @param   {string}   id   App ID
     * @return  {Promise<void>}     :Promise.
     */
    ExchangeService.prototype.UninstallApp = function (id) {
        EwsUtilities.ValidateParam(id, "id");
        var request = new UninstallAppRequest(this, id);
        return request.Execute();
    };
    //info - not used in client side, only server side calls are supported per function documentation.
    // GetClientExtension(requestedExtensionIds: StringList, shouldReturnEnabledOnly: boolean, isUserScope: boolean, userId: string, userEnabledExtensionIds: StringList, userDisabledExtensionIds: StringList, isDebug: boolean): GetClientExtensionResponse { throw new Error("ExchangeService.ts - GetClientExtension : Not implemented."); }
    // SetClientExtension(actions: Function[] /*System.Collections.Generic.List<T>*/): any { throw new Error("ExchangeService.ts - SetClientExtension : Not implemented."); }
    // GetEncryptionConfiguration(): GetEncryptionConfigurationResponse { throw new Error("ExchangeService.ts - GetEncryptionConfiguration : Not implemented."); }
    // SetEncryptionConfiguration(imageBase64: string, emailText: string, portalText: string, disclaimerText: string): any { throw new Error("ExchangeService.ts - SetEncryptionConfiguration : Not implemented."); }
    /* #endregion Client Extensibility */
    /* #region Diagnostic Method -- Only used by test */
    //ExecuteDiagnosticMethod(verb: string, parameter: System.Xml.XmlNode): System.Xml.XmlDocument { throw new Error("ExchangeService.ts - ExecuteDiagnosticMethod : Not implemented."); }    
    /* #endregion Diagnostic Method -- Only used by test */
    /* #region Validation */
    ExchangeService.IsMajorMinor = function (versionPart) {
        var MajorMinorSeparator = '.'; //char
        var parts = versionPart.split(MajorMinorSeparator);
        if (parts.length != 2) {
            return false;
        }
        for (var _a = 0, parts_1 = parts; _a < parts_1.length; _a++) {
            var s = parts_1[_a];
            for (var _b = 0, _c = s.split(''); _b < _c.length; _b++) {
                var c = _c[_b];
                if (isNaN(c)) {
                    return false;
                }
            }
        }
        return true;
    };
    /**
     * @internal Validates this instance.
     *
     */
    ExchangeService.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        if (this.Url == null) {
            throw new ServiceLocalException(Strings.ServiceUrlMustBeSet);
        }
        if (this.PrivilegedUserId != null && this.ImpersonatedUserId != null) {
            throw new ServiceLocalException(Strings.CannotSetBothImpersonatedAndPrivilegedUser);
        }
        // only one of PrivilegedUserId|ImpersonatedUserId|ManagementRoles can be set.
    };
    /**
     * @internal Validates a new-style version string. This validation is not as strict as server-side validation.
     *
     * @param   {string}   version   the version string
     */
    ExchangeService.ValidateTargetVersion = function (version) {
        var ParameterSeparator = ';'; //char
        var LegacyVersionPrefix = "Exchange20";
        var ParameterValueSeparator = '='; //char
        var ParameterName = "minimum";
        if (StringHelper.IsNullOrEmpty(version)) {
            throw new ArgumentException("Target version must not be empty.");
        }
        var parts = version.trim().split(ParameterSeparator);
        if (parts.length > 2) {
            throw new ArgumentException("Target version should have the form.");
        }
        var skipPart1 = true;
        if (parts.length === 2) {
            // Validate the optional minimum version parameter, "minimum=X.Y"
            var part2 = parts[1].trim();
            var minParts = part2.split(ParameterValueSeparator);
            if (minParts.length == 2 &&
                minParts[0].trim().toUpperCase() === ParameterName.toUpperCase() &&
                ExchangeService.IsMajorMinor(minParts[1].trim())) {
                skipPart1 = false;
            }
            else {
                throw new ArgumentException("Target version must match X.Y or Exchange20XX.");
            }
        }
        if (parts.length >= 0 && !skipPart1) {
            // Validate the header value. We allow X.Y or Exchange20XX.
            var part1 = parts[0].trim();
            if (parts[0].indexOf(LegacyVersionPrefix) === 0) {
                // Close enough; misses corner cases like "Exchange2001". Server will do complete validation.
            }
            else if (ExchangeService.IsMajorMinor(part1)) {
                // Also close enough; misses corner cases like ".5".
            }
            else {
                throw new ArgumentException("Target version must match X.Y or Exchange20XX.");
            }
        }
    };
    /* #endregion Validation */
    /* #region Utilities */
    /**
     * @internal Creates an IXHROptions instance and initializes it with the appropriate parameters, based on the configuration of this service object.
     *
     * @param   {string}   methodName   Name of the method.
     * @return  {IXHROptions}           An instance of IXHROptions to call web service with.
     */
    ExchangeService.prototype.PrepareHttpWebRequest = function (methodName) {
        var endpoint = this.Url;
        //this.RegisterCustomBasicAuthModule();
        if (this.RenderingMethod === RenderingMode.JSON) {
            //endpoint = new Uri(
            //    endpoint,
            //    string.Format("{0}/{1}{2}", endpoint.AbsolutePath, methodName, endpoint.Query));
        }
        else {
            endpoint = this.AdjustServiceUriFromCredentials(endpoint);
        }
        var request = this.PrepareHttpWebRequestForUrl(endpoint, this.AcceptGzipEncoding, true);
        if (!StringHelper.IsNullOrEmpty(this.TargetServerVersion)) {
            request.headers[ExchangeService.TargetServerVersionHeaderName] = this.TargetServerVersion;
        }
        return request;
    };
    /**
     * @internal Processes an HTTP error response.
     *
     * @param   {XMLHttpRequest}   httpWebResponse      The HTTP web response.
     * @param   {SoapFaultDetails}   soapFault          The SoapFault Instance.
     */
    ExchangeService.prototype.ProcessHttpErrorResponse = function (httpWebResponse, soapFault) {
        this.InternalProcessHttpErrorResponse(httpWebResponse, soapFault, TraceFlags.EwsResponseHttpHeaders, TraceFlags.EwsResponse);
    };
    /**
     * Sets the type of the content.
     *
     * @param   {IXHROptions}   request   The request.
     */
    ExchangeService.prototype.SetContentType = function (request /*IEwsHttpWebRequest*/) {
        if (this.renderingMode == RenderingMode.Xml) {
            request.headers["Content-Type"] = "text/xml; charset=utf-8";
            request.headers["Accept"] = "text/xml";
        }
        else if (this.renderingMode == RenderingMode.JSON) {
            request.headers["Content-Type"] = "application/json; charset=utf-8";
            request.headers["Accept"] = "application/json";
        }
        else {
            _super.prototype.SetContentType.call(this, request);
        }
    };
    /* #region Constants */
    ExchangeService.TargetServerVersionHeaderName = "X-EWS-TargetVersion";
    return ExchangeService;
}(ExchangeServiceBase));
exports.ExchangeService = ExchangeService;
//module ExchangeService { -> moved to its own file to remove circular dependency.
//    export enum RenderingMode {
//        Xml = 0,
//        JSON = 1
//    }
//}
/**
 * JSON names not shared with the XmlElementNames or XmlAttributeNames classes.
 */
var JsonNames;
(function (JsonNames) {
    JsonNames.Events = "Events";
    JsonNames.NotificationType = "NotificationType";
    JsonNames.OldFolderId = "OldFolderId";
    JsonNames.OldItemId = "OldItemId";
    JsonNames.PathToExtendedFieldType = "ExtendedPropertyUri";
    JsonNames.PathToIndexedFieldType = "DictionaryPropertyUri";
    JsonNames.PathToUnindexedFieldType = "PropertyUri";
    JsonNames.Path = "Path";
    JsonNames.RecurrencePattern = "RecurrencePattern";
    JsonNames.RecurrenceRange = "RecurrenceRange";
})(JsonNames = exports.JsonNames || (exports.JsonNames = {}));
var JsonObject = (function () {
    function JsonObject() {
    }
    JsonObject.TypeAttribute = "__type";
    JsonObject.JsonTypeNamespace = "Exchange";
    JsonObject.JsonValueString = "Value";
    return JsonObject;
}());
exports.JsonObject = JsonObject;
var JsonParser = (function () {
    function JsonParser() {
    }
    JsonParser.prototype.Parse = function () { throw new Error("JsonParser.ts - Parse : Not implemented."); };
    JsonParser.prototype.ParseArray = function () { throw new Error("JsonParser.ts - ParseArray : Not implemented."); };
    JsonParser.prototype.ParseKeyValuePair = function (jsonObject) { throw new Error("JsonParser.ts - ParseKeyValuePair : Not implemented."); };
    JsonParser.prototype.ParseNumber = function (valueToken) { throw new Error("JsonParser.ts - ParseNumber : Not implemented."); };
    JsonParser.prototype.ParseObject = function () { throw new Error("JsonParser.ts - ParseObject : Not implemented."); };
    JsonParser.prototype.ParseValue = function () { throw new Error("JsonParser.ts - ParseValue : Not implemented."); };
    JsonParser.prototype.ReadAndValidateToken = function (token, expectedTokenTypes) { throw new Error("JsonParser.ts - ReadAndValidateToken : Not implemented."); };
    JsonParser.prototype.UnescapeString = function (value) { throw new Error("JsonParser.ts - UnescapeString : Not implemented."); };
    return JsonParser;
}());
exports.JsonParser = JsonParser;
var JsonTokenizer = (function () {
    function JsonTokenizer() {
    }
    JsonTokenizer.prototype.AdvanceRegExMatch = function () { throw new Error("JsonTokenizer.ts - AdvanceRegExMatch : Not implemented."); };
    JsonTokenizer.prototype.NextToken = function (token) { throw new Error("JsonTokenizer.ts - NextToken : Not implemented."); };
    JsonTokenizer.prototype.Peek = function () { throw new Error("JsonTokenizer.ts - Peek : Not implemented."); };
    JsonTokenizer.JsonStringRegExCode = '"([^\\"]|\\"|\\\\|\\/|\\b|\\f|\\n|\\r|\\t|\\u[\da - fA - F]{4 }) * "';
    JsonTokenizer.JsonNumberRegExCode = "-?\d+(.\d+)?([eE][+-]?\d+)?";
    JsonTokenizer.JsonBooleanRegExCode = "(true|false)";
    JsonTokenizer.JsonNullRegExCode = "null";
    JsonTokenizer.JsonOpenObjectRegExCode = "\{";
    JsonTokenizer.JsonCloseObjectRegExCode = "\}";
    JsonTokenizer.JsonOpenArrayRegExCode = "\[";
    JsonTokenizer.JsonCloseArrayRegExCode = "\]";
    JsonTokenizer.JsonColonRegExCode = "\:";
    JsonTokenizer.JsonCommaRegExCode = "\,";
    return JsonTokenizer;
}());
exports.JsonTokenizer = JsonTokenizer;
// class JsonWriter extends System.IO.TextWriter {
//private static Indentation: string = "  ";
//	Encoding: any /*System.Text.Encoding*/;
//	ShouldCloseStream: boolean;
//	private outStream: any /*System.IO.Stream*/;
//	private shouldCloseStream: boolean;
//	private prettyPrint: boolean;
//	private writingStringValue: boolean;
//	private smallBuffer: any /*System.Byte[]*/;
//	private singleCharBuffer: any[] /*System.Char[]*/;
//	private closures: string[] /*System.Collections.Generic.Stack<string>*/;
//	private closureHasMembers: boolean[] /*System.Collections.Generic.Stack<boolean>*/;
//	AddingValue(): void{ throw new Error("JsonWriter.ts - AddingValue : Not implemented.");}
//	Dispose(disposing: boolean): void{ throw new Error("JsonWriter.ts - Dispose : Not implemented.");}
//	PopClosure(): void{ throw new Error("JsonWriter.ts - PopClosure : Not implemented.");}
//	PushArrayClosure(): void{ throw new Error("JsonWriter.ts - PushArrayClosure : Not implemented.");}
//	PushObjectClosure(): void{ throw new Error("JsonWriter.ts - PushObjectClosure : Not implemented.");}
//	Write(value: string): void{ throw new Error("JsonWriter.ts - Write : Not implemented.");}
//	WriteIndentation(): void{ throw new Error("JsonWriter.ts - WriteIndentation : Not implemented.");}
//	WriteInternal(value: string): void{ throw new Error("JsonWriter.ts - WriteInternal : Not implemented.");}
//	WriteKey(key: string): void{ throw new Error("JsonWriter.ts - WriteKey : Not implemented.");}
//	WriteNullValue(): void{ throw new Error("JsonWriter.ts - WriteNullValue : Not implemented.");}
//	WriteQuote(): void{ throw new Error("JsonWriter.ts - WriteQuote : Not implemented.");}
//	WriteValue(value: number): void{ throw new Error("JsonWriter.ts - WriteValue : Not implemented.");}
//	//WriteValue(value: number): void{ throw new Error("JsonWriter.ts - WriteValue : Not implemented.");}
//	//WriteValue(value: number): void{ throw new Error("JsonWriter.ts - WriteValue : Not implemented.");}
//	//WriteValue(value: System.Enum): void{ throw new Error("JsonWriter.ts - WriteValue : Not implemented.");}
//	//WriteValue(value: boolean): void{ throw new Error("JsonWriter.ts - WriteValue : Not implemented.");}
//	//WriteValue(value: string): void{ throw new Error("JsonWriter.ts - WriteValue : Not implemented.");}
//	//WriteValue(value: Date): void{ throw new Error("JsonWriter.ts - WriteValue : Not implemented.");}
//	//WriteValue(value: number): void{ throw new Error("JsonWriter.ts - WriteValue : Not implemented.");}
//}
//export = JsonWriter;
/**
 * @internal Represents a property bag keyed on PropertyDefinition objects.
 */
var PropertyBag = (function () {
    /**
     * @internal Initializes a new instance of **PropertyBag**.
     *
     * @param   {ServiceObject}   owner   The owner of the bag.
     */
    function PropertyBag(owner) {
        this.owner = null;
        this.isDirty = false;
        this.loading = false;
        this.onlySummaryPropertiesRequested = false;
        this.loadedProperties = [];
        this.properties = new DictionaryWithPropertyDefitionKey();
        this.deletedProperties = new DictionaryWithPropertyDefitionKey();
        this.modifiedProperties = [];
        this.addedProperties = [];
        this.requestedPropertySet = null;
        EwsLogging.Assert(owner != null, "PropertyBag.ctor", "owner is null");
        this.owner = owner;
    }
    Object.defineProperty(PropertyBag.prototype, "Properties", {
        /**
         * @internal Gets a dictionary holding the bag's properties.
         */
        get: function () {
            return this.properties;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertyBag.prototype, "Owner", {
        /**
         * @internal Gets the owner of this bag.
         */
        get: function () {
            return this.owner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertyBag.prototype, "IsDirty", {
        /**
         * @internal True if the bag has pending changes, false otherwise.
         */
        get: function () {
            var changes = this.modifiedProperties.length + this.deletedProperties.length + this.addedProperties.length;
            return changes > 0 || this.isDirty;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets or sets the value of a property.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property to get or set.
     * @return  {any}                   An object representing the value of the property.
     */
    PropertyBag.prototype._getItem = function (propertyDefinition) {
        var serviceException = { outValue: null, exception: null };
        var propertyValue = this.GetPropertyValueOrException(propertyDefinition, serviceException);
        if (serviceException.outValue === null) {
            return propertyValue;
        }
        else {
            throw serviceException.exception;
        }
    };
    /**
     * @internal Gets or sets the value of a property.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property to get or set.
     * @return  {any}                   An object representing the value of the property.
     */
    PropertyBag.prototype._setItem = function (propertyDefinition, value) {
        if (propertyDefinition.Version > this.Owner.Service.RequestedServerVersion) {
            throw new ServiceVersionException(StringHelper.Format(Strings.PropertyIncompatibleWithRequestVersion, propertyDefinition.Name, ExchangeVersion[propertyDefinition.Version]), null);
        }
        // If the property bag is not in the loading state, we need to verify whether
        // the property can actually be set or updated.
        if (!this.loading) {
            // If the owner is new and if the property cannot be set, throw.
            if (this.Owner.IsNew && !propertyDefinition.HasFlag(PropertyDefinitionFlags.CanSet, this.Owner.Service.RequestedServerVersion)) {
                throw new Error("property is readonly\n" + JSON.stringify(propertyDefinition)); //  ServiceObjectPropertyException(Strings.PropertyIsReadOnly, propertyDefinition);
            }
            if (!this.Owner.IsNew) {
                // If owner is an item attachment, properties cannot be updated (EWS doesn't support updating item attachments)
                var isItem = this.owner instanceof TypeContainer.Item; //ref: //info: TypeContainer contains constructor of Item (not instance) to evade circular dependency. Assigned at bootstarp
                //debugger;
                //let ownerItem = <Item>this.Owner; - implemented IsAttachment on service object to remove dependency to Item object.
                if (isItem && this.owner.IsAttachment) {
                    throw new ServiceObjectPropertyException(Strings.ItemAttachmentCannotBeUpdated, propertyDefinition);
                }
                // If the property cannot be deleted, throw.
                if (value == null && !propertyDefinition.HasFlag(PropertyDefinitionFlags.CanDelete)) {
                    throw new ServiceObjectPropertyException(Strings.PropertyCannotBeDeleted, propertyDefinition);
                }
                // If the property cannot be updated, throw.
                if (!propertyDefinition.HasFlag(PropertyDefinitionFlags.CanUpdate)) {
                    throw new ServiceObjectPropertyException(Strings.PropertyCannotBeUpdated, propertyDefinition);
                }
            }
        }
        // If the value is set to null, delete the property.
        if (value == null) {
            this.DeleteProperty(propertyDefinition);
        }
        else {
            var complexProperty = null;
            var currentValue = this.properties.get(propertyDefinition);
            if (currentValue) {
                complexProperty = currentValue;
                if (complexProperty instanceof ComplexProperty) {
                    ArrayHelper.RemoveEntry(complexProperty.OnChange, this.PropertyChanged); //cant do += or -= in javascript (hopefully in ECMA6)                    
                }
            }
            // If the property was to be deleted, the deletion becomes an update.
            if (this.deletedProperties.remove(propertyDefinition)) {
                PropertyBag.AddToChangeList(propertyDefinition, this.modifiedProperties);
            }
            else {
                // If the property value was not set, we have a newly set property.
                if (this.properties.getStringKeys().indexOf(propertyDefinition.Name) == -1 /*.ContainsKey(propertyDefinition)*/) {
                    PropertyBag.AddToChangeList(propertyDefinition, this.addedProperties);
                }
                else {
                    // The last case is that we have a modified property.
                    if (this.modifiedProperties.indexOf(propertyDefinition) == -1 /*.Contains(propertyDefinition)*/) {
                        PropertyBag.AddToChangeList(propertyDefinition, this.modifiedProperties);
                    }
                }
            }
            this.InitComplexProperty(value instanceof ComplexProperty ? value : undefined);
            this.properties.set(propertyDefinition, value);
            this.Changed();
        }
    };
    /**
     * @internal Adds the specified property to the specified change list if it is not already present.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property to add to the change list.
     * @param   {PropertyDefinition[]}  changeList           The change list to add the property to.
     */
    PropertyBag.AddToChangeList = function (propertyDefinition, changeList /*System.Collections.Generic.List<PropertyDefinition>*/) {
        if (changeList.indexOf(propertyDefinition) < 0) {
            changeList.push(propertyDefinition);
        }
    };
    /**
     * @internal Sets the isDirty flag to true and triggers dispatch of the change event to the owner of the property bag.
     * Changed must be called whenever an operation that changes the state of this property bag is performed (e.g. adding or removing a property).
     */
    PropertyBag.prototype.Changed = function () {
        this.isDirty = true;
        this.owner.Changed();
    };
    /**
     * @internal Clears the bag.
     */
    PropertyBag.prototype.Clear = function () {
        this.ClearChangeLog();
        this.properties.clear();
        this.loadedProperties.splice(0);
        this.requestedPropertySet = undefined;
    };
    /**
     * @internal Clears the bag's change log.
     */
    PropertyBag.prototype.ClearChangeLog = function () {
        this.deletedProperties.clear();
        this.modifiedProperties.splice(0);
        this.addedProperties.splice(0);
        for (var _a = 0, _b = this.properties.Values; _a < _b.length; _a++) {
            var val = _b[_a];
            var complexProperty = val;
            if (complexProperty instanceof ComplexProperty) {
                complexProperty.ClearChangeLog();
            }
        }
        this.isDirty = false;
    };
    /**
     * @internal Determines whether the property bag contains a specific property.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property to check against.
     * @return  {boolean}               True if the specified property is in the bag, false otherwise.
     */
    PropertyBag.prototype.Contains = function (propertyDefinition) {
        return this.properties.containsKey(propertyDefinition);
    };
    /**
     * @internal Deletes the property from the bag.
     *
     * @param   {PropertyDefinition}   propertyDefinition   The property to delete.
     */
    PropertyBag.prototype.DeleteProperty = function (propertyDefinition) {
        if (!this.deletedProperties.containsKey(propertyDefinition)) {
            var propertyValue = { outValue: null };
            this.properties.tryGetValue(propertyDefinition, propertyValue);
            this.properties.remove(propertyDefinition);
            var modifiedIndex = this.modifiedProperties.indexOf(propertyDefinition);
            if (modifiedIndex >= 0)
                this.modifiedProperties.splice(modifiedIndex, 1);
            this.deletedProperties.Add(propertyDefinition, propertyValue);
            var complexProperty = propertyValue.outValue;
            if (complexProperty instanceof ComplexProperty) {
                ArrayHelper.RemoveEntry(complexProperty.OnChange, this.PropertyChanged); // -= this.PropertyChanged; // counld not do c# like event -= in js                
            }
        }
    };
    /**
     * @internal Determines whether an EWS UpdateItem/UpdateFolder call is necessary to save the changes that occurred in the bag.
     *
     * @return  {boolean}      True if an UpdateItem/UpdateFolder call is necessary, false otherwise.
     */
    PropertyBag.prototype.GetIsUpdateCallNecessary = function () {
        var propertyDefinitions = [];
        propertyDefinitions = propertyDefinitions.concat(this.addedProperties);
        propertyDefinitions = propertyDefinitions.concat(this.modifiedProperties);
        propertyDefinitions = propertyDefinitions.concat(this.deletedProperties.Keys);
        for (var _a = 0, propertyDefinitions_1 = propertyDefinitions; _a < propertyDefinitions_1.length; _a++) {
            var propertyDefinition = propertyDefinitions_1[_a];
            if (propertyDefinition.HasFlag(PropertyDefinitionFlags.CanUpdate)) {
                return true;
            }
        }
        return false;
    };
    /**
     * @internal Gets the name of the property update item.
     *
     * @param   {ServiceObject}     serviceObject   The service object.
     * @return  {string}            [description]
     */
    PropertyBag.GetPropertyUpdateItemName = function (serviceObject) {
        return serviceObject instanceof TypeContainer.Folder ?
            XmlElementNames.Folder :
            XmlElementNames.Item;
    };
    /**
     * Gets the property value.
     *
     * @param   {PropertyDefinition}                    propertyDefinition   The property definition.
     * @param   { IOutParam<ServiceLocalException>}     exception            Exception that would be raised if there's an error retrieving the property.
     * @return  {any}                                   Propert value. May be null.
     */
    PropertyBag.prototype.GetPropertyValueOrException = function (propertyDefinition, exception) {
        var propertyValue = { outValue: null };
        if (propertyDefinition.Version > this.Owner.Service.RequestedServerVersion) {
            exception.outValue = new ServiceVersionException(StringHelper.Format(Strings.PropertyIncompatibleWithRequestVersion, propertyDefinition.Name, ExchangeVersion[propertyDefinition.Version]));
            return null;
        }
        if (this.TryGetValue(propertyDefinition, propertyValue)) {
            // If the requested property is in the bag, return it.
            return propertyValue.outValue;
        }
        else {
            if (propertyDefinition.HasFlag(PropertyDefinitionFlags.AutoInstantiateOnRead)) {
                // The requested property is an auto-instantiate-on-read property
                var complexPropertyDefinition = propertyDefinition;
                EwsLogging.Assert((complexPropertyDefinition instanceof ComplexPropertyDefinitionBase), "PropertyBag.get_this[]", "propertyDefinition is marked with AutoInstantiateOnRead but is not a descendant of ComplexPropertyDefinitionBase");
                propertyValue.outValue = complexPropertyDefinition.CreatePropertyInstance(this.Owner);
                if (propertyValue.outValue != null) {
                    this.InitComplexProperty(propertyValue.outValue);
                    this.properties.set(propertyDefinition, propertyValue.outValue);
                }
            }
            else {
                // If the property is not the Id (we need to let developers read the Id when it's null) and if has
                // not been loaded, we throw.
                if (propertyDefinition != this.Owner.GetIdPropertyDefinition()) {
                    if (!this.IsPropertyLoaded(propertyDefinition)) {
                        exception.outValue = new ServiceObjectPropertyException(Strings.MustLoadOrAssignPropertyBeforeAccess, propertyDefinition);
                        return null;
                    }
                    // Non-nullable properties (int, bool, etc.) must be assigned or loaded; cannot return null value.
                    if (!propertyDefinition.IsNullable) {
                        var errorMessage = this.IsRequestedProperty(propertyDefinition)
                            ? Strings.ValuePropertyNotLoaded
                            : Strings.ValuePropertyNotAssigned;
                        exception.outValue = new ServiceObjectPropertyException(errorMessage, propertyDefinition);
                    }
                }
            }
            return propertyValue.outValue;
        }
    };
    /**
     * Initializes a ComplexProperty instance. When a property is inserted into the bag, it needs to be initialized in order for changes that occur on that property to be properly detected and dispatched.
     *
     * @param   {ComplexProperty}   complexProperty   The ComplexProperty instance to initialize.
     */
    PropertyBag.prototype.InitComplexProperty = function (complexProperty) {
        if (complexProperty) {
            complexProperty.OnChange.push(this.PropertyChanged.bind(this)); // can't do += in javascript;
            if (TypeGuards.isIOwnedProperty(complexProperty)) {
                complexProperty.Owner = this.Owner;
            }
        }
    };
    /**
     * @internal Determines whether specified property is loaded. This also includes properties that were requested when the property bag was loaded but were not returned by the server. In this case, the property value will be null.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property definition.
     * @return  {boolean}               true if property was loaded or requested; otherwise, false.
     */
    PropertyBag.prototype.IsPropertyLoaded = function (propertyDefinition) {
        // Is the property loaded?
        if (this.loadedProperties.indexOf(propertyDefinition) >= 0) {
            return true;
        }
        else {
            // Was the property requested?
            return this.IsRequestedProperty(propertyDefinition);
        }
    };
    /**
     * @internal Determines whether the specified property has been updated.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property definition.
     * @return  {boolean}               true if the specified property has been updated; otherwise, false.
     */
    PropertyBag.prototype.IsPropertyUpdated = function (propertyDefinition) {
        return this.modifiedProperties.indexOf(propertyDefinition) >= 0 || this.addedProperties.indexOf(propertyDefinition) >= 0;
    };
    /**
     * Determines whether specified property was requested.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property definition.
     * @return  {boolean}               true if property was requested; otherwise, false.
     */
    PropertyBag.prototype.IsRequestedProperty = function (propertyDefinition) {
        // If no requested property set, then property wasn't requested.
        if (this.requestedPropertySet == null || this.requestedPropertySet == undefined) {
            return false;
        }
        // If base property set is all first-class properties, use the appropriate list of
        // property definitions to see if this property was requested. Otherwise, property had
        // to be explicitly requested and needs to be listed in AdditionalProperties.
        if (this.requestedPropertySet.BasePropertySet == BasePropertySet.FirstClassProperties) {
            var firstClassProps = this.onlySummaryPropertiesRequested
                ? this.Owner.Schema.FirstClassSummaryProperties
                : this.Owner.Schema.FirstClassProperties;
            return firstClassProps.indexOf(propertyDefinition) >= 0 ||
                this.requestedPropertySet.Contains(propertyDefinition);
        }
        else {
            return this.requestedPropertySet.Contains(propertyDefinition);
        }
    };
    /**
     * @internal Loads from xml js object.
     *
     * @param   {any}   jsObject                The json service object.
     * @param   {ExchangeService}   service                          The service.
     * @param   {boolean}   clear                            Indicates whether the bag should be cleared before properties are loaded.
     * @param   {PropertySet}   requestedPropertySet             The requested property set.
     * @param   {boolean}   onlySummaryPropertiesRequested   Indicates whether summary or full properties were requested.
     */
    PropertyBag.prototype.LoadFromXmlJsObject = function (jsObject, service, clear, requestedPropertySet, onlySummaryPropertiesRequested) {
        if (clear) {
            this.Clear();
        }
        // Put the property bag in "loading" mode. When in loading mode, no checking is done
        // when setting property values.
        this.loading = true;
        this.requestedPropertySet = requestedPropertySet;
        this.onlySummaryPropertiesRequested = onlySummaryPropertiesRequested;
        try {
            for (var key in jsObject) {
                if (key.indexOf("__") === 0)
                    continue;
                if (jsObject.hasOwnProperty(key)) {
                    var element = jsObject[key];
                    var propertyDefinition = { outValue: null };
                    if (this.owner.Schema.TryGetPropertyDefinition(key, propertyDefinition)) {
                        EwsLogging.Assert(false, EwsUtilities.GetPrintableTypeName(propertyDefinition.outValue), "\t\tLoading property :\t\t" + key);
                        propertyDefinition.outValue.LoadPropertyValueFromXmlJsObject(element, service, this);
                        this.loadedProperties.push(propertyDefinition.outValue);
                        EwsLogging.DebugLog(this._getItem(propertyDefinition.outValue), true); //todo:remove this after testing
                    }
                }
            }
            //            let objTypeName: string = jsObject["__type"];
            //            if (StringHelper.IsNullOrEmpty(objTypeName)) {
            //                objTypeName = TypeSystem.GetJsObjectTypeName(jsObject);
            //                jsObject = jsObject[objTypeName];
            //            }
            //            if (StringHelper.IsNullOrEmpty(objTypeName))
            //                throw new Error("error determining typename");
            //
            //            let propertyDefinition: IOutParam<PropertyDefinition> = { value: null };
            //
            //            if (this.Owner.Schema.TryGetPropertyDefinition(objTypeName, propertyDefinition)) {
            //                propertyDefinition.outValue.LoadPropertyValueFromXmlJsObject(jsObject, this);
            //
            //                this.loadedProperties.push(propertyDefinition.outValue);
            //            }
            this.ClearChangeLog();
        }
        catch (exception) {
            EwsLogging.Log(exception);
        }
        finally {
            this.loading = false;
        }
    };
    /**
     * @internal Handles a change event for the specified property.
     *
     * @param   {ComplexProperty}   complexProperty   The property that changes.
     */
    PropertyBag.prototype.PropertyChanged = function (complexProperty) {
        for (var _a = 0, _b = this.properties.Items; _a < _b.length; _a++) {
            var keyValuePair = _b[_a];
            if (keyValuePair.value == complexProperty) {
                if (!this.deletedProperties.containsKey(keyValuePair.key)) {
                    PropertyBag.AddToChangeList(keyValuePair.key, this.modifiedProperties);
                    this.Changed();
                }
            }
        }
    };
    /**
     * @internal Tries to get a property value based on a property definition.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property definition.
     * @param   {IOutParam<any>}        propertyValue        The property value.
     * @return  {boolean}               True if property was retrieved.
     */
    PropertyBag.prototype.TryGetProperty = function (propertyDefinition, propertyValue) {
        var serviceException = { outValue: null };
        propertyValue.outValue = this.GetPropertyValueOrException(propertyDefinition, serviceException);
        return serviceException.outValue == null;
    };
    /**
     * @internal Tries to get a property value based on a property definition.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property definition.
     * @param   {IOutParam<any>}        propertyValue        The property value.
     * @return  {boolean}               True if property was retrieved.
     */
    PropertyBag.prototype.TryGetPropertyAs = function (propertyDefinition, propertyValue) {
        // Verify that the type parameter and property definition's type are compatible.
        //debug: 
        //todo: fix isassignablefrom use Typed parameter and default value of that type when asking.
        //if (!typeof (T).IsAssignableFrom(propertyDefinition.Type)) {
        //    string errorMessage = ExtensionMethods.stringFormatting.Format(
        //        Strings.PropertyDefinitionTypeMismatch,
        //        EwsUtilities.GetPrintableTypeName(propertyDefinition.Type),
        //        EwsUtilities.GetPrintableTypeName(typeof (T)));
        //    throw new ArgumentException(errorMessage, "propertyDefinition");
        //}
        var outValue = { outValue: null };
        var result = this.TryGetProperty(propertyDefinition, outValue);
        propertyValue.outValue = result ? outValue.outValue : undefined;
        return result;
    };
    /**
     * @internal Tries to retrieve the value of the specified property.
     *
     * @param   {PropertyDefinition}    propertyDefinition   The property for which to retrieve a value.
     * @param   {IOutParam<any>}        propertyValue        If the method succeeds, contains the value of the property.
     * @return  {boolean}               True if the value could be retrieved, false otherwise.
     */
    PropertyBag.prototype.TryGetValue = function (propertyDefinition, propertyValue) {
        return this.properties.tryGetValue(propertyDefinition, propertyValue);
    };
    /**
     * @internal Validate property bag instance.
     */
    PropertyBag.prototype.Validate = function () {
        for (var _a = 0, _b = this.addedProperties; _a < _b.length; _a++) {
            var propertyDefinition = _b[_a];
            this.ValidatePropertyValue(propertyDefinition);
        }
        for (var _c = 0, _d = this.modifiedProperties; _c < _d.length; _c++) {
            var propertyDefinition = _d[_c];
            this.ValidatePropertyValue(propertyDefinition);
        }
    };
    /**
     * Validates the property value.
     */
    PropertyBag.prototype.ValidatePropertyValue = function (propertyDefinition) {
        var propertyValue = { outValue: null };
        if (this.TryGetProperty(propertyDefinition, propertyValue)) {
            if (TypeGuards.isISelfValidate(propertyValue.outValue)) {
                propertyValue.outValue.Validate();
            }
        }
    };
    /**
     * Writes an EWS DeleteUpdate opeartion for the specified property.
     *
     * @param   {EwsServiceXmlWriter}   writer               The writer to write the update to.
     * @param   {PropertyDefinition}    propertyDefinition   The property fro which to write the update.
     * @param   {any}                   propertyValue        The current value of the property.
     */
    PropertyBag.prototype.WriteDeleteUpdateToXml = function (writer, propertyDefinition, propertyValue) {
        // The following test should not be necessary since the property bag prevents
        // properties to be deleted (set to null) if they don't have the CanDelete flag,
        // but it doesn't hurt...
        if (propertyDefinition.HasFlag(PropertyDefinitionFlags.CanDelete)) {
            var handled = false;
            if (TypeGuards.isICustomUpdateSerializer(propertyValue)) {
                handled = propertyValue.WriteDeleteUpdateToXml(writer, this.Owner);
            }
            if (!handled) {
                writer.WriteStartElement(XmlNamespace.Types, this.Owner.GetDeleteFieldXmlElementName());
                propertyDefinition.WriteToXml(writer);
                writer.WriteEndElement();
            }
        }
    };
    /**
     * Writes an EWS SetUpdate opeartion for the specified property.
     *
     * @param   {EwsServiceXmlWriter}   writer               The writer to write the update to.
     * @param   {PropertyDefinition}    propertyDefinition   The property fro which to write the update.
     */
    PropertyBag.prototype.WriteSetUpdateToXml = function (writer, propertyDefinition) {
        // The following test should not be necessary since the property bag prevents
        // properties to be updated if they don't have the CanUpdate flag, but it
        // doesn't hurt...
        if (propertyDefinition.HasFlag(PropertyDefinitionFlags.CanUpdate)) {
            var propertyValue = this._getItem(propertyDefinition);
            var handled = false;
            if (TypeGuards.isICustomUpdateSerializer(propertyValue)) {
                handled = propertyValue.WriteSetUpdateToXml(writer, this.Owner, propertyDefinition);
            }
            if (!handled) {
                writer.WriteStartElement(XmlNamespace.Types, this.Owner.GetSetFieldXmlElementName());
                propertyDefinition.WriteToXml(writer);
                writer.WriteStartElement(XmlNamespace.Types, this.Owner.GetXmlElementName());
                propertyDefinition.WritePropertyValueToXml(writer, this, true /* isUpdateOperation */);
                writer.WriteEndElement();
                writer.WriteEndElement();
            }
        }
    };
    /**
     * @internal Writes the bag's properties to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer to write the properties to.
     */
    PropertyBag.prototype.WriteToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Types, this.Owner.GetXmlElementName());
        //debug: //todo: fix Schema objects IEnumerable.
        //
        for (var _a = 0, _b = this.Owner.Schema.GetEnumerator(); _a < _b.length; _a++) {
            var propertyDefinition = _b[_a];
            // The following test should not be necessary since the property bag prevents
            // properties to be set if they don't have the CanSet flag, but it doesn't hurt...
            if (propertyDefinition.HasFlag(PropertyDefinitionFlags.CanSet, writer.Service.RequestedServerVersion)) {
                if (this.Contains(propertyDefinition)) {
                    propertyDefinition.WritePropertyValueToXml(writer, this, false /* isUpdateOperation */);
                }
            }
        }
        writer.WriteEndElement();
    };
    /**
     * @internal Writes the EWS update operations corresponding to the changes that occurred in the bag to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer to write the updates to.
     */
    PropertyBag.prototype.WriteToXmlForUpdate = function (writer) {
        writer.WriteStartElement(XmlNamespace.Types, this.Owner.GetChangeXmlElementName());
        this.Owner.GetId().WriteToXml(writer);
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Updates);
        for (var _a = 0, _b = this.addedProperties; _a < _b.length; _a++) {
            var propertyDefinition = _b[_a];
            this.WriteSetUpdateToXml(writer, propertyDefinition);
        }
        for (var _c = 0, _d = this.modifiedProperties; _c < _d.length; _c++) {
            var propertyDefinition = _d[_c];
            this.WriteSetUpdateToXml(writer, propertyDefinition);
        }
        for (var _e = 0, _f = this.deletedProperties.Items; _e < _f.length; _e++) {
            var kv = _f[_e];
            this.WriteDeleteUpdateToXml(writer, kv.key, kv.value);
        }
        writer.WriteEndElement();
        writer.WriteEndElement();
    };
    return PropertyBag;
}());
exports.PropertyBag = PropertyBag;
/**
 * Represents a set of item or folder properties. Property sets are used to indicate what properties of an item or folder should be loaded when binding to an existing item or folder or when loading an item or folder's properties.
 *
 * @sealed
 */
var PropertySet = (function () {
    function PropertySet(basePropertySetOrAdditionalProperties, _additionalProperties) {
        if (basePropertySetOrAdditionalProperties === void 0) { basePropertySetOrAdditionalProperties = null; }
        if (_additionalProperties === void 0) { _additionalProperties = null; }
        /**
         * The base property set this property set is based upon.
         */
        this.basePropertySet = BasePropertySet.IdOnly;
        /**
         * The list of additional properties included in this property set.
         */
        this.additionalProperties = [];
        /**
         * The requested body type for get and find operations. If null, the "best body" is returned.
         */
        this.requestedBodyType = null; //nullable
        /**
         * The requested unique body type for get and find operations. If null, the should return the same value as body type.
         */
        this.requestedUniqueBodyType = null; //nullable
        /**
         * The requested normalized body type for get and find operations. If null, the should return the same value as body type.
         */
        this.requestedNormalizedBodyType = null; //nullable
        /**
         * Value indicating whether or not the server should filter HTML content.
         */
        this.filterHtml = null; //nullable
        /**
         * Value indicating whether or not the server should convert HTML code page to UTF8.
         */
        this.convertHtmlCodePageToUTF8 = null; //nullable
        /**
         * Value of the URL template to use for the src attribute of inline IMG elements.
         */
        this.inlineImageUrlTemplate = null;
        /**
         * Value indicating whether or not the server should block references to external images.
         */
        this.blockExternalImages = null; //nullable
        /**
         * Value indicating whether or not to add a blank target attribute to anchor links.
         */
        this.addTargetToLinks = null; //nullable
        /**
         * Value indicating whether or not this PropertySet can be modified.
         */
        this.isReadOnly = false;
        /**
         * Value indicating the maximum body size to retrieve.
         */
        this.maximumBodySize = null; //nullable
        var argsLength = arguments.length;
        var basePropertySet = BasePropertySet.IdOnly;
        var additionalProperties = [];
        if (argsLength >= 1) {
            if (typeof basePropertySetOrAdditionalProperties === 'number') {
                basePropertySet = basePropertySetOrAdditionalProperties;
            }
            else if (ArrayHelper.isArray(basePropertySetOrAdditionalProperties)) {
                additionalProperties = basePropertySetOrAdditionalProperties;
            }
            else {
                additionalProperties = [basePropertySetOrAdditionalProperties];
            }
        }
        if (argsLength >= 2) {
            if (ArrayHelper.isArray(_additionalProperties)) {
                additionalProperties = _additionalProperties;
            }
            else {
                additionalProperties.push(_additionalProperties);
            }
        }
        if (argsLength > 2) {
            for (var _i = 2; _i < arguments.length; _i++) {
                additionalProperties.push(arguments[_i]);
            }
        }
        this.basePropertySet = basePropertySet;
        if (additionalProperties.length > 0) {
            this.additionalProperties = additionalProperties;
            //ArrayHelper.AddRange(this.additionalProperties, <any>additionalProperties);
            //this.additionalProperties.push.apply(this.additionalProperties, additionalProperties); //todo: addrange for array - http://typescript.codeplex.com/workitem/1422
        }
    }
    Object.defineProperty(PropertySet, "DefaultPropertySetMap", {
        /**
         * @internal Maps BasePropertySet values to EWS's BaseShape values.
         */
        get: function () {
            return this.defaultPropertySetMap;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertySet.prototype, "BasePropertySet", {
        /**
         * Gets or sets the base property set the property set is based upon.
         */
        get: function () {
            return this.basePropertySet;
        },
        set: function (value) {
            this.ThrowIfReadonly();
            this.basePropertySet = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertySet.prototype, "RequestedBodyType", {
        /**
         * Gets or sets type of body that should be loaded on items. If RequestedBodyType is null, body is returned as HTML if available, plain text otherwise.
         *
         * @Nullable
         */
        get: function () {
            return this.requestedBodyType;
        },
        set: function (value) {
            this.ThrowIfReadonly();
            this.requestedBodyType = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertySet.prototype, "RequestedUniqueBodyType", {
        /**
         * Gets or sets type of body that should be loaded on items. If null, the should return the same value as body type.
         *
         * @nullable
         */
        get: function () {
            return this.requestedUniqueBodyType;
        },
        set: function (value) {
            this.ThrowIfReadonly();
            this.requestedUniqueBodyType = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertySet.prototype, "RequestedNormalizedBodyType", {
        /**
         * Gets or sets type of normalized body that should be loaded on items. If null, the should return the same value as body type.
         *
         * @nullable
         */
        get: function () {
            return this.requestedNormalizedBodyType;
        },
        set: function (value) {
            this.ThrowIfReadonly();
            this.requestedNormalizedBodyType = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertySet.prototype, "Count", {
        /**
         * Gets the number of explicitly added properties in this set.
         */
        get: function () {
            return this.additionalProperties.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertySet.prototype, "FilterHtmlContent", {
        /**
         * Gets or sets value indicating whether or not to filter potentially unsafe HTML content from message bodies.
         *
         * @nullable
         */
        get: function () {
            return this.filterHtml;
        },
        set: function (value) {
            this.ThrowIfReadonly();
            this.filterHtml = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertySet.prototype, "ConvertHtmlCodePageToUTF8", {
        /**
         * Gets or sets value indicating whether or not to convert HTML code page to UTF8 encoding.
         *
         * @nullable
         */
        get: function () {
            return this.convertHtmlCodePageToUTF8;
        },
        set: function (value) {
            this.ThrowIfReadonly();
            this.convertHtmlCodePageToUTF8 = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertySet.prototype, "InlineImageUrlTemplate", {
        /**
         * Gets or sets a value of the URL template to use for the src attribute of inline IMG elements.
         *
         * @nullable
         */
        get: function () {
            return this.inlineImageUrlTemplate;
        },
        set: function (value) {
            this.ThrowIfReadonly();
            this.inlineImageUrlTemplate = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertySet.prototype, "BlockExternalImages", {
        /**
         * Gets or sets value indicating whether or not to convert inline images to data URLs.
         *
         * @nullable
         */
        get: function () {
            return this.blockExternalImages;
        },
        set: function (value) {
            this.ThrowIfReadonly();
            this.blockExternalImages = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertySet.prototype, "AddBlankTargetToLinks", {
        /**
         * Gets or sets value indicating whether or not to add blank target attribute to anchor links.
         *
         * @nullable
         */
        get: function () {
            return this.addTargetToLinks;
        },
        set: function (value) {
            this.ThrowIfReadonly();
            this.addTargetToLinks = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PropertySet.prototype, "MaximumBodySize", {
        /**
         * Gets or sets the maximum size of the body to be retrieved.
         *
         * @nullable
         *
         * @value   The maximum size of the body to be retrieved.
         */
        get: function () {
            return this.maximumBodySize;
        },
        set: function (value) {
            this.ThrowIfReadonly();
            this.maximumBodySize = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the **PropertyDefinitionBase** at the specified index. this[int] indexer
     *
     * @param   {number}   index   Index.
     */
    PropertySet.prototype._getItem = function (index) {
        return this.additionalProperties[index];
    };
    /**
     * Adds the specified property to the property set.
     *
     * @param   {PropertyDefinitionBase}   property   The property to add.
     */
    PropertySet.prototype.Add = function (property) {
        this.ThrowIfReadonly();
        EwsUtilities.ValidateParam(property, "property");
        if (this.additionalProperties.indexOf(property) === -1) {
            this.additionalProperties.push(property);
        }
    };
    /**
     * Adds the specified properties to the property set.
     *
     * @param   {PropertyDefinitionBase[]}   properties   The properties to add.
     */
    PropertySet.prototype.AddRange = function (properties) {
        this.ThrowIfReadonly();
        EwsUtilities.ValidateParamCollection(properties, "properties");
        for (var _a = 0, properties_1 = properties; _a < properties_1.length; _a++) {
            var property = properties_1[_a];
            this.Add(property);
        }
    };
    /**
     * Remove all explicitly added properties from the property set.
     */
    PropertySet.prototype.Clear = function () {
        this.ThrowIfReadonly();
        this.additionalProperties.splice(0);
    };
    /**
     * Determines whether the specified property has been explicitly added to this property set using the Add or AddRange methods.
     *
     * @param   {PropertyDefinitionBase}    property   The property.
     * @return  {boolean}                   true if this property set contains the specified propert]; otherwise, false.
     */
    PropertySet.prototype.Contains = function (property) { return this.additionalProperties.indexOf(property) !== -1; };
    /**
     * Creates a read-only PropertySet.
     *
     * @param   {BasePropertySet}   basePropertySet   The base property set.
     * @return  {PropertySet}       PropertySet
     */
    PropertySet.CreateReadonlyPropertySet = function (basePropertySet) {
        var propertySet = new PropertySet(basePropertySet);
        propertySet.isReadOnly = true;
        return propertySet;
    };
    /**
     *  Returns an enumerator that iterates through the collection. this case this.additionalProperties itself
     */
    PropertySet.prototype.GetEnumerator = function () {
        return this.additionalProperties;
    };
    /**
     * Gets the name of the shape.
     *
     * @param   {ServiceObjectType}     serviceObjectType   Type of the service object.
     * @return  {string}                Shape name.
     */
    PropertySet.GetShapeName = function (serviceObjectType) {
        switch (serviceObjectType) {
            case ServiceObjectType.Item:
                return XmlElementNames.ItemShape;
            case ServiceObjectType.Folder:
                return XmlElementNames.FolderShape;
            case ServiceObjectType.Conversation:
                return XmlElementNames.ConversationShape;
            default:
                EwsLogging.Assert(false, "PropertySet.GetShapeName", StringHelper.Format("An unexpected object type {0} for property shape. This code path should never be reached.", serviceObjectType));
                return StringHelper.Empty;
        }
    };
    /**
     * @internal Validates this property set.
     */
    PropertySet.prototype.InternalValidate = function () {
        for (var i = 0; i < this.additionalProperties.length; i++) {
            if (this.additionalProperties[i] == null) {
                throw new ServiceValidationException(StringHelper.Format(Strings.AdditionalPropertyIsNull, i));
            }
        }
    };
    /**
     * Removes the specified property from the set.
     *
     * @param   {PropertyDefinitionBase}    property   The property to remove.
     * @return  {boolean}                   true if the property was successfully removed, false otherwise.
     */
    PropertySet.prototype.Remove = function (property) {
        this.ThrowIfReadonly();
        return ArrayHelper.RemoveEntry(this.additionalProperties, property);
    };
    /**
     * Throws if readonly property set.
     */
    PropertySet.prototype.ThrowIfReadonly = function () {
        if (this.isReadOnly) {
            throw new Error(" PropertySet can not be modified"); // System.NotSupportedException(Strings.PropertySetCannotBeModified);
        }
    };
    /**
     * Implements ISelfValidate.Validate. Validates this property set.
     */
    PropertySet.prototype.Validate = function () {
        this.InternalValidate();
    };
    /**
     * @internal Validates this property set instance for request to ensure that:
     *  1. Properties are valid for the request server version.
     *  2. If only summary properties are legal for this request (e.g. FindItem) then only summary properties were specified.
     *
     * @param   {ServiceRequestBase}    request                 The request.
     * @param   {boolean}               summaryPropertiesOnly   if set to true then only summary properties are allowed.
     */
    PropertySet.prototype.ValidateForRequest = function (request, summaryPropertiesOnly) {
        for (var _a = 0, _b = this.additionalProperties; _a < _b.length; _a++) {
            var propDefBase = _b[_a];
            //let propDefBase: PropertyDefinitionBase = propItem;
            var propertyDefinition = propDefBase;
            if (propertyDefinition instanceof PropertyDefinition /* != null*/) {
                if (propertyDefinition.Version > request.Service.RequestedServerVersion) {
                    throw new ServiceVersionException(StringHelper.Format(Strings.PropertyIncompatibleWithRequestVersion, propertyDefinition.Name, ExchangeVersion[propertyDefinition.Version]));
                }
                if (summaryPropertiesOnly && !propertyDefinition.HasFlag(PropertyDefinitionFlags.CanFind, request.Service.RequestedServerVersion)) {
                    throw new ServiceValidationException(StringHelper.Format(Strings.NonSummaryPropertyCannotBeUsed, propertyDefinition.Name, request.GetXmlElementName()));
                }
            }
        }
        if (this.FilterHtmlContent /*.HasValue*/) {
            if (request.Service.RequestedServerVersion < ExchangeVersion.Exchange2010) {
                throw new ServiceVersionException(StringHelper.Format(Strings.PropertyIncompatibleWithRequestVersion, "FilterHtmlContent", ExchangeVersion[ExchangeVersion.Exchange2010]));
            }
        }
        if (this.ConvertHtmlCodePageToUTF8 /*.HasValue*/) {
            if (request.Service.RequestedServerVersion < ExchangeVersion.Exchange2010_SP1) {
                throw new ServiceVersionException(StringHelper.Format(Strings.PropertyIncompatibleWithRequestVersion, "ConvertHtmlCodePageToUTF8", ExchangeVersion[ExchangeVersion.Exchange2010_SP1]));
            }
        }
        if (!StringHelper.IsNullOrEmpty(this.InlineImageUrlTemplate)) {
            if (request.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
                throw new ServiceVersionException(StringHelper.Format(Strings.PropertyIncompatibleWithRequestVersion, "InlineImageUrlTemplate", ExchangeVersion[ExchangeVersion.Exchange2013]));
            }
        }
        if (this.BlockExternalImages /*.HasValue*/) {
            if (request.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
                throw new ServiceVersionException(StringHelper.Format(Strings.PropertyIncompatibleWithRequestVersion, "BlockExternalImages", ExchangeVersion[ExchangeVersion.Exchange2013]));
            }
        }
        if (this.AddBlankTargetToLinks /*.HasValue*/) {
            if (request.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
                throw new ServiceVersionException(StringHelper.Format(Strings.PropertyIncompatibleWithRequestVersion, "AddTargetToLinks", ExchangeVersion[ExchangeVersion.Exchange2013]));
            }
        }
        if (this.MaximumBodySize /*.HasValue*/) {
            if (request.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
                throw new ServiceVersionException(StringHelper.Format(Strings.PropertyIncompatibleWithRequestVersion, "MaximumBodySize", ExchangeVersion[ExchangeVersion.Exchange2013]));
            }
        }
    };
    /**
     * @internal Writes additonal properties to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer                The writer to write to.
     * @param   {PropertyDefinitionBase[]}   propertyDefinitions   The property definitions to write.
     */
    PropertySet.WriteAdditionalPropertiesToXml = function (writer, propertyDefinitions) {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.AdditionalProperties);
        for (var _a = 0, propertyDefinitions_2 = propertyDefinitions; _a < propertyDefinitions_2.length; _a++) {
            var propertyDefinition = propertyDefinitions_2[_a];
            propertyDefinition.WriteToXml(writer);
        }
        writer.WriteEndElement();
    };
    /**
     * @internal Writes the property set to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer              The writer to write to.
     * @param   {ServiceObjectType}     serviceObjectType   The type of service object the property set is emitted for.
     */
    PropertySet.prototype.WriteToXml = function (writer, serviceObjectType) {
        var shapeElementName = PropertySet.GetShapeName(serviceObjectType);
        writer.WriteStartElement(XmlNamespace.Messages, shapeElementName);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.BaseShape, PropertySet.defaultPropertySetMap.Member.get(this.BasePropertySet));
        if (serviceObjectType == ServiceObjectType.Item) {
            if (this.RequestedBodyType /*.HasValue*/) {
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.BodyType, BodyType[this.RequestedBodyType] /*.Value*/);
            }
            if (this.RequestedUniqueBodyType /*.HasValue*/) {
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.UniqueBodyType, BodyType[this.RequestedUniqueBodyType] /*.Value*/);
            }
            if (this.RequestedNormalizedBodyType /*.HasValue*/) {
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.NormalizedBodyType, BodyType[this.RequestedNormalizedBodyType] /*.Value*/);
            }
            if (this.FilterHtmlContent /*.HasValue*/) {
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.FilterHtmlContent, this.FilterHtmlContent /*.Value*/);
            }
            if (this.ConvertHtmlCodePageToUTF8 /*.HasValue*/ &&
                writer.Service.RequestedServerVersion >= ExchangeVersion.Exchange2010_SP1) {
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ConvertHtmlCodePageToUTF8, this.ConvertHtmlCodePageToUTF8 /*.Value*/);
            }
            if (!StringHelper.IsNullOrEmpty(this.InlineImageUrlTemplate) &&
                writer.Service.RequestedServerVersion >= ExchangeVersion.Exchange2013) {
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.InlineImageUrlTemplate, this.InlineImageUrlTemplate);
            }
            if (this.BlockExternalImages /*.HasValue*/ &&
                writer.Service.RequestedServerVersion >= ExchangeVersion.Exchange2013) {
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.BlockExternalImages, this.BlockExternalImages /*.Value*/);
            }
            if (this.AddBlankTargetToLinks /*.HasValue*/ &&
                writer.Service.RequestedServerVersion >= ExchangeVersion.Exchange2013) {
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.AddBlankTargetToLinks, this.AddBlankTargetToLinks /*.Value*/);
            }
            if (this.MaximumBodySize /*.HasValue*/ &&
                writer.Service.RequestedServerVersion >= ExchangeVersion.Exchange2013) {
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.MaximumBodySize, this.MaximumBodySize /*.Value*/);
            }
        }
        if (this.additionalProperties.length > 0) {
            PropertySet.WriteAdditionalPropertiesToXml(writer, this.additionalProperties);
        }
        writer.WriteEndElement(); // Item/FolderShape
    };
    /**
     * Returns a predefined property set that only includes the Id property.
     */
    PropertySet.IdOnly = PropertySet.CreateReadonlyPropertySet(BasePropertySet.IdOnly);
    /**
     * Returns a predefined property set that includes the first class properties of an item or folder.
     */
    PropertySet.FirstClassProperties = PropertySet.CreateReadonlyPropertySet(BasePropertySet.FirstClassProperties);
    /**
     * Maps BasePropertySet values to EWS's BaseShape values.
     */
    PropertySet.defaultPropertySetMap = new LazyMember(function () {
        var result = new Dictionary(function (bps) { return BasePropertySet[bps]; });
        result.Add(BasePropertySet.IdOnly, "IdOnly");
        result.Add(BasePropertySet.FirstClassProperties, "AllProperties");
        return result;
    });
    return PropertySet;
}());
exports.PropertySet = PropertySet;
var SimplePropertyBag = (function () {
    function SimplePropertyBag(keyPicker) {
        this.items = null;
        this.removedItems = [];
        this.addedItems = [];
        this.modifiedItems = [];
        this.OnChange = [];
        this.items = new Dictionary(keyPicker);
    }
    Object.defineProperty(SimplePropertyBag.prototype, "AddedItems", {
        get: function () {
            return this.addedItems;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimplePropertyBag.prototype, "RemovedItems", {
        get: function () {
            return this.removedItems;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SimplePropertyBag.prototype, "ModifiedItems", {
        get: function () {
            return this.modifiedItems;
        },
        enumerable: true,
        configurable: true
    });
    SimplePropertyBag.prototype._getItem = function (key) {
        var value = { outValue: null };
        if (this.TryGetValue(key, value)) {
            return value.outValue;
        }
        else {
            return null;
        }
    };
    SimplePropertyBag.prototype._setItem = function (key, value) {
        if (value == null) {
            this.InternalRemoveItem(key);
        }
        else {
            // If the item was to be deleted, the deletion becomes an update.
            if (ArrayHelper.RemoveEntry(this.removedItems, key)) {
                this.InternalAddItemToChangeList(key, this.modifiedItems);
            }
            else {
                // If the property value was not set, we have a newly set property.
                if (!this.ContainsKey(key)) {
                    this.InternalAddItemToChangeList(key, this.addedItems);
                }
                else {
                    // The last case is that we have a modified property.
                    if (this.modifiedItems.indexOf(key) === -1) {
                        this.InternalAddItemToChangeList(key, this.modifiedItems);
                    }
                }
            }
            this.items.set(key, value);
            this.Changed();
        }
    };
    SimplePropertyBag.prototype.Changed = function () {
        if (this.OnChange != null) {
            EwsLogging.Assert(false, "SimplePropertyBag.Changed", "OnChange events not fired due to circular calling, todo: fix needed");
            return;
            for (var _a = 0, _b = this.OnChange; _a < _b.length; _a++) {
                var changeDelegate = _b[_a];
                changeDelegate();
            }
        }
    };
    SimplePropertyBag.prototype.ClearChangeLog = function () {
        this.removedItems.splice(0);
        this.addedItems.splice(0);
        this.modifiedItems.splice(0);
    };
    SimplePropertyBag.prototype.ContainsKey = function (key) { return this.items.containsKey(key); };
    SimplePropertyBag.prototype.GetEnumerator = function () { throw new Error("SimplePropertyBag.ts - GetEnumerator : Not implemented."); };
    SimplePropertyBag.prototype.InternalAddItemToChangeList = function (key, changeList) {
        if (changeList.indexOf(key) === -1) {
            changeList.push(key);
        }
    };
    SimplePropertyBag.prototype.InternalRemoveItem = function (key) {
        var value = { outValue: null };
        if (this.TryGetValue(key, value)) {
            this.items.remove(key);
            this.removedItems.push(key);
            this.Changed();
        }
    };
    SimplePropertyBag.prototype.TryGetValue = function (key, value) { return this.items.tryGetValue(key, value); };
    return SimplePropertyBag;
}());
exports.SimplePropertyBag = SimplePropertyBag;
/**
 * ## @internal *Not Implemented*
 */
var AsyncRequestResult = (function () {
    function AsyncRequestResult() {
    }
    AsyncRequestResult.prototype.ExtractServiceRequest = function (exchangeService, asyncResult /*System.IAsyncResult*/) { throw new Error("AsyncRequestResult.ts - ExtractServiceRequest<T> : Not implemented."); };
    return AsyncRequestResult;
}());
exports.AsyncRequestResult = AsyncRequestResult;
/**
 * @internal Represents an abstract service request.
 */
var ServiceRequestBase = (function () {
    /**
     *  @internal Initializes a new instance of the **ServiceRequestBase** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function ServiceRequestBase(service) {
        //#endregion
        /**
         * @internal Gets or sets the anchor mailbox associated with the request
         *
         * /remarks/    Setting this value will add special headers to the request which in turn will route the request directly to the mailbox server against which the request is to be executed.
         */
        this.AnchorMailbox = null;
        if (service == null) {
            throw new ArgumentNullException("service");
        }
        this.service = service;
        this.ThrowIfNotSupportedByRequestedServerVersion();
    }
    Object.defineProperty(ServiceRequestBase.prototype, "Service", {
        /**
         * @internal Gets the service.
         *
         * @value   The service.
         */
        get: function () {
            return this.service;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServiceRequestBase.prototype, "EmitTimeZoneHeader", {
        // #region abstract Methods for subclasses to override
        /**
         *  @internal Gets a value indicating whether the TimeZoneContext SOAP header should be eimitted.
         *
         * @value   true if the time zone should be emitted; otherwise, false.
         */
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    ServiceRequestBase.prototype.GetXmlElementName = function () { throw new Error("abstract method, must override"); };
    /**
     * @internal Gets the minimum server version required to process this request.
     *
     * @return  {ExchangeVersion}      Exchange server version.
     */
    ServiceRequestBase.prototype.GetMinimumRequiredServerVersion = function () { throw new Error("abstract method, must override"); };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    ServiceRequestBase.prototype.GetResponseXmlElementName = function () { throw new Error("abstract method, must override"); };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    ServiceRequestBase.prototype.ParseResponse = function (jsonBody) {
        var serviceResponse = new ServiceResponse();
        serviceResponse.LoadFromXmlJsObject(jsonBody, this.Service);
        return serviceResponse;
    };
    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ServiceRequestBase.prototype.WriteElementsToXml = function (writer) { throw new Error("abstract method, must override"); };
    //#endregion
    /**
     * @internal Allows the subclasses to add their own header information
     *
     * @param   {any}   webHeaderCollection   The HTTP request headers
     */
    ServiceRequestBase.prototype.AddHeaders = function (webHeaderCollection /*WebHeaderCollection*/) {
        if (!StringHelper.IsNullOrEmpty(this.AnchorMailbox)) {
            webHeaderCollection.Set(ServiceRequestBase.AnchorMailboxHeaderName, this.AnchorMailbox);
            webHeaderCollection.Set(ServiceRequestBase.ExplicitLogonUserHeaderName, this.AnchorMailbox);
        }
    };
    //BuildEwsHttpWebRequest(): IEwsHttpWebRequest { throw new Error("Could not implemented."); }
    ServiceRequestBase.prototype.BuildXHR = function () {
        var request = this.Service.PrepareHttpWebRequest(this.GetXmlElementName());
        //try
        //{
        //    IEwsHttpWebRequest request = this.Service.PrepareHttpWebRequest(this.GetXmlElementName());
        //    this.Service.TraceHttpRequestHeaders(TraceFlags.EwsRequestHttpHeaders, request);
        //    bool needSignature = this.Service.Credentials != null && this.Service.Credentials.NeedSignature;
        //    bool needTrace = this.Service.IsTraceEnabledFor(TraceFlags.EwsRequest);
        //    // If tracing is enabled, we generate the request in-memory so that we
        //    // can pass it along to the ITraceListener. Then we copy the stream to
        //    // the request stream.
        //    if (needSignature || needTrace) {
        //        this.TraceAndEmitRequest(request, needSignature, needTrace);
        //    }
        //    else {
        this.EmitRequest(request);
        //    }
        return request;
        //}
        //catch (WebException ex)
        //{
        //    if (ex.Status == WebExceptionStatus.ProtocolError && ex.Response != null) {
        //        this.ProcessWebException(ex);
        //    }
        //    // Wrap exception if the above code block didn't throw
        //    throw new ServiceRequestException(string.Format(Strings.ServiceRequestFailed, ex.Message), ex);
        //}
        //catch (IOException e)
        //{
        //    // Wrap exception.
        //    throw new ServiceRequestException(string.Format(Strings.ServiceRequestFailed, e.Message), e);
        //}
    };
    ServiceRequestBase.prototype.BuildResponseObjectFromJson = function (jsObject) {
        if (jsObject[XmlElementNames.SOAPHeaderElementName]) {
            this.ReadSoapHeader(jsObject[XmlElementNames.SOAPHeaderElementName]);
        }
        return this.ParseResponse(jsObject[XmlElementNames.SOAPBodyElementName]);
    };
    //CreateJsonHeaders(): JsonObject { throw new Error("Could not implemented."); }
    //CreateJsonRequest(): JsonObject { throw new Error("Could not implemented."); }
    /**
     * Emits the request.
     *
     * @param   {IXHROptions}   request   The request.
     */
    ServiceRequestBase.prototype.EmitRequest = function (request) {
        if (this.Service.RenderingMethod === RenderingMode.Xml) {
            var writer = new EwsServiceXmlWriter(this.service); //writer.Service
            this.WriteToXml(writer);
            request.data = writer.GetXML();
        }
        else if (this.Service.RenderingMethod === RenderingMode.JSON) {
            //JsonObject requestObject = this.CreateJsonRequest();
            //using(Stream serviceRequestStream = this.GetWebRequestStream(request))
            //{
            //    requestObject.SerializeToJson(serviceRequestStream);
            //}
            debugger;
        }
    };
    //EndGetEwsHttpWebResponse(request: IEwsHttpWebRequest, asyncResult: any /*System.IAsyncResult*/): IEwsHttpWebResponse { throw new Error("Could not implemented."); }
    ServiceRequestBase.prototype.GetEwsHttpWebResponse = function (request /*IEwsHttpWebRequest*/) { return this.service.XHRApi.xhr(request); };
    /**
     * Gets string representation of requested server version.
     *
     * /remarks/    In order to support E12 RTM servers, ExchangeService has another flag indicating that we should use "Exchange2007" as the server version string rather than Exchange2007_SP1.
     * @return  {string}      String representation of requested server version.
     */
    ServiceRequestBase.prototype.GetRequestedServiceVersionString = function () {
        if (this.Service.Exchange2007CompatibilityMode && this.Service.RequestedServerVersion == ExchangeVersion.Exchange2007_SP1) {
            return "Exchange2007";
        }
        else {
            return ExchangeVersion[this.Service.RequestedServerVersion];
        }
    };
    //GetResponseStream(response: IEwsHttpWebResponse): any /*System.IO.Stream*/ { throw new Error("Could not implemented."); }
    //GetResponseStream(response: IEwsHttpWebResponse, readTimeout: number):any /*System.IO.Stream*/{ throw new Error("ServiceRequestBase.ts - GetResponseStream : Not implemented.");}
    //GetWebRequestStream(request: IEwsHttpWebRequest): any /*System.IO.Stream*/ { throw new Error("Could not implemented."); }
    /**
     * Processes the web exception.
     *
     * @param   {XMLHttpRequest}   webException   The web response XHR object.
     * @return  {SoapFaultDetails}      Soap fault details if any.
     */
    ServiceRequestBase.prototype.ProcessWebException = function (webException) {
        if (webException) {
            //IEwsHttpWebResponse httpWebResponse = this.Service.HttpWebRequestFactory.CreateExceptionResponse(webException);
            var soapFaultDetails = null;
            if (webException.status == 500 /*System.Net.HttpStatusCode.InternalServerError*/) {
                //this.Service.ProcessHttpResponseHeaders(TraceFlags.EwsResponseHttpHeaders, httpWebResponse);
                // If tracing is enabled, we read the entire response into a MemoryStream so that we
                // can pass it along to the ITraceListener. Then we parse the response from the
                // MemoryStream.
                //if (this.Service.IsTraceEnabledFor(TraceFlags.EwsResponse)) {
                //    using(MemoryStream memoryStream = new MemoryStream())
                //    {
                //        using(Stream serviceResponseStream = ServiceRequestBase.GetResponseStream(httpWebResponse))
                //        {
                //            // Copy response to in-memory stream and reset position to start.
                //            EwsUtilities.CopyStream(serviceResponseStream, memoryStream);
                //            memoryStream.Position = 0;
                //        }
                //        if (this.Service.RenderingMethod == ExchangeService.RenderingMode.Xml) {
                //            this.TraceResponseXml(httpWebResponse, memoryStream);
                //            EwsServiceXmlReader reader = new EwsServiceXmlReader(memoryStream, this.Service);
                //            soapFaultDetails = this.ReadSoapFault(reader);
                //        }
                //        else if (this.Service.RenderingMethod == ExchangeService.RenderingMode.JSON) {
                //            this.TraceResponseJson(httpWebResponse, memoryStream);
                //            try {
                //                JsonObject jsonSoapFault = new JsonParser(memoryStream).Parse();
                //                soapFaultDetails = this.ReadSoapFault(jsonSoapFault);
                //            }
                //            catch (ServiceJsonDeserializationException) {
                //                // If no valid JSON response was returned, just return null SoapFault details
                //            }
                //        }
                //        else {
                //            throw new InvalidOperationException();
                //        }
                //    }
                //}
                //else {
                //    using(Stream stream = ServiceRequestBase.GetResponseStream(httpWebResponse))
                //    {
                //        if (this.Service.RenderingMethod == ExchangeService.RenderingMode.Xml) {
                //            EwsServiceXmlReader reader = new EwsServiceXmlReader(stream, this.Service);
                //            soapFaultDetails = this.ReadSoapFault(reader);
                //        }
                //        else if (this.Service.RenderingMethod == ExchangeService.RenderingMode.JSON) {
                //            try {
                //                JsonObject jsonSoapFault = new JsonParser(stream).Parse();
                //                soapFaultDetails = this.ReadSoapFault(jsonSoapFault);
                //            }
                //            catch (ServiceJsonDeserializationException) {
                //                // If no valid JSON response was returned, just return null SoapFault details
                //            }
                //        }
                //        else {
                //            throw new InvalidOperationException();
                //        }
                //    }
                //}
                //todo: fix tracing and other operations here
                var reader = new EwsServiceXmlReader(webException.responseText, this.Service);
                soapFaultDetails = this.ReadSoapFault(reader.JsObject);
                if (soapFaultDetails != null) {
                    //todo: implement soap fault error throw
                    this.SoapFaultDetails = soapFaultDetails;
                    soapFaultDetails.HttpStatusCode = webException.status;
                    //    switch (soapFaultDetails.ResponseCode) {
                    //        case ServiceError.ErrorInvalidServerVersion:
                    //            throw new Exceptions.ServiceVersionException(Strings.ServerVersionNotSupported);
                    //        case ServiceError.ErrorSchemaValidation:
                    //            // If we're talking to an E12 server (8.00.xxxx.xxx), a schema validation error is the same as a version mismatch error.
                    //            // (Which only will happen if we send a request that's not valid for E12).
                    //            if ((this.Service.ServerInfo != null) &&
                    //                (this.Service.ServerInfo.MajorVersion == 8) && (this.Service.ServerInfo.MinorVersion == 0)) {
                    //                throw new Exceptions.ServiceVersionException(Strings.ServerVersionNotSupported);
                    //            }
                    //            break;
                    //        case ServiceError.ErrorIncorrectSchemaVersion:
                    //            // This shouldn't happen. It indicates that a request wasn't valid for the version that was specified.
                    //            EwsUtilities.Assert(
                    //                false,
                    //                "ServiceRequestBase.ProcessWebException",
                    //                "Exchange server supports requested version but request was invalid for that version");
                    //            break;
                    //        case ServiceError.ErrorServerBusy:
                    //            throw new ServerBusyException(new ServiceResponse(soapFaultDetails));
                    //        default:
                    //            // Other error codes will be reported as remote error
                    //            break;
                    //    }
                    //    // General fall-through case: throw a ServiceResponseException
                    //    throw new ServiceResponseException(new ServiceResponse(soapFaultDetails));
                }
            }
            else {
                soapFaultDetails = new SoapFaultDetails(webException && webException.message ? webException.message : '');
                soapFaultDetails.HttpStatusCode = webException.status;
                if (webException.stack)
                    soapFaultDetails.stack = webException.stack;
                this.Service.ProcessHttpErrorResponse(webException, soapFaultDetails);
            }
            return soapFaultDetails;
        }
        return null;
    };
    /**
     * Reads the response from converted XML JS Object Soap enevlop is is omited, object has Body and Header as direct member.
     *
     * @param   {any}   jsObject    The converted XMl JS Object.
     * @return  {any}               Service response.
     */
    ServiceRequestBase.prototype.ReadResponseXmlJsObject = function (jsObject) {
        if (jsObject[XmlElementNames.SOAPHeaderElementName]) {
            this.ReadSoapHeader(jsObject[XmlElementNames.SOAPHeaderElementName]);
        }
        if (!jsObject[XmlElementNames.SOAPBodyElementName]) {
            throw new Error("invalid soap message");
        }
        var serviceResponse;
        var jsBody = jsObject[XmlElementNames.SOAPBodyElementName];
        var jsResponse = jsBody[this.GetResponseXmlElementName()];
        serviceResponse = this.ParseResponse(jsResponse);
        return serviceResponse;
    };
    /**
     * Reads the SOAP fault.
     *
     * @param   {any}   jsonSoapFault   The SOAP fault.
     * @return  {SoapFaultDetails}      Parsed SoapFaultDetails
     */
    ServiceRequestBase.prototype.ReadSoapFault = function (jsSoapFault) {
        var soapFaultDetails = null;
        if (jsSoapFault[XmlElementNames.SOAPHeaderElementName]) {
            this.ReadSoapHeader(jsSoapFault[XmlElementNames.SOAPHeaderElementName]);
        }
        if (jsSoapFault[XmlElementNames.SOAPBodyElementName]) {
            var jsSoapBody = jsSoapFault[XmlElementNames.SOAPBodyElementName];
            if (jsSoapBody[XmlElementNames.SOAPFaultElementName]) {
                soapFaultDetails = SoapFaultDetails.Parse(jsSoapBody[XmlElementNames.SOAPFaultElementName]);
            }
        }
        return soapFaultDetails;
    };
    /**
     * Read SOAP header and extract server version
     *
     * @param   {any}   jsObject   Header value in JsObject
     */
    ServiceRequestBase.prototype.ReadSoapHeader = function (jsObject) {
        if (jsObject[XmlElementNames.ServerVersionInfo]) {
            this.Service.ServerInfo = ExchangeServerInfo.Parse(jsObject[XmlElementNames.ServerVersionInfo]);
        }
    };
    /**
     * @internal Throw exception if request is not supported in requested server version.
     *
     * @exception   {ServiceVersionException}   Raised if request requires a later version of Exchange.
     */
    ServiceRequestBase.prototype.ThrowIfNotSupportedByRequestedServerVersion = function () {
        if (this.Service.RequestedServerVersion < this.GetMinimumRequiredServerVersion()) {
            throw new ServiceVersionException(StringHelper.Format(Strings.RequestIncompatibleWithRequestVersion, this.GetXmlElementName(), ExchangeVersion[this.GetMinimumRequiredServerVersion()]), null);
        }
    };
    //TraceAndEmitRequest(request: IEwsHttpWebRequest, needSignature: boolean, needTrace: boolean): any { throw new Error("Could not implemented."); }
    //TraceJsonRequest(requestObject: JsonObject): any { throw new Error("Could not implemented."); }
    //TraceResponseJson(response: IEwsHttpWebResponse, memoryStream: any): any { throw new Error("Could not implemented."); }
    //TraceResponseXml(response: IEwsHttpWebResponse, memoryStream: any): any { throw new Error("Could not implemented."); }
    //TraceXmlRequest(memoryStream: any): any { throw new Error("Could not implemented."); }
    /**
     * @internal Validate request.
     */
    ServiceRequestBase.prototype.Validate = function () {
        this.Service.Validate();
    };
    /**
     * Validates request parameters, and emits the request to the server.
     *
     * @param   {IXHROptions}               request   The request.
     * @return  {Promise<XMLHttpRequest>}  The response returned by the server.
     */
    ServiceRequestBase.prototype.ValidateAndEmitRequest = function (request) {
        this.Validate();
        //var request = this.BuildXHR();
        if (this.service.SendClientLatencies) {
            var clientStatisticsToAdd = '';
            //lock(clientStatisticsCache)
            //{
            if (ServiceRequestBase.clientStatisticsCache.length > 0) {
                clientStatisticsToAdd = ServiceRequestBase.clientStatisticsCache[0];
                ServiceRequestBase.clientStatisticsCache.splice(0, 1);
            }
            //}
            if (!StringHelper.IsNullOrEmpty(clientStatisticsToAdd)) {
                if (request.headers[ServiceRequestBase.ClientStatisticsRequestHeader]) {
                    request.headers[ServiceRequestBase.ClientStatisticsRequestHeader] =
                        request.headers[ServiceRequestBase.ClientStatisticsRequestHeader] + clientStatisticsToAdd;
                }
                else {
                    request.headers[ServiceRequestBase.ClientStatisticsRequestHeader] = clientStatisticsToAdd;
                }
            }
        }
        //var startTime = Date.now();// DateTime.UtcNow;
        //var response = XHR(request);
        EwsLogging.DebugLog("sending ews request");
        EwsLogging.DebugLog(request, true);
        return this.service.XHRApi.xhr(request);
        //try
        //{
        //    var response = this.GetEwsHttpWebResponse(request);
        //}
        //finally {
        //    if (this.service.SendClientLatencies) {
        //        int clientSideLatency = (int)(DateTime.UtcNow - startTime).TotalMilliseconds;
        //        string requestId = string.Empty;
        //        string soapAction = this.GetType().Name.Replace("Request", string.Empty);
        //        if (response != null && response.Headers != null) {
        //            foreach(string requestIdHeader in ServiceRequestBase.RequestIdResponseHeaders)
        //            {
        //                string requestIdValue = response.Headers.Get(requestIdHeader);
        //                if (!string.IsNullOrEmpty(requestIdValue)) {
        //                    requestId = requestIdValue;
        //                    break;
        //                }
        //            }
        //        }
        //        StringBuilder sb = new StringBuilder();
        //        sb.Append("MessageId=");
        //        sb.Append(requestId);
        //        sb.Append(",ResponseTime=");
        //        sb.Append(clientSideLatency);
        //        sb.Append(",SoapAction=");
        //        sb.Append(soapAction);
        //        sb.Append(";");
        //        lock(clientStatisticsCache)
        //        {
        //            clientStatisticsCache.Add(sb.ToString());
        //        }
        //    }
        //}
        //return response;
    };
    //WrapStream(responseStream: any /*System.IO.Stream*/, contentEncoding: string): any /*System.IO.Stream*/ { throw new Error("Could not implemented."); }
    /**
     * @internal Writes XML attributes.
     *
     * /remarks/    Subclass will override if it has XML attributes.
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ServiceRequestBase.prototype.WriteAttributesToXml = function (writer) { };
    /**
     * @internal Writes XML body.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ServiceRequestBase.prototype.WriteBodyToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Messages, this.GetXmlElementName());
        this.WriteAttributesToXml(writer);
        this.WriteElementsToXml(writer);
        writer.WriteEndElement(); // m:this.GetXmlElementName()
    };
    //#region HttpWebRequest-based implementation
    /**
     * @internal Writes XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ServiceRequestBase.prototype.WriteToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Soap, XmlElementNames.SOAPEnvelopeElementName);
        writer.WriteAttributeValue("xmlns", EwsUtilities.EwsXmlSchemaInstanceNamespacePrefix, EwsUtilities.EwsXmlSchemaInstanceNamespace);
        writer.WriteAttributeValue("xmlns", EwsUtilities.EwsMessagesNamespacePrefix, EwsUtilities.EwsMessagesNamespace);
        writer.WriteAttributeValue("xmlns", EwsUtilities.EwsTypesNamespacePrefix, EwsUtilities.EwsTypesNamespace);
        if (writer.RequireWSSecurityUtilityNamespace) {
            writer.WriteAttributeValue("xmlns", EwsUtilities.WSSecurityUtilityNamespacePrefix, EwsUtilities.WSSecurityUtilityNamespace);
        }
        writer.WriteStartElement(XmlNamespace.Soap, XmlElementNames.SOAPHeaderElementName);
        if (this.Service.Credentials != null) {
            //todo: fix extra soap headers if required
            this.Service.Credentials.EmitExtraSoapHeaderNamespaceAliases(null);
        }
        // Emit the RequestServerVersion header
        if (!this.Service.SuppressXmlVersionHeader) {
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.RequestServerVersion);
            writer.WriteAttributeValue(XmlAttributeNames.Version, this.GetRequestedServiceVersionString());
            writer.WriteEndElement(); // RequestServerVersion
        }
        // Against Exchange 2007 SP1, we always emit the simplified time zone header. It adds very little to
        // the request, so bandwidth consumption is not an issue. Against Exchange 2010 and above, we emit
        // the full time zone header but only when the request actually needs it.
        //
        // The exception to this is if we are in Exchange2007 Compat Mode, in which case we should never emit
        // the header.  (Note: Exchange2007 Compat Mode is enabled for testability purposes only.)
        //
        if ((this.Service.RequestedServerVersion == ExchangeVersion.Exchange2007_SP1 || this.EmitTimeZoneHeader) &&
            (!this.Service.Exchange2007CompatibilityMode)) {
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.TimeZoneContext);
            this.Service.TimeZoneDefinition.WriteToXml(writer);
            writer.WriteEndElement(); // TimeZoneContext
            writer.IsTimeZoneHeaderEmitted = true;
        }
        // Emit the MailboxCulture header
        if (this.Service.PreferredCulture != null) {
            //todo: fix preferred culture.
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.MailboxCulture, this.Service.PreferredCulture.Name);
        }
        // Emit the DateTimePrecision header
        if (this.Service.DateTimePrecision != DateTimePrecision.Default) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DateTimePrecision, DateTimePrecision[this.Service.DateTimePrecision]);
            //this.Service.DateTimePrecision.ToString());
        }
        // Emit the ExchangeImpersonation header
        if (this.Service.ImpersonatedUserId != null) {
            this.Service.ImpersonatedUserId.WriteToXml(writer);
        }
        else if (this.Service.PrivilegedUserId != null) {
            //todo: find scenario if this is used anywhere, did not find any reference in MSDN
            this.Service.PrivilegedUserId.WriteToXml(writer, this.Service.RequestedServerVersion);
        }
        else if (this.Service.ManagementRoles != null) {
            this.Service.ManagementRoles.WriteToXml(writer);
        }
        if (this.Service.Credentials != null) {
            this.Service.Credentials.SerializeExtraSoapHeaders(writer, this.GetXmlElementName());
        }
        this.Service.DoOnSerializeCustomSoapHeaders(writer);
        writer.WriteEndElement(); // soap:Header
        writer.WriteStartElement(XmlNamespace.Soap, XmlElementNames.SOAPBodyElementName);
        this.WriteBodyToXml(writer);
        writer.WriteEndElement(); // soap:Body
        writer.WriteEndElement(); // soap:Envelope
    };
    //#region private static and const
    //ref:this may be from newer code overall i am using, update when updating from ews base code library //todo:
    /**
     * The two contants below are used to set the AnchorMailbox and ExplicitLogonUser values in the request header.
     *
     * /remarks/    Note: Setting this values will route the request directly to the backend hosting the AnchorMailbox. These headers should be used primarily for UnifiedGroup scenario where a request needs to be routed directly to the group mailbox versus the user mailbox.
     */
    ServiceRequestBase.AnchorMailboxHeaderName = "X-AnchorMailbox";
    ServiceRequestBase.ExplicitLogonUserHeaderName = "X-OWA-ExplicitLogonUser";
    ServiceRequestBase.RequestIdResponseHeaders = ["RequestId", "request-id"];
    ServiceRequestBase.XMLSchemaNamespace = "http://www.w3.org/2001/XMLSchema";
    ServiceRequestBase.XMLSchemaInstanceNamespace = "http://www.w3.org/2001/XMLSchema-instance";
    ServiceRequestBase.ClientStatisticsRequestHeader = "X-ClientStatistics";
    /**
     * Maintains the collection of client side statistics for requests already completed
     */
    ServiceRequestBase.clientStatisticsCache = [];
    return ServiceRequestBase;
}());
exports.ServiceRequestBase = ServiceRequestBase;
/**
 * @internal Represents a collection of arguments for the HangingServiceRequestBase.HangingRequestDisconnectHandler delegate method.
 */
var HangingRequestDisconnectEventArgs = (function () {
    /**
     * Initializes a new instance of the **HangingRequestDisconnectEventArgs** class.
     *
     * @param   {HangingRequestDisconnectReason}   	reason      The reason.
     * @param   {Exception}   						exception   The exception.
     */
    function HangingRequestDisconnectEventArgs(reason, exception) {
        this.Reason = reason;
        this.Exception = exception;
    }
    return HangingRequestDisconnectEventArgs;
}());
exports.HangingRequestDisconnectEventArgs = HangingRequestDisconnectEventArgs;
/**
 * @internal Represents an abstract, hanging service request.
 */
var HangingServiceRequestBase = (function (_super) {
    __extends(HangingServiceRequestBase, _super);
    // /**
    //  * ews-javascript-api:  FetchStream object
    //  */
    // private stream: FetchStream;
    /**
     * @internal Initializes a new instance of the **HangingServiceRequestBase** class.
     *
     * @param   {ExchangeService}   	service                	The service.
     * @param   {HandleResponseObject} 	handler   				Callback delegate to handle response objects.
     * @param   {number}   				heartbeatFrequency      Frequency at which we expect heartbeats, in milliseconds.
     */
    function HangingServiceRequestBase(service, handler, heartbeatFrequency) {
        var _this = _super.call(this, service) || this;
        _this.responseHandler = null;
        _this.response = null;
        _this.request = null;
        _this.heartbeatFrequencyMilliseconds = 0;
        /**
         * @internal Occurs when the hanging request is disconnected. events converted into array of delagte function
         */
        _this.OnDisconnect = [];
        _this.IsConnected = false;
        /**
         * Stores chunked data from fetch FetchStream
         */
        _this.chunk = '';
        _this.responseHandler = handler;
        _this.heartbeatFrequencyMilliseconds = heartbeatFrequency;
        return _this;
    }
    HangingServiceRequestBase.prototype.Disconnect = function (reason, exception) {
        if (reason === void 0) { reason = HangingRequestDisconnectReason.UserInitiated; }
        if (exception === void 0) { exception = null; }
        if (this.IsConnected) {
            this.Service.XHRApi.disconnect();
            this.InternalOnDisconnect(reason, exception);
        }
    };
    /**
     * @internal Exectures the request.
     */
    HangingServiceRequestBase.prototype.InternalExecute = function () {
        //lock (this.lockObject){
        //this.response = this.ValidateAndEmitRequest(this.BuildXHR());
        var _this = this;
        return new exports.Promise(function (successDelegate, errorDelegate) {
            var request = _this.BuildXHR();
            //this.ReadResponsePrivate(response);
            _this.ValidateAndEmitRequest(request, function (progress) {
                switch (progress.type) {
                    case "data":
                        _this.InternalOnConnect();
                        progress.data = progress.data.trim();
                        _this.chunk += progress.data;
                        var _continue = false;
                        var xml = '';
                        if (!StringHelper.IsNullOrEmpty(_this.chunk)) {
                            //"<Envelope>indexOf</Envelope>"
                            var start = _this.chunk.indexOf("<Envelope");
                            var end = _this.chunk.indexOf("</Envelope>");
                            if (start >= 0 && end > 0) {
                                xml = _this.chunk.substr(start, end - start + 11);
                                _this.chunk = _this.chunk.substr(end + 11);
                                _continue = true;
                            }
                        }
                        if (_continue) {
                            var dom = new exports.DOMParser();
                            var xml2js = new xml2JsObject();
                            var req = void 0;
                            try {
                                //req = xml2js.parseXMLNode(dom.parseFromString(xml, "text/xml").documentElement, true);
                                //EwsLogging.DebugLog(req, true);
                                EwsLogging.DebugLog(xml, true);
                                var ewsXmlReader = new EwsServiceXmlReader(xml, _this.Service);
                                EwsLogging.DebugLog(ewsXmlReader.JsObject, true);
                                //var serviceResponse = 
                                _this.ParseResponses(ewsXmlReader.JsObject);
                                // if (successDelegate)
                                //     successDelegate(serviceResponse || xml);
                                // else {
                                //     if (errorDelegate)
                                //         errorDelegate(xml);
                                // }
                            }
                            catch (error) {
                                if (errorDelegate)
                                    errorDelegate(error);
                            }
                        }
                        break;
                    case "header":
                        _this.InternalOnConnect();
                        if (_this.OnResponseHeader && typeof _this.OnResponseHeader === 'function') {
                            _this.OnResponseHeader(progress.headers);
                        }
                        //console.log(meta);
                        break;
                    case "end":
                        _this.IsConnected = false;
                        break;
                    case "error":
                        _this.Disconnect(HangingRequestDisconnectReason.Exception, progress.error);
                        if (errorDelegate) {
                            errorDelegate(progress.error);
                        }
                        break;
                    default:
                        break;
                }
            }).then(function (xhrResponse) {
                //console.log(xhrResponse);
                //successDelegate(void 0);
            }, function (resperr) {
                if (resperr.status && resperr.getAllResponseHeaders) {
                    EwsLogging.Log("Error in calling service, error code: " + resperr.status + "\r\n " + resperr.getAllResponseHeaders());
                }
                else {
                    EwsLogging.Log("Error in calling service, error code: " + (resperr.status || resperr.message));
                }
                if (errorDelegate)
                    errorDelegate(_this.ProcessWebException(resperr) || resperr);
            });
        });
    };
    /**
     * Perform any bookkeeping needed when we connect
     */
    HangingServiceRequestBase.prototype.InternalOnConnect = function () {
        if (!this.IsConnected) {
            this.IsConnected = true;
            // Trace Http headers
            // this.Service.ProcessHttpResponseHeaders(
            //     TraceFlags.EwsResponseHttpHeaders,
            //     this.response);
            //info: //ref: - not needed, no threadpool, handled in 
            // ThreadPool.QueueUserWorkItem(
            //     new WaitCallback(this.ParseResponses));
        }
    };
    /**
     * Perform any bookkeeping needed when we disconnect (cleanly or forcefully)
     *
     * @param   {HangingRequestDisconnectReason}    reason      [description]
     * @param   {Exception}                         exception   [description]
     */
    HangingServiceRequestBase.prototype.InternalOnDisconnect = function (reason, exception) {
        var _this = this;
        if (this.IsConnected) {
            this.IsConnected = false;
            if (this.OnDisconnect && ArrayHelper.isArray(this.OnDisconnect)) {
                try {
                    this.OnDisconnect.forEach(function (OnDisconnect) {
                        OnDisconnect(_this, new HangingRequestDisconnectEventArgs(reason, exception));
                    });
                }
                catch (e) { }
            }
        }
    };
    //* @return  {any}   parsed response object.
    /**
     * Parses the responses.
     *
     * @param   {any}   state   Notification state.
     */
    HangingServiceRequestBase.prototype.ParseResponses = function (state) {
        try {
            var responseObject = this.ReadResponseXmlJsObject(state);
            this.responseHandler(responseObject);
        }
        catch (error) {
            this.Disconnect(HangingRequestDisconnectReason.Exception, error);
            console.log("error parsing object....\n TODO: Implement better parse error for Notifications");
            //console.log(state);
        }
        // try
        //     {
        //         Guid traceId = Guid.Empty;
        //         HangingTraceStream tracingStream = null;
        //         MemoryStream responseCopy = null;
        //         try
        //         {
        //             bool traceEwsResponse = this.Service.IsTraceEnabledFor(TraceFlags.EwsResponse);
        //             using (Stream responseStream = this.response.GetResponseStream())
        //             {
        //                 responseStream.ReadTimeout = 2 * this.heartbeatFrequencyMilliseconds;
        //                 tracingStream = new HangingTraceStream(responseStream, this.Service);
        //                 // EwsServiceMultiResponseXmlReader.Create causes a read.
        //                 if (traceEwsResponse)
        //                 {
        //                     responseCopy = new MemoryStream();
        //                     tracingStream.SetResponseCopy(responseCopy);
        //                 }
        //                 EwsServiceMultiResponseXmlReader ewsXmlReader = EwsServiceMultiResponseXmlReader.Create(tracingStream, this.Service);
        //                 while (this.IsConnected)
        //                 {
        //                     object responseObject = null;
        //                     if (traceEwsResponse)
        //                     {
        //                         try
        //                         {
        //                             responseObject = this.ReadResponse(ewsXmlReader, this.response.Headers);
        //                         }
        //                         finally
        //                         {
        //                             this.Service.TraceXml(TraceFlags.EwsResponse, responseCopy);
        //                         }
        //                         // reset the stream collector.
        //                         responseCopy.Close();
        //                         responseCopy = new MemoryStream();
        //                         tracingStream.SetResponseCopy(responseCopy);
        //                     }
        //                     else
        //                     {
        //                         responseObject = this.ReadResponse(ewsXmlReader, this.response.Headers);
        //                     }
        //                     this.responseHandler(responseObject);
        //                 }
        //             }
        //         }
        //         catch (TimeoutException ex)
        //         {
        //             // The connection timed out.
        //             this.Disconnect(HangingRequestDisconnectReason.Timeout, ex);
        //             return;
        //         }
        //         catch (IOException ex)
        //         {
        //             // Stream is closed, so disconnect.
        //             this.Disconnect(HangingRequestDisconnectReason.Exception, ex);
        //             return;
        //         }
        //         catch (HttpException ex)
        //         {
        //             // Stream is closed, so disconnect.
        //             this.Disconnect(HangingRequestDisconnectReason.Exception, ex);
        //             return;
        //         }
        //         catch (WebException ex)
        //         {
        //             // Stream is closed, so disconnect.
        //             this.Disconnect(HangingRequestDisconnectReason.Exception, ex);
        //             return;
        //         }
        //         catch (ObjectDisposedException ex)
        //         {
        //             // Stream is closed, so disconnect.
        //             this.Disconnect(HangingRequestDisconnectReason.Exception, ex);
        //             return;
        //         }
        //         catch (NotSupportedException)
        //         {
        //             // This is thrown if we close the stream during a read operation due to a user method call.
        //             // Trying to delay closing until the read finishes simply results in a long-running connection.
        //             this.Disconnect(HangingRequestDisconnectReason.UserInitiated, null);
        //             return;
        //         }
        //         catch (XmlException ex)
        //         {
        //             // Thrown if server returned no XML document.
        //             this.Disconnect(HangingRequestDisconnectReason.UserInitiated, ex);
        //             return;
        //         }
        //         finally
        //         {
        //             if (responseCopy != null)
        //             {
        //                 responseCopy.Dispose();
        //                 responseCopy = null;
        //             }
        //         }
        //     }
        //     catch (ServiceLocalException exception)
        //     {
        //         this.Disconnect(HangingRequestDisconnectReason.Exception, exception);
        //     }
    };
    //ReadPreamble(ewsXmlReader: EwsServiceXmlReader): void { throw new Error("HangingServiceRequestBase.ts - ReadPreamble : Not implemented."); }
    /* ews-javascript-api specific */
    /**
     * Validates request parameters, and emits the request to the server.
     *
     * @param   {IXHROptions}               request   The request.
     * @return  {Promise<XMLHttpRequest>}   The response returned by the server.
     */
    HangingServiceRequestBase.prototype.ValidateAndEmitRequest = function (request, progressDelegate) {
        this.Validate();
        //var request = this.BuildXHR();
        if (this.Service.SendClientLatencies) {
            var clientStatisticsToAdd = '';
            //lock(clientStatisticsCache)
            //{
            if (ServiceRequestBase.clientStatisticsCache.length > 0) {
                clientStatisticsToAdd = ServiceRequestBase.clientStatisticsCache[0];
                ServiceRequestBase.clientStatisticsCache.splice(0, 1);
            }
            //}
            if (!StringHelper.IsNullOrEmpty(clientStatisticsToAdd)) {
                if (request.headers[ServiceRequestBase.ClientStatisticsRequestHeader]) {
                    request.headers[ServiceRequestBase.ClientStatisticsRequestHeader] =
                        request.headers[ServiceRequestBase.ClientStatisticsRequestHeader] + clientStatisticsToAdd;
                }
                else {
                    request.headers[ServiceRequestBase.ClientStatisticsRequestHeader] = clientStatisticsToAdd;
                }
            }
        }
        //var startTime = Date.now();// DateTime.UtcNow;
        //var response = XHR(request);
        EwsLogging.DebugLog("sending ews request");
        EwsLogging.DebugLog(request, true);
        return this.Service.XHRApi.xhrStream(request, progressDelegate);
        // return new Promise((successDelegate, errorDelegate) => {
        //     this.stream = new FetchStream(this.Service.Url.ToString(), request);
        //     this.stream.on("data", (chunk) => {
        //         //console.log(chunk.toString());
        //         progressDelegate(chunk.toString());
        //     });
        //     this.stream.on("meta", (meta) => {
        //         if (this.OnResponseHeader && typeof this.OnResponseHeader === 'function') {
        //             this.OnResponseHeader(meta["responseHeaders"])
        //         }
        //         //console.log(meta);
        //     });
        //     this.stream.on("end", (data) => {
        //         this.IsConnected = false;
        //     });
        //     this.stream.on('error', (error) => {
        //         this.Disconnect(HangingRequestDisconnectReason.Exception, <any>error);
        //         if (errorDelegate) {
        //             errorDelegate(error);
        //         }
        //     });
        // });
        //try
        //{
        //    var response = this.GetEwsHttpWebResponse(request);
        //}
        //finally {
        //    if (this.service.SendClientLatencies) {
        //        int clientSideLatency = (int)(DateTime.UtcNow - startTime).TotalMilliseconds;
        //        string requestId = string.Empty;
        //        string soapAction = this.GetType().Name.Replace("Request", string.Empty);
        //        if (response != null && response.Headers != null) {
        //            foreach(string requestIdHeader in ServiceRequestBase.RequestIdResponseHeaders)
        //            {
        //                string requestIdValue = response.Headers.Get(requestIdHeader);
        //                if (!string.IsNullOrEmpty(requestIdValue)) {
        //                    requestId = requestIdValue;
        //                    break;
        //                }
        //            }
        //        }
        //        StringBuilder sb = new StringBuilder();
        //        sb.Append("MessageId=");
        //        sb.Append(requestId);
        //        sb.Append(",ResponseTime=");
        //        sb.Append(clientSideLatency);
        //        sb.Append(",SoapAction=");
        //        sb.Append(soapAction);
        //        sb.Append(";");
        //        lock(clientStatisticsCache)
        //        {
        //            clientStatisticsCache.Add(sb.ToString());
        //        }
        //    }
        //}
        //return response;
    };
    HangingServiceRequestBase.BufferSize = 4096;
    return HangingServiceRequestBase;
}(ServiceRequestBase));
exports.HangingServiceRequestBase = HangingServiceRequestBase;
/**
 * @internal Represents a GetStreamingEvents request.
 */
var GetStreamingEventsRequest = (function (_super) {
    __extends(GetStreamingEventsRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetStreamingEventsRequest** class.
     *
     * @param   {ExchangeService}   	service                The service.
     * @param   {HandleResponseObject} 	serviceObjectHandler   Callback method to handle response objects received.
     * @param   {string[]}   			subscriptionIds        List of subscription ids to listen to on this request.
     * @param   {number}   				connectionTimeout      Connection timeout, in minutes.
     */
    function GetStreamingEventsRequest(service, serviceObjectHandler, subscriptionIds, connectionTimeout) {
        var _this = _super.call(this, service, serviceObjectHandler, GetStreamingEventsRequest.heartbeatFrequency) || this;
        _this.subscriptionIds = subscriptionIds;
        _this.connectionTimeout = connectionTimeout;
        return _this;
    }
    Object.defineProperty(GetStreamingEventsRequest, "HeartbeatFrequency", {
        /**
         * @internal Allow test code to change heartbeat value
         * /remarks/	set only.
         */
        set: function (value) {
            this.heartbeatFrequency = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetStreamingEventsRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2010_SP1; };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    GetStreamingEventsRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.GetStreamingEventsResponse; };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetStreamingEventsRequest.prototype.GetXmlElementName = function () { return XmlElementNames.GetStreamingEvents; };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    GetStreamingEventsRequest.prototype.ParseResponse = function (jsBody) {
        var jsResponseMessages = jsBody[XmlElementNames.ResponseMessages];
        var response = new GetStreamingEventsResponse(this);
        response.LoadFromXmlJsObject(jsResponseMessages[XmlElementNames.GetStreamingEventsResponseMessage], this.Service);
        return response;
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetStreamingEventsRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.SubscriptionIds);
        for (var _a = 0, _b = this.subscriptionIds; _a < _b.length; _a++) {
            var id = _b[_a];
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.SubscriptionId, id);
        }
        writer.WriteEndElement();
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.ConnectionTimeout, this.connectionTimeout);
    };
    GetStreamingEventsRequest.HeartbeatFrequencyDefault = 45000;
    GetStreamingEventsRequest.heartbeatFrequency = GetStreamingEventsRequest.HeartbeatFrequencyDefault;
    return GetStreamingEventsRequest;
}(HangingServiceRequestBase));
exports.GetStreamingEventsRequest = GetStreamingEventsRequest;
/** @internal */
var SimpleServiceRequestBase = (function (_super) {
    __extends(SimpleServiceRequestBase, _super);
    function SimpleServiceRequestBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    //BeginExecute(callback: System.AsyncCallback, state: any): any/*System.IAsyncResult*/ { throw new Error("SimpleServiceRequestBase.ts - BeginExecute : Not implemented.");}
    //EndInternalExecute(asyncResult: any/*System.IAsyncResult*/): any { throw new Error("SimpleServiceRequestBase.ts - EndInternalExecute : Not implemented.");}
    SimpleServiceRequestBase.prototype.InternalExecute = function () {
        //var writer = new Data.EwsServiceXmlWriter();
        //this.WriteSoapRequest(this.url, writer);
        var _this = this;
        //if (!this.Service && !this.Service.Credentials && (!this.Service.Credentials.UserName || this.service.Credentials.Password))
        //    throw new Error("missing credential");
        //var cred = "Basic " + btoa(this.Service.Credentials.UserName + ":" + this.Service.Credentials.Password);
        //var cc = writer.GetXML();
        //var xhrOptions: IXHROptions = {
        //    type: "POST",
        //    data: cc,
        //    url: "https://pod51045.outlook.com/autodiscover/autodiscover.svc",
        //    headers: { "Content-Type": "text/xml", "Authorization": cred },
        //    //customRequestInitializer: function (x) {
        //    //    var m = x;
        //    //}
        //};
        return new exports.Promise(function (successDelegate, errorDelegate) {
            var request = _this.BuildXHR();
            //this.ReadResponsePrivate(response);
            _this.ValidateAndEmitRequest(request).then(function (xhrResponse) {
                var dom = new exports.DOMParser();
                var xml2js = new xml2JsObject();
                var req = xml2js.parseXMLNode(dom.parseFromString(request.data, "text/xml").documentElement, true);
                EwsLogging.DebugLog(req, true);
                if (xhrResponse.status == 200) {
                    EwsLogging.DebugLog(xhrResponse, true);
                    var ewsXmlReader = new EwsServiceXmlReader(xhrResponse.responseText || xhrResponse.response, _this.Service);
                    //EwsLogging.DebugLog(ewsXmlReader.JsObject, true);
                    var serviceResponse = _this.ReadResponsePrivate(ewsXmlReader.JsObject);
                    if (successDelegate)
                        successDelegate(serviceResponse || xhrResponse.responseText || xhrResponse.response);
                }
                else {
                    if (errorDelegate)
                        errorDelegate(_this.ProcessWebException(serviceResponse || xhrResponse.responseText || xhrResponse.response) || serviceResponse);
                }
            }, function (resperr) {
                EwsLogging.Log("Error in calling service, error code:" + resperr.status + "\r\n" + resperr.getAllResponseHeaders());
                if (errorDelegate)
                    errorDelegate(_this.ProcessWebException(resperr) || resperr);
            });
        });
    };
    SimpleServiceRequestBase.prototype.ReadResponsePrivate = function (response /*IEwsHttpWebResponse*/) {
        var serviceResponse;
        try {
            this.Service.ProcessHttpResponseHeaders(TraceFlags.EwsResponseHttpHeaders, response);
            // If tracing is enabled, we read the entire response into a MemoryStream so that we
            // can pass it along to the ITraceListener. Then we parse the response from the
            // MemoryStream.
            if (this.Service.IsTraceEnabledFor(TraceFlags.EwsResponse)) {
                //using(MemoryStream memoryStream = new MemoryStream())
                //{
                //    using(Stream serviceResponseStream = ServiceRequestBase.GetResponseStream(response))
                //    {
                //        // Copy response to in-memory stream and reset position to start.
                //        EwsUtilities.CopyStream(serviceResponseStream, memoryStream);
                //        memoryStream.Position = 0;
                //    }
                //    if (this.Service.RenderingMethod == ExchangeService.RenderingMode.Xml) {
                //        this.TraceResponseXml(response, memoryStream);
                //        serviceResponse = this.ReadResponseXml(memoryStream);
                //    }
                //    else if (this.Service.RenderingMethod == ExchangeService.RenderingMode.JSON) {
                //        this.TraceResponseJson(response, memoryStream);
                //        serviceResponse = this.ReadResponseJson(memoryStream);
                //    }
                //    else {
                //        throw new InvalidOperationException("Unknown RenderingMethod.");
                //    }
                //}
            }
            else {
                if (this.Service.RenderingMethod == RenderingMode.Xml) {
                    serviceResponse = this.ReadResponseXmlJsObject(response);
                }
                else if (this.Service.RenderingMethod == RenderingMode.JSON) {
                    serviceResponse = this.ReadResponseJson(response);
                }
                else {
                    throw new Error /*InvalidOperationException*/("Unknown RenderingMethod.");
                }
            }
        }
        catch (ex) {
            if (ex.Response != null) {
                //IEwsHttpWebResponse exceptionResponse = this.Service.HttpWebRequestFactory.CreateExceptionResponse(e);
                this.Service.ProcessHttpResponseHeaders(TraceFlags.EwsResponseHttpHeaders, response);
            }
            throw new ServiceRequestException(StringHelper.Format(Strings.ServiceRequestFailed, ex.Message), ex);
        }
        return serviceResponse;
    };
    SimpleServiceRequestBase.prototype.ReadResponseJson = function (jsObject /*System.IO.Stream*/) {
        //var jsonResponse: JsonObject = new JsonParser(responseStream).Parse();
        return _super.prototype.BuildResponseObjectFromJson.call(this, jsObject);
    };
    SimpleServiceRequestBase.prototype.WebRequestAsyncCallback = function (webAsyncResult /*System.IAsyncResult*/) { throw new Error("SimpleServiceRequestBase.ts - WebRequestAsyncCallback : Not implemented."); };
    return SimpleServiceRequestBase;
}(ServiceRequestBase));
exports.SimpleServiceRequestBase = SimpleServiceRequestBase;
/**
 * @internal Represents a DisableApp request.
 *
 * @sealed
 */
var DisableAppRequest = (function (_super) {
    __extends(DisableAppRequest, _super);
    /**
     * @internal Initializes a new instance of the **DisableAppRequest** class.
     *
     * @param   {ExchangeService}   	service         The service.
     * @param   {string}   				id              Extension id.
     * @param   {DisableReasonType}   	disableReason   Disable reason.
     */
    function DisableAppRequest(service, id, disableReason) {
        var _this = _super.call(this, service) || this;
        /**
         * Extension id
         */
        _this.Id = null;
        /**
         * Disable reason
         */
        _this.DisableReason = DisableReasonType.NoReason;
        _this.Id = id;
        _this.DisableReason = disableReason;
        return _this;
    }
    /**
     * @internal Executes this request.
     *
     * @return  {Promise<DisableAppResponse>}      Service response  :Promise.
     */
    DisableAppRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    DisableAppRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2013;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    DisableAppRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.DisableAppResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    DisableAppRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.DisableAppRequest;
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    DisableAppRequest.prototype.ParseResponse = function (jsonBody) {
        var response = new DisableAppResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    DisableAppRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.ID, this.Id);
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.DisableReason, DisableReasonType[this.DisableReason]);
    };
    return DisableAppRequest;
}(SimpleServiceRequestBase));
exports.DisableAppRequest = DisableAppRequest;
/**
 * ## @internal *Not Implemented*
 */
var DisconnectPhoneCallRequest = (function (_super) {
    __extends(DisconnectPhoneCallRequest, _super);
    function DisconnectPhoneCallRequest() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DisconnectPhoneCallRequest.prototype.Execute = function () { throw new Error("DisconnectPhoneCallRequest.ts - Execute : Not implemented."); };
    DisconnectPhoneCallRequest.prototype.GetMinimumRequiredServerVersion = function () { throw new Error("DisconnectPhoneCallRequest.ts - GetMinimumRequiredServerVersion : Not implemented."); };
    DisconnectPhoneCallRequest.prototype.GetResponseXmlElementName = function () { throw new Error("DisconnectPhoneCallRequest.ts - GetResponseXmlElementName : Not implemented."); };
    DisconnectPhoneCallRequest.prototype.GetXmlElementName = function () { throw new Error("DisconnectPhoneCallRequest.ts - GetXmlElementName : Not implemented."); };
    DisconnectPhoneCallRequest.prototype.ParseResponse = function (reader) { throw new Error("DisconnectPhoneCallRequest.ts - ParseResponse : Not implemented."); };
    /**@internal */
    DisconnectPhoneCallRequest.prototype.WriteElementsToXml = function (writer) { throw new Error("DisconnectPhoneCallRequest.ts - WriteElementsToXml : Not implemented."); };
    return DisconnectPhoneCallRequest;
}(SimpleServiceRequestBase));
exports.DisconnectPhoneCallRequest = DisconnectPhoneCallRequest;
/**
 * @internal Represents a request to a Find Conversation operation
 *
 * @sealed
 */
var FindConversationRequest = (function (_super) {
    __extends(FindConversationRequest, _super);
    /**
     * @internal Initializes a new instance of the **FindConversationRequest** class.
     *
     * @param   {service}   service   The service.
     */
    function FindConversationRequest(service) {
        var _this = _super.call(this, service) || this;
        _this.view = null;
        _this.folderId = null;
        _this.queryString = null;
        _this.returnHighlightTerms = false;
        _this.mailboxScope = null;
        return _this;
    }
    Object.defineProperty(FindConversationRequest.prototype, "View", {
        /**
         * Gets or sets the view controlling the number of conversations returned.
         */
        get: function () {
            return this.view;
        },
        set: function (value) {
            this.view = value;
            if (this.view instanceof SeekToConditionItemView) {
                this.view.SetServiceObjectType(ServiceObjectType.Conversation);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindConversationRequest.prototype, "FolderId", {
        /**
         * @internal Gets or sets folder id
         */
        get: function () {
            return this.folderId;
        },
        set: function (value) {
            this.folderId = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindConversationRequest.prototype, "QueryString", {
        /**
         * @internal Gets or sets the query string for search value.
         */
        get: function () {
            return this.queryString;
        },
        set: function (value) {
            this.queryString = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindConversationRequest.prototype, "ReturnHighlightTerms", {
        /**
         * @internal Gets or sets the query string highlight terms.
         */
        get: function () {
            return this.returnHighlightTerms;
        },
        set: function (value) {
            this.returnHighlightTerms = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindConversationRequest.prototype, "MailboxScope", {
        /**
         * @internal Gets or sets the mailbox search location to include in the search.
         */
        get: function () {
            return this.mailboxScope;
        },
        set: function (value) {
            this.mailboxScope = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Executes this request.
     *
     * @return  {Promise<FindConversationResponse>}      Service response  :Promise.
     */
    FindConversationRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    FindConversationRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2010_SP1;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    FindConversationRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.FindConversationResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    FindConversationRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.FindConversation;
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    FindConversationRequest.prototype.ParseResponse = function (jsonBody) {
        var response = new FindConversationResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    };
    /**
     * @internal Validate request.
     */
    FindConversationRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        this.view.InternalValidate(this);
        // query string parameter is only valid for Exchange2013 or higher
        //
        if (!StringHelper.IsNullOrEmpty(this.queryString) &&
            this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
            throw new ServiceVersionException(StringHelper.Format(Strings.ParameterIncompatibleWithRequestVersion, "queryString", ExchangeVersion[ExchangeVersion.Exchange2013]));
        }
        // ReturnHighlightTerms parameter is only valid for Exchange2013 or higher
        //
        if (this.ReturnHighlightTerms &&
            this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
            throw new ServiceVersionException(StringHelper.Format(Strings.ParameterIncompatibleWithRequestVersion, "returnHighlightTerms", ExchangeVersion[ExchangeVersion.Exchange2013]));
        }
        // SeekToConditionItemView is only valid for Exchange2013 or higher
        //
        if ((this.View instanceof SeekToConditionItemView) &&
            this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
            throw new ServiceVersionException(StringHelper.Format(Strings.ParameterIncompatibleWithRequestVersion, "SeekToConditionItemView", ExchangeVersion[ExchangeVersion.Exchange2013]));
        }
        // MailboxScope is only valid for Exchange2013 or higher
        //
        if (this.MailboxScope &&
            this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
            throw new ServiceVersionException(StringHelper.Format(Strings.ParameterIncompatibleWithRequestVersion, "MailboxScope", ExchangeVersion[ExchangeVersion.Exchange2013]));
        }
    };
    /**
     * @internal Writes XML attributes.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    FindConversationRequest.prototype.WriteAttributesToXml = function (writer) {
        this.View.WriteAttributesToXml(writer);
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    FindConversationRequest.prototype.WriteElementsToXml = function (writer) {
        // Emit the view element
        //
        this.View.WriteToXml(writer, null);
        // Emit the Sort Order
        //
        this.View.WriteOrderByToXml(writer);
        // Emit the Parent Folder Id
        //
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.ParentFolderId);
        this.FolderId.WriteToXml(writer);
        writer.WriteEndElement();
        // Emit the MailboxScope flag
        // 
        if (this.MailboxScope) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.MailboxScope, MailboxSearchLocation[this.MailboxScope]);
        }
        if (!StringHelper.IsNullOrEmpty(this.queryString)) {
            // Emit the QueryString
            //
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.QueryString);
            if (this.ReturnHighlightTerms) {
                writer.WriteAttributeString(XmlAttributeNames.ReturnHighlightTerms, this.ReturnHighlightTerms.toString().toLowerCase()); //todo: better tolower() .ToString().ToLowerInvariant());
            }
            writer.WriteValue(this.queryString, XmlElementNames.QueryString);
            writer.WriteEndElement();
        }
        if (this.Service.RequestedServerVersion >= ExchangeVersion.Exchange2013) {
            if (this.View.PropertySet != null) {
                this.View.PropertySet.WriteToXml(writer, ServiceObjectType.Conversation);
            }
        }
    };
    return FindConversationRequest;
}(SimpleServiceRequestBase));
exports.FindConversationRequest = FindConversationRequest;
/**
 *  @internal Represents a GetAppManifests request.
 *
 * @sealed
*/
var GetAppManifestsRequest = (function (_super) {
    __extends(GetAppManifestsRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetAppManifestsRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function GetAppManifestsRequest(service) {
        var _this = _super.call(this, service) || this;
        /**
         * @internal Gets or sets the api version supported by the client.
         * This tells Exchange service which app manifests should be returned based on the api version.
         *
         * @value	The Api version supported.
         */
        _this.ApiVersionSupported = null;
        /**
         * @internal Gets or sets the Schema version supported by the client.
         * This tells Exchange service which app manifests should be returned based on the schema version.
         *
         * @value	The schema version supported.
         */
        _this.SchemaVersionSupported = null;
        return _this;
    }
    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetAppManifestsResponse>}      Service response  :Promise.
     */
    GetAppManifestsRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetAppManifestsRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2013;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    GetAppManifestsRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.GetAppManifestsResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetAppManifestsRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.GetAppManifestsRequest;
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    GetAppManifestsRequest.prototype.ParseResponse = function (jsonBody) {
        var response = new GetAppManifestsResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    };
    /**
     * @internal Validate request.
     */
    GetAppManifestsRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateNonBlankStringParamAllowNull(this.ApiVersionSupported, "ApiVersionSupported");
        EwsUtilities.ValidateNonBlankStringParamAllowNull(this.SchemaVersionSupported, "SchemaVersionSupported");
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetAppManifestsRequest.prototype.WriteElementsToXml = function (writer) {
        if (!StringHelper.IsNullOrEmpty(this.ApiVersionSupported)) {
            writer.WriteElementValue(XmlNamespace.Messages, "ApiVersionSupported", this.ApiVersionSupported);
        }
        if (!StringHelper.IsNullOrEmpty(this.SchemaVersionSupported)) {
            writer.WriteElementValue(XmlNamespace.Messages, "SchemaVersionSupported", this.SchemaVersionSupported);
        }
    };
    return GetAppManifestsRequest;
}(SimpleServiceRequestBase));
exports.GetAppManifestsRequest = GetAppManifestsRequest;
/**
 * @internal Represents a GetAppMarketplaceUrl request.
 *
 * @sealed
 */
var GetAppMarketplaceUrlRequest = (function (_super) {
    __extends(GetAppMarketplaceUrlRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetAppMarketplaceUrlRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function GetAppMarketplaceUrlRequest(service) {
        var _this = _super.call(this, service) || this;
        /**
         * @internal Gets or sets the api version supported by the client.
         * This is used by EWS to generate a market place url with the correct version filter.
         *
         * @value	The Api version supported.
         */
        _this.ApiVersionSupported = null;
        /**
         * @internal Gets or sets the Schema version supported by the client.
         * This is used by EWS to generate a market place url with the correct version filter.
         *
         * @value	The schema version supported.
         */
        _this.SchemaVersionSupported = null;
        return _this;
    }
    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetAppMarketplaceUrlResponse>}      Service response  :Promise.
     */
    GetAppMarketplaceUrlRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetAppMarketplaceUrlRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2013;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    GetAppMarketplaceUrlRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.GetAppMarketplaceUrlResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetAppMarketplaceUrlRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.GetAppMarketplaceUrlRequest;
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    GetAppMarketplaceUrlRequest.prototype.ParseResponse = function (jsonBody) {
        var response = new GetAppMarketplaceUrlResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    };
    /**
     * @internal Validate request.
     */
    GetAppMarketplaceUrlRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateNonBlankStringParamAllowNull(this.ApiVersionSupported, "ApiVersionSupported");
        EwsUtilities.ValidateNonBlankStringParamAllowNull(this.SchemaVersionSupported, "SchemaVersionSupported");
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetAppMarketplaceUrlRequest.prototype.WriteElementsToXml = function (writer) {
        if (!StringHelper.IsNullOrEmpty(this.ApiVersionSupported)) {
            writer.WriteElementValue(XmlNamespace.Messages, "ApiVersionSupported", this.ApiVersionSupported);
        }
        if (!StringHelper.IsNullOrEmpty(this.SchemaVersionSupported)) {
            writer.WriteElementValue(XmlNamespace.Messages, "SchemaVersionSupported", this.SchemaVersionSupported);
        }
    };
    return GetAppMarketplaceUrlRequest;
}(SimpleServiceRequestBase));
exports.GetAppMarketplaceUrlRequest = GetAppMarketplaceUrlRequest;
/**
 * ## @internal *Not Implemented*  Server to server call - not needed
 */
var GetClientExtensionRequest = (function (_super) {
    __extends(GetClientExtensionRequest, _super);
    function GetClientExtensionRequest() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GetClientExtensionRequest.prototype.Execute = function () { throw new Error("GetClientExtensionRequest.ts - Execute : Not implemented."); };
    GetClientExtensionRequest.prototype.GetMinimumRequiredServerVersion = function () { throw new Error("GetClientExtensionRequest.ts - GetMinimumRequiredServerVersion : Not implemented."); };
    GetClientExtensionRequest.prototype.GetResponseXmlElementName = function () { throw new Error("GetClientExtensionRequest.ts - GetResponseXmlElementName : Not implemented."); };
    GetClientExtensionRequest.prototype.GetXmlElementName = function () { throw new Error("GetClientExtensionRequest.ts - GetXmlElementName : Not implemented."); };
    GetClientExtensionRequest.prototype.ParseResponse = function (reader) { throw new Error("GetClientExtensionRequest.ts - ParseResponse : Not implemented."); };
    /**@internal */
    GetClientExtensionRequest.prototype.WriteElementsToXml = function (writer) { throw new Error("GetClientExtensionRequest.ts - WriteElementsToXml : Not implemented."); };
    return GetClientExtensionRequest;
}(SimpleServiceRequestBase));
exports.GetClientExtensionRequest = GetClientExtensionRequest;
/**
 * @internal Represents a GetDiscoverySearchConfigurationRequest.
 *
 * @sealed
 */
var GetDiscoverySearchConfigurationRequest = (function (_super) {
    __extends(GetDiscoverySearchConfigurationRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetDiscoverySearchConfigurationRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function GetDiscoverySearchConfigurationRequest(service) {
        var _this = _super.call(this, service) || this;
        /**
         * Search Id
         */
        _this.SearchId = null;
        /**
         * Expand group membership
         */
        _this.ExpandGroupMembership = false;
        /**
         * In-Place hold configuration only
         */
        _this.InPlaceHoldConfigurationOnly = false;
        return _this;
    }
    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetDiscoverySearchConfigurationResponse>}      Service response  :Promise.
     */
    GetDiscoverySearchConfigurationRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetDiscoverySearchConfigurationRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2013;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    GetDiscoverySearchConfigurationRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.GetDiscoverySearchConfigurationResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetDiscoverySearchConfigurationRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.GetDiscoverySearchConfiguration;
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    GetDiscoverySearchConfigurationRequest.prototype.ParseResponse = function (jsonBody) {
        var response = new GetDiscoverySearchConfigurationResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetDiscoverySearchConfigurationRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.SearchId, this.SearchId || StringHelper.Empty);
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.ExpandGroupMembership, this.ExpandGroupMembership);
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.InPlaceHoldConfigurationOnly, this.InPlaceHoldConfigurationOnly);
    };
    return GetDiscoverySearchConfigurationRequest;
}(SimpleServiceRequestBase));
exports.GetDiscoverySearchConfigurationRequest = GetDiscoverySearchConfigurationRequest;
/**
 * ## @internal *Not Implemented*   Server to server call - not needed
 */
var GetEncryptionConfigurationRequest = (function (_super) {
    __extends(GetEncryptionConfigurationRequest, _super);
    function GetEncryptionConfigurationRequest() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GetEncryptionConfigurationRequest.prototype.Execute = function () { throw new Error("GetEncryptionConfigurationRequest.ts - Execute : Not implemented."); };
    GetEncryptionConfigurationRequest.prototype.GetMinimumRequiredServerVersion = function () { throw new Error("GetEncryptionConfigurationRequest.ts - GetMinimumRequiredServerVersion : Not implemented."); };
    GetEncryptionConfigurationRequest.prototype.GetResponseXmlElementName = function () { throw new Error("GetEncryptionConfigurationRequest.ts - GetResponseXmlElementName : Not implemented."); };
    GetEncryptionConfigurationRequest.prototype.GetXmlElementName = function () { throw new Error("GetEncryptionConfigurationRequest.ts - GetXmlElementName : Not implemented."); };
    GetEncryptionConfigurationRequest.prototype.ParseResponse = function (reader) { throw new Error("GetEncryptionConfigurationRequest.ts - ParseResponse : Not implemented."); };
    /**@internal */
    GetEncryptionConfigurationRequest.prototype.WriteElementsToXml = function (writer) { throw new Error("GetEncryptionConfigurationRequest.ts - WriteElementsToXml : Not implemented."); };
    return GetEncryptionConfigurationRequest;
}(SimpleServiceRequestBase));
exports.GetEncryptionConfigurationRequest = GetEncryptionConfigurationRequest;
/**
 * @internal Represents a GetHoldOnMailboxesRequest request.
 *
 * @sealed
 */
var GetHoldOnMailboxesRequest = (function (_super) {
    __extends(GetHoldOnMailboxesRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetHoldOnMailboxesRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function GetHoldOnMailboxesRequest(service) {
        var _this = _super.call(this, service) || this;
        /**
         * Hold id
         */
        _this.HoldId = null;
        return _this;
    }
    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetHoldOnMailboxesResponse>}      Service response  :Promise.
     */
    GetHoldOnMailboxesRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetHoldOnMailboxesRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2013;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    GetHoldOnMailboxesRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.GetHoldOnMailboxesResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetHoldOnMailboxesRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.GetHoldOnMailboxes;
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    GetHoldOnMailboxesRequest.prototype.ParseResponse = function (jsonBody) {
        var response = new GetHoldOnMailboxesResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    };
    /**
     * @internal Validate request.
     */
    GetHoldOnMailboxesRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        if (StringHelper.IsNullOrEmpty(this.HoldId)) {
            throw new ServiceValidationException(Strings.HoldIdParameterIsNotSpecified);
        }
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetHoldOnMailboxesRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.HoldId, this.HoldId);
    };
    return GetHoldOnMailboxesRequest;
}(SimpleServiceRequestBase));
exports.GetHoldOnMailboxesRequest = GetHoldOnMailboxesRequest;
/**
 * @internal Represents a GetInboxRules request.
 *
 * @sealed
 */
var GetInboxRulesRequest = (function (_super) {
    __extends(GetInboxRulesRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetInboxRulesRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function GetInboxRulesRequest(service) {
        return _super.call(this, service) || this;
    }
    Object.defineProperty(GetInboxRulesRequest.prototype, "MailboxSmtpAddress", {
        /**
         * Gets or sets the address of the mailbox from which to get the inbox rules.
         */
        get: function () {
            return this.mailboxSmtpAddress;
        },
        set: function (value) {
            this.mailboxSmtpAddress = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetInboxRulesResponse>}      Service response  :Promise.
     */
    GetInboxRulesRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetInboxRulesRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2010_SP1;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    GetInboxRulesRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.GetInboxRulesResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    GetInboxRulesRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.GetInboxRules;
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    GetInboxRulesRequest.prototype.ParseResponse = function (jsonBody) {
        var response = new GetInboxRulesResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetInboxRulesRequest.prototype.WriteElementsToXml = function (writer) {
        if (!StringHelper.IsNullOrEmpty(this.mailboxSmtpAddress)) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.MailboxSmtpAddress, this.mailboxSmtpAddress);
        }
    };
    return GetInboxRulesRequest;
}(SimpleServiceRequestBase));
exports.GetInboxRulesRequest = GetInboxRulesRequest;
/**
 * @internal Represents a GetNonIndexableItemDetailsRequest request.
 *
 * @sealed
 */
var GetNonIndexableItemDetailsRequest = (function (_super) {
    __extends(GetNonIndexableItemDetailsRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetNonIndexableItemDetailsRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function GetNonIndexableItemDetailsRequest(service) {
        var _this = _super.call(this, service) || this;
        /**
         * Mailboxes
         */
        _this.Mailboxes = null;
        /**
         * @Nullable Page size
         */
        _this.PageSize = null;
        /**
         * Page item reference
         */
        _this.PageItemReference = null;
        /**
         * @Nullable Page direction
         */
        _this.PageDirection = null;
        /**
         * Whether to search archive only
         */
        _this.SearchArchiveOnly = false;
        return _this;
    }
    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetNonIndexableItemDetailsResponse>}      Service response  :Promise.
     */
    GetNonIndexableItemDetailsRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetNonIndexableItemDetailsRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2013;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    GetNonIndexableItemDetailsRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.GetNonIndexableItemDetailsResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetNonIndexableItemDetailsRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.GetNonIndexableItemDetails;
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    GetNonIndexableItemDetailsRequest.prototype.ParseResponse = function (jsonBody) {
        var response = new GetNonIndexableItemDetailsResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    };
    /**
     * @internal Validate request.
     */
    GetNonIndexableItemDetailsRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        if (this.Mailboxes == null || this.Mailboxes.length == 0) {
            throw new ServiceValidationException(Strings.MailboxesParameterIsNotSpecified);
        }
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetNonIndexableItemDetailsRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.Mailboxes);
        for (var _a = 0, _b = this.Mailboxes; _a < _b.length; _a++) {
            var mailbox = _b[_a];
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.LegacyDN, mailbox);
        }
        writer.WriteEndElement();
        if (this.PageSize) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.PageSize, this.PageSize);
        }
        if (!StringHelper.IsNullOrEmpty(this.PageItemReference)) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.PageItemReference, this.PageItemReference);
        }
        if (this.PageDirection) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.PageDirection, SearchPageDirection[this.PageDirection]);
        }
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.SearchArchiveOnly, this.SearchArchiveOnly);
    };
    return GetNonIndexableItemDetailsRequest;
}(SimpleServiceRequestBase));
exports.GetNonIndexableItemDetailsRequest = GetNonIndexableItemDetailsRequest;
/**
 * @internal Represents the GetNonIndexableItemStatistics response.
 */
var GetNonIndexableItemStatisticsRequest = (function (_super) {
    __extends(GetNonIndexableItemStatisticsRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetNonIndexableItemStatisticsRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function GetNonIndexableItemStatisticsRequest(service) {
        var _this = _super.call(this, service) || this;
        /**
         * Mailboxes
         */
        _this.Mailboxes = null;
        /**
         * Whether to search archive only
         */
        _this.SearchArchiveOnly = false;
        return _this;
    }
    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetNonIndexableItemStatisticsResponse>}      Service response  :Promise.
     */
    GetNonIndexableItemStatisticsRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetNonIndexableItemStatisticsRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2013;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    GetNonIndexableItemStatisticsRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.GetNonIndexableItemStatisticsResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetNonIndexableItemStatisticsRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.GetNonIndexableItemStatistics;
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    GetNonIndexableItemStatisticsRequest.prototype.ParseResponse = function (jsonBody) {
        var response = new GetNonIndexableItemStatisticsResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    };
    /**
     * @internal Validate request.
     */
    GetNonIndexableItemStatisticsRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        if (this.Mailboxes == null || this.Mailboxes.length == 0) {
            throw new ServiceValidationException(Strings.MailboxesParameterIsNotSpecified);
        }
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetNonIndexableItemStatisticsRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.Mailboxes);
        for (var _a = 0, _b = this.Mailboxes; _a < _b.length; _a++) {
            var mailbox = _b[_a];
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.LegacyDN, mailbox);
        }
        writer.WriteEndElement();
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.SearchArchiveOnly, this.SearchArchiveOnly);
    };
    return GetNonIndexableItemStatisticsRequest;
}(SimpleServiceRequestBase));
exports.GetNonIndexableItemStatisticsRequest = GetNonIndexableItemStatisticsRequest;
/** @internal */
var GetPasswordExpirationDateRequest = (function (_super) {
    __extends(GetPasswordExpirationDateRequest, _super);
    function GetPasswordExpirationDateRequest(service) {
        var _this = _super.call(this, service) || this;
        _this.mailboxSmtpAddress = null;
        return _this;
    }
    Object.defineProperty(GetPasswordExpirationDateRequest.prototype, "MailboxSmtpAddress", {
        get: function () {
            return this.mailboxSmtpAddress;
        },
        set: function (value) {
            this.mailboxSmtpAddress = value;
        },
        enumerable: true,
        configurable: true
    });
    GetPasswordExpirationDateRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    };
    GetPasswordExpirationDateRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2010_SP1; };
    GetPasswordExpirationDateRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.GetPasswordExpirationDateResponse; };
    GetPasswordExpirationDateRequest.prototype.GetXmlElementName = function () { return XmlElementNames.GetPasswordExpirationDateRequest; };
    //ParseResponse(reader: any): any { throw new Error("GetPasswordExpirationDateRequest.ts - ParseResponse : Not implemented."); }
    GetPasswordExpirationDateRequest.prototype.ParseResponse = function (jsonBody) {
        var serviceResponse = new GetPasswordExpirationDateResponse();
        serviceResponse.LoadFromXmlJsObject(jsonBody, this.Service);
        return serviceResponse;
    };
    /**@internal */
    GetPasswordExpirationDateRequest.prototype.WriteElementsToXml = function (writer) { writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.MailboxSmtpAddress, this.MailboxSmtpAddress); };
    return GetPasswordExpirationDateRequest;
}(SimpleServiceRequestBase));
exports.GetPasswordExpirationDateRequest = GetPasswordExpirationDateRequest;
/**
 * ## @internal *Not Implemented*
 */
var GetPhoneCallRequest = (function (_super) {
    __extends(GetPhoneCallRequest, _super);
    function GetPhoneCallRequest() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GetPhoneCallRequest.prototype.Execute = function () { throw new Error("GetPhoneCallRequest.ts - Execute : Not implemented."); };
    GetPhoneCallRequest.prototype.GetMinimumRequiredServerVersion = function () { throw new Error("GetPhoneCallRequest.ts - GetMinimumRequiredServerVersion : Not implemented."); };
    GetPhoneCallRequest.prototype.GetResponseXmlElementName = function () { throw new Error("GetPhoneCallRequest.ts - GetResponseXmlElementName : Not implemented."); };
    GetPhoneCallRequest.prototype.GetXmlElementName = function () { throw new Error("GetPhoneCallRequest.ts - GetXmlElementName : Not implemented."); };
    GetPhoneCallRequest.prototype.ParseResponse = function (reader) { throw new Error("GetPhoneCallRequest.ts - ParseResponse : Not implemented."); };
    /**@internal */
    GetPhoneCallRequest.prototype.WriteElementsToXml = function (writer) { throw new Error("GetPhoneCallRequest.ts - WriteElementsToXml : Not implemented."); };
    return GetPhoneCallRequest;
}(SimpleServiceRequestBase));
exports.GetPhoneCallRequest = GetPhoneCallRequest;
/**
 * @internal Represents a GetRoomList request.
 *
 * @sealed
 */
var GetRoomListsRequest = (function (_super) {
    __extends(GetRoomListsRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetRoomListsRequest** class.
     *
     * @param   {service}   service   The service.
     */
    function GetRoomListsRequest(service) {
        return _super.call(this, service) || this;
    }
    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetRoomListsResponse>}      Service response  :Promise.
     */
    GetRoomListsRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetRoomListsRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2010;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    GetRoomListsRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.GetRoomListsResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetRoomListsRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.GetRoomListsRequest;
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    GetRoomListsRequest.prototype.ParseResponse = function (jsonBody) {
        var response = new GetRoomListsResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetRoomListsRequest.prototype.WriteElementsToXml = function (writer) {
        // Don't have parameter in request
    };
    return GetRoomListsRequest;
}(SimpleServiceRequestBase));
exports.GetRoomListsRequest = GetRoomListsRequest;
/**
 * @internal Represents a GetRooms request.
 *
 * @sealed
 */
var GetRoomsRequest = (function (_super) {
    __extends(GetRoomsRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetRoomsRequest** class.
     *
     * @param   {service}   service   The service.
     */
    function GetRoomsRequest(service) {
        var _this = _super.call(this, service) || this;
        _this.roomList = null;
        return _this;
    }
    Object.defineProperty(GetRoomsRequest.prototype, "RoomList", {
        /**
         * @internal Gets or sets the room list to retrieve rooms from.
         */
        get: function () {
            return this.roomList;
        },
        set: function (value) {
            this.roomList = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetRoomsResponse>}      Service response  :Promise.
     */
    GetRoomsRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetRoomsRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2010;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    GetRoomsRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.GetRoomsResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetRoomsRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.GetRoomsRequest;
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    GetRoomsRequest.prototype.ParseResponse = function (jsonBody) {
        var response = new GetRoomsResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetRoomsRequest.prototype.WriteElementsToXml = function (writer) {
        //this.RoomList.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.RoomList);
        this.RoomList.WriteToXml(writer, XmlElementNames.RoomList, XmlNamespace.Messages); //info: temp workaround github #52 
    };
    return GetRoomsRequest;
}(SimpleServiceRequestBase));
exports.GetRoomsRequest = GetRoomsRequest;
/**
 * @internal Represents a GetSearchableMailboxesRequest request.
 */
var GetSearchableMailboxesRequest = (function (_super) {
    __extends(GetSearchableMailboxesRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetSearchableMailboxesRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function GetSearchableMailboxesRequest(service) {
        var _this = _super.call(this, service) || this;
        /**
         * Search filter
         */
        _this.SearchFilter = null;
        /**
         * Expand group membership
         */
        _this.ExpandGroupMembership = false;
        return _this;
    }
    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetDiscoverySearchConfigurationResponse>}      Service response  :Promise.
     */
    GetSearchableMailboxesRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetSearchableMailboxesRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2013;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    GetSearchableMailboxesRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.GetSearchableMailboxesResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetSearchableMailboxesRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.GetSearchableMailboxes;
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    GetSearchableMailboxesRequest.prototype.ParseResponse = function (jsonBody) {
        var response = new GetSearchableMailboxesResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetSearchableMailboxesRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.SearchFilter, this.SearchFilter || StringHelper.Empty);
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.ExpandGroupMembership, this.ExpandGroupMembership);
    };
    return GetSearchableMailboxesRequest;
}(SimpleServiceRequestBase));
exports.GetSearchableMailboxesRequest = GetSearchableMailboxesRequest;
/** @internal */
var GetUserAvailabilityRequest = (function (_super) {
    __extends(GetUserAvailabilityRequest, _super);
    // private attendees: AttendeeInfo[];//System.Collections.Generic.IEnumerable<AttendeeInfo>; - no need of backing field
    // private timeWindow: TimeWindow;
    // private requestedData: AvailabilityData;
    // private options: AvailabilityOptions;
    function GetUserAvailabilityRequest(service) {
        var _this = _super.call(this, service) || this;
        _this.Attendees = []; //System.Collections.Generic.IEnumerable<AttendeeInfo>;
        _this.TimeWindow = null;
        _this.RequestedData = AvailabilityData.FreeBusyAndSuggestions;
        _this.Options = null;
        return _this;
    }
    Object.defineProperty(GetUserAvailabilityRequest.prototype, "EmitTimeZoneHeader", {
        get: function () { return true; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetUserAvailabilityRequest.prototype, "IsFreeBusyViewRequested", {
        get: function () { return this.RequestedData == AvailabilityData.FreeBusy || this.RequestedData == AvailabilityData.FreeBusyAndSuggestions; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetUserAvailabilityRequest.prototype, "IsSuggestionsViewRequested", {
        get: function () { return this.RequestedData == AvailabilityData.Suggestions || this.RequestedData == AvailabilityData.FreeBusyAndSuggestions; },
        enumerable: true,
        configurable: true
    });
    GetUserAvailabilityRequest.prototype.Execute = function () { return this.InternalExecute(); };
    GetUserAvailabilityRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    GetUserAvailabilityRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.GetUserAvailabilityResponse; };
    GetUserAvailabilityRequest.prototype.GetXmlElementName = function () { return XmlElementNames.GetUserAvailabilityRequest; };
    GetUserAvailabilityRequest.prototype.ParseResponse = function (jsonBody) {
        var serviceResponse = new GetUserAvailabilityResults();
        if (this.IsFreeBusyViewRequested) {
            serviceResponse.AttendeesAvailability = new ServiceResponseCollection();
            var responseArray = jsonBody[XmlElementNames.FreeBusyResponseArray];
            var responseMessages = responseArray[XmlElementNames.FreeBusyResponse];
            if (!Array.isArray(responseMessages)) {
                responseMessages = [responseMessages];
            }
            for (var _a = 0, responseMessages_1 = responseMessages; _a < responseMessages_1.length; _a++) {
                var responseMessage = responseMessages_1[_a];
                var freeBusyResponse = new AttendeeAvailability();
                freeBusyResponse.LoadFromXmlJsObject(responseMessage[XmlElementNames.ResponseMessage], this.Service);
                if (freeBusyResponse.ErrorCode == ServiceError.NoError) {
                    freeBusyResponse.LoadFreeBusyViewFromXmlJsObject(responseMessage[XmlElementNames.FreeBusyView], this.Options.RequestedFreeBusyView, this.Service);
                }
                serviceResponse.AttendeesAvailability.Add(freeBusyResponse);
            }
        }
        if (this.IsSuggestionsViewRequested) {
            serviceResponse.SuggestionsResponse = new SuggestionsResponse();
            var suggestionResponse = jsonBody[XmlElementNames.SuggestionsResponse];
            serviceResponse.SuggestionsResponse.LoadFromXmlJsObject(suggestionResponse[XmlElementNames.ResponseMessage], this.Service);
            if (serviceResponse.SuggestionsResponse.ErrorCode == ServiceError.NoError) {
                serviceResponse.SuggestionsResponse.LoadSuggestedDaysFromXml(suggestionResponse, this.Service);
            }
        }
        return serviceResponse;
    };
    GetUserAvailabilityRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        this.Options.Validate(this.TimeWindow.Duration);
    };
    /**@internal */
    GetUserAvailabilityRequest.prototype.WriteElementsToXml = function (writer) {
        // Only serialize the TimeZone property against an Exchange 2007 SP1 server.
        // Against Exchange 2010, the time zone is emitted in the request's SOAP header.
        if (writer.Service.RequestedServerVersion == ExchangeVersion.Exchange2007_SP1) {
            //todo: implement TimeZone and then LegacyAvailabilityTimeZone
            // var legacyTimeZone:LegacyAvailabilityTimeZone = new LegacyAvailabilityTimeZone(writer.Service.TimeZone);
            // legacyTimeZone.WriteToXml(writer, XmlElementNames.TimeZone);
        }
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.MailboxDataArray);
        for (var _a = 0, _b = this.Attendees; _a < _b.length; _a++) {
            var attendee = _b[_a];
            attendee.WriteToXml(writer);
        }
        writer.WriteEndElement(); // MailboxDataArray
        this.Options.WriteToXml(writer, this);
    };
    return GetUserAvailabilityRequest;
}(SimpleServiceRequestBase));
exports.GetUserAvailabilityRequest = GetUserAvailabilityRequest;
/**
 * @internal Represents a GetUserOofSettings request.
 *
 * @sealed
 */
var GetUserOofSettingsRequest = (function (_super) {
    __extends(GetUserOofSettingsRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetUserOofSettingsRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function GetUserOofSettingsRequest(service) {
        var _this = _super.call(this, service) || this;
        _this.smtpAddress = null;
        return _this;
    }
    Object.defineProperty(GetUserOofSettingsRequest.prototype, "SmtpAddress", {
        /**
         * @internal Gets or sets the SMTP address.
         */
        get: function () {
            return this.smtpAddress;
        },
        set: function (value) {
            this.smtpAddress = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetUserOofSettingsResponse>}      Service response.
     */
    GetUserOofSettingsRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetUserOofSettingsRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    GetUserOofSettingsRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.GetUserOofSettingsResponse; };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    GetUserOofSettingsRequest.prototype.GetXmlElementName = function () { return XmlElementNames.GetUserOofSettingsRequest; };
    /**
     * Parses the response.
     *
     * @param   {any}   jsObjectBody   The jsObjectBody from XmlJsObject.
     * @return  {any}            Response object.
     */
    GetUserOofSettingsRequest.prototype.ParseResponse = function (jsObjectBody) {
        var serviceResponse = new GetUserOofSettingsResponse();
        serviceResponse.LoadFromXmlJsObject(jsObjectBody[XmlElementNames.ResponseMessage], this.Service);
        if (serviceResponse.ErrorCode == ServiceError.NoError) {
            if (jsObjectBody[XmlElementNames.OofSettings]) {
                serviceResponse.OofSettings = new OofSettings();
                serviceResponse.OofSettings.LoadFromXmlJsObject(jsObjectBody[XmlElementNames.OofSettings], this.Service);
                serviceResponse.OofSettings.AllowExternalOof = OofExternalAudience[jsObjectBody[XmlElementNames.AllowExternalOof]];
            }
        }
        return serviceResponse;
    };
    /**
     * @internal Validate request.
     */
    GetUserOofSettingsRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParam(this.SmtpAddress, "SmtpAddress");
    };
    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetUserOofSettingsRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Mailbox);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Address, this.SmtpAddress);
        writer.WriteEndElement(); // Mailbox
    };
    return GetUserOofSettingsRequest;
}(SimpleServiceRequestBase));
exports.GetUserOofSettingsRequest = GetUserOofSettingsRequest;
/**
 * @internal Represents a GetUserRetentionPolicyTagsRequest request.
 *
 * @sealed
 */
var GetUserRetentionPolicyTagsRequest = (function (_super) {
    __extends(GetUserRetentionPolicyTagsRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetUserRetentionPolicyTagsRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function GetUserRetentionPolicyTagsRequest(service) {
        return _super.call(this, service) || this;
    }
    /**
     * @internal Executes this request.
     *
     * @return  {Promise<GetUserRetentionPolicyTagsResponse>}      Service response  :Promise.
     */
    GetUserRetentionPolicyTagsRequest.prototype.Execute = function () {
        return this.InternalExecute();
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetUserRetentionPolicyTagsRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2013;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    GetUserRetentionPolicyTagsRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.GetUserRetentionPolicyTagsResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    GetUserRetentionPolicyTagsRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.GetUserRetentionPolicyTags;
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    GetUserRetentionPolicyTagsRequest.prototype.ParseResponse = function (jsonBody) {
        var response = new GetUserRetentionPolicyTagsResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetUserRetentionPolicyTagsRequest.prototype.WriteElementsToXml = function (writer) {
        // Don't have parameter in request.
    };
    return GetUserRetentionPolicyTagsRequest;
}(SimpleServiceRequestBase));
exports.GetUserRetentionPolicyTagsRequest = GetUserRetentionPolicyTagsRequest;
/**
 * @internal Represents a InstallApp request.
 *
 * @sealed
 */
var InstallAppRequest = (function (_super) {
    __extends(InstallAppRequest, _super);
    /**
     * Initializes a new instance of the **InstallAppRequest** class.
     *
     * @param   {ExchangeService}   service          The service.
     * @param   {string}   			manifestStream   The manifest's plain text XML stream.
     */
    function InstallAppRequest(service, manifestStream) {
        var _this = _super.call(this, service) || this;
        /**
         * The plain text manifest stream as base64 encoded string.
         */
        _this.manifestStream = null;
        _this.manifestStream = manifestStream;
        return _this;
    }
    /**
     * @internal Executes this request.
     *
     * @return  {Promise<InstallAppResponse>}      Service response  :Promise.
     */
    InstallAppRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    InstallAppRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2013;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    InstallAppRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.InstallAppResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    InstallAppRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.InstallAppRequest;
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    InstallAppRequest.prototype.ParseResponse = function (jsonBody) {
        var response = new InstallAppResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    InstallAppRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.Manifest);
        //writer.WriteBase64ElementValue(manifestStream);
        writer.WriteValue(this.manifestStream, null);
        writer.WriteEndElement();
    };
    return InstallAppRequest;
}(SimpleServiceRequestBase));
exports.InstallAppRequest = InstallAppRequest;
/**
 * ## @internal *Not Implemented*
 */
var PlayOnPhoneRequest = (function (_super) {
    __extends(PlayOnPhoneRequest, _super);
    function PlayOnPhoneRequest() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PlayOnPhoneRequest.prototype.Execute = function () { throw new Error("PlayOnPhoneRequest.ts - Execute : Not implemented."); };
    PlayOnPhoneRequest.prototype.GetMinimumRequiredServerVersion = function () { throw new Error("PlayOnPhoneRequest.ts - GetMinimumRequiredServerVersion : Not implemented."); };
    PlayOnPhoneRequest.prototype.GetResponseXmlElementName = function () { throw new Error("PlayOnPhoneRequest.ts - GetResponseXmlElementName : Not implemented."); };
    PlayOnPhoneRequest.prototype.GetXmlElementName = function () { throw new Error("PlayOnPhoneRequest.ts - GetXmlElementName : Not implemented."); };
    PlayOnPhoneRequest.prototype.ParseResponse = function (reader) { throw new Error("PlayOnPhoneRequest.ts - ParseResponse : Not implemented."); };
    //ParseResponse(jsonBody: JsonObject): any { throw new Error("PlayOnPhoneRequest.ts - ParseResponse : Not implemented."); }
    /**@internal */
    PlayOnPhoneRequest.prototype.WriteElementsToXml = function (writer) { throw new Error("PlayOnPhoneRequest.ts - WriteElementsToXml : Not implemented."); };
    return PlayOnPhoneRequest;
}(SimpleServiceRequestBase));
exports.PlayOnPhoneRequest = PlayOnPhoneRequest;
/**
 * ## @internal *Not Implemented*   Server to server call - not needed
 */
var SetEncryptionConfigurationRequest = (function (_super) {
    __extends(SetEncryptionConfigurationRequest, _super);
    function SetEncryptionConfigurationRequest() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SetEncryptionConfigurationRequest.prototype.Execute = function () { throw new Error("SetEncryptionConfigurationRequest.ts - Execute : Not implemented."); };
    SetEncryptionConfigurationRequest.prototype.GetMinimumRequiredServerVersion = function () { throw new Error("SetEncryptionConfigurationRequest.ts - GetMinimumRequiredServerVersion : Not implemented."); };
    SetEncryptionConfigurationRequest.prototype.GetResponseXmlElementName = function () { throw new Error("SetEncryptionConfigurationRequest.ts - GetResponseXmlElementName : Not implemented."); };
    SetEncryptionConfigurationRequest.prototype.GetXmlElementName = function () { throw new Error("SetEncryptionConfigurationRequest.ts - GetXmlElementName : Not implemented."); };
    SetEncryptionConfigurationRequest.prototype.ParseResponse = function (reader) { throw new Error("SetEncryptionConfigurationRequest.ts - ParseResponse : Not implemented."); };
    /**@internal */
    SetEncryptionConfigurationRequest.prototype.WriteElementsToXml = function (writer) { throw new Error("SetEncryptionConfigurationRequest.ts - WriteElementsToXml : Not implemented."); };
    return SetEncryptionConfigurationRequest;
}(SimpleServiceRequestBase));
exports.SetEncryptionConfigurationRequest = SetEncryptionConfigurationRequest;
/**
 * @internal Represents a SetHoldOnMailboxesRequest request.
 *
 * @sealed
 */
var SetHoldOnMailboxesRequest = (function (_super) {
    __extends(SetHoldOnMailboxesRequest, _super);
    /**
     * @internal Initializes a new instance of the **SetHoldOnMailboxesRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function SetHoldOnMailboxesRequest(service) {
        var _this = _super.call(this, service) || this;
        /**
         * Action type
         */
        _this.ActionType = HoldAction.Create;
        /**
         * Hold id
         */
        _this.HoldId = null;
        /**
         * Query
         */
        _this.Query = null;
        /**
         * Collection of mailboxes to be held/unheld
         */
        _this.Mailboxes = null;
        /**
         * Query language
         */
        _this.Language = null;
        /**
         * InPlaceHold Identity
         */
        _this.InPlaceHoldIdentity = null;
        /**
         * Item hold period
         * *The text value can be "Unlimited" or the string value of any Timespan value.*
         */
        _this.ItemHoldPeriod = null;
        /**
         * Include Non Indexable Items
         */
        _this.IncludeNonIndexableItems = null;
        /**
         * Perform deduplication
         */
        _this.PerformDeduplication = null;
        return _this;
    }
    /**
     * @internal Executes this request.
     *
     * @return  {Promise<SetHoldOnMailboxesResponse>}      Service response  :Promise.
     */
    SetHoldOnMailboxesRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    SetHoldOnMailboxesRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2013;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    SetHoldOnMailboxesRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.SetHoldOnMailboxesResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    SetHoldOnMailboxesRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.SetHoldOnMailboxes;
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    SetHoldOnMailboxesRequest.prototype.ParseResponse = function (jsonBody) {
        var response = new SetHoldOnMailboxesResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    };
    /**
     * @internal Validate request.
     */
    SetHoldOnMailboxesRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        if (StringHelper.IsNullOrEmpty(this.HoldId)) {
            throw new ServiceValidationException(Strings.HoldIdParameterIsNotSpecified);
        }
        if (StringHelper.IsNullOrEmpty(this.InPlaceHoldIdentity) && (this.Mailboxes == null || this.Mailboxes.length == 0)) {
            throw new ServiceValidationException(Strings.HoldMailboxesParameterIsNotSpecified);
        }
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    SetHoldOnMailboxesRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.ActionType, HoldAction[this.ActionType]);
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.HoldId, this.HoldId);
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.Query, this.Query || StringHelper.Empty);
        if (this.Mailboxes != null && this.Mailboxes.length > 0) {
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.Mailboxes);
            for (var _a = 0, _b = this.Mailboxes; _a < _b.length; _a++) {
                var mailbox = _b[_a];
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.String, mailbox);
            }
            writer.WriteEndElement(); // Mailboxes
        }
        // Language
        if (!StringHelper.IsNullOrEmpty(this.Language)) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.Language, this.Language);
        }
        if (!StringHelper.IsNullOrEmpty(this.InPlaceHoldIdentity)) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.InPlaceHoldIdentity, this.InPlaceHoldIdentity);
        }
        /** per github issue #120 */
        if (this.IncludeNonIndexableItems !== null) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.IncludeNonIndexableItems, this.IncludeNonIndexableItems);
        }
        /** per github issue #120 */
        if (this.PerformDeduplication !== null) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.Deduplication, this.PerformDeduplication);
        }
        if (!StringHelper.IsNullOrEmpty(this.ItemHoldPeriod)) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.ItemHoldPeriod, this.ItemHoldPeriod);
        }
    };
    return SetHoldOnMailboxesRequest;
}(SimpleServiceRequestBase));
exports.SetHoldOnMailboxesRequest = SetHoldOnMailboxesRequest;
/**
 * @internal Represents a SetTeamMailbox request.
 *
 * @sealed
 */
var SetTeamMailboxRequest = (function (_super) {
    __extends(SetTeamMailboxRequest, _super);
    /**
     * @internal Initializes a new instance of the **SetTeamMailboxRequest** class.
     *
     * @param   {ExchangeService}               service             The service
     * @param   {EmailAddress}                  emailAddress        TeamMailbox email address
     * @param   {Uri}                           sharePointSiteUrl   SharePoint site URL
     * @param   {TeamMailboxLifecycleState}     state               TeamMailbox state
     */
    function SetTeamMailboxRequest(service, emailAddress, sharePointSiteUrl, state) {
        var _this = _super.call(this, service) || this;
        /**
         * TeamMailbox email address
         */
        _this.emailAddress = null;
        /**
         * SharePoint site URL
         */
        _this.sharePointSiteUrl = null;
        /**
         * TeamMailbox lifecycle state
         */
        _this.state = TeamMailboxLifecycleState.Active;
        if (emailAddress === null) {
            throw new ArgumentNullException("emailAddress");
        }
        if (sharePointSiteUrl === null) {
            throw new ArgumentNullException("sharePointSiteUrl");
        }
        _this.emailAddress = emailAddress;
        _this.sharePointSiteUrl = sharePointSiteUrl;
        _this.state = state;
        return _this;
    }
    /**
     * @internal Executes this request.
     *
     * @return  {ServiceResponse}      Service response.
     */
    SetTeamMailboxRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    SetTeamMailboxRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2013;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    SetTeamMailboxRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.SetTeamMailboxResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    SetTeamMailboxRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.SetTeamMailbox;
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    SetTeamMailboxRequest.prototype.ParseResponse = function (jsonBody) {
        var serviceResponse = new ServiceResponse();
        serviceResponse.LoadFromXmlJsObject(jsonBody, this.Service);
        return serviceResponse;
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    SetTeamMailboxRequest.prototype.WriteElementsToXml = function (writer) {
        //this.emailAddress.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.EmailAddress);
        this.emailAddress.WriteToXml(writer, XmlElementNames.EmailAddress, XmlNamespace.Messages);
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.SharePointSiteUrl, this.sharePointSiteUrl.ToString());
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.State, TeamMailboxLifecycleState[this.state]);
    };
    return SetTeamMailboxRequest;
}(SimpleServiceRequestBase));
exports.SetTeamMailboxRequest = SetTeamMailboxRequest;
/**
 * @internal Represents a SetUserOofSettings request.
 *
 * @sealed
 */
var SetUserOofSettingsRequest = (function (_super) {
    __extends(SetUserOofSettingsRequest, _super);
    /**
     * @internal Initializes a new instance of the **SetUserOofSettingsRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function SetUserOofSettingsRequest(service) {
        var _this = _super.call(this, service) || this;
        _this.smtpAddress = null;
        _this.oofSettings = null;
        return _this;
    }
    Object.defineProperty(SetUserOofSettingsRequest.prototype, "SmtpAddress", {
        /**
         * Gets or sets the SMTP address.
         */
        get: function () {
            return this.smtpAddress;
        },
        set: function (value) {
            this.smtpAddress = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SetUserOofSettingsRequest.prototype, "OofSettings", {
        /**
         * Gets or sets the oof settings.
         */
        get: function () {
            return this.oofSettings;
        },
        set: function (value) {
            this.oofSettings = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Executes this request.
     *
     * @return  {ServiceResponse}      Service response.
     */
    SetUserOofSettingsRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    SetUserOofSettingsRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    SetUserOofSettingsRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.SetUserOofSettingsResponse; };
    /**
     * Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    SetUserOofSettingsRequest.prototype.GetXmlElementName = function () { return XmlElementNames.SetUserOofSettingsRequest; };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsObjectBody   The jsObjectBody from XmlJsObject.
     * @return  {any}            Service response.
     */
    SetUserOofSettingsRequest.prototype.ParseResponse = function (jsObjectBody) {
        var serviceResponse = new ServiceResponse();
        serviceResponse.LoadFromXmlJsObject(jsObjectBody[XmlElementNames.ResponseMessage], this.Service);
        return serviceResponse;
    };
    /**
     * @internal Validate request..
     */
    SetUserOofSettingsRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParam(this.SmtpAddress, "SmtpAddress");
        EwsUtilities.ValidateParam(this.OofSettings, "OofSettings");
    };
    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    SetUserOofSettingsRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Mailbox);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Address, this.SmtpAddress);
        writer.WriteEndElement(); // Mailbox
        this.OofSettings.WriteToXml(writer, XmlElementNames.UserOofSettings);
    };
    return SetUserOofSettingsRequest;
}(SimpleServiceRequestBase));
exports.SetUserOofSettingsRequest = SetUserOofSettingsRequest;
/**
 * @internal  Represents a UninstallApp request.
 *
 * @sealed
 */
var UninstallAppRequest = (function (_super) {
    __extends(UninstallAppRequest, _super);
    /**
     * @internal Initializes a new instance of the **UninstallAppRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     * @param   {string}   			id        Extension ID
     */
    function UninstallAppRequest(service, id) {
        var _this = _super.call(this, service) || this;
        /**
         * Extension ID
         */
        _this.ID = null;
        _this.ID = id;
        return _this;
    }
    /**
     * @internal Executes this request.
     *
     * @return  {Promise<UninstallAppResponse>}      Service response  :Promise.
     */
    UninstallAppRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    UninstallAppRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2013;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    UninstallAppRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.UninstallAppResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    UninstallAppRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.UninstallAppRequest;
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    UninstallAppRequest.prototype.ParseResponse = function (jsonBody) {
        var response = new UninstallAppResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    UninstallAppRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.ID, this.ID);
    };
    return UninstallAppRequest;
}(SimpleServiceRequestBase));
exports.UninstallAppRequest = UninstallAppRequest;
/**
 * @internal Represents a UnpinTeamMailbox request.
 *
 * @sealed
 */
var UnpinTeamMailboxRequest = (function (_super) {
    __extends(UnpinTeamMailboxRequest, _super);
    /**
     * Initializes a new instance of the **UnpinTeamMailboxRequest** class.
     *
     * @param   {ExchangeService}   service        The service
     * @param   {EmailAddress}      emailAddress   TeamMailbox email address
     */
    function UnpinTeamMailboxRequest(service, emailAddress) {
        var _this = _super.call(this, service) || this;
        /**
         * TeamMailbox email address
         */
        _this.emailAddress = null;
        if (emailAddress === null) {
            throw new ArgumentNullException("emailAddress");
        }
        _this.emailAddress = emailAddress;
        return _this;
    }
    /**
     * @internal Executes this request.
     *
     * @return  {ServiceResponse}      Service response.
     */
    UnpinTeamMailboxRequest.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    UnpinTeamMailboxRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2013;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    UnpinTeamMailboxRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.UnpinTeamMailboxResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    UnpinTeamMailboxRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.UnpinTeamMailbox;
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    UnpinTeamMailboxRequest.prototype.ParseResponse = function (jsonBody) {
        var serviceResponse = new ServiceResponse();
        serviceResponse.LoadFromXmlJsObject(jsonBody, this.Service);
        return serviceResponse;
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    UnpinTeamMailboxRequest.prototype.WriteElementsToXml = function (writer) {
        //this.emailAddress.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.EmailAddress);
        this.emailAddress.WriteToXml(writer, XmlElementNames.EmailAddress, XmlNamespace.Messages);
    };
    return UnpinTeamMailboxRequest;
}(SimpleServiceRequestBase));
exports.UnpinTeamMailboxRequest = UnpinTeamMailboxRequest;
/**
 * @internal Represents a UpdateInboxRulesRequest request.
 *
 * @sealed
 */
var UpdateInboxRulesRequest = (function (_super) {
    __extends(UpdateInboxRulesRequest, _super);
    /**
     * @internal Initializes a new instance of the **UpdateInboxRulesRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function UpdateInboxRulesRequest(service) {
        var _this = _super.call(this, service) || this;
        /**
         * The smtp address of the mailbox from which to get the inbox rules.
         */
        _this.mailboxSmtpAddress = null;
        /**
         * Remove OutlookRuleBlob or not.
         */
        _this.removeOutlookRuleBlob = false;
        /**
         * InboxRule operation collection.
         */
        _this.inboxRuleOperations = null;
        return _this;
    }
    Object.defineProperty(UpdateInboxRulesRequest.prototype, "MailboxSmtpAddress", {
        get: function () {
            return this.mailboxSmtpAddress;
        },
        set: function (value) {
            this.mailboxSmtpAddress = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UpdateInboxRulesRequest.prototype, "RemoveOutlookRuleBlob", {
        get: function () {
            return this.removeOutlookRuleBlob;
        },
        set: function (value) {
            this.removeOutlookRuleBlob = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UpdateInboxRulesRequest.prototype, "InboxRuleOperations", {
        get: function () {
            return this.inboxRuleOperations;
        },
        set: function (value) {
            this.inboxRuleOperations = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Executes this request.
     *
     * @return  {Promise<UpdateInboxRulesResponse>}      Service response  :Promise.
     */
    UpdateInboxRulesRequest.prototype.Execute = function () {
        var _this = this;
        return this.InternalExecute().then(function (serviceResponse) {
            if (serviceResponse.Result == ServiceResult.Error) {
                throw new UpdateInboxRulesException(serviceResponse, _this.inboxRuleOperations);
            }
            return serviceResponse;
        });
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    UpdateInboxRulesRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2010_SP1;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    UpdateInboxRulesRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.UpdateInboxRulesResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    UpdateInboxRulesRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.UpdateInboxRules;
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    UpdateInboxRulesRequest.prototype.ParseResponse = function (jsonBody) {
        var response = new UpdateInboxRulesResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    };
    /**
     * @internal Validate request.
     */
    UpdateInboxRulesRequest.prototype.Validate = function () {
        if (this.inboxRuleOperations == null) {
            throw new ArgumentException("RuleOperations cannot be null.", "Operations");
        }
        var operationCount = 0;
        for (var _a = 0, _b = this.inboxRuleOperations; _a < _b.length; _a++) {
            var operation = _b[_a];
            EwsUtilities.ValidateParam(operation, "RuleOperation");
            operationCount++;
        }
        if (operationCount == 0) {
            throw new ArgumentException("RuleOperations cannot be empty.", "Operations");
        }
        this.Service.Validate();
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    UpdateInboxRulesRequest.prototype.WriteElementsToXml = function (writer) {
        if (!StringHelper.IsNullOrEmpty(this.mailboxSmtpAddress)) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.MailboxSmtpAddress, this.mailboxSmtpAddress);
        }
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.RemoveOutlookRuleBlob, this.RemoveOutlookRuleBlob);
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.Operations);
        for (var _a = 0, _b = this.inboxRuleOperations; _a < _b.length; _a++) {
            var operation = _b[_a];
            operation.WriteToXml(writer, operation.XmlElementName);
        }
        writer.WriteEndElement();
    };
    return UpdateInboxRulesRequest;
}(SimpleServiceRequestBase));
exports.UpdateInboxRulesRequest = UpdateInboxRulesRequest;
/**
 * @internal Represents an abstract delegate management request.
 *
 * @typeparam   {TResponse}     The type of the response.
 */
var DelegateManagementRequestBase = (function (_super) {
    __extends(DelegateManagementRequestBase, _super);
    /**
     * @internal Initializes a new instance of the **DelegateManagementRequestBase<TResponse>** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function DelegateManagementRequestBase(service) {
        var _this = _super.call(this, service) || this;
        _this.mailbox = null;
        return _this;
    }
    Object.defineProperty(DelegateManagementRequestBase.prototype, "Mailbox", {
        /**
         *  Gets or sets the mailbox.
         *
         * @value    The mailbox.
         */
        get: function () {
            return this.mailbox;
        },
        set: function (value) {
            this.mailbox = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Executes this request.
     *
     * @return  {Promise<TResponse>}      Service response  :Promise.
     */
    DelegateManagementRequestBase.prototype.Execute = function () {
        return this.InternalExecute().then(function (serviceResponse) {
            serviceResponse.ThrowIfNecessary();
            return serviceResponse;
        });
    };
    /**
     * @internal Parses the response.
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    DelegateManagementRequestBase.prototype.ParseResponse = function (jsonBody) {
        var response = this.CreateResponse();
        response.LoadFromXmlJsObject(jsonBody, this.Service);
        return response;
    };
    /**
     * @internal Validate request.
     */
    DelegateManagementRequestBase.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParam(this.Mailbox, "Mailbox");
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    DelegateManagementRequestBase.prototype.WriteElementsToXml = function (writer) {
        this.Mailbox.WriteToXml(writer, XmlElementNames.Mailbox, XmlNamespace.Messages);
    };
    return DelegateManagementRequestBase;
}(SimpleServiceRequestBase));
exports.DelegateManagementRequestBase = DelegateManagementRequestBase;
/**
 * @internal Represents an AddDelegate request.
 */
var AddDelegateRequest = (function (_super) {
    __extends(AddDelegateRequest, _super);
    /**
     * @internal Initializes a new instance of the **AddDelegateRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function AddDelegateRequest(service) {
        var _this = _super.call(this, service) || this;
        _this.delegateUsers = [];
        _this.meetingRequestsDeliveryScope = null; //Nullable
        return _this;
    }
    Object.defineProperty(AddDelegateRequest.prototype, "MeetingRequestsDeliveryScope", {
        /**
         * Gets or sets the meeting requests delivery scope.
         *
         * @value   The meeting requests delivery scope.
         */
        get: function () {
            return this.meetingRequestsDeliveryScope;
        },
        set: function (value) {
            this.meetingRequestsDeliveryScope = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AddDelegateRequest.prototype, "DelegateUsers", {
        /**
         * Gets the delegate users.
         *
         * @value   The delegate users.
         */
        get: function () {
            return this.delegateUsers;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the response
     *
     * @return  {DelegateManagementResponse}		Response object.
     */
    AddDelegateRequest.prototype.CreateResponse = function () {
        return new DelegateManagementResponse(true, this.delegateUsers);
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    AddDelegateRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    AddDelegateRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.AddDelegateResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    AddDelegateRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.AddDelegate;
    };
    /**
     * @internal Validate request.
     */
    AddDelegateRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParamCollection(this.DelegateUsers, "DelegateUsers");
        for (var _a = 0, _b = this.DelegateUsers; _a < _b.length; _a++) {
            var delegateUser = _b[_a];
            delegateUser.ValidateUpdateDelegate();
        }
        if (this.MeetingRequestsDeliveryScope) {
            EwsUtilities.ValidateEnumVersionValue(MeetingRequestsDeliveryScope, this.MeetingRequestsDeliveryScope, this.Service.RequestedServerVersion, "MeetingRequestsDeliveryScope");
        }
    };
    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    AddDelegateRequest.prototype.WriteElementsToXml = function (writer) {
        _super.prototype.WriteElementsToXml.call(this, writer);
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.DelegateUsers);
        for (var _a = 0, _b = this.DelegateUsers; _a < _b.length; _a++) {
            var delegateUser = _b[_a];
            delegateUser.WriteToXml(writer, XmlElementNames.DelegateUser);
        }
        writer.WriteEndElement(); // DelegateUsers
        if (this.MeetingRequestsDeliveryScope) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.DeliverMeetingRequests, MeetingRequestsDeliveryScope[this.MeetingRequestsDeliveryScope]);
        }
    };
    return AddDelegateRequest;
}(DelegateManagementRequestBase));
exports.AddDelegateRequest = AddDelegateRequest;
/**
 * @internal Represents a GetDelegate request.
 */
var GetDelegateRequest = (function (_super) {
    __extends(GetDelegateRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetDelegateRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function GetDelegateRequest(service) {
        var _this = _super.call(this, service) || this;
        _this.userIds = [];
        _this.includePermissions = false;
        return _this;
    }
    Object.defineProperty(GetDelegateRequest.prototype, "UserIds", {
        /**
         * Gets the user ids.
         *
         * @value   The user ids.
         */
        get: function () {
            return this.userIds;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetDelegateRequest.prototype, "IncludePermissions", {
        /**
         * Gets or sets a value indicating whether permissions are included.
         */
        get: function () {
            return this.includePermissions;
        },
        set: function (value) {
            this.includePermissions = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the response
     *
     * @return  {GetDelegateResponse}		Response object.
     */
    GetDelegateRequest.prototype.CreateResponse = function () {
        return new GetDelegateResponse(true);
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetDelegateRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    GetDelegateRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.GetDelegateResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    GetDelegateRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.GetDelegate;
    };
    /**
     * @internal Writes XML attributes.
     *
     * /remarks/    Subclass will override if it has XML attributes.
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetDelegateRequest.prototype.WriteAttributesToXml = function (writer) {
        _super.prototype.WriteAttributesToXml.call(this, writer);
        writer.WriteAttributeValue(XmlAttributeNames.IncludePermissions, this.IncludePermissions);
    };
    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetDelegateRequest.prototype.WriteElementsToXml = function (writer) {
        _super.prototype.WriteElementsToXml.call(this, writer);
        if (this.UserIds.length > 0) {
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.UserIds);
            for (var _a = 0, _b = this.UserIds; _a < _b.length; _a++) {
                var userId = _b[_a];
                userId.WriteToXml(writer, XmlElementNames.UserId);
            }
            writer.WriteEndElement(); // UserIds
        }
    };
    return GetDelegateRequest;
}(DelegateManagementRequestBase));
exports.GetDelegateRequest = GetDelegateRequest;
/**
 * @internal Represents a RemoveDelete request.
 */
var RemoveDelegateRequest = (function (_super) {
    __extends(RemoveDelegateRequest, _super);
    /**
     * @internal Initializes a new instance of the **RemoveDelegateRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function RemoveDelegateRequest(service) {
        var _this = _super.call(this, service) || this;
        _this.userIds = [];
        return _this;
    }
    Object.defineProperty(RemoveDelegateRequest.prototype, "UserIds", {
        /**
         * Gets the user ids.
         *
         * @value   The user ids.
         */
        get: function () {
            return this.userIds;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the response
     *
     * @return  {DelegateManagementResponse}		Response object.
     */
    RemoveDelegateRequest.prototype.CreateResponse = function () {
        return new DelegateManagementResponse(false, null);
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    RemoveDelegateRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    RemoveDelegateRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.RemoveDelegateResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    RemoveDelegateRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.RemoveDelegate;
    };
    /**
     * @internal Validate request.
     */
    RemoveDelegateRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParamCollection(this.UserIds, "UserIds");
    };
    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    RemoveDelegateRequest.prototype.WriteElementsToXml = function (writer) {
        _super.prototype.WriteElementsToXml.call(this, writer);
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.UserIds);
        for (var _a = 0, _b = this.UserIds; _a < _b.length; _a++) {
            var userId = _b[_a];
            userId.WriteToXml(writer, XmlElementNames.UserId);
        }
        writer.WriteEndElement(); // UserIds
    };
    return RemoveDelegateRequest;
}(DelegateManagementRequestBase));
exports.RemoveDelegateRequest = RemoveDelegateRequest;
/**
 * @internal Represents an UpdateDelegate request.
 */
var UpdateDelegateRequest = (function (_super) {
    __extends(UpdateDelegateRequest, _super);
    /**
     * @internal Initializes a new instance of the **UpdateDelegateRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function UpdateDelegateRequest(service) {
        var _this = _super.call(this, service) || this;
        _this.delegateUsers = [];
        _this.meetingRequestsDeliveryScope = null; //Nullable
        return _this;
    }
    Object.defineProperty(UpdateDelegateRequest.prototype, "MeetingRequestsDeliveryScope", {
        /**
         * Gets or sets the meeting requests delivery scope.
         *
         * @value   The meeting requests delivery scope.
         */
        get: function () {
            return this.meetingRequestsDeliveryScope;
        },
        set: function (value) {
            this.meetingRequestsDeliveryScope = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UpdateDelegateRequest.prototype, "DelegateUsers", {
        /**
         * Gets the delegate users.
         *
         * @value   The delegate users.
         */
        get: function () {
            return this.delegateUsers;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the response
     *
     * @return  {DelegateManagementResponse}		Response object.
     */
    UpdateDelegateRequest.prototype.CreateResponse = function () {
        return new DelegateManagementResponse(true, this.delegateUsers);
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    UpdateDelegateRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    UpdateDelegateRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.UpdateDelegateResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    UpdateDelegateRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.UpdateDelegate;
    };
    /**
     * @internal Validate request.
     */
    UpdateDelegateRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParamCollection(this.DelegateUsers, "DelegateUsers");
        for (var _a = 0, _b = this.DelegateUsers; _a < _b.length; _a++) {
            var delegateUser = _b[_a];
            delegateUser.ValidateUpdateDelegate();
        }
    };
    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    UpdateDelegateRequest.prototype.WriteElementsToXml = function (writer) {
        _super.prototype.WriteElementsToXml.call(this, writer);
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.DelegateUsers);
        for (var _a = 0, _b = this.DelegateUsers; _a < _b.length; _a++) {
            var delegateUser = _b[_a];
            delegateUser.WriteToXml(writer, XmlElementNames.DelegateUser);
        }
        writer.WriteEndElement(); // DelegateUsers
        if (this.MeetingRequestsDeliveryScope) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.DeliverMeetingRequests, MeetingRequestsDeliveryScope[this.MeetingRequestsDeliveryScope]);
        }
    };
    return UpdateDelegateRequest;
}(DelegateManagementRequestBase));
exports.UpdateDelegateRequest = UpdateDelegateRequest;
/** @internal */
var MultiResponseServiceRequest = (function (_super) {
    __extends(MultiResponseServiceRequest, _super);
    function MultiResponseServiceRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service) || this;
        _this.errorHandlingMode = errorHandlingMode;
        return _this;
    }
    Object.defineProperty(MultiResponseServiceRequest.prototype, "ErrorHandlingMode", {
        get: function () { return this.errorHandlingMode; },
        enumerable: true,
        configurable: true
    });
    MultiResponseServiceRequest.prototype.CreateServiceResponse = function (service, responseIndex) { throw new Error("abstract; must implemented."); };
    //EndExecute(asyncResult: any/*System.IAsyncResult*/): ServiceResponseCollection<TResponse> { throw new Error("MultiResponseServiceRequest.ts - EndExecute : Not implemented."); }
    MultiResponseServiceRequest.prototype.Execute = function () {
        var _this = this;
        return new exports.Promise(function (successDelegate, errorDelegate) {
            _this.InternalExecute().then(function (value) {
                var serviceResponses = value;
                if (_this.ErrorHandlingMode == ServiceErrorHandling.ThrowOnError) {
                    EwsLogging.Assert(serviceResponses.Count == 1, "MultiResponseServiceRequest.Execute", "ServiceErrorHandling.ThrowOnError error handling is only valid for singleton request");
                    try {
                        serviceResponses.__thisIndexer(0).ThrowIfNecessary();
                    }
                    catch (error) {
                        if (errorDelegate) {
                            errorDelegate(error);
                        }
                    }
                }
                //return serviceResponses; //no return succedssdelegates take care of returning
                if (successDelegate) {
                    successDelegate(serviceResponses);
                }
            }, function (resperr) {
                debugger;
                if (errorDelegate) {
                    errorDelegate(resperr);
                }
            });
        });
    };
    MultiResponseServiceRequest.prototype.GetExpectedResponseMessageCount = function () { throw new Error("Abstract; must implemented."); };
    MultiResponseServiceRequest.prototype.GetResponseMessageXmlElementName = function () { throw new Error("Abstract; must implemented."); };
    MultiResponseServiceRequest.prototype.ParseResponseXMLJsObject = function (jsObject) {
        var serviceResponses = new ServiceResponseCollection();
        //set context to XmlElementNames.ResponseMessages
        //todo: this can have multiple reponse messages.
        var jsResponseMessages = jsObject[XmlElementNames.ResponseMessages];
        // if (!Array.isArray(jsResponseMessages)) {
        //     jsResponseMessages = [jsResponseMessages];
        // }
        var responseMessageXmlElementName = this.GetResponseMessageXmlElementName();
        var responseMessages = EwsServiceJsonReader.ReadAsArray(jsResponseMessages, responseMessageXmlElementName);
        //for (var i = 0; i < responses.length; i++) {
        for (var i = 0; i < this.GetExpectedResponseMessageCount(); i++) {
            var response = this.CreateServiceResponse(this.Service, i);
            //ref: check need for responseMessageXmlElementName
            var jsResponseMessage = responseMessages[i];
            response.LoadFromXmlJsObject(jsResponseMessage, this.Service); //, responseMessageXmlElementName, this.Service);
            // Add the response to the list after it has been deserialized because the response
            // list updates an overall result as individual responses are added to it.
            serviceResponses.Add(response);
        }
        // If there's a general error in batch processing,
        // the server will return a single response message containing the error
        // (for example, if the SavedItemFolderId is bogus in a batch CreateItem
        // call). In this case, throw a ServiceResponsException. Otherwise this
        // is an unexpected server error.
        if (serviceResponses.Count < this.GetExpectedResponseMessageCount()) {
            if ((serviceResponses.Count >= 1) && (serviceResponses.__thisIndexer(0).Result == ServiceResult.Error)) {
                throw new ServiceResponseException(serviceResponses.__thisIndexer(0));
            }
            else {
                throw new ServiceXmlDeserializationException(StringHelper.Format(Strings.TooFewServiceReponsesReturned, this.GetResponseMessageXmlElementName(), this.GetExpectedResponseMessageCount(), serviceResponses.Count));
            }
        }
        return serviceResponses;
    };
    MultiResponseServiceRequest.prototype.ParseResponse = function (jsonBody) {
        if (this.Service.RenderingMethod === RenderingMode.JSON) {
            throw new Error("not implemented");
            var serviceResponses = new ServiceResponseCollection();
            var jsonResponseMessages = jsonBody[XmlElementNames.ResponseMessages][XmlElementNames.Items];
            var responseCtr = 0;
            for (var _a = 0, jsonResponseMessages_1 = jsonResponseMessages; _a < jsonResponseMessages_1.length; _a++) {
                var jsonResponseObject = jsonResponseMessages_1[_a];
                var response = this.CreateServiceResponse(this.Service, responseCtr);
                response.LoadFromXmlJsObject(jsonResponseObject, this.Service);
                // Add the response to the list after it has been deserialized because the response
                // list updates an overall result as individual responses are added to it.
                serviceResponses.Add(response);
                responseCtr++;
            }
            if (serviceResponses.Count < this.GetExpectedResponseMessageCount()) {
                if ((serviceResponses.Count == 1) && (serviceResponses[0].Result == ServiceResult.Error)) {
                    throw new ServiceResponseException(serviceResponses[0]);
                }
                else {
                    throw new ServiceJsonDeserializationException();
                }
            }
            return serviceResponses;
        }
        else {
            return this.ParseResponseXMLJsObject(jsonBody);
        }
    };
    return MultiResponseServiceRequest;
}(SimpleServiceRequestBase));
exports.MultiResponseServiceRequest = MultiResponseServiceRequest;
/**
 * @internal Represents a request to a Apply Conversation Action operation
 *
 * @sealed
 */
var ApplyConversationActionRequest = (function (_super) {
    __extends(ApplyConversationActionRequest, _super);
    /**
     * @internal Initializes a new instance of the **ApplyConversationActionRequest** class.
     *
     * @param   {ExchangeService}       service   The service.
     * @param   {ServiceErrorHandling}  errorHandlingMode   Indicates how errors should be handled.
     */
    function ApplyConversationActionRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        _this.conversationActions = [];
        return _this;
    }
    Object.defineProperty(ApplyConversationActionRequest.prototype, "ConversationActions", {
        get: function () {
            return this.conversationActions;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}   			responseIndex   Index of the response.
     * @return  {ServiceResponse}	Service response.
     */
    ApplyConversationActionRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new ServiceResponse();
    };
    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of expected response messages.
     */
    ApplyConversationActionRequest.prototype.GetExpectedResponseMessageCount = function () {
        return this.conversationActions.length;
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    ApplyConversationActionRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2010_SP1;
    };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      Xml element name.
     */
    ApplyConversationActionRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.ApplyConversationActionResponseMessage; };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      Xml element name.
     */
    ApplyConversationActionRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.ApplyConversationActionResponse; };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      Xml element name.
     */
    ApplyConversationActionRequest.prototype.GetXmlElementName = function () { return XmlElementNames.ApplyConversationAction; };
    /**
     * @internal Validate the request.
     */
    ApplyConversationActionRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParamCollection(this.conversationActions, "conversationActions");
        for (var iAction = 0; iAction < this.ConversationActions.length; iAction++) {
            this.ConversationActions[iAction].Validate();
        }
    };
    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ApplyConversationActionRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.ConversationActions);
        for (var iAction = 0; iAction < this.ConversationActions.length; iAction++) {
            this.ConversationActions[iAction].WriteElementsToXml(writer);
        }
        writer.WriteEndElement();
    };
    return ApplyConversationActionRequest;
}(MultiResponseServiceRequest));
exports.ApplyConversationActionRequest = ApplyConversationActionRequest;
/** @internal */
var ArchiveItemRequest = (function (_super) {
    __extends(ArchiveItemRequest, _super);
    function ArchiveItemRequest(service, errorHandlingModeServiceErrorHandling) {
        var _this = _super.call(this, service, errorHandlingModeServiceErrorHandling) || this;
        _this.ids = new ItemIdWrapperList();
        return _this;
    }
    Object.defineProperty(ArchiveItemRequest.prototype, "Ids", {
        get: function () { return this.ids; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArchiveItemRequest.prototype, "SourceFolderId", {
        get: function () {
            return this.sourceFolderId;
        },
        set: function (value) {
            this.sourceFolderId = value;
        },
        enumerable: true,
        configurable: true
    });
    //AddIdsToJson(jsonObject: JsonObject, service: ExchangeService): any { throw new Error("ArchiveItemRequest.ts - AddIdsToJson : Not implemented."); }
    ArchiveItemRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new ArchiveItemResponse(); };
    ArchiveItemRequest.prototype.GetExpectedResponseMessageCount = function () { return this.ids.Count; };
    ArchiveItemRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2013; };
    ArchiveItemRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.ArchiveItemResponseMessage; };
    ArchiveItemRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.ArchiveItemResponse; };
    ArchiveItemRequest.prototype.GetXmlElementName = function () { return XmlElementNames.ArchiveItem; };
    ArchiveItemRequest.prototype.Validate = function () {
        //EwsUtilities.ValidateParam(this.sourceFolderId, "SourceFolderId");
        this.sourceFolderId.Validate(this.Service.RequestedServerVersion);
    };
    /**@internal */
    ArchiveItemRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.ArchiveSourceFolderId);
        this.SourceFolderId.WriteToXml(writer);
        writer.WriteEndElement();
        this.WriteIdsToXml(writer);
    };
    /**@internal */
    ArchiveItemRequest.prototype.WriteIdsToXml = function (writer) {
        this.Ids.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.ItemIds);
    };
    return ArchiveItemRequest;
}(MultiResponseServiceRequest));
exports.ArchiveItemRequest = ArchiveItemRequest;
/**
 * @internal Represents a ConvertId request.
 *
 * @sealed
 */
var ConvertIdRequest = (function (_super) {
    __extends(ConvertIdRequest, _super);
    /**
     * @internal Initializes a new instance of the **ConvertIdRequest** class.
     *
     * @param   {ExchangeService}   service             The service.
     * @param   {ServiceErrorHandling}   errorHandlingMode   Indicates how errors should be handled.
     */
    function ConvertIdRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        _this.destinationFormat = IdFormat.EwsId;
        _this.ids = [];
        return _this;
    }
    Object.defineProperty(ConvertIdRequest.prototype, "DestinationFormat", {
        /**
         * Gets or sets the destination format.
         *
         * @value   The destination format.
         */
        get: function () {
            return this.destinationFormat;
        },
        set: function (value) {
            this.destinationFormat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConvertIdRequest.prototype, "Ids", {
        /**
         * Gets the ids.
         *
         * @value   The ids.
         */
        get: function () {
            return this.ids;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}            responseIndex   Index of the response.
     * @return  {ConvertIdResponse}     Service response.
     */
    ConvertIdRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new ConvertIdResponse();
    };
    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of expected response messages.
     */
    ConvertIdRequest.prototype.GetExpectedResponseMessageCount = function () {
        return this.Ids.length;
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    ConvertIdRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      XML element name,
     */
    ConvertIdRequest.prototype.GetResponseMessageXmlElementName = function () {
        return XmlElementNames.ConvertIdResponseMessage;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    ConvertIdRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.ConvertIdResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    ConvertIdRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.ConvertId;
    };
    /**
     * @internal Validate request.
     */
    ConvertIdRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParamCollection(this.Ids, "Ids");
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ConvertIdRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteAttributeValue(XmlAttributeNames.DestinationFormat, IdFormat[this.DestinationFormat]);
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.SourceIds);
        for (var _a = 0, _b = this.Ids; _a < _b.length; _a++) {
            var alternateId = _b[_a];
            alternateId.WriteToXml(writer);
        }
        writer.WriteEndElement(); // SourceIds
    };
    return ConvertIdRequest;
}(MultiResponseServiceRequest));
exports.ConvertIdRequest = ConvertIdRequest;
/**
 * @internal Represents a CreateAttachment request.
 * @sealed
 */
var CreateAttachmentRequest = (function (_super) {
    __extends(CreateAttachmentRequest, _super);
    /**
     * @internal Initializes a new instance of the **CreateAttachmentRequest** class.
     *
     * @param   {ExchangeService}       service             The service.
     * @param   {ServiceErrorHandling}  errorHandlingMode   Indicates how errors should be handled.
     */
    function CreateAttachmentRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        _this.parentItemId = null;
        _this.attachments = [];
        return _this;
    }
    Object.defineProperty(CreateAttachmentRequest.prototype, "EmitTimeZoneHeader", {
        /**
         * @internal Gets a value indicating whether the TimeZoneContext SOAP header should be emitted.
         */
        get: function () {
            for (var _a = 0, _b = ArrayHelper.OfType(this.attachments, function (item) { return item instanceof ItemAttachment; }); _a < _b.length; _a++) {
                var itemAttachment = _b[_a];
                if ((itemAttachment.Item != null) && itemAttachment.Item.GetIsTimeZoneHeaderRequired(false /* isUpdateOperation */)) {
                    return true;
                }
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CreateAttachmentRequest.prototype, "Attachments", {
        /**
         * Gets the attachments.
         */
        get: function () {
            return this.attachments;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CreateAttachmentRequest.prototype, "ParentItemId", {
        /**
         * Gets or sets the parent item id.
         * @value   The parent item id.
         */
        get: function () {
            return this.parentItemId;
        },
        set: function (value) {
            this.parentItemId = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}            responseIndex   Index of the response.
     * @return  {CreateAttachmentResponse}     Service response.
     */
    CreateAttachmentRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new CreateAttachmentResponse(this.Attachments[responseIndex]);
    };
    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of expected response messages.
     */
    CreateAttachmentRequest.prototype.GetExpectedResponseMessageCount = function () {
        return this.Attachments.length;
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    CreateAttachmentRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      XML element name,
     */
    CreateAttachmentRequest.prototype.GetResponseMessageXmlElementName = function () {
        return XmlElementNames.CreateAttachmentResponseMessage;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    CreateAttachmentRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.CreateAttachmentResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    CreateAttachmentRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.CreateAttachment;
    };
    /**
     * @internal Validate request.
     */
    CreateAttachmentRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParam(this.ParentItemId, "ParentItemId");
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    CreateAttachmentRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.ParentItemId);
        writer.WriteAttributeValue(XmlAttributeNames.Id, this.ParentItemId);
        writer.WriteEndElement();
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.Attachments);
        for (var _a = 0, _b = this.Attachments; _a < _b.length; _a++) {
            var attachment = _b[_a];
            attachment.WriteToXml(writer, attachment.GetXmlElementName());
        }
        writer.WriteEndElement();
    };
    return CreateAttachmentRequest;
}(MultiResponseServiceRequest));
exports.CreateAttachmentRequest = CreateAttachmentRequest;
/**
 * @internal Represents a CreateUserConfiguration request.
 *
 * @sealed
 */
var CreateUserConfigurationRequest = (function (_super) {
    __extends(CreateUserConfigurationRequest, _super);
    /**
     * @internal Initializes a new instance of the **CreateUserConfigurationRequest** class.
     *
     * @param   {ExchangeService}       service   The service.
     */
    function CreateUserConfigurationRequest(service) {
        var _this = _super.call(this, service, ServiceErrorHandling.ThrowOnError) || this;
        _this.userConfiguration = null;
        return _this;
    }
    Object.defineProperty(CreateUserConfigurationRequest.prototype, "UserConfiguration", {
        /**
         * Gets or sets the user configuration.
         *
         * @value   The userConfiguration.
         */
        get: function () {
            return this.userConfiguration;
        },
        set: function (value) {
            this.userConfiguration = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}   			responseIndex   Index of the response.
     * @return  {ServiceResponse}	Service response.
     */
    CreateUserConfigurationRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new ServiceResponse();
    };
    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of expected response messages.
     */
    CreateUserConfigurationRequest.prototype.GetExpectedResponseMessageCount = function () {
        return 1;
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    CreateUserConfigurationRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2010;
    };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      Xml element name.
     */
    CreateUserConfigurationRequest.prototype.GetResponseMessageXmlElementName = function () {
        return XmlElementNames.CreateUserConfigurationResponseMessage;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      Xml element name.
     */
    CreateUserConfigurationRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.CreateUserConfigurationResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      Xml element name.
     */
    CreateUserConfigurationRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.CreateUserConfiguration;
    };
    /**
     * @internal Validate the request.
     */
    CreateUserConfigurationRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParam(this.userConfiguration, "userConfiguration");
    };
    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    CreateUserConfigurationRequest.prototype.WriteElementsToXml = function (writer) {
        // Write UserConfiguation element
        this.userConfiguration.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.UserConfiguration);
    };
    return CreateUserConfigurationRequest;
}(MultiResponseServiceRequest));
exports.CreateUserConfigurationRequest = CreateUserConfigurationRequest;
/**
 * @internal Represents a DeleteAttachment request.
 * @sealed
 */
var DeleteAttachmentRequest = (function (_super) {
    __extends(DeleteAttachmentRequest, _super);
    /**
     * @internal Initializes a new instance of the **DeleteAttachmentRequest** class.
     *
     * @param   {ExchangeService}       service             The service.
     * @param   {ServiceErrorHandling}  errorHandlingMode   Indicates how errors should be handled.
     */
    function DeleteAttachmentRequest(service, errorHandlingMode) {
        return _super.call(this, service, errorHandlingMode) || this;
    }
    Object.defineProperty(DeleteAttachmentRequest.prototype, "Attachments", {
        /**
         * Gets the attachments.
         * @value   The attachments.
         */
        get: function () {
            return this.attachments;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}            responseIndex   Index of the response.
     * @return  {DeleteAttachmentResponse}     Service response.
     */
    DeleteAttachmentRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new DeleteAttachmentResponse(this.Attachments[responseIndex]);
    };
    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of expected response messages.
     */
    DeleteAttachmentRequest.prototype.GetExpectedResponseMessageCount = function () {
        return this.Attachments.length;
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    DeleteAttachmentRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      XML element name,
     */
    DeleteAttachmentRequest.prototype.GetResponseMessageXmlElementName = function () {
        return XmlElementNames.DeleteAttachmentResponseMessage;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    DeleteAttachmentRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.DeleteAttachmentResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    DeleteAttachmentRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.DeleteAttachment;
    };
    /**
     * @internal Validate request.
     */
    DeleteAttachmentRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParamCollection(this.Attachments, "Attachments");
        for (var i = 0; i < this.Attachments.length; i++) {
            EwsUtilities.ValidateParam(this.Attachments[i].Id, StringHelper.Format("Attachment[{0}].Id", i));
        }
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    DeleteAttachmentRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.AttachmentIds);
        for (var _a = 0, _b = this.Attachments; _a < _b.length; _a++) {
            var attachment = _b[_a];
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.AttachmentId);
            writer.WriteAttributeValue(XmlAttributeNames.Id, attachment.Id);
            writer.WriteEndElement();
        }
        writer.WriteEndElement();
    };
    return DeleteAttachmentRequest;
}(MultiResponseServiceRequest));
exports.DeleteAttachmentRequest = DeleteAttachmentRequest;
/**
 * @internal Represents a DeleteUserConfiguration request.
 */
var DeleteUserConfigurationRequest = (function (_super) {
    __extends(DeleteUserConfigurationRequest, _super);
    /**
     * @internal Initializes a new instance of the **DeleteUserConfigurationRequest** class.
     *
     * @param   {ExchangeService}       service   The service.
     */
    function DeleteUserConfigurationRequest(service) {
        var _this = _super.call(this, service, ServiceErrorHandling.ThrowOnError) || this;
        _this.name = null;
        _this.parentFolderId = null;
        return _this;
    }
    Object.defineProperty(DeleteUserConfigurationRequest.prototype, "Name", {
        /**
         * @internal Gets or sets the name.
         *
         * @Value   The Name
         */
        get: function () {
            return this.name;
        },
        set: function (value) {
            this.name = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DeleteUserConfigurationRequest.prototype, "ParentFolderId", {
        /**
         * @internal Gets or sets the parent folder Id.
         *
         * @value   The parent folder Id.
         */
        get: function () {
            return this.parentFolderId;
        },
        set: function (value) {
            this.parentFolderId = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}   			responseIndex   Index of the response.
     * @return  {ServiceResponse}	Service response.
     */
    DeleteUserConfigurationRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new ServiceResponse();
    };
    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of expected response messages.
     */
    DeleteUserConfigurationRequest.prototype.GetExpectedResponseMessageCount = function () {
        return 1;
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    DeleteUserConfigurationRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2010;
    };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      Xml element name.
     */
    DeleteUserConfigurationRequest.prototype.GetResponseMessageXmlElementName = function () {
        return XmlElementNames.DeleteUserConfigurationResponseMessage;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      Xml element name.
     */
    DeleteUserConfigurationRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.DeleteUserConfigurationResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      Xml element name.
     */
    DeleteUserConfigurationRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.DeleteUserConfiguration;
    };
    /**
     * @internal Validate the request.
     */
    DeleteUserConfigurationRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParam(this.name, "name");
        EwsUtilities.ValidateParam(this.parentFolderId, "parentFolderId");
        this.ParentFolderId.Validate(this.Service.RequestedServerVersion);
    };
    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    DeleteUserConfigurationRequest.prototype.WriteElementsToXml = function (writer) {
        // Write UserConfiguationName element
        UserConfiguration.WriteUserConfigurationNameToXml(writer, XmlNamespace.Messages, this.name, this.parentFolderId);
    };
    return DeleteUserConfigurationRequest;
}(MultiResponseServiceRequest));
exports.DeleteUserConfigurationRequest = DeleteUserConfigurationRequest;
/**
 * ## @internal *Not Implemented*
 */
var ExecuteDiagnosticMethodRequest = (function (_super) {
    __extends(ExecuteDiagnosticMethodRequest, _super);
    function ExecuteDiagnosticMethodRequest() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ExecuteDiagnosticMethodRequest.prototype.CreateServiceResponse = function (service, responseIndex) { throw new Error("ExecuteDiagnosticMethodRequest.ts - CreateServiceResponse : Not implemented."); };
    ExecuteDiagnosticMethodRequest.prototype.GetExpectedResponseMessageCount = function () { throw new Error("ExecuteDiagnosticMethodRequest.ts - GetExpectedResponseMessageCount : Not implemented."); };
    ExecuteDiagnosticMethodRequest.prototype.GetMinimumRequiredServerVersion = function () { throw new Error("ExecuteDiagnosticMethodRequest.ts - GetMinimumRequiredServerVersion : Not implemented."); };
    ExecuteDiagnosticMethodRequest.prototype.GetResponseMessageXmlElementName = function () { throw new Error("ExecuteDiagnosticMethodRequest.ts - GetResponseMessageXmlElementName : Not implemented."); };
    ExecuteDiagnosticMethodRequest.prototype.GetResponseXmlElementName = function () { throw new Error("ExecuteDiagnosticMethodRequest.ts - GetResponseXmlElementName : Not implemented."); };
    ExecuteDiagnosticMethodRequest.prototype.GetXmlElementName = function () { throw new Error("ExecuteDiagnosticMethodRequest.ts - GetXmlElementName : Not implemented."); };
    /**@internal */
    ExecuteDiagnosticMethodRequest.prototype.WriteElementsToXml = function (writer) { throw new Error("ExecuteDiagnosticMethodRequest.ts - WriteElementsToXml : Not implemented."); };
    return ExecuteDiagnosticMethodRequest;
}(MultiResponseServiceRequest));
exports.ExecuteDiagnosticMethodRequest = ExecuteDiagnosticMethodRequest;
/** @internal */
var ExpandGroupRequest = (function (_super) {
    __extends(ExpandGroupRequest, _super);
    function ExpandGroupRequest(service) {
        var _this = _super.call(this, service, ServiceErrorHandling.ThrowOnError) || this;
        _this.emailAddress = null;
        return _this;
    }
    Object.defineProperty(ExpandGroupRequest.prototype, "EmailAddress", {
        get: function () {
            return this.emailAddress;
        },
        set: function (value) {
            this.emailAddress = value;
        },
        enumerable: true,
        configurable: true
    });
    ExpandGroupRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new ExpandGroupResponse(); };
    ExpandGroupRequest.prototype.GetExpectedResponseMessageCount = function () { return 1; };
    ExpandGroupRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    ExpandGroupRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.ExpandDLResponseMessage; };
    ExpandGroupRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.ExpandDLResponse; };
    ExpandGroupRequest.prototype.GetXmlElementName = function () { return XmlElementNames.ExpandDL; };
    ExpandGroupRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        //EwsUtilities.ValidateParam(this.EmailAddress, "EmailAddress");
    };
    /**@internal */
    ExpandGroupRequest.prototype.WriteElementsToXml = function (writer) {
        if (this.EmailAddress != null) {
            this.EmailAddress.WriteToXml(writer, XmlElementNames.Mailbox, XmlNamespace.Messages);
        }
    };
    return ExpandGroupRequest;
}(MultiResponseServiceRequest));
exports.ExpandGroupRequest = ExpandGroupRequest;
/**
 * @internal Represents a GetAttachment request.
 */
var GetAttachmentRequest = (function (_super) {
    __extends(GetAttachmentRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetAttachmentRequest** class.
     *
     * @param   {ExchangeService}       service             The service.
     * @param   {ServiceErrorHandling}  errorHandlingMode   Indicates how errors should be handled.
     */
    function GetAttachmentRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        _this.attachments = [];
        _this.attachmentIds = [];
        _this.additionalProperties = [];
        _this.bodyType = null;
        return _this;
    }
    Object.defineProperty(GetAttachmentRequest.prototype, "Attachments", {
        /**
         * Gets the attachments.
         *
         * @value The attachments.
         */
        get: function () {
            return this.attachments;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetAttachmentRequest.prototype, "AttachmentIds", {
        /**
         * Gets the attachment ids.
         *
         * @value The attachment ids.
         */
        get: function () {
            return this.attachmentIds;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetAttachmentRequest.prototype, "AdditionalProperties", {
        /**
         * Gets the additional properties.
         *
         * @value The additional properties.
         */
        get: function () {
            return this.additionalProperties;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetAttachmentRequest.prototype, "BodyType", {
        /**
         * Gets or sets the type of the body.
         *
         * @value The type of the body.
         */
        get: function () {
            return this.bodyType;
        },
        set: function (value) {
            this.bodyType = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetAttachmentRequest.prototype, "EmitTimeZoneHeader", {
        /**
         * @internal Gets a value indicating whether the TimeZoneContext SOAP header should be emitted.
         *
         * @value *true* if the time zone should be emitted; otherwise, *false*.
         */
        get: function () {
            return this.additionalProperties.indexOf(Schemas.ItemSchema.MimeContent) >= 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}            responseIndex   Index of the response.
     * @return  {GetAttachmentResponse}             Service response.
     */
    GetAttachmentRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new GetAttachmentResponse(this.Attachments.length > 0 ? this.Attachments[responseIndex] : null);
    };
    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of expected response messages.
     */
    GetAttachmentRequest.prototype.GetExpectedResponseMessageCount = function () { return this.Attachments.length + this.AttachmentIds.length; };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetAttachmentRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      XML element name,
     */
    GetAttachmentRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.GetAttachmentResponseMessage; };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    GetAttachmentRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.GetAttachmentResponse; };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    GetAttachmentRequest.prototype.GetXmlElementName = function () { return XmlElementNames.GetAttachment; };
    /**
     * @internal Validate request.
     */
    GetAttachmentRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        if (this.Attachments.length > 0) {
            EwsUtilities.ValidateParamCollection(this.Attachments, "Attachments");
        }
        if (this.AttachmentIds.length > 0) {
            EwsUtilities.ValidateParamCollection(this.AttachmentIds, "AttachmentIds");
        }
        if (this.AttachmentIds.length == 0 && this.Attachments.length == 0) {
            throw new ArgumentException(Strings.CollectionIsEmpty, "Attachments/AttachmentIds");
        }
        for (var i = 0; i < this.AdditionalProperties.length; i++) {
            EwsUtilities.ValidateParam(this.AdditionalProperties[i], StringHelper.Format("AdditionalProperties[{0}]", i));
        }
    };
    /**
     * @internal Writes attachment id elements.
     *
     * @param   {EwsServiceXmlWriter}   writer         The writer.
     * @param   {string}                attachmentId   The attachment id.
     */
    GetAttachmentRequest.prototype.WriteAttachmentIdXml = function (writer, attachmentId) {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.AttachmentId);
        writer.WriteAttributeValue(XmlAttributeNames.Id, attachmentId);
        writer.WriteEndElement();
    };
    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetAttachmentRequest.prototype.WriteElementsToXml = function (writer) {
        if (this.BodyType || this.AdditionalProperties.length > 0) {
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.AttachmentShape);
            if (this.BodyType) {
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.BodyType, BodyType[this.BodyType]);
            }
            if (this.AdditionalProperties.length > 0) {
                PropertySet.WriteAdditionalPropertiesToXml(writer, this.AdditionalProperties);
            }
            writer.WriteEndElement(); // AttachmentShape
        }
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.AttachmentIds);
        for (var _a = 0, _b = this.Attachments; _a < _b.length; _a++) {
            var attachment = _b[_a];
            this.WriteAttachmentIdXml(writer, attachment.Id);
        }
        for (var _c = 0, _d = this.AttachmentIds; _c < _d.length; _c++) {
            var attachmentId = _d[_c];
            this.WriteAttachmentIdXml(writer, attachmentId);
        }
        writer.WriteEndElement();
    };
    return GetAttachmentRequest;
}(MultiResponseServiceRequest));
exports.GetAttachmentRequest = GetAttachmentRequest;
/**
 * @internal Represents a GetClientAccessToken request.
 *
 * @sealed
 */
var GetClientAccessTokenRequest = (function (_super) {
    __extends(GetClientAccessTokenRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetClientAccessTokenRequest** class.
     *
     * @param   {ExchangeService}   	service             The service.
     * @param   {ServiceErrorHandling}  errorHandlingMode   Indicates how errors should be handled.
     */
    function GetClientAccessTokenRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        _this.TokenRequests = [];
        return _this;
    }
    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}   			responseIndex   Index of the response.
     * @return  {GetClientAccessTokenResponse}		Response object.
     */
    GetClientAccessTokenRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new GetClientAccessTokenResponse(this.TokenRequests[responseIndex].Id, this.TokenRequests[responseIndex].TokenType);
    };
    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of items in response.
     */
    GetClientAccessTokenRequest.prototype.GetExpectedResponseMessageCount = function () {
        return this.TokenRequests.length;
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetClientAccessTokenRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2013;
    };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      XML element name.
     */
    GetClientAccessTokenRequest.prototype.GetResponseMessageXmlElementName = function () {
        return XmlElementNames.GetClientAccessTokenResponseMessage;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    GetClientAccessTokenRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.GetClientAccessTokenResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetClientAccessTokenRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.GetClientAccessToken;
    };
    /**
     * @internal Validate request.
     */
    GetClientAccessTokenRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        if (this.TokenRequests == null || this.TokenRequests.length == 0) {
            throw new ServiceValidationException(Strings.HoldIdParameterIsNotSpecified);
        }
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetClientAccessTokenRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.TokenRequests);
        for (var _a = 0, _b = this.TokenRequests; _a < _b.length; _a++) {
            var tokenRequestInfo = _b[_a];
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.TokenRequest);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Id, tokenRequestInfo.Id);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.TokenType, ClientAccessTokenType[tokenRequestInfo.TokenType]);
            if (!StringHelper.IsNullOrEmpty(tokenRequestInfo.Scope)) {
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.HighlightTermScope, tokenRequestInfo.Scope);
            }
            writer.WriteEndElement();
        }
        writer.WriteEndElement();
    };
    return GetClientAccessTokenRequest;
}(MultiResponseServiceRequest));
exports.GetClientAccessTokenRequest = GetClientAccessTokenRequest;
/**
 * @internal Represents a request to a GetConversationItems operation
 *
 * @sealed
 */
var GetConversationItemsRequest = (function (_super) {
    __extends(GetConversationItemsRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetConversationItemsRequest** class.
     *
     * @param   {ExchangeService}       service   The service.
     * @param   {ServiceErrorHandling}  errorHandlingMode   Indicates how errors should be handled.
     */
    function GetConversationItemsRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        /**
         * @internal Gets or sets the conversations.
         */
        _this.Conversations = null;
        /**
         * Gets or sets the item properties.
         */
        _this.ItemProperties = null;
        /**
         * @internal Gets or sets the folders to ignore.
         */
        _this.FoldersToIgnore = null;
        /**
         * @internal Gets or sets the maximum number of items to return.
         *
         * @Nullable
         */
        _this.MaxItemsToReturn = null;
        /**
         * @internal Gets or sets the conversation sort order.
         *
         * @Nullable
         */
        _this.SortOrder = null;
        /**
         * @internal Gets or sets the mailbox search location to include in the search.
         *
         * @Nullable
         */
        _this.MailboxScope = null;
        return _this;
    }
    /**
     * @internal Creates service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}   			responseIndex   Index of the response.
     * @return  {GetConversationItemsResponse}	    Service response.
     */
    GetConversationItemsRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new GetConversationItemsResponse(this.ItemProperties);
    };
    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of expected response messages.
     */
    GetConversationItemsRequest.prototype.GetExpectedResponseMessageCount = function () {
        return this.Conversations ? this.Conversations.length : 0;
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetConversationItemsRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2013;
    };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      Xml element name.
     */
    GetConversationItemsRequest.prototype.GetResponseMessageXmlElementName = function () {
        return XmlElementNames.GetConversationItemsResponseMessage;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      Xml element name.
     */
    GetConversationItemsRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.GetConversationItemsResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      Xml element name.
     */
    GetConversationItemsRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.GetConversationItems;
    };
    /**
     * @internal Validate the request.
     */
    GetConversationItemsRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        // SearchScope is only valid for Exchange2013 or higher
        //
        if (this.MailboxScope &&
            this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
            throw new ServiceVersionException(StringHelper.Format(Strings.ParameterIncompatibleWithRequestVersion, "MailboxScope", ExchangeVersion[ExchangeVersion.Exchange2013]));
        }
    };
    /**
     * @internal Writes XML attributes.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetConversationItemsRequest.prototype.WriteAttributesToXml = function (writer) {
        _super.prototype.WriteAttributesToXml.call(this, writer);
    };
    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetConversationItemsRequest.prototype.WriteElementsToXml = function (writer) {
        this.ItemProperties.WriteToXml(writer, ServiceObjectType.Item);
        //this.FoldersToIgnore.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.FoldersToIgnore);
        this.FoldersToIgnore.WriteToXml(writer, XmlElementNames.FoldersToIgnore, XmlNamespace.Messages); //info: temp workaround github #52 
        if (this.MaxItemsToReturn) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.MaxItemsToReturn, this.MaxItemsToReturn);
        }
        if (this.SortOrder) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.SortOrder, ConversationSortOrder[this.SortOrder]);
        }
        if (this.MailboxScope) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.MailboxScope, MailboxSearchLocation[this.MailboxScope]);
        }
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.Conversations);
        this.Conversations.forEach(function (conversation) { return conversation.WriteToXml(writer, XmlElementNames.Conversation); });
        writer.WriteEndElement();
    };
    return GetConversationItemsRequest;
}(MultiResponseServiceRequest));
exports.GetConversationItemsRequest = GetConversationItemsRequest;
/**
 * @internal GetEvents request
 */
var GetEventsRequest = (function (_super) {
    __extends(GetEventsRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetEventsRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function GetEventsRequest(service) {
        var _this = _super.call(this, service, ServiceErrorHandling.ThrowOnError) || this;
        _this.subscriptionId = null;
        _this.watermark = null;
        return _this;
    }
    Object.defineProperty(GetEventsRequest.prototype, "SubscriptionId", {
        /**
         * Gets or sets the subscription id.
         *
         * @value	The subscription id.
         */
        get: function () {
            return this.subscriptionId;
        },
        set: function (value) {
            this.subscriptionId = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetEventsRequest.prototype, "Watermark", {
        /**
         * Gets or sets the watermark.
         *
         * @value	The watermark.
         */
        get: function () {
            return this.watermark;
        },
        set: function (value) {
            this.watermark = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}   			responseIndex   Index of the response.
     * @return  {GetEventsResponse}		Service response.
     */
    GetEventsRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new GetEventsResponse();
    };
    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of expected response messages.
     */
    GetEventsRequest.prototype.GetExpectedResponseMessageCount = function () {
        return 1;
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetEventsRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      XML element name,
     */
    GetEventsRequest.prototype.GetResponseMessageXmlElementName = function () {
        return XmlElementNames.GetEventsResponseMessage;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    GetEventsRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.GetEventsResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetEventsRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.GetEvents;
    };
    /**
     * @internal Validate request.
     */
    GetEventsRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateNonBlankStringParam(this.SubscriptionId, "SubscriptionId");
        EwsUtilities.ValidateNonBlankStringParam(this.Watermark, "Watermark");
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetEventsRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.SubscriptionId, this.SubscriptionId);
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.Watermark, this.Watermark);
    };
    return GetEventsRequest;
}(MultiResponseServiceRequest));
exports.GetEventsRequest = GetEventsRequest;
/**
 * @internal Represents a GetServerTimeZones request.
 */
var GetServerTimeZonesRequest = (function (_super) {
    __extends(GetServerTimeZonesRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetServerTimeZonesRequest** class.
     *
     * @param   {service}   service   The service.
     */
    function GetServerTimeZonesRequest(service) {
        return _super.call(this, service, ServiceErrorHandling.ThrowOnError) || this;
    }
    Object.defineProperty(GetServerTimeZonesRequest.prototype, "Ids", {
        /**
         * @internal Gets or sets the ids of the time zones that should be returned by the server.
         */
        get: function () {
            return this.ids;
        },
        set: function (value) {
            this.ids = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}   			responseIndex   Index of the response.
     * @return  {SyncFolderItemsResponse}		Response object.
     */
    GetServerTimeZonesRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new GetServerTimeZonesResponse();
    };
    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of items in response.
     */
    GetServerTimeZonesRequest.prototype.GetExpectedResponseMessageCount = function () {
        return 1;
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetServerTimeZonesRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2010;
    };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      XML element name.
     */
    GetServerTimeZonesRequest.prototype.GetResponseMessageXmlElementName = function () {
        return XmlElementNames.GetServerTimeZonesResponseMessage;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    GetServerTimeZonesRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.GetServerTimeZonesResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    GetServerTimeZonesRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.GetServerTimeZones;
    };
    /**
     * @internal Validate request.
     */
    GetServerTimeZonesRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        if (this.ids != null) {
            EwsUtilities.ValidateParamCollection(this.ids, "Ids");
        }
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetServerTimeZonesRequest.prototype.WriteElementsToXml = function (writer) {
        if (this.Ids != null) {
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.Ids);
            for (var _a = 0, _b = this.ids; _a < _b.length; _a++) {
                var id = _b[_a];
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Id, id);
            }
            writer.WriteEndElement(); // Ids
        }
    };
    return GetServerTimeZonesRequest;
}(MultiResponseServiceRequest));
exports.GetServerTimeZonesRequest = GetServerTimeZonesRequest;
/**
 * @internal Represents a GetUserConfiguration request.
 */
var GetUserConfigurationRequest = (function (_super) {
    __extends(GetUserConfigurationRequest, _super);
    /**
     * @internal Initializes a new instance of the **GetUserConfigurationRequest** class.
     *
     * @param   {ExchangeService}       service   The service.
     */
    function GetUserConfigurationRequest(service) {
        var _this = _super.call(this, service, ServiceErrorHandling.ThrowOnError) || this;
        _this.name = null;
        _this.parentFolderId = null;
        _this.properties = UserConfigurationProperties.Id;
        _this.userConfiguration = null;
        return _this;
    }
    Object.defineProperty(GetUserConfigurationRequest.prototype, "Name", {
        /**
         * @internal Gets or sets the name.
         *
         * @value   The name.
         */
        get: function () {
            return this.name;
        },
        set: function (value) {
            this.name = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetUserConfigurationRequest.prototype, "ParentFolderId", {
        /**
         * @internal Gets or sets the parent folder Id.
         *
         * @value   The parent folder Id.
         */
        get: function () {
            return this.parentFolderId;
        },
        set: function (value) {
            this.parentFolderId = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetUserConfigurationRequest.prototype, "UserConfiguration", {
        /**
         * @internal Gets or sets the user configuration.
         *
         * @value   The userConfiguration.
         */
        get: function () {
            return this.userConfiguration;
        },
        set: function (value) {
            this.userConfiguration = value;
            this.name = this.userConfiguration.Name;
            this.parentFolderId = this.userConfiguration.ParentFolderId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetUserConfigurationRequest.prototype, "Properties", {
        /**
         * @internal Gets or sets the properties.
         *
         * @value   The properties.
         */
        get: function () {
            return this.properties;
        },
        set: function (value) {
            this.properties = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}   			responseIndex   Index of the response.
     * @return  {GetUserConfigurationResponse}	    Service response.
     */
    GetUserConfigurationRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        // In the case of UserConfiguration.Load(), this.userConfiguration is set.
        if (this.userConfiguration == null) {
            this.userConfiguration = new UserConfiguration(service, this.properties);
            this.userConfiguration.Name = this.name;
            this.userConfiguration.ParentFolderId = this.parentFolderId;
        }
        return new GetUserConfigurationResponse(this.userConfiguration);
    };
    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of expected response messages.
     */
    GetUserConfigurationRequest.prototype.GetExpectedResponseMessageCount = function () {
        return 1;
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    GetUserConfigurationRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2010;
    };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      Xml element name.
     */
    GetUserConfigurationRequest.prototype.GetResponseMessageXmlElementName = function () {
        return XmlElementNames.GetUserConfigurationResponseMessage;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      Xml element name.
     */
    GetUserConfigurationRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.GetUserConfigurationResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      Xml element name.
     */
    GetUserConfigurationRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.GetUserConfiguration;
    };
    /**
     * @internal Validate the request.
     */
    GetUserConfigurationRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParam(this.name, "name");
        EwsUtilities.ValidateParam(this.parentFolderId, "parentFolderId");
        this.ParentFolderId.Validate(this.Service.RequestedServerVersion);
    };
    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    GetUserConfigurationRequest.prototype.WriteElementsToXml = function (writer) {
        // Write UserConfiguationName element
        UserConfiguration.WriteUserConfigurationNameToXml(writer, XmlNamespace.Messages, this.name, this.parentFolderId);
        // Write UserConfigurationProperties element
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.UserConfigurationProperties, this.properties === UserConfigurationProperties.All ? UserConfigurationProperties[this.properties] : EnumHelper.ToString(UserConfigurationProperties, this.properties).split(GetUserConfigurationRequest.EnumDelimiter).join(""));
        //.replace(GetUserConfigurationRequest.EnumDelimiter, " ")); //info: replace only replaces first occurance
    };
    GetUserConfigurationRequest.EnumDelimiter = ",";
    return GetUserConfigurationRequest;
}(MultiResponseServiceRequest));
exports.GetUserConfigurationRequest = GetUserConfigurationRequest;
/** @internal */
var MarkAllItemsAsReadRequest = (function (_super) {
    __extends(MarkAllItemsAsReadRequest, _super);
    function MarkAllItemsAsReadRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        _this.folderIds = new FolderIdWrapperList();
        _this.ReadFlag = false;
        _this.SuppressReadReceipts = false;
        return _this;
    }
    Object.defineProperty(MarkAllItemsAsReadRequest.prototype, "FolderIds", {
        get: function () {
            return this.folderIds;
        },
        enumerable: true,
        configurable: true
    });
    MarkAllItemsAsReadRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new ServiceResponse(); };
    MarkAllItemsAsReadRequest.prototype.GetExpectedResponseMessageCount = function () { return this.FolderIds.Count; };
    MarkAllItemsAsReadRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2013; };
    MarkAllItemsAsReadRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.MarkAllItemsAsReadResponseMessage; };
    MarkAllItemsAsReadRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.MarkAllItemsAsReadResponse; };
    MarkAllItemsAsReadRequest.prototype.GetXmlElementName = function () { return XmlElementNames.MarkAllItemsAsRead; };
    MarkAllItemsAsReadRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        //EwsUtilities.ValidateParam(this.FolderIds, "FolderIds");
        this.FolderIds.Validate(this.Service.RequestedServerVersion);
    };
    /**@internal */
    MarkAllItemsAsReadRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.ReadFlag, this.ReadFlag);
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.SuppressReadReceipts, this.SuppressReadReceipts);
        this.FolderIds.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.FolderIds);
    };
    return MarkAllItemsAsReadRequest;
}(MultiResponseServiceRequest));
exports.MarkAllItemsAsReadRequest = MarkAllItemsAsReadRequest;
/** @internal */
var MarkAsJunkRequest = (function (_super) {
    __extends(MarkAsJunkRequest, _super);
    function MarkAsJunkRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        _this.itemIds = new ItemIdWrapperList();
        _this.IsJunk = false;
        _this.MoveItem = false;
        return _this;
    }
    Object.defineProperty(MarkAsJunkRequest.prototype, "ItemIds", {
        get: function () {
            return this.itemIds;
        },
        enumerable: true,
        configurable: true
    });
    MarkAsJunkRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new MarkAsJunkResponse(); };
    MarkAsJunkRequest.prototype.GetExpectedResponseMessageCount = function () { return this.itemIds.Count; };
    MarkAsJunkRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2013; };
    MarkAsJunkRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.MarkAsJunkResponseMessage; };
    MarkAsJunkRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.MarkAsJunkResponse; };
    MarkAsJunkRequest.prototype.GetXmlElementName = function () { return XmlElementNames.MarkAsJunk; };
    MarkAsJunkRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        //EwsUtilities.ValidateParam(this.ItemIds, "ItemIds");
    };
    /**@internal */
    MarkAsJunkRequest.prototype.WriteAttributesToXml = function (writer) {
        writer.WriteAttributeValue(XmlAttributeNames.IsJunk, this.IsJunk);
        writer.WriteAttributeValue(XmlAttributeNames.MoveItem, this.MoveItem);
    };
    /**@internal */
    MarkAsJunkRequest.prototype.WriteElementsToXml = function (writer) { this.itemIds.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.ItemIds); };
    return MarkAsJunkRequest;
}(MultiResponseServiceRequest));
exports.MarkAsJunkRequest = MarkAsJunkRequest;
/** @internal */
var ResolveNamesRequest = (function (_super) {
    __extends(ResolveNamesRequest, _super);
    function ResolveNamesRequest(service) {
        var _this = _super.call(this, service, ServiceErrorHandling.ThrowOnError) || this;
        _this.nameToResolve = null;
        _this.returnFullContactData = false;
        _this.searchLocation = ResolveNameSearchLocation.DirectoryOnly;
        _this.contactDataPropertySet = null;
        _this.parentFolderIds = new FolderIdWrapperList();
        return _this;
    }
    Object.defineProperty(ResolveNamesRequest.prototype, "NameToResolve", {
        get: function () {
            return this.nameToResolve;
        },
        set: function (value) {
            this.nameToResolve = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResolveNamesRequest.prototype, "ReturnFullContactData", {
        get: function () {
            return this.returnFullContactData;
        },
        set: function (value) {
            this.returnFullContactData = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResolveNamesRequest.prototype, "SearchLocation", {
        get: function () {
            return this.searchLocation;
        },
        set: function (value) {
            this.searchLocation = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResolveNamesRequest.prototype, "ContactDataPropertySet", {
        get: function () {
            return this.contactDataPropertySet;
        },
        set: function (value) {
            this.contactDataPropertySet = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResolveNamesRequest.prototype, "ParentFolderIds", {
        get: function () {
            return this.parentFolderIds;
        },
        enumerable: true,
        configurable: true
    });
    ResolveNamesRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new ResolveNamesResponse(service); };
    ResolveNamesRequest.prototype.GetExpectedResponseMessageCount = function () { return 1; };
    ResolveNamesRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    ResolveNamesRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.ResolveNamesResponseMessage; };
    ResolveNamesRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.ResolveNamesResponse; };
    ResolveNamesRequest.prototype.GetXmlElementName = function () { return XmlElementNames.ResolveNames; };
    ResolveNamesRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        //EwsUtilities.ValidateNonBlankStringParam(this.NameToResolve, "NameToResolve");
    };
    /**@internal */
    ResolveNamesRequest.prototype.WriteAttributesToXml = function (writer) {
        writer.WriteAttributeValue(XmlAttributeNames.ReturnFullContactData, this.ReturnFullContactData);
        var searchScope = { outValue: null };
        ResolveNamesRequest.searchScopeMap.Member.tryGetValue(this.SearchLocation, searchScope);
        EwsLogging.Assert(!StringHelper.IsNullOrEmpty(searchScope.outValue), "ResolveNameRequest.WriteAttributesToXml", "The specified search location cannot be mapped to an EWS search scope.");
        var propertySet = { outValue: null };
        if (this.contactDataPropertySet != null) {
            PropertySet.DefaultPropertySetMap.Member.tryGetValue(this.contactDataPropertySet.BasePropertySet, propertySet);
        }
        if (!this.Service.Exchange2007CompatibilityMode) {
            writer.WriteAttributeValue(XmlAttributeNames.SearchScope, searchScope.outValue);
        }
        if (!StringHelper.IsNullOrEmpty(propertySet.outValue)) {
            writer.WriteAttributeValue(XmlAttributeNames.ContactDataShape, propertySet.outValue);
        }
    };
    /**@internal */
    ResolveNamesRequest.prototype.WriteElementsToXml = function (writer) {
        this.ParentFolderIds.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.ParentFolderIds);
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.UnresolvedEntry, this.NameToResolve);
    };
    ResolveNamesRequest.searchScopeMap = new LazyMember(function () {
        var map = new Dictionary(function (rnsl) { return ResolveNameSearchLocation[rnsl]; });
        map.Add(ResolveNameSearchLocation.DirectoryOnly, "ActiveDirectory");
        map.Add(ResolveNameSearchLocation.DirectoryThenContacts, "ActiveDirectoryContacts");
        map.Add(ResolveNameSearchLocation.ContactsOnly, "Contacts");
        map.Add(ResolveNameSearchLocation.ContactsThenDirectory, "ContactsActiveDirectory");
        return map;
    });
    return ResolveNamesRequest;
}(MultiResponseServiceRequest));
exports.ResolveNamesRequest = ResolveNamesRequest;
/**
 * @internal Represents a SearchMailboxesRequest request.
 *
 * @sealed
 */
var SearchMailboxesRequest = (function (_super) {
    __extends(SearchMailboxesRequest, _super);
    /**
     * @internal Initializes a new instance of the **SearchMailboxesRequest** class.
     *
     * @param   {ExchangeService}       service   The service.
     * @param   {ServiceErrorHandling}  errorHandlingMode   Indicates how errors should be handled.
     */
    function SearchMailboxesRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        _this.searchQueries = [];
        _this.searchResultType = SearchResultType.PreviewOnly;
        _this.sortOrder = SortDirection.Ascending;
        _this.sortByProperty = null;
        _this.performDeduplication = false;
        _this.pageSize = 0;
        _this.pageItemReference = null;
        _this.pageDirection = SearchPageDirection.Next;
        _this.previewItemResponseShape = null;
        /**
         * Query language
         */
        _this.Language = null;
        /**
         * Gets or sets the server version.
         * @interface IDiscoveryVersionable
         */
        _this.ServerVersion = 0;
        return _this;
    }
    Object.defineProperty(SearchMailboxesRequest.prototype, "SearchQueries", {
        /**
         * Collection of query + mailboxes
         */
        get: function () {
            return this.searchQueries;
        },
        set: function (value) {
            this.searchQueries = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchMailboxesRequest.prototype, "ResultType", {
        /**
         * Search result type
         */
        get: function () {
            return this.searchResultType;
        },
        set: function (value) {
            this.searchResultType = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchMailboxesRequest.prototype, "PreviewItemResponseShape", {
        /**
         * Preview item response shape
         */
        get: function () {
            return this.previewItemResponseShape;
        },
        set: function (value) {
            this.previewItemResponseShape = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchMailboxesRequest.prototype, "SortOrder", {
        /**
         * Sort order
         */
        get: function () {
            return this.sortOrder;
        },
        set: function (value) {
            this.sortOrder = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchMailboxesRequest.prototype, "SortByProperty", {
        /**
         * Sort by property name
         */
        get: function () {
            return this.sortByProperty;
        },
        set: function (value) {
            this.sortByProperty = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchMailboxesRequest.prototype, "PerformDeduplication", {
        /**
         * Perform deduplication or not
         */
        get: function () {
            return this.performDeduplication;
        },
        set: function (value) {
            this.performDeduplication = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchMailboxesRequest.prototype, "PageSize", {
        /**
         * Page size
         */
        get: function () {
            return this.pageSize;
        },
        set: function (value) {
            this.pageSize = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchMailboxesRequest.prototype, "PageItemReference", {
        /**
         * Page item reference
         */
        get: function () {
            return this.pageItemReference;
        },
        set: function (value) {
            this.pageItemReference = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchMailboxesRequest.prototype, "PageDirection", {
        /**
         * Page direction
         */
        get: function () {
            return this.pageDirection;
        },
        set: function (value) {
            this.pageDirection = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}   			responseIndex   Index of the response.
     * @return  {SearchMailboxesResponse}	Service response.
     */
    SearchMailboxesRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new SearchMailboxesResponse();
    };
    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of expected response messages.
     */
    SearchMailboxesRequest.prototype.GetExpectedResponseMessageCount = function () {
        return 1;
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    SearchMailboxesRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2013;
    };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      Xml element name.
     */
    SearchMailboxesRequest.prototype.GetResponseMessageXmlElementName = function () {
        return XmlElementNames.SearchMailboxesResponseMessage;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      Xml element name.
     */
    SearchMailboxesRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.SearchMailboxesResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      Xml element name.
     */
    SearchMailboxesRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.SearchMailboxes;
    };
    /**
     * @internal Parses the response.
     * See O15:324151 (OfficeDev bug/issue not visible to external world) on why we need to override ParseResponse here instead of calling the one in MultiResponseServiceRequest.cs
     *
     * @param   {any}   jsonBody   The js object response body.
     * @return  {any}              Response object.
     */
    SearchMailboxesRequest.prototype.ParseResponse = function (jsonBody) {
        var serviceResponses = new ServiceResponseCollection();
        var jsResponseMessages = EwsServiceJsonReader.ReadAsArray(jsonBody[XmlElementNames.ResponseMessages], this.GetResponseMessageXmlElementName());
        for (var _a = 0, jsResponseMessages_1 = jsResponseMessages; _a < jsResponseMessages_1.length; _a++) {
            var jsResponseObject = jsResponseMessages_1[_a];
            var response = new SearchMailboxesResponse();
            response.LoadFromXmlJsObject(jsResponseObject, this.Service);
            serviceResponses.Add(response);
        }
        return serviceResponses;
    };
    /**
     * @internal Validate the request.
     */
    SearchMailboxesRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        if (this.SearchQueries == null || this.SearchQueries.length == 0) {
            throw new ServiceValidationException(Strings.MailboxQueriesParameterIsNotSpecified);
        }
        for (var _a = 0, _b = this.SearchQueries; _a < _b.length; _a++) {
            var searchQuery = _b[_a];
            if (searchQuery.MailboxSearchScopes == null || searchQuery.MailboxSearchScopes.length == 0) {
                throw new ServiceValidationException(Strings.MailboxQueriesParameterIsNotSpecified);
            }
            for (var _c = 0, _d = searchQuery.MailboxSearchScopes; _c < _d.length; _c++) {
                var searchScope = _d[_c];
                if (searchScope.ExtendedAttributes != null && searchScope.ExtendedAttributes.length > 0 && !DiscoverySchemaChanges.SearchMailboxesExtendedData.IsCompatible(this)) {
                    throw new ServiceVersionException(StringHelper.Format(Strings.ClassIncompatibleWithRequestVersion, "ExtendedAttribute", //typeof (ExtendedAttribute).Name,
                    DiscoverySchemaChanges.SearchMailboxesExtendedData.MinimumServerVersion));
                }
                if (searchScope.SearchScopeType != MailboxSearchScopeType.LegacyExchangeDN && (!DiscoverySchemaChanges.SearchMailboxesExtendedData.IsCompatible(this) || !DiscoverySchemaChanges.SearchMailboxesAdditionalSearchScopes.IsCompatible(this))) {
                    throw new ServiceVersionException(StringHelper.Format(Strings.EnumValueIncompatibleWithRequestVersion, MailboxSearchScopeType[searchScope.SearchScopeType], "MailboxSearchScopeType", //typeof (MailboxSearchScopeType).Name,
                    DiscoverySchemaChanges.SearchMailboxesAdditionalSearchScopes.MinimumServerVersion));
                }
            }
        }
        if (!StringHelper.IsNullOrEmpty(this.SortByProperty)) {
            var prop = null;
            try {
                prop = ServiceObjectSchema.FindPropertyDefinition(this.SortByProperty);
            }
            catch (ex) {
            }
            if (prop == null) {
                throw new ServiceValidationException(StringHelper.Format(Strings.InvalidSortByPropertyForMailboxSearch, this.SortByProperty));
            }
        }
    };
    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    SearchMailboxesRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.SearchQueries);
        for (var _a = 0, _b = this.SearchQueries; _a < _b.length; _a++) {
            var mailboxQuery = _b[_a];
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.MailboxQuery);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Query, mailboxQuery.Query);
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.MailboxSearchScopes);
            for (var _c = 0, _d = mailboxQuery.MailboxSearchScopes; _c < _d.length; _c++) {
                var mailboxSearchScope = _d[_c];
                // The checks here silently downgrade the schema based on compatability checks, to recieve errors use the validate method
                if (mailboxSearchScope.SearchScopeType == MailboxSearchScopeType.LegacyExchangeDN || DiscoverySchemaChanges.SearchMailboxesAdditionalSearchScopes.IsCompatible(this)) {
                    writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.MailboxSearchScope);
                    writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Mailbox, mailboxSearchScope.Mailbox);
                    writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.SearchScope, MailboxSearchLocation[mailboxSearchScope.SearchScope]);
                    if (DiscoverySchemaChanges.SearchMailboxesExtendedData.IsCompatible(this)) {
                        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.ExtendedAttributes);
                        if (mailboxSearchScope.SearchScopeType != MailboxSearchScopeType.LegacyExchangeDN) {
                            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.ExtendedAttribute);
                            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ExtendedAttributeName, XmlElementNames.SearchScopeType);
                            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ExtendedAttributeValue, MailboxSearchScopeType[mailboxSearchScope.SearchScopeType]);
                            writer.WriteEndElement();
                        }
                        if (mailboxSearchScope.ExtendedAttributes != null && mailboxSearchScope.ExtendedAttributes.length > 0) {
                            for (var _e = 0, _f = mailboxSearchScope.ExtendedAttributes; _e < _f.length; _e++) {
                                var attribute = _f[_e];
                                writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.ExtendedAttribute);
                                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ExtendedAttributeName, attribute.Name);
                                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ExtendedAttributeValue, attribute.Value);
                                writer.WriteEndElement();
                            }
                        }
                        writer.WriteEndElement(); // ExtendedData
                    }
                    writer.WriteEndElement(); // MailboxSearchScope
                }
            }
            writer.WriteEndElement(); // MailboxSearchScopes
            writer.WriteEndElement(); // MailboxQuery
        }
        writer.WriteEndElement(); // SearchQueries
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.ResultType, SearchResultType[this.ResultType]);
        if (this.PreviewItemResponseShape != null) {
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.PreviewItemResponseShape);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.BaseShape, PreviewItemBaseShape[this.PreviewItemResponseShape.BaseShape]);
            if (this.PreviewItemResponseShape.AdditionalProperties != null && this.PreviewItemResponseShape.AdditionalProperties.length > 0) {
                writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.AdditionalProperties);
                for (var _g = 0, _h = this.PreviewItemResponseShape.AdditionalProperties; _g < _h.length; _g++) {
                    var additionalProperty = _h[_g];
                    additionalProperty.WriteToXml(writer);
                }
                writer.WriteEndElement(); // AdditionalProperties
            }
            writer.WriteEndElement(); // PreviewItemResponseShape
        }
        if (!StringHelper.IsNullOrEmpty(this.SortByProperty)) {
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.SortBy);
            writer.WriteAttributeValue(XmlElementNames.Order, SortDirection[this.SortOrder]);
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.FieldURI);
            writer.WriteAttributeValue(XmlElementNames.FieldURI, this.sortByProperty);
            writer.WriteEndElement(); // FieldURI
            writer.WriteEndElement(); // SortBy
        }
        // Language
        if (!StringHelper.IsNullOrEmpty(this.Language)) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.Language, this.Language);
        }
        // Dedupe
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.Deduplication, this.performDeduplication);
        if (this.PageSize > 0) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.PageSize, this.PageSize);
        }
        if (!StringHelper.IsNullOrEmpty(this.PageItemReference)) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.PageItemReference, this.PageItemReference);
        }
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.PageDirection, SearchPageDirection[this.PageDirection]);
    };
    return SearchMailboxesRequest;
}(MultiResponseServiceRequest));
exports.SearchMailboxesRequest = SearchMailboxesRequest;
/** @internal */
var SendItemRequest = (function (_super) {
    __extends(SendItemRequest, _super);
    function SendItemRequest(service, errorHandlingModeServiceErrorHandling) {
        var _this = _super.call(this, service, errorHandlingModeServiceErrorHandling) || this;
        _this.items = [];
        _this.savedCopyDestinationFolderId = null;
        return _this;
    }
    Object.defineProperty(SendItemRequest.prototype, "Items", {
        get: function () {
            return this.items;
        },
        set: function (value) {
            this.items = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SendItemRequest.prototype, "SavedCopyDestinationFolderId", {
        get: function () {
            return this.savedCopyDestinationFolderId;
        },
        set: function (value) {
            this.savedCopyDestinationFolderId = value;
        },
        enumerable: true,
        configurable: true
    });
    SendItemRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new ServiceResponse(); };
    SendItemRequest.prototype.GetExpectedResponseMessageCount = function () { return this.items.length; };
    SendItemRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    SendItemRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.SendItemResponseMessage; };
    SendItemRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.SendItemResponse; };
    SendItemRequest.prototype.GetXmlElementName = function () { return XmlElementNames.SendItem; };
    SendItemRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        //EwsUtilities.ValidateParam(this.Items, "Items");
        if (this.SavedCopyDestinationFolderId != null) {
            this.SavedCopyDestinationFolderId.Validate(this.Service.RequestedServerVersion);
        }
    };
    /**@internal */
    SendItemRequest.prototype.WriteAttributesToXml = function (writer) {
        _super.prototype.WriteAttributesToXml.call(this, writer);
        writer.WriteAttributeValue(XmlAttributeNames.SaveItemToFolder, this.SavedCopyDestinationFolderId != null);
    };
    /**@internal */
    SendItemRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.ItemIds);
        for (var _a = 0, _b = this.items; _a < _b.length; _a++) {
            var item = _b[_a];
            item.Id.WriteToXml(writer); //, XmlElementNames.ItemId);
        }
        writer.WriteEndElement(); // ItemIds
        if (this.SavedCopyDestinationFolderId != null) {
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.SavedItemFolderId);
            this.SavedCopyDestinationFolderId.WriteToXml(writer);
            writer.WriteEndElement();
        }
    };
    return SendItemRequest;
}(MultiResponseServiceRequest));
exports.SendItemRequest = SendItemRequest;
/**
 * ## @internal *Not Implemented*   Server to server call - not needed
 */
var SetClientExtensionRequest = (function (_super) {
    __extends(SetClientExtensionRequest, _super);
    function SetClientExtensionRequest() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SetClientExtensionRequest.prototype.CreateServiceResponse = function (service, responseIndex) { throw new Error("SetClientExtensionRequest.ts - CreateServiceResponse : Not implemented."); };
    SetClientExtensionRequest.prototype.GetExpectedResponseMessageCount = function () { throw new Error("SetClientExtensionRequest.ts - GetExpectedResponseMessageCount : Not implemented."); };
    SetClientExtensionRequest.prototype.GetMinimumRequiredServerVersion = function () { throw new Error("SetClientExtensionRequest.ts - GetMinimumRequiredServerVersion : Not implemented."); };
    SetClientExtensionRequest.prototype.GetResponseMessageXmlElementName = function () { throw new Error("SetClientExtensionRequest.ts - GetResponseMessageXmlElementName : Not implemented."); };
    SetClientExtensionRequest.prototype.GetResponseXmlElementName = function () { throw new Error("SetClientExtensionRequest.ts - GetResponseXmlElementName : Not implemented."); };
    SetClientExtensionRequest.prototype.GetXmlElementName = function () { throw new Error("SetClientExtensionRequest.ts - GetXmlElementName : Not implemented."); };
    SetClientExtensionRequest.prototype.Validate = function () { throw new Error("SetClientExtensionRequest.ts - Validate : Not implemented."); };
    /**@internal */
    SetClientExtensionRequest.prototype.WriteElementsToXml = function (writer) { throw new Error("SetClientExtensionRequest.ts - WriteElementsToXml : Not implemented."); };
    return SetClientExtensionRequest;
}(MultiResponseServiceRequest));
exports.SetClientExtensionRequest = SetClientExtensionRequest;
/**
 * @internal Represents a SyncFolderHierarchy request.
 */
var SyncFolderHierarchyRequest = (function (_super) {
    __extends(SyncFolderHierarchyRequest, _super);
    /**
     * @internal Initializes a new instance of the **SyncFolderItemsRequest** class.
     *
     * @param   {ExchangeService}   	service             The service.
     */
    function SyncFolderHierarchyRequest(service) {
        var _this = _super.call(this, service, ServiceErrorHandling.ThrowOnError) || this;
        _this.propertySet = null;
        _this.syncFolderId = null;
        _this.syncState = null;
        return _this;
    }
    Object.defineProperty(SyncFolderHierarchyRequest.prototype, "PropertySet", {
        /**
         * Gets or sets the property set.
         *
         * @value	The property set
         */
        get: function () {
            return this.propertySet;
        },
        set: function (value) {
            this.propertySet = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SyncFolderHierarchyRequest.prototype, "SyncFolderId", {
        /**
         * Gets or sets the sync folder id.
         *
         * @value	The sync folder id.
         */
        get: function () {
            return this.syncFolderId;
        },
        set: function (value) {
            this.syncFolderId = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SyncFolderHierarchyRequest.prototype, "SyncState", {
        /**
         * Gets or sets the state of the sync.
         *
         * @value	The state of the sync.
         */
        get: function () {
            return this.syncState;
        },
        set: function (value) {
            this.syncState = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}   			responseIndex   Index of the response.
     * @return  {SyncFolderItemsResponse}		Response object.
     */
    SyncFolderHierarchyRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new SyncFolderHierarchyResponse(this.PropertySet);
    };
    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of items in response.
     */
    SyncFolderHierarchyRequest.prototype.GetExpectedResponseMessageCount = function () {
        return 1;
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    SyncFolderHierarchyRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      XML element name.
     */
    SyncFolderHierarchyRequest.prototype.GetResponseMessageXmlElementName = function () {
        return XmlElementNames.SyncFolderHierarchyResponseMessage;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    SyncFolderHierarchyRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.SyncFolderHierarchyResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    SyncFolderHierarchyRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.SyncFolderHierarchy;
    };
    /**
     * @internal Validate request.
     */
    SyncFolderHierarchyRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParam(this.PropertySet, "PropertySet");
        if (this.SyncFolderId != null) {
            this.SyncFolderId.Validate(this.Service.RequestedServerVersion);
        }
        this.PropertySet.ValidateForRequest(this, false /*summaryPropertiesOnly*/);
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    SyncFolderHierarchyRequest.prototype.WriteElementsToXml = function (writer) {
        this.PropertySet.WriteToXml(writer, ServiceObjectType.Folder);
        if (this.SyncFolderId != null) {
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.SyncFolderId);
            this.SyncFolderId.WriteToXml(writer);
            writer.WriteEndElement();
        }
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.SyncState, this.SyncState);
    };
    return SyncFolderHierarchyRequest;
}(MultiResponseServiceRequest));
exports.SyncFolderHierarchyRequest = SyncFolderHierarchyRequest;
/**
 * @internal Represents a SyncFolderItems request.
 */
var SyncFolderItemsRequest = (function (_super) {
    __extends(SyncFolderItemsRequest, _super);
    /**
     * @internal Initializes a new instance of the **SyncFolderItemsRequest** class.
     *
     * @param   {ExchangeService}   	service             The service.
     */
    function SyncFolderItemsRequest(service) {
        var _this = _super.call(this, service, ServiceErrorHandling.ThrowOnError) || this;
        _this.propertySet = null;
        _this.syncFolderId = null;
        _this.syncScope = SyncFolderItemsScope.NormalItems;
        _this.syncState = null;
        _this.ignoredItemIds = new ItemIdWrapperList();
        _this.maxChangesReturned = 100;
        _this.numberOfDays = 0;
        return _this;
    }
    Object.defineProperty(SyncFolderItemsRequest.prototype, "PropertySet", {
        /**
         * Gets or sets the property set.
         *
         * @value	The property set
         */
        get: function () {
            return this.propertySet;
        },
        set: function (value) {
            this.propertySet = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SyncFolderItemsRequest.prototype, "SyncFolderId", {
        /**
         * Gets or sets the sync folder id.
         *
         * @value	The sync folder id.
         */
        get: function () {
            return this.syncFolderId;
        },
        set: function (value) {
            this.syncFolderId = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SyncFolderItemsRequest.prototype, "SyncScope", {
        /**
         * Gets or sets the scope of the sync.
         *
         * @value	The scope of the sync.
         */
        get: function () {
            return this.syncScope;
        },
        set: function (value) {
            this.syncScope = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SyncFolderItemsRequest.prototype, "SyncState", {
        /**
         * Gets or sets the state of the sync.
         *
         * @value	The state of the sync.
         */
        get: function () {
            return this.syncState;
        },
        set: function (value) {
            this.syncState = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SyncFolderItemsRequest.prototype, "IgnoredItemIds", {
        /**
         * Gets the list of ignored item ids.
         *
         * @value	The ignored item ids.
         */
        get: function () {
            return this.ignoredItemIds;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SyncFolderItemsRequest.prototype, "MaxChangesReturned", {
        /**
         * Gets or sets the maximum number of changes returned by SyncFolderItems.
         * Values must be between 1 and 512.
         * Default is 100.
         */
        get: function () {
            return this.maxChangesReturned;
        },
        set: function (value) {
            if (value >= 1 && value <= 512) {
                this.maxChangesReturned = value;
            }
            else {
                throw new ArgumentException(Strings.MaxChangesMustBeBetween1And512);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SyncFolderItemsRequest.prototype, "NumberOfDays", {
        /**
         * Gets or sets the number of days of content returned by SyncFolderItems.
         * Zero means return all content.
         * Default is zero.
         */
        get: function () {
            return this.numberOfDays;
        },
        set: function (value) {
            if (value >= 0) {
                this.numberOfDays = value;
            }
            else {
                throw new ArgumentException(Strings.NumberOfDaysMustBePositive);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}   			responseIndex   Index of the response.
     * @return  {SyncFolderItemsResponse}		Response object.
     */
    SyncFolderItemsRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new SyncFolderItemsResponse(this.PropertySet);
    };
    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of items in response.
     */
    SyncFolderItemsRequest.prototype.GetExpectedResponseMessageCount = function () {
        return 1;
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    SyncFolderItemsRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      XML element name.
     */
    SyncFolderItemsRequest.prototype.GetResponseMessageXmlElementName = function () {
        return XmlElementNames.SyncFolderItemsResponseMessage;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    SyncFolderItemsRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.SyncFolderItemsResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    SyncFolderItemsRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.SyncFolderItems;
    };
    /**
     * @internal Validate request.
     */
    SyncFolderItemsRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParam(this.PropertySet, "PropertySet");
        EwsUtilities.ValidateParam(this.SyncFolderId, "SyncFolderId");
        this.SyncFolderId.Validate(this.Service.RequestedServerVersion);
        // SyncFolderItemsScope enum was introduced with Exchange2010.  Only
        // value NormalItems is valid with previous server versions.
        if (this.Service.RequestedServerVersion < ExchangeVersion.Exchange2010 &&
            this.syncScope != SyncFolderItemsScope.NormalItems) {
            throw new ServiceVersionException(StringHelper.Format(Strings.EnumValueIncompatibleWithRequestVersion, SyncFolderItemsScope[this.syncScope], "SyncFolderItemsScope", ExchangeVersion[ExchangeVersion.Exchange2010]));
        }
        // NumberOfDays was introduced with Exchange 2013.
        if (this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013 &&
            this.NumberOfDays != 0) {
            throw new ServiceVersionException(StringHelper.Format(Strings.ParameterIncompatibleWithRequestVersion, "numberOfDays", ExchangeVersion[ExchangeVersion.Exchange2013]));
        }
        // SyncFolderItems can only handle summary properties
        this.PropertySet.ValidateForRequest(this, true /*summaryPropertiesOnly*/);
    };
    /**
     * @internal Writes the elements to XML writer.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    SyncFolderItemsRequest.prototype.WriteElementsToXml = function (writer) {
        this.PropertySet.WriteToXml(writer, ServiceObjectType.Item);
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.SyncFolderId);
        this.SyncFolderId.WriteToXml(writer);
        writer.WriteEndElement();
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.SyncState, this.SyncState);
        this.IgnoredItemIds.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.Ignore);
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.MaxChangesReturned, this.MaxChangesReturned);
        if (this.Service.RequestedServerVersion >= ExchangeVersion.Exchange2010) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.SyncScope, SyncFolderItemsScope[this.syncScope]);
        }
        if (this.NumberOfDays != 0) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.NumberOfDays, this.numberOfDays);
        }
    };
    return SyncFolderItemsRequest;
}(MultiResponseServiceRequest));
exports.SyncFolderItemsRequest = SyncFolderItemsRequest;
/**
 * @internal Represents an Unsubscribe request.
 */
var UnsubscribeRequest = (function (_super) {
    __extends(UnsubscribeRequest, _super);
    /**
     * @internal Initializes a new instance of the **UnsubscribeRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function UnsubscribeRequest(service) {
        return _super.call(this, service, ServiceErrorHandling.ThrowOnError) || this;
    }
    /**
     * @internal Creates service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}   			responseIndex   Index of the response.
     * @return  {ServiceResponse}	Service response.
     */
    UnsubscribeRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new ServiceResponse(); };
    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of expected response messages.
     */
    UnsubscribeRequest.prototype.GetExpectedResponseMessageCount = function () { return 1; };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    UnsubscribeRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      Xml element name.
     */
    UnsubscribeRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.UnsubscribeResponseMessage; };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      Xml element name.
     */
    UnsubscribeRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.UnsubscribeResponse; };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      Xml element name.
     */
    UnsubscribeRequest.prototype.GetXmlElementName = function () { return XmlElementNames.Unsubscribe; };
    /**
     * @internal Validate the request.
     */
    UnsubscribeRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateNonBlankStringParam(this.SubscriptionId, "SubscriptionId");
    };
    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    UnsubscribeRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.SubscriptionId, this.SubscriptionId);
    };
    return UnsubscribeRequest;
}(MultiResponseServiceRequest));
exports.UnsubscribeRequest = UnsubscribeRequest;
/**
 * @internal Represents an UpdateFolder request.
 *
 * @sealed
*/
var UpdateFolderRequest = (function (_super) {
    __extends(UpdateFolderRequest, _super);
    /**
     * @internal Initializes a new instance of the **UpdateFolderRequest** class.
     *
     * @param   {ExchangeService}       service             The service.
     * @param   {ServiceErrorHandling}  errorHandlingMode   Indicates how errors should be handled.
     */
    function UpdateFolderRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        _this.folders = [];
        return _this;
    }
    Object.defineProperty(UpdateFolderRequest.prototype, "Folders", {
        /**
         * Gets the list of folders.
         *
         * @value   The folders.
         */
        get: function () {
            return this.folders;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   session         The session.
     * @param   {number}            responseIndex   Index of the response.
     * @return  {ServiceResponse}   Service response.
     */
    UpdateFolderRequest.prototype.CreateServiceResponse = function (session, responseIndex) {
        return new UpdateFolderResponse(this.Folders[responseIndex]);
    };
    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of expected response messages.
     */
    UpdateFolderRequest.prototype.GetExpectedResponseMessageCount = function () {
        return this.folders.length;
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    UpdateFolderRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      XML element name,
     */
    UpdateFolderRequest.prototype.GetResponseMessageXmlElementName = function () {
        return XmlElementNames.UpdateFolderResponseMessage;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    UpdateFolderRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.UpdateFolderResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    UpdateFolderRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.UpdateFolder;
    };
    /**
     * @internal Validates the request.
     */
    UpdateFolderRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParamCollection(this.Folders, "Folders");
        for (var _a = 0, _b = this.folders; _a < _b.length; _a++) {
            var folder = _b[_a];
            if ((folder == null) || folder.IsNew) {
                throw new Error(StringHelper.Format(Strings.FolderToUpdateCannotBeNullOrNew, this.folders.indexOf(folder)));
            }
            folder.Validate();
        }
    };
    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    UpdateFolderRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.FolderChanges);
        for (var _a = 0, _b = this.folders; _a < _b.length; _a++) {
            var folder = _b[_a];
            folder.WriteToXmlForUpdate(writer);
        }
        writer.WriteEndElement();
    };
    return UpdateFolderRequest;
}(MultiResponseServiceRequest));
exports.UpdateFolderRequest = UpdateFolderRequest;
/** @internal */
var UpdateItemRequest = (function (_super) {
    __extends(UpdateItemRequest, _super);
    function UpdateItemRequest(service, errorHandlingModeServiceErrorHandling) {
        var _this = _super.call(this, service, errorHandlingModeServiceErrorHandling) || this;
        _this.items = [];
        _this.savedItemsDestinationFolder = null;
        _this.conflictResolutionMode = 0;
        _this.messageDisposition = null;
        _this.sendInvitationsOrCancellationsMode = null;
        _this.SuppressReadReceipts = false;
        return _this;
    }
    Object.defineProperty(UpdateItemRequest.prototype, "EmitTimeZoneHeader", {
        get: function () {
            for (var _a = 0, _b = this.Items; _a < _b.length; _a++) {
                var item = _b[_a];
                if (item.GetIsTimeZoneHeaderRequired(true /* isUpdateOpeartion */)) {
                    return true;
                }
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UpdateItemRequest.prototype, "MessageDisposition", {
        get: function () {
            return this.messageDisposition;
        },
        set: function (value) {
            this.messageDisposition = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UpdateItemRequest.prototype, "ConflictResolutionMode", {
        get: function () {
            return this.conflictResolutionMode;
        },
        set: function (value) {
            this.conflictResolutionMode = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UpdateItemRequest.prototype, "SendInvitationsOrCancellationsMode", {
        get: function () {
            return this.sendInvitationsOrCancellationsMode;
        },
        set: function (value) {
            this.sendInvitationsOrCancellationsMode = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UpdateItemRequest.prototype, "Items", {
        get: function () {
            return this.items;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UpdateItemRequest.prototype, "SavedItemsDestinationFolder", {
        get: function () {
            return this.savedItemsDestinationFolder;
        },
        set: function (value) {
            this.savedItemsDestinationFolder = value;
        },
        enumerable: true,
        configurable: true
    });
    UpdateItemRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new UpdateItemResponse(this.Items[responseIndex]); };
    UpdateItemRequest.prototype.GetExpectedResponseMessageCount = function () { return this.items.length; };
    UpdateItemRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    UpdateItemRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.UpdateItemResponseMessage; };
    UpdateItemRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.UpdateItemResponse; };
    UpdateItemRequest.prototype.GetXmlElementName = function () { return XmlElementNames.UpdateItem; };
    UpdateItemRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        //EwsUtilities.ValidateParamCollection(this.Items, "Items");
        for (var i = 0; i < this.Items.length; i++) {
            if ((this.Items[i] == null) || this.Items[i].IsNew) {
                throw new Error(StringHelper.Format(Strings.ItemToUpdateCannotBeNullOrNew, i)); //ArgumentException
            }
        }
        if (this.SavedItemsDestinationFolder != null) {
            this.SavedItemsDestinationFolder.Validate(this.Service.RequestedServerVersion);
        }
        // Validate each item.
        for (var _a = 0, _b = this.Items; _a < _b.length; _a++) {
            var item = _b[_a];
            item.Validate();
        }
        if (this.SuppressReadReceipts && this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
            throw new ServiceVersionException(StringHelper.Format(Strings.ParameterIncompatibleWithRequestVersion, "SuppressReadReceipts", ExchangeVersion[ExchangeVersion.Exchange2013]));
        }
    };
    /**@internal */
    UpdateItemRequest.prototype.WriteAttributesToXml = function (writer) {
        _super.prototype.WriteAttributesToXml.call(this, writer);
        if (this.MessageDisposition !== null) {
            writer.WriteAttributeValue(XmlAttributeNames.MessageDisposition, MessageDisposition[this.MessageDisposition]);
        }
        if (this.SuppressReadReceipts) {
            writer.WriteAttributeValue(XmlAttributeNames.SuppressReadReceipts, true);
        }
        writer.WriteAttributeValue(XmlAttributeNames.ConflictResolution, ConflictResolutionMode[this.ConflictResolutionMode]);
        if (this.SendInvitationsOrCancellationsMode !== null) {
            writer.WriteAttributeValue(XmlAttributeNames.SendMeetingInvitationsOrCancellations, SendInvitationsOrCancellationsMode[this.SendInvitationsOrCancellationsMode]);
        }
    };
    /**@internal */
    UpdateItemRequest.prototype.WriteElementsToXml = function (writer) {
        if (this.SavedItemsDestinationFolder != null) {
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.SavedItemFolderId);
            this.SavedItemsDestinationFolder.WriteToXml(writer);
            writer.WriteEndElement();
        }
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.ItemChanges);
        for (var _a = 0, _b = this.items; _a < _b.length; _a++) {
            var item = _b[_a];
            item.WriteToXmlForUpdate(writer);
        }
        writer.WriteEndElement();
    };
    return UpdateItemRequest;
}(MultiResponseServiceRequest));
exports.UpdateItemRequest = UpdateItemRequest;
/**
 * @internal Represents a UpdateUserConfiguration request.
 */
var UpdateUserConfigurationRequest = (function (_super) {
    __extends(UpdateUserConfigurationRequest, _super);
    /**
     * @internal Initializes a new instance of the **UpdateUserConfigurationRequest** class.
     *
     * @param   {ExchangeService}       service   The service.
     */
    function UpdateUserConfigurationRequest(service) {
        var _this = _super.call(this, service, ServiceErrorHandling.ThrowOnError) || this;
        _this.userConfiguration = null;
        return _this;
    }
    Object.defineProperty(UpdateUserConfigurationRequest.prototype, "UserConfiguration", {
        /**
         * Gets or sets the user configuration.
         *
         * @value   The userConfiguration.
         */
        get: function () {
            return this.userConfiguration;
        },
        set: function (value) {
            this.userConfiguration = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}   			responseIndex   Index of the response.
     * @return  {ServiceResponse}	Service response.
     */
    UpdateUserConfigurationRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new ServiceResponse();
    };
    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of expected response messages.
     */
    UpdateUserConfigurationRequest.prototype.GetExpectedResponseMessageCount = function () {
        return 1;
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    UpdateUserConfigurationRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2010;
    };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      Xml element name.
     */
    UpdateUserConfigurationRequest.prototype.GetResponseMessageXmlElementName = function () {
        return XmlElementNames.UpdateUserConfigurationResponseMessage;
    };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      Xml element name.
     */
    UpdateUserConfigurationRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.UpdateUserConfigurationResponse;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      Xml element name.
     */
    UpdateUserConfigurationRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.UpdateUserConfiguration;
    };
    /**
     * @internal Validate the request.
     */
    UpdateUserConfigurationRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParam(this.userConfiguration, "userConfiguration");
    };
    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    UpdateUserConfigurationRequest.prototype.WriteElementsToXml = function (writer) {
        // Write UserConfiguation element
        this.userConfiguration.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.UserConfiguration);
    };
    return UpdateUserConfigurationRequest;
}(MultiResponseServiceRequest));
exports.UpdateUserConfigurationRequest = UpdateUserConfigurationRequest;
/** @internal */
var CreateRequest = (function (_super) {
    __extends(CreateRequest, _super);
    function CreateRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        _this.parentFolderId = null;
        _this.objects = []; // null;
        return _this;
    }
    Object.defineProperty(CreateRequest.prototype, "Objects", {
        get: function () {
            return this.objects;
        },
        set: function (value) {
            this.objects = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CreateRequest.prototype, "ParentFolderId", {
        get: function () {
            return this.parentFolderId;
        },
        set: function (value) {
            this.parentFolderId = value;
        },
        enumerable: true,
        configurable: true
    });
    CreateRequest.prototype.AddJsonProperties = function (jsonRequest, service) { throw new Error("CreateRequest.ts - AddJsonProperties : Not implemented."); };
    CreateRequest.prototype.GetExpectedResponseMessageCount = function () { return this.Objects.length; };
    CreateRequest.prototype.GetObjectCollectionXmlElementName = function () { throw new Error("CreateRequest.ts - GetObjectCollectionXmlElementName : abstract - must implement."); };
    CreateRequest.prototype.GetParentFolderXmlElementName = function () { throw new Error("CreateRequest.ts - GetParentFolderXmlElementName : abstract - must implement."); };
    CreateRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        if (this.ParentFolderId != null) {
            this.ParentFolderId.Validate(this.Service.RequestedServerVersion);
        }
    };
    /**@internal */
    CreateRequest.prototype.WriteElementsToXml = function (writer) {
        if (this.ParentFolderId != null) {
            writer.WriteStartElement(XmlNamespace.Messages, this.GetParentFolderXmlElementName());
            this.ParentFolderId.WriteToXml(writer);
            writer.WriteEndElement();
        }
        writer.WriteStartElement(XmlNamespace.Messages, this.GetObjectCollectionXmlElementName());
        for (var _a = 0, _b = this.objects; _a < _b.length; _a++) {
            var obj = _b[_a];
            obj.WriteToXml(writer);
        }
        writer.WriteEndElement();
    };
    return CreateRequest;
}(MultiResponseServiceRequest));
exports.CreateRequest = CreateRequest;
/** @internal */
var CreateFolderRequest = (function (_super) {
    __extends(CreateFolderRequest, _super);
    function CreateFolderRequest(service, errorHandlingMode) {
        return _super.call(this, service, errorHandlingMode) || this;
    }
    Object.defineProperty(CreateFolderRequest.prototype, "Folders", {
        get: function () {
            return this.Objects;
        },
        set: function (value) {
            this.Objects = value;
        },
        enumerable: true,
        configurable: true
    });
    CreateFolderRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        //return new CreateFolderResponse(<Folder>EwsUtilities.GetEnumeratedObjectAt(this.Folders, responseIndex));
        if (this.Folders.length >= responseIndex) {
            throw new Error(Strings.IEnumerableDoesNotContainThatManyObject);
        }
        return new CreateFolderResponse(this.Folders[responseIndex]);
    };
    CreateFolderRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    CreateFolderRequest.prototype.GetObjectCollectionXmlElementName = function () { return XmlElementNames.Folders; };
    CreateFolderRequest.prototype.GetParentFolderXmlElementName = function () { return XmlElementNames.ParentFolderId; };
    CreateFolderRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.CreateFolderResponseMessage; };
    CreateFolderRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.CreateFolderResponse; };
    CreateFolderRequest.prototype.GetXmlElementName = function () { return XmlElementNames.CreateFolder; };
    CreateFolderRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        //EwsUtilities.ValidateParam(this.Folders, "Folders");
        // Validate each folder.
        for (var _a = 0, _b = this.Folders; _a < _b.length; _a++) {
            var folder = _b[_a];
            folder.Validate();
        }
    };
    return CreateFolderRequest;
}(CreateRequest));
exports.CreateFolderRequest = CreateFolderRequest;
/** @internal */
var CreateItemRequestBase = (function (_super) {
    __extends(CreateItemRequestBase, _super);
    function CreateItemRequestBase(service, errorHandlingModeServiceErrorHandling) {
        var _this = _super.call(this, service, errorHandlingModeServiceErrorHandling) || this;
        //private messageDisposition: MessageDisposition; - backing property not needed
        //private sendInvitationsMode: SendInvitationsMode;
        _this.MessageDisposition = null;
        _this.SendInvitationsMode = null;
        return _this;
    }
    Object.defineProperty(CreateItemRequestBase.prototype, "Items", {
        get: function () {
            return this.Objects;
        },
        set: function (value) {
            this.Objects = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CreateItemRequestBase.prototype, "EmitTimeZoneHeader", {
        get: function () {
            for (var _a = 0, _b = this.Items; _a < _b.length; _a++) {
                var serviceObject = _b[_a];
                if (serviceObject.GetIsTimeZoneHeaderRequired(false /* isUpdateOperation */)) {
                    return true;
                }
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    CreateItemRequestBase.prototype.AddJsonProperties = function (jsonRequest, service) { throw new Error("CreateItemRequestBase.ts - AddJsonProperties : Not implemented."); };
    CreateItemRequestBase.prototype.GetObjectCollectionXmlElementName = function () { return XmlElementNames.Items; };
    CreateItemRequestBase.prototype.GetParentFolderXmlElementName = function () { return XmlElementNames.SavedItemFolderId; };
    CreateItemRequestBase.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.CreateItemResponseMessage; };
    CreateItemRequestBase.prototype.GetResponseXmlElementName = function () { return XmlElementNames.CreateItemResponse; };
    CreateItemRequestBase.prototype.GetXmlElementName = function () { return XmlElementNames.CreateItem; };
    CreateItemRequestBase.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        //EwsUtilities.ValidateParam(this.Items, "Items");
    };
    /**@internal */
    CreateItemRequestBase.prototype.WriteAttributesToXml = function (writer) {
        _super.prototype.WriteAttributesToXml.call(this, writer);
        if (this.MessageDisposition !== null) {
            writer.WriteAttributeValue(XmlAttributeNames.MessageDisposition, MessageDisposition[this.MessageDisposition]);
        }
        if (this.SendInvitationsMode !== null) {
            writer.WriteAttributeValue(XmlAttributeNames.SendMeetingInvitations, SendInvitationsMode[this.SendInvitationsMode]);
        }
    };
    return CreateItemRequestBase;
}(CreateRequest));
exports.CreateItemRequestBase = CreateItemRequestBase;
/** @internal */
var CreateItemRequest = (function (_super) {
    __extends(CreateItemRequest, _super);
    function CreateItemRequest(service, errorHandlingModeServiceErrorHandling) {
        return _super.call(this, service, errorHandlingModeServiceErrorHandling) || this;
    }
    CreateItemRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new CreateItemResponse(this.Items[responseIndex]); };
    CreateItemRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    CreateItemRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        // Validate each item.
        for (var _a = 0, _b = this.Items; _a < _b.length; _a++) {
            var item = _b[_a];
            item.Validate();
        }
    };
    return CreateItemRequest;
}(CreateItemRequestBase));
exports.CreateItemRequest = CreateItemRequest;
/** @internal */
var CreateResponseObjectRequest = (function (_super) {
    __extends(CreateResponseObjectRequest, _super);
    function CreateResponseObjectRequest(service, errorHandlingModeServiceErrorHandling) {
        return _super.call(this, service, errorHandlingModeServiceErrorHandling) || this;
    }
    CreateResponseObjectRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new CreateResponseObjectResponse(); };
    CreateResponseObjectRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    return CreateResponseObjectRequest;
}(CreateItemRequestBase));
exports.CreateResponseObjectRequest = CreateResponseObjectRequest;
/** @internal */
var DeleteRequest = (function (_super) {
    __extends(DeleteRequest, _super);
    function DeleteRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        _this.deleteMode = DeleteMode.SoftDelete;
        return _this;
    }
    Object.defineProperty(DeleteRequest.prototype, "DeleteMode", {
        get: function () {
            return this.deleteMode;
        },
        set: function (value) {
            this.deleteMode = value;
        },
        enumerable: true,
        configurable: true
    });
    DeleteRequest.prototype.InternalToJson = function (body) { throw new Error("DeleteRequest.ts - InternalToJson : Not implemented."); };
    /**@internal */
    DeleteRequest.prototype.WriteAttributesToXml = function (writer) {
        _super.prototype.WriteAttributesToXml.call(this, writer);
        writer.WriteAttributeValue(XmlAttributeNames.DeleteType, DeleteMode[this.DeleteMode]);
    };
    return DeleteRequest;
}(MultiResponseServiceRequest));
exports.DeleteRequest = DeleteRequest;
/** @internal */
var DeleteFolderRequest = (function (_super) {
    __extends(DeleteFolderRequest, _super);
    function DeleteFolderRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        _this.folderIds = new FolderIdWrapperList();
        return _this;
    }
    Object.defineProperty(DeleteFolderRequest.prototype, "FolderIds", {
        get: function () {
            return this.folderIds;
        },
        enumerable: true,
        configurable: true
    });
    DeleteFolderRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new ServiceResponse(); };
    DeleteFolderRequest.prototype.GetExpectedResponseMessageCount = function () { return this.FolderIds.Count; };
    DeleteFolderRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    DeleteFolderRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.DeleteFolderResponseMessage; };
    DeleteFolderRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.DeleteFolderResponse; };
    DeleteFolderRequest.prototype.GetXmlElementName = function () { return XmlElementNames.DeleteFolder; };
    DeleteFolderRequest.prototype.InternalToJson = function (body) { throw new Error("DeleteFolderRequest.ts - InternalToJson : Not implemented."); };
    DeleteFolderRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        //EwsUtilities.ValidateParam(this.FolderIds, "FolderIds");
        this.FolderIds.Validate(this.Service.RequestedServerVersion);
    };
    /**@internal */
    DeleteFolderRequest.prototype.WriteElementsToXml = function (writer) {
        this.FolderIds.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.FolderIds);
    };
    return DeleteFolderRequest;
}(DeleteRequest));
exports.DeleteFolderRequest = DeleteFolderRequest;
/** @internal */
var DeleteItemRequest = (function (_super) {
    __extends(DeleteItemRequest, _super);
    function DeleteItemRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        _this.itemIds = new ItemIdWrapperList();
        _this.affectedTaskOccurrences = null;
        _this.sendCancellationsMode = null;
        _this.SuppressReadReceipts = false;
        return _this;
    }
    Object.defineProperty(DeleteItemRequest.prototype, "ItemIds", {
        get: function () {
            return this.itemIds;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DeleteItemRequest.prototype, "AffectedTaskOccurrences", {
        get: function () {
            return this.affectedTaskOccurrences;
        },
        set: function (value) {
            this.affectedTaskOccurrences = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DeleteItemRequest.prototype, "SendCancellationsMode", {
        get: function () {
            return this.sendCancellationsMode;
        },
        set: function (value) {
            this.sendCancellationsMode = value;
        },
        enumerable: true,
        configurable: true
    });
    DeleteItemRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new ServiceResponse(); };
    DeleteItemRequest.prototype.GetExpectedResponseMessageCount = function () { return this.itemIds.Count; };
    DeleteItemRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    DeleteItemRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.DeleteItemResponseMessage; };
    DeleteItemRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.DeleteItemResponse; };
    DeleteItemRequest.prototype.GetXmlElementName = function () { return XmlElementNames.DeleteItem; };
    DeleteItemRequest.prototype.InternalToJson = function (body) { throw new Error("DeleteItemRequest.ts - InternalToJson : Not implemented."); };
    DeleteItemRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        //EwsUtilities.ValidateParam(this.ItemIds, "ItemIds");
        if (this.SuppressReadReceipts && this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
            throw new ServiceVersionException(StringHelper.Format(Strings.ParameterIncompatibleWithRequestVersion, "SuppressReadReceipts", ExchangeVersion[ExchangeVersion.Exchange2013]));
        }
    };
    /**@internal */
    DeleteItemRequest.prototype.WriteAttributesToXml = function (writer) {
        _super.prototype.WriteAttributesToXml.call(this, writer);
        if (this.AffectedTaskOccurrences !== null) {
            writer.WriteAttributeValue(XmlAttributeNames.AffectedTaskOccurrences, AffectedTaskOccurrence[this.AffectedTaskOccurrences]);
        }
        if (this.SendCancellationsMode !== null) {
            writer.WriteAttributeValue(XmlAttributeNames.SendMeetingCancellations, SendCancellationsMode[this.SendCancellationsMode]);
        }
        if (this.SuppressReadReceipts) {
            writer.WriteAttributeValue(XmlAttributeNames.SuppressReadReceipts, true);
        }
    };
    /**@internal */
    DeleteItemRequest.prototype.WriteElementsToXml = function (writer) {
        this.itemIds.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.ItemIds);
    };
    return DeleteItemRequest;
}(DeleteRequest));
exports.DeleteItemRequest = DeleteItemRequest;
/** @internal */
var EmptyFolderRequest = (function (_super) {
    __extends(EmptyFolderRequest, _super);
    function EmptyFolderRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        _this.DeleteSubFolders = false;
        _this.folderIds = new FolderIdWrapperList();
        return _this;
    }
    Object.defineProperty(EmptyFolderRequest.prototype, "FolderIds", {
        get: function () {
            return this.folderIds;
        },
        enumerable: true,
        configurable: true
    });
    EmptyFolderRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new ServiceResponse(); };
    EmptyFolderRequest.prototype.GetExpectedResponseMessageCount = function () { return this.FolderIds.Count; };
    EmptyFolderRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2010_SP1; };
    EmptyFolderRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.EmptyFolderResponseMessage; };
    EmptyFolderRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.EmptyFolderResponse; };
    EmptyFolderRequest.prototype.GetXmlElementName = function () { return XmlElementNames.EmptyFolder; };
    EmptyFolderRequest.prototype.InternalToJson = function (body) { throw new Error("EmptyFolderRequest.ts - InternalToJson : Not implemented."); };
    EmptyFolderRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        //EwsUtilities.ValidateParam(this.FolderIds, "FolderIds");
        this.FolderIds.Validate(this.Service.RequestedServerVersion);
    };
    /**@internal */
    EmptyFolderRequest.prototype.WriteAttributesToXml = function (writer) {
        _super.prototype.WriteAttributesToXml.call(this, writer);
        writer.WriteAttributeValue(XmlAttributeNames.DeleteSubFolders, this.DeleteSubFolders);
    };
    /**@internal */
    EmptyFolderRequest.prototype.WriteElementsToXml = function (writer) {
        this.FolderIds.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.FolderIds);
    };
    return EmptyFolderRequest;
}(DeleteRequest));
exports.EmptyFolderRequest = EmptyFolderRequest;
/** @internal */
var FindRequest = (function (_super) {
    __extends(FindRequest, _super);
    //private searchFilter: SearchFilter;  - no backing property needed
    //private queryString: string;
    //private returnHighlightTerms: boolean;
    //private view: ViewBase;
    function FindRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        _this.SearchFilter = null;
        _this.QueryString = null;
        _this.ReturnHighlightTerms = null;
        _this.View = null;
        _this.parentFolderIds = new FolderIdWrapperList();
        return _this;
    }
    Object.defineProperty(FindRequest.prototype, "ParentFolderIds", {
        get: function () { return this.parentFolderIds; },
        enumerable: true,
        configurable: true
    });
    FindRequest.prototype.GetExpectedResponseMessageCount = function () { return this.ParentFolderIds.Count; };
    FindRequest.prototype.GetGroupBy = function () { return null; };
    FindRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        this.View.InternalValidate(this);
        // query string parameter is only valid for Exchange2010 or higher
        //
        if (!StringHelper.IsNullOrEmpty(this.QueryString) &&
            this.Service.RequestedServerVersion < ExchangeVersion.Exchange2010) {
            throw new ServiceVersionException(StringHelper.Format(Strings.ParameterIncompatibleWithRequestVersion, "queryString", ExchangeVersion[ExchangeVersion.Exchange2010]));
        }
        // ReturnHighlightTerms parameter is only valid for Exchange2013 or higher
        //
        if (this.ReturnHighlightTerms &&
            this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
            throw new ServiceVersionException(StringHelper.Format(Strings.ParameterIncompatibleWithRequestVersion, "returnHighlightTerms", ExchangeVersion[ExchangeVersion.Exchange2013]));
        }
        // SeekToConditionItemView is only valid for Exchange2013 or higher
        //
        if ((this.View instanceof SeekToConditionItemView) &&
            this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
            throw new ServiceVersionException(StringHelper.Format(Strings.ParameterIncompatibleWithRequestVersion, "SeekToConditionItemView", ExchangeVersion[ExchangeVersion.Exchange2013]));
        }
        if (!StringHelper.IsNullOrEmpty(this.QueryString) &&
            this.SearchFilter != null) {
            throw new ServiceLocalException(Strings.BothSearchFilterAndQueryStringCannotBeSpecified);
        }
    };
    /**@internal */
    FindRequest.prototype.WriteAttributesToXml = function (writer) {
        _super.prototype.WriteAttributesToXml.call(this, writer);
        this.View.WriteAttributesToXml(writer);
    };
    /**@internal */
    FindRequest.prototype.WriteElementsToXml = function (writer) {
        this.View.WriteToXml(writer, this.GetGroupBy());
        if (this.SearchFilter != null) {
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.Restriction);
            this.SearchFilter.WriteToXml(writer);
            writer.WriteEndElement(); // Restriction
        }
        this.View.WriteOrderByToXml(writer);
        this.ParentFolderIds.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.ParentFolderIds);
        if (!StringHelper.IsNullOrEmpty(this.QueryString)) {
            // Emit the QueryString
            //
            writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.QueryString);
            if (this.ReturnHighlightTerms) {
                writer.WriteAttributeString(XmlAttributeNames.ReturnHighlightTerms, this.ReturnHighlightTerms.toString());
            }
            writer.WriteValue(this.QueryString, XmlElementNames.QueryString);
            writer.WriteEndElement();
        }
    };
    return FindRequest;
}(MultiResponseServiceRequest));
exports.FindRequest = FindRequest;
/** @internal */
var FindFolderRequest = (function (_super) {
    __extends(FindFolderRequest, _super);
    function FindFolderRequest(service, errorHandlingMode) {
        return _super.call(this, service, errorHandlingMode) || this;
    }
    FindFolderRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new FindFolderResponse(this.View.GetPropertySetOrDefault()); };
    FindFolderRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    FindFolderRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.FindFolderResponseMessage; };
    FindFolderRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.FindFolderResponse; };
    FindFolderRequest.prototype.GetXmlElementName = function () { return XmlElementNames.FindFolder; };
    return FindFolderRequest;
}(FindRequest));
exports.FindFolderRequest = FindFolderRequest;
/**
 * @internal Represents a **FindItem** request.
 *
 * @type <TItem>   Item type.
 */
var FindItemRequest = (function (_super) {
    __extends(FindItemRequest, _super);
    /**
     * @internal Initializes a new instance of the **FindItemRequest** class.
     *
     * @param   {ExchangeService}       service             The service.
     * @param   {ServiceErrorHandling}  errorHandlingMode   Indicates how errors should be handled.
     */
    function FindItemRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        _this.groupBy = null;
        return _this;
    }
    Object.defineProperty(FindItemRequest.prototype, "GroupBy", {
        /**
         * Gets or sets the group by.
         *
         * @value The group by.
         */
        get: function () {
            return this.groupBy;
        },
        set: function (value) {
            this.groupBy = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}            responseIndex   Index of the response.
     * @return  {FindItemResponse<TItem>}           Service response.
     */
    FindItemRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new FindItemResponse(this.GroupBy != null, this.View.GetPropertySetOrDefault()); };
    /**
     * @internal Gets the group by clause.
     *
     * @return  {Grouping}      The group by clause, null if the request does not have or support grouping.
     */
    FindItemRequest.prototype.GetGroupBy = function () { return this.GroupBy; };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    FindItemRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      XML element name.
     */
    FindItemRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.FindItemResponseMessage; };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name.
     */
    FindItemRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.FindItemResponse; };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string} XML element name.
     */
    FindItemRequest.prototype.GetXmlElementName = function () { return XmlElementNames.FindItem; };
    return FindItemRequest;
}(FindRequest));
exports.FindItemRequest = FindItemRequest;
/** @internal */
var GetRequest = (function (_super) {
    __extends(GetRequest, _super);
    //private propertySet: PropertySet;
    function GetRequest(service, errorHandlingMode) {
        return _super.call(this, service, errorHandlingMode) || this;
    }
    //abstract - AddIdsToRequest(jsonRequest: JsonObject, service: ExchangeService): any { throw new Error("GetRequest.ts - abstract - AddIdsToRequest : Not implemented."); }
    //IJsonSerializable.ToJson(ExchangeService service): any {
    //    JsonObject jsonRequest = new JsonObject();
    //    this.propertySet.WriteGetShapeToJson(jsonRequest, service, this.GetServiceObjectType());
    //    this.AddIdsToRequest(jsonRequest, service);
    //    return jsonRequest;
    //}
    GetRequest.prototype.GetServiceObjectType = function () { throw new Error("Abstract; must implemented."); };
    GetRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        //EwsUtilities.ValidateParam(this.PropertySet, "PropertySet");
        this.PropertySet.ValidateForRequest(this, false /*summaryPropertiesOnly*/);
    };
    /**@internal */
    GetRequest.prototype.WriteElementsToXml = function (writer) { this.PropertySet.WriteToXml(writer, this.GetServiceObjectType()); };
    return GetRequest;
}(MultiResponseServiceRequest));
exports.GetRequest = GetRequest;
/** @internal */
var GetFolderRequestBase = (function (_super) {
    __extends(GetFolderRequestBase, _super);
    function GetFolderRequestBase(service, errorHandlingModeServiceErrorHandling) {
        var _this = _super.call(this, service, errorHandlingModeServiceErrorHandling) || this;
        _this.folderIds = new FolderIdWrapperList();
        return _this;
    }
    Object.defineProperty(GetFolderRequestBase.prototype, "FolderIds", {
        get: function () { return this.folderIds; },
        enumerable: true,
        configurable: true
    });
    //AddIdsToRequest(jsonRequest: JsonObject, service: ExchangeService): any{ throw new Error("GetFolderRequestBase.ts - AddIdsToRequest : Not implemented.");}
    GetFolderRequestBase.prototype.GetExpectedResponseMessageCount = function () { return this.FolderIds.Count; };
    GetFolderRequestBase.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    GetFolderRequestBase.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.GetFolderResponseMessage; };
    GetFolderRequestBase.prototype.GetResponseXmlElementName = function () { return XmlElementNames.GetFolderResponse; };
    GetFolderRequestBase.prototype.GetServiceObjectType = function () { return ServiceObjectType.Folder; };
    GetFolderRequestBase.prototype.GetXmlElementName = function () { return XmlElementNames.GetFolder; };
    GetFolderRequestBase.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        //EwsUtilities.ValidateParamCollection(this.FolderIds, "FolderIds");
        this.FolderIds.Validate(this.Service.RequestedServerVersion);
    };
    /**@internal */
    GetFolderRequestBase.prototype.WriteElementsToXml = function (writer) {
        _super.prototype.WriteElementsToXml.call(this, writer);
        this.FolderIds.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.FolderIds);
    };
    return GetFolderRequestBase;
}(GetRequest));
exports.GetFolderRequestBase = GetFolderRequestBase;
/** @internal */
var GetFolderRequest = (function (_super) {
    __extends(GetFolderRequest, _super);
    function GetFolderRequest(service, errorHandlingMode) {
        return _super.call(this, service, errorHandlingMode) || this;
    }
    GetFolderRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new GetFolderResponse(this.FolderIds._getItem(responseIndex).GetFolder(), this.PropertySet);
    };
    return GetFolderRequest;
}(GetFolderRequestBase));
exports.GetFolderRequest = GetFolderRequest;
/** @internal */
var GetFolderRequestForLoad = (function (_super) {
    __extends(GetFolderRequestForLoad, _super);
    function GetFolderRequestForLoad(service, errorHandlingMode) {
        return _super.call(this, service, errorHandlingMode) || this;
    }
    GetFolderRequestForLoad.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new GetFolderResponse(this.FolderIds._getItem(responseIndex).GetFolder(), this.PropertySet);
    };
    return GetFolderRequestForLoad;
}(GetFolderRequestBase));
exports.GetFolderRequestForLoad = GetFolderRequestForLoad;
/** @internal */
var GetItemRequestBase = (function (_super) {
    __extends(GetItemRequestBase, _super);
    function GetItemRequestBase(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        _this.itemIds = new ItemIdWrapperList();
        return _this;
    }
    Object.defineProperty(GetItemRequestBase.prototype, "ItemIds", {
        get: function () {
            return this.itemIds;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetItemRequestBase.prototype, "EmitTimeZoneHeader", {
        get: function () {
            // currently we do not emit "ItemResponseShapeType.IncludeMimeContent".
            //
            return this.PropertySet.Contains(Schemas.ItemSchema.MimeContent);
        },
        enumerable: true,
        configurable: true
    });
    //AddIdsToRequest(jsonRequest: any, service: ExchangeService): any { throw new Error("GetItemRequestBase.ts - AddIdsToRequest : Not implemented."); }
    GetItemRequestBase.prototype.GetExpectedResponseMessageCount = function () { return this.ItemIds.Count; };
    GetItemRequestBase.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    GetItemRequestBase.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.GetItemResponseMessage; };
    GetItemRequestBase.prototype.GetResponseXmlElementName = function () { return XmlElementNames.GetItemResponse; };
    GetItemRequestBase.prototype.GetServiceObjectType = function () { return ServiceObjectType.Item; };
    GetItemRequestBase.prototype.GetXmlElementName = function () { return XmlElementNames.GetItem; };
    GetItemRequestBase.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        //EwsUtilities.ValidateParamCollection(this.ItemIds, "ItemIds");
    };
    /**@internal */
    GetItemRequestBase.prototype.WriteElementsToXml = function (writer) {
        _super.prototype.WriteElementsToXml.call(this, writer);
        this.ItemIds.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.ItemIds);
    };
    return GetItemRequestBase;
}(GetRequest));
exports.GetItemRequestBase = GetItemRequestBase;
/** @internal */
var GetItemRequest = (function (_super) {
    __extends(GetItemRequest, _super);
    function GetItemRequest(service, errorHandlingMode) {
        return _super.call(this, service, errorHandlingMode) || this;
    }
    GetItemRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new GetItemResponse(this.ItemIds[responseIndex], this.PropertySet); };
    return GetItemRequest;
}(GetItemRequestBase));
exports.GetItemRequest = GetItemRequest;
/** @internal */
var GetItemRequestForLoad = (function (_super) {
    __extends(GetItemRequestForLoad, _super);
    function GetItemRequestForLoad(service, errorHandlingModeServiceErrorHandling) {
        return _super.call(this, service, errorHandlingModeServiceErrorHandling) || this;
    }
    GetItemRequestForLoad.prototype.CreateServiceResponse = function (service, responseIndex) { return new GetItemResponse(this.ItemIds._getItem(responseIndex), this.PropertySet); };
    return GetItemRequestForLoad;
}(GetItemRequestBase));
exports.GetItemRequestForLoad = GetItemRequestForLoad;
/** @internal */
var MoveCopyRequest = (function (_super) {
    __extends(MoveCopyRequest, _super);
    function MoveCopyRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        _this.destinationFolderId = null;
        return _this;
    }
    Object.defineProperty(MoveCopyRequest.prototype, "DestinationFolderId", {
        get: function () {
            return this.destinationFolderId;
        },
        set: function (value) {
            this.destinationFolderId = value;
        },
        enumerable: true,
        configurable: true
    });
    MoveCopyRequest.prototype.AddIdsToJson = function (jsonObject, service) { throw new Error("MoveCopyRequest.ts - AddIdsToJson : Not implemented."); };
    MoveCopyRequest.prototype.Validate = function () {
        //EwsUtilities.ValidateParam(this.DestinationFolderId, "DestinationFolderId");
        this.DestinationFolderId.Validate(this.Service.RequestedServerVersion);
    };
    /**@internal */
    MoveCopyRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.ToFolderId);
        this.DestinationFolderId.WriteToXml(writer);
        writer.WriteEndElement();
        this.WriteIdsToXml(writer);
    };
    /**@internal */
    MoveCopyRequest.prototype.WriteIdsToXml = function (writer) { throw new Error("MoveCopyRequest.ts - WriteIdsToXml : Abstract - must implement."); };
    return MoveCopyRequest;
}(MultiResponseServiceRequest));
exports.MoveCopyRequest = MoveCopyRequest;
/** @internal */
var MoveCopyFolderRequest = (function (_super) {
    __extends(MoveCopyFolderRequest, _super);
    function MoveCopyFolderRequest(service, errorHandlingMode) {
        var _this = _super.call(this, service, errorHandlingMode) || this;
        _this.folderIds = new FolderIdWrapperList();
        return _this;
    }
    Object.defineProperty(MoveCopyFolderRequest.prototype, "FolderIds", {
        get: function () { return this.folderIds; },
        enumerable: true,
        configurable: true
    });
    MoveCopyFolderRequest.prototype.AddIdsToJson = function (jsonObject, service) { throw new Error("MoveCopyFolderRequest.ts - AddIdsToJson : Not implemented."); };
    MoveCopyFolderRequest.prototype.GetExpectedResponseMessageCount = function () { return this.FolderIds.Count; };
    MoveCopyFolderRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        //EwsUtilities.ValidateParamCollection(this.FolderIds, "FolderIds");
        this.FolderIds.Validate(this.Service.RequestedServerVersion);
    };
    /**@internal */
    MoveCopyFolderRequest.prototype.WriteIdsToXml = function (writer) {
        this.folderIds.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.FolderIds);
    };
    return MoveCopyFolderRequest;
}(MoveCopyRequest));
exports.MoveCopyFolderRequest = MoveCopyFolderRequest;
/** @internal */
var CopyFolderRequest = (function (_super) {
    __extends(CopyFolderRequest, _super);
    function CopyFolderRequest(service, errorHandlingMode) {
        return _super.call(this, service, errorHandlingMode) || this;
    }
    CopyFolderRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new MoveCopyFolderResponse(); };
    CopyFolderRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    CopyFolderRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.CopyFolderResponseMessage; };
    CopyFolderRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.CopyFolderResponse; };
    CopyFolderRequest.prototype.GetXmlElementName = function () { return XmlElementNames.CopyFolder; };
    return CopyFolderRequest;
}(MoveCopyFolderRequest));
exports.CopyFolderRequest = CopyFolderRequest;
/** @internal */
var MoveFolderRequest = (function (_super) {
    __extends(MoveFolderRequest, _super);
    function MoveFolderRequest(service, errorHandlingMode) {
        return _super.call(this, service, errorHandlingMode) || this;
    }
    MoveFolderRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new MoveCopyFolderResponse(); };
    MoveFolderRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    MoveFolderRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.MoveFolderResponseMessage; };
    MoveFolderRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.MoveFolderResponse; };
    MoveFolderRequest.prototype.GetXmlElementName = function () { return XmlElementNames.MoveFolder; };
    return MoveFolderRequest;
}(MoveCopyFolderRequest));
exports.MoveFolderRequest = MoveFolderRequest;
/** @internal */
var MoveCopyItemRequest = (function (_super) {
    __extends(MoveCopyItemRequest, _super);
    function MoveCopyItemRequest(service, errorHandlingModeServiceErrorHandling) {
        var _this = _super.call(this, service, errorHandlingModeServiceErrorHandling) || this;
        _this.ReturnNewItemIds = null; //nullable
        _this.itemIds = new ItemIdWrapperList();
        return _this;
    }
    Object.defineProperty(MoveCopyItemRequest.prototype, "ItemIds", {
        get: function () { return this.itemIds; },
        enumerable: true,
        configurable: true
    });
    //AddIdsToJson(jsonObject: any, service: ExchangeService): any { throw new Error("MoveCopyItemRequest.ts - AddIdsToJson : Not implemented."); }
    MoveCopyItemRequest.prototype.GetExpectedResponseMessageCount = function () { return this.ItemIds.Count; };
    MoveCopyItemRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        //EwsUtilities.ValidateParam(this.ItemIds, "ItemIds");
    };
    /**@internal */
    MoveCopyItemRequest.prototype.WriteIdsToXml = function (writer) {
        this.ItemIds.WriteToXml(writer, XmlNamespace.Messages, XmlElementNames.ItemIds);
        if (this.ReturnNewItemIds) {
            writer.WriteElementValue(XmlNamespace.Messages, XmlElementNames.ReturnNewItemIds, this.ReturnNewItemIds);
        }
    };
    return MoveCopyItemRequest;
}(MoveCopyRequest));
exports.MoveCopyItemRequest = MoveCopyItemRequest;
/** @internal */
var CopyItemRequest = (function (_super) {
    __extends(CopyItemRequest, _super);
    function CopyItemRequest(service, errorHandlingModeServiceErrorHandling) {
        return _super.call(this, service, errorHandlingModeServiceErrorHandling) || this;
    }
    CopyItemRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new MoveCopyItemResponse(); };
    CopyItemRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    CopyItemRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.CopyItemResponseMessage; };
    CopyItemRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.CopyItemResponse; };
    CopyItemRequest.prototype.GetXmlElementName = function () { return XmlElementNames.CopyItem; };
    return CopyItemRequest;
}(MoveCopyItemRequest));
exports.CopyItemRequest = CopyItemRequest;
/** @internal */
var MoveItemRequest = (function (_super) {
    __extends(MoveItemRequest, _super);
    function MoveItemRequest(service, errorHandlingModeServiceErrorHandling) {
        return _super.call(this, service, errorHandlingModeServiceErrorHandling) || this;
    }
    MoveItemRequest.prototype.CreateServiceResponse = function (service, responseIndex) { return new MoveCopyItemResponse(); };
    MoveItemRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    MoveItemRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.MoveItemResponseMessage; };
    MoveItemRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.MoveItemResponse; };
    MoveItemRequest.prototype.GetXmlElementName = function () { return XmlElementNames.MoveItem; };
    return MoveItemRequest;
}(MoveCopyItemRequest));
exports.MoveItemRequest = MoveItemRequest;
/**
 * @internal Represents an abstract Subscribe request.
 *
 * @typeparam	{TSubscription}		The type of the subscription.
 */
var SubscribeRequest = (function (_super) {
    __extends(SubscribeRequest, _super);
    /**
     * @internal Initializes a new instance of the **SubscribeRequest<TSubscription>** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function SubscribeRequest(service) {
        var _this = _super.call(this, service, ServiceErrorHandling.ThrowOnError) || this;
        _this.FolderIds = new FolderIdWrapperList();
        _this.EventTypes = [];
        return _this;
    }
    /**
     * @internal Gets the expected response message count.
     *
     * @return  {number}      Number of expected response messages.
     */
    SubscribeRequest.prototype.GetExpectedResponseMessageCount = function () { return 1; };
    /**
     * @internal Gets the name of the response message XML element.
     *
     * @return  {string}      XML element name,
     */
    SubscribeRequest.prototype.GetResponseMessageXmlElementName = function () { return XmlElementNames.SubscribeResponseMessage; };
    /**
     * @internal Gets the name of the response XML element.
     *
     * @return  {string}      XML element name,
     */
    SubscribeRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.SubscribeResponse; };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name,
     */
    SubscribeRequest.prototype.GetXmlElementName = function () { return XmlElementNames.Subscribe; };
    /**
     * @internal Validate request.
     */
    SubscribeRequest.prototype.Validate = function () {
        var _this = this;
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParam(this.FolderIds, "FolderIds");
        EwsUtilities.ValidateParamCollection(this.EventTypes, "EventTypes");
        this.FolderIds.Validate(this.Service.RequestedServerVersion);
        // Check that caller isn't trying to subscribe to Status events.
        if (ArrayHelper.OfType(this.EventTypes, function (eventType) { return eventType === EventType.Status; }).length > 0) {
            throw new ServiceValidationException(Strings.CannotSubscribeToStatusEvents);
        }
        // If Watermark was specified, make sure it's not a blank string.
        if (!StringHelper.IsNullOrEmpty(this.Watermark)) {
            EwsUtilities.ValidateNonBlankStringParam(this.Watermark, "Watermark");
        }
        this.EventTypes.forEach(function (eventType) {
            EwsUtilities.ValidateEnumVersionValue(EventType, eventType, _this.Service.RequestedServerVersion, "EventType");
        });
    };
    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    SubscribeRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Messages, this.GetSubscriptionXmlElementName());
        if (this.FolderIds.Count == 0) {
            writer.WriteAttributeValue(XmlAttributeNames.SubscribeToAllFolders, true);
        }
        this.FolderIds.WriteToXml(writer, XmlNamespace.Types, XmlElementNames.FolderIds);
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.EventTypes);
        for (var _a = 0, _b = this.EventTypes; _a < _b.length; _a++) {
            var eventType = _b[_a];
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.EventType, EventType[eventType] + "Event");
        }
        writer.WriteEndElement();
        if (!StringHelper.IsNullOrEmpty(this.Watermark)) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Watermark, this.Watermark);
        }
        this.InternalWriteElementsToXml(writer);
        writer.WriteEndElement();
    };
    return SubscribeRequest;
}(MultiResponseServiceRequest));
exports.SubscribeRequest = SubscribeRequest;
/**
 * @internal Represents a "pull" Subscribe request.
 */
var SubscribeToPullNotificationsRequest = (function (_super) {
    __extends(SubscribeToPullNotificationsRequest, _super);
    /**
     * @internal Initializes a new instance of the **SubscribeToPullNotificationsRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function SubscribeToPullNotificationsRequest(service) {
        var _this = _super.call(this, service) || this;
        _this.timeout = 30;
        return _this;
    }
    Object.defineProperty(SubscribeToPullNotificationsRequest.prototype, "Timeout", {
        /**
         * Gets or sets the timeout.
         *
         * @value	The timeout.
         */
        get: function () {
            return this.timeout;
        },
        set: function (value) {
            this.timeout = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}   			responseIndex   Index of the response.
     * @return  {SubscribeResponse<PullSubscription>}		Service response.
     */
    SubscribeToPullNotificationsRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new SubscribeResponse(new PullSubscription(service));
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    SubscribeToPullNotificationsRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Gets the name of the subscription XML element.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    SubscribeToPullNotificationsRequest.prototype.GetSubscriptionXmlElementName = function () {
        return XmlElementNames.PullSubscriptionRequest;
    };
    /**
     * @internal Internal method to write XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    SubscribeToPullNotificationsRequest.prototype.InternalWriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Timeout, this.Timeout);
    };
    /**
     * @internal Validate request.
     */
    SubscribeToPullNotificationsRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        if ((this.Timeout < 1) || (this.Timeout > 1440)) {
            throw new ArgumentException(StringHelper.Format(Strings.InvalidTimeoutValue, this.Timeout));
        }
    };
    return SubscribeToPullNotificationsRequest;
}(SubscribeRequest));
exports.SubscribeToPullNotificationsRequest = SubscribeToPullNotificationsRequest;
/**
 * @internal Represents a "push" Subscribe request.
 */
var SubscribeToPushNotificationsRequest = (function (_super) {
    __extends(SubscribeToPushNotificationsRequest, _super);
    /**
     * @internal Initializes a new instance of the **SubscribeToPushNotificationsRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function SubscribeToPushNotificationsRequest(service) {
        var _this = _super.call(this, service) || this;
        _this.frequency = 30;
        _this.url = null;
        _this.callerData = null;
        return _this;
    }
    Object.defineProperty(SubscribeToPushNotificationsRequest.prototype, "Frequency", {
        /**
         * Gets or sets the frequency.
         *
         * @value	The frequency.
         */
        get: function () {
            return this.frequency;
        },
        set: function (value) {
            this.frequency = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubscribeToPushNotificationsRequest.prototype, "Url", {
        /**
         * Gets or sets the URL.
         *
         * @value	The URL.
         */
        get: function () {
            return this.url;
        },
        set: function (value) {
            this.url = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubscribeToPushNotificationsRequest.prototype, "CallerData", {
        /**
         * Gets or sets the CallerData.
         *
         * @value	The CallerData.
         */
        get: function () {
            return this.callerData;
        },
        set: function (value) {
            this.callerData = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates the service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}   			responseIndex   Index of the response.
     * @return  {SubscribeResponse<PushSubscription>}		Service response.
     */
    SubscribeToPushNotificationsRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new SubscribeResponse(new PushSubscription(service));
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    SubscribeToPushNotificationsRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Gets the name of the subscription XML element.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    SubscribeToPushNotificationsRequest.prototype.GetSubscriptionXmlElementName = function () {
        return XmlElementNames.PushSubscriptionRequest;
    };
    /**
     * @internal Internal method to write XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    SubscribeToPushNotificationsRequest.prototype.InternalWriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.StatusFrequency, this.Frequency);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.URL, this.Url.ToString());
        if (this.Service.RequestedServerVersion >= ExchangeVersion.Exchange2013
            && !StringHelper.IsNullOrEmpty(this.callerData)) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.CallerData, this.CallerData);
        }
    };
    /**
     * @internal Validate request.
     */
    SubscribeToPushNotificationsRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParam(this.Url, "Url");
        if ((this.Frequency < 1) || (this.Frequency > 1440)) {
            throw new ArgumentException(StringHelper.Format(Strings.InvalidFrequencyValue, this.Frequency));
        }
    };
    return SubscribeToPushNotificationsRequest;
}(SubscribeRequest));
exports.SubscribeToPushNotificationsRequest = SubscribeToPushNotificationsRequest;
/**
 * @internal Represents a *Streaming* Subscribe request.
 */
var SubscribeToStreamingNotificationsRequest = (function (_super) {
    __extends(SubscribeToStreamingNotificationsRequest, _super);
    /**
     * @internal Initializes a new instance of the **SubscribeToStreamingNotificationsRequest** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function SubscribeToStreamingNotificationsRequest(service) {
        return _super.call(this, service) || this;
    }
    /**
     * @internal Creates service response.
     *
     * @param   {ExchangeService}   service         The service.
     * @param   {number}   			responseIndex   Index of the response.
     * @return  {SubscribeResponse<StreamingSubscription>}	Service response.
     */
    SubscribeToStreamingNotificationsRequest.prototype.CreateServiceResponse = function (service, responseIndex) {
        return new SubscribeResponse(new StreamingSubscription(service));
    };
    /**
     * @internal Gets the request version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this request is supported.
     */
    SubscribeToStreamingNotificationsRequest.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2010_SP1; };
    /**
     * @internal Gets the name of the subscription XML element.
     *
     * @return  {string}      XML element name,
     */
    SubscribeToStreamingNotificationsRequest.prototype.GetSubscriptionXmlElementName = function () { return XmlElementNames.StreamingSubscriptionRequest; };
    /**
     * @internal Internal method to write XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    SubscribeToStreamingNotificationsRequest.prototype.InternalWriteElementsToXml = function (writer) {
    };
    /**
     * @internal Validate request.
     */
    SubscribeToStreamingNotificationsRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        if (!StringHelper.IsNullOrEmpty(this.Watermark)) {
            throw new ArgumentException("Watermarks cannot be used with StreamingSubscriptions.", "Watermark");
        }
    };
    return SubscribeToStreamingNotificationsRequest;
}(SubscribeRequest));
exports.SubscribeToStreamingNotificationsRequest = SubscribeToStreamingNotificationsRequest;
/**
 * Represents the standard response to an Exchange Web Services operation.
 */
var ServiceResponse = (function () {
    function ServiceResponse(soapFaultDetailsOrResponseCode, errorMessage) {
        this.errorDetails = new DictionaryWithStringKey();
        this.errorProperties = [];
        var argsLength = arguments.length;
        if (argsLength == 0)
            return;
        if (typeof soapFaultDetailsOrResponseCode === 'number') {
            this.result = ServiceResult.Error;
            this.errorCode = soapFaultDetailsOrResponseCode;
            this.errorMessage = errorMessage;
            this.errorDetails = null;
        }
        else {
            this.result = ServiceResult.Error;
            this.errorCode = soapFaultDetailsOrResponseCode.ResponseCode;
            this.errorMessage = soapFaultDetailsOrResponseCode.FaultString;
            this.errorDetails = soapFaultDetailsOrResponseCode.ErrorDetails;
        }
    }
    ;
    Object.defineProperty(ServiceResponse.prototype, "BatchProcessingStopped", {
        /**
         * @internal Gets a value indicating whether a batch request stopped processing before the end.
         */
        get: function () {
            return (this.result == ServiceResult.Warning) && (this.errorCode == ServiceError.ErrorBatchProcessingStopped);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServiceResponse.prototype, "Result", {
        /**
         * Gets the result associated with this response.
         */
        get: function () {
            return this.result;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServiceResponse.prototype, "ErrorCode", {
        /**
         * Gets the error code associated with this response.
         */
        get: function () {
            return this.errorCode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServiceResponse.prototype, "ErrorMessage", {
        /**
         * Gets a detailed error message associated with the response. If Result is set to Success, ErrorMessage returns null.
         * ErrorMessage is localized according to the PreferredCulture property of the ExchangeService object that was used to call the method that generated the response.
         */
        get: function () {
            return this.errorMessage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServiceResponse.prototype, "ErrorDetails", {
        /**
         * Gets error details associated with the response. If Result is set to Success, ErrorDetailsDictionary returns null.
         * Error details will only available for some error codes. For example, when error code is ErrorRecurrenceHasNoOccurrence, the ErrorDetailsDictionary will contain keys for EffectiveStartDate and EffectiveEndDate.
         *
         * @value   The error details dictionary.
         */
        get: function () {
            return this.errorDetails;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServiceResponse.prototype, "ErrorProperties", {
        /**
         * Gets information about property errors associated with the response. If Result is set to Success, ErrorProperties returns null.
         * ErrorProperties is only available for some error codes. For example, when the error code is ErrorInvalidPropertyForOperation, ErrorProperties will contain the definition of the property that was invalid for the request.
         *
         * @value   The error properties list.
         */
        get: function () {
            return this.errorProperties;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Internal method that throws a ServiceResponseException if this response has its Result property set to Error.
     */
    ServiceResponse.prototype.InternalThrowIfNecessary = function () {
        if (this.Result == ServiceResult.Error) {
            throw new ServiceResponseException(this);
        }
    };
    /**
     * @internal Called when the response has been loaded from XML.
     */
    ServiceResponse.prototype.Loaded = function () { };
    /**
     * @internal Loads extra error details from XML
     *
     * @param   {any}               responseObject      Json Object converted from XML.
     * @param   {ExchangeService}   service             The service.
     */
    ServiceResponse.prototype.LoadExtraErrorDetailsFromXmlJsObject = function (responseObject, service) {
        if (responseObject[XmlElementNames.MessageXml]) {
            this.ParseMessageXml(responseObject[XmlElementNames.MessageXml]);
        }
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 responseObject        Json Object converted from XML.
     * @param   {ExchangeService}     service               The service.
     */
    ServiceResponse.prototype.LoadFromXmlJsObject = function (responseObject, service) {
        this.result = ServiceResult[responseObject[XmlAttributeNames.ResponseClass]];
        this.errorCode = ServiceError[responseObject[XmlElementNames.ResponseCode]];
        // TODO: Deal with a JSON version of "LoadExtraDetailsFromXml"
        if (this.result == ServiceResult.Warning || this.result == ServiceResult.Error) {
            this.errorMessage = responseObject[XmlElementNames.MessageText];
            this.LoadExtraErrorDetailsFromXmlJsObject(responseObject, service);
        }
        if (this.result == ServiceResult.Success || this.result == ServiceResult.Warning) {
            if (!this.BatchProcessingStopped) {
                this.ReadElementsFromXmlJsObject(responseObject, service);
            }
        }
        this.MapErrorCodeToErrorMessage();
        this.Loaded();
    };
    /**
     * @internal Called after the response has been loaded from XML in order to map error codes to "better" error messages.
     */
    ServiceResponse.prototype.MapErrorCodeToErrorMessage = function () {
        // Use a better error message when an item cannot be updated because its changeKey is old.
        if (this.ErrorCode == ServiceError.ErrorIrresolvableConflict) {
            this.errorMessage = Strings.ItemIsOutOfDate;
        }
    };
    /**
     * Parses the message XML.
     *
     * @param   {any}   jsObject   The MessageXml Object.
     */
    ServiceResponse.prototype.ParseMessageXml = function (jsObject) {
        var _this = this;
        for (var key in jsObject) {
            if (key.indexOf("__") === 0) {
                continue;
            }
            switch (key) {
                case XmlElementNames.Value:
                    var values = EwsServiceJsonReader.ReadAsArray(jsObject, key);
                    values.forEach(function (value, index) {
                        var name = value[XmlAttributeNames.Name];
                        if (name) {
                            if (_this.ErrorDetails.containsKey(name)) {
                                name = name + " - " + (index + 1);
                            }
                            _this.errorDetails.Add(name, value[key]);
                        }
                    });
                    break;
                case XmlElementNames.FieldURI:
                    this.errorProperties.push(ServiceObjectSchema.FindPropertyDefinition(jsObject[key][XmlAttributeNames.FieldURI]));
                    break;
                case XmlElementNames.IndexedFieldURI:
                    var indexFieldUriObject = jsObject[key];
                    this.errorProperties.push(new IndexedPropertyDefinition(indexFieldUriObject[XmlAttributeNames.FieldURI], indexFieldUriObject[XmlAttributeNames.FieldIndex]));
                    break;
                case XmlElementNames.ExtendedFieldURI:
                    var extendedPropDef = new ExtendedPropertyDefinition();
                    extendedPropDef.LoadPropertyValueFromXmlJsObject(jsObject[key]);
                    this.errorProperties.push(extendedPropDef);
                    break;
                default:
                    EwsLogging.Assert(false, "ServiceResponse.ParseMessageXml", "Element: " + key + " - Please report example of this operation to ews-javascript-api repo to improve SoapFault parsing");
                    break;
            }
        }
    };
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ServiceResponse.prototype.ReadElementsFromXmlJsObject = function (jsObject, service) {
        /* virtualvoid to be implemented throw new Error("Not implemented.");*/
        var caller = "ServiceResponse->child";
        try {
            caller = this.constructor.name;
        }
        catch (e) { }
        EwsLogging.Assert(caller === "ServiceResponse", caller + ".ReadElementsFromXmlJsObject", "BatchProcessingStopped is false but ReadElementsFromXmlJsObject is not available in derived class to call.");
    };
    /**
     * @internal Throws a ServiceResponseException if this response has its Result property set to Error.
     */
    ServiceResponse.prototype.ThrowIfNecessary = function () {
        this.InternalThrowIfNecessary();
    };
    return ServiceResponse;
}());
exports.ServiceResponse = ServiceResponse;
var ArchiveItemResponse = (function (_super) {
    __extends(ArchiveItemResponse, _super);
    function ArchiveItemResponse() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ArchiveItemResponse.prototype.GetObjectInstance = function (service, xmlElementName) {
        return (new ItemInfo()).CreateEwsObjectFromXmlElementName(service, xmlElementName);
    };
    ArchiveItemResponse.prototype.ReadElementsFromJson = function (responseObject, service) { throw new Error("ArchiveItemResponse.ts - ReadElementsFromJson : Not implemented."); };
    ArchiveItemResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        debugger;
        var items = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson(responseObject, service, XmlElementNames.Folders, this.GetObjectInstance.bind(this), false, /* clearPropertyBag */ null, /* requestedPropertySet */ false); /* summaryPropertiesOnly */
        if (items.length > 0) {
            this.item = items[0];
        }
    };
    return ArchiveItemResponse;
}(ServiceResponse));
exports.ArchiveItemResponse = ArchiveItemResponse;
var AttendeeAvailability = (function (_super) {
    __extends(AttendeeAvailability, _super);
    function AttendeeAvailability() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.calendarEvents = [];
        _this.mergedFreeBusyStatus = [];
        _this.viewType = FreeBusyViewType.None;
        _this.workingHours = null;
        return _this;
    }
    Object.defineProperty(AttendeeAvailability.prototype, "CalendarEvents", {
        get: function () { return this.calendarEvents; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttendeeAvailability.prototype, "ViewType", {
        get: function () { return this.viewType; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttendeeAvailability.prototype, "MergedFreeBusyStatus", {
        get: function () { return this.mergedFreeBusyStatus; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttendeeAvailability.prototype, "WorkingHours", {
        get: function () { return this.workingHours; },
        enumerable: true,
        configurable: true
    });
    AttendeeAvailability.prototype.LoadFreeBusyViewFromXmlJsObject = function (jsObject, viewType, service) {
        var viewTypeString = jsObject[XmlElementNames.FreeBusyViewType];
        this.viewType = FreeBusyViewType[viewTypeString];
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.MergedFreeBusy:
                    var mergedFreeBusy = jsObject[key];
                    for (var _a = 0, _b = mergedFreeBusy.split(''); _a < _b.length; _a++) {
                        var status = _b[_a];
                        this.mergedFreeBusyStatus.push(Number(status));
                    }
                    break;
                case XmlElementNames.CalendarEventArray:
                    var calendarEventArray = jsObject[key];
                    var calendarEvents = calendarEventArray[XmlElementNames.CalendarEvent];
                    if (!Array.isArray(calendarEvents)) {
                        calendarEvents = [calendarEvents];
                    }
                    for (var _c = 0, calendarEvents_1 = calendarEvents; _c < calendarEvents_1.length; _c++) {
                        var calendarEventObj = calendarEvents_1[_c];
                        var calendarEvent = new CalendarEvent();
                        calendarEvent.LoadFromXmlJsObject(calendarEventObj, service);
                        this.calendarEvents.push(calendarEvent);
                    }
                    break;
                case XmlElementNames.WorkingHours:
                    this.workingHours = new WorkingHours();
                    this.workingHours.LoadFromXmlJsObject(jsObject[key], service);
                    break;
            }
        }
    };
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    AttendeeAvailability.prototype.ReadElementsFromXmlJsObject = function (jsObject, service) {
    };
    return AttendeeAvailability;
}(ServiceResponse));
exports.AttendeeAvailability = AttendeeAvailability;
/**
 * Represents the response to an individual Id conversion operation.
 *
 * @sealed
 */
var ConvertIdResponse = (function (_super) {
    __extends(ConvertIdResponse, _super);
    /**
     * @internal Initializes a new instance of the **ConvertIdResponse** class.
     */
    function ConvertIdResponse() {
        return _super.call(this) || this;
    }
    Object.defineProperty(ConvertIdResponse.prototype, "ConvertedId", {
        /**
         * Gets the converted Id.
         */
        get: function () {
            return this.convertedId;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    ConvertIdResponse.prototype.ReadElementsFromXmlJsObject = function (jsObject, service) {
        var responseObject = jsObject[XmlElementNames.AlternateId];
        var alternateIdClass = responseObject[XmlAttributeNames.Type];
        if (alternateIdClass) {
            alternateIdClass = alternateIdClass.replace("t:", "");
        }
        switch (alternateIdClass) {
            case AlternateId.SchemaTypeName:
                this.convertedId = new AlternateId();
                break;
            case AlternatePublicFolderId.SchemaTypeName:
                this.convertedId = new AlternatePublicFolderId();
                break;
            case AlternatePublicFolderItemId.SchemaTypeName:
                this.convertedId = new AlternatePublicFolderItemId();
                break;
            default:
                EwsLogging.Assert(false, "ConvertIdResponse.ReadElementsFromXml", StringHelper.Format("Unknown alternate Id class: {0}", alternateIdClass));
                break;
        }
        this.convertedId.LoadAttributesFromXmlJsObject(responseObject);
    };
    return ConvertIdResponse;
}(ServiceResponse));
exports.ConvertIdResponse = ConvertIdResponse;
/**
 * Represents the response to an individual attachment creation operation.
 * @sealed
 */
var CreateAttachmentResponse = (function (_super) {
    __extends(CreateAttachmentResponse, _super);
    /**
     * Initializes a new instance of the **CreateAttachmentResponse** class.
     *
     * @param   {Attachment}   attachment   The attachment.
     */
    function CreateAttachmentResponse(attachment) {
        var _this = _super.call(this) || this;
        _this.attachment = null;
        EwsLogging.Assert(attachment != null, "CreateAttachmentResponse.ctor", "attachment is null");
        _this.attachment = attachment;
        return _this;
    }
    Object.defineProperty(CreateAttachmentResponse.prototype, "Attachment", {
        /**
         * Gets the attachment that was created.
         */
        get: function () {
            return this.attachment;
        },
        enumerable: true,
        configurable: true
    });
    /**
      * @internal Reads response elements from Xml JsObject.
      *
      * @param   {any}               jsObject   The response object.
      * @param   {ExchangeService}   service    The service.
      */
    CreateAttachmentResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        var attachmentArray = EwsServiceJsonReader.ReadAsArray(responseObject, XmlElementNames.Attachments);
        if (attachmentArray != null && attachmentArray.length > 0) {
            var attachmenTypetArray = EwsServiceJsonReader.ReadAsArray(attachmentArray[0], XmlElementNames.ItemAttachment);
            if (attachmenTypetArray.length > 0) {
                this.attachment.LoadFromXmlJsObject(attachmenTypetArray[0], service);
                return;
            }
            attachmenTypetArray = EwsServiceJsonReader.ReadAsArray(attachmentArray[0], XmlElementNames.FileAttachment);
            if (attachmenTypetArray.length > 0) {
                this.attachment.LoadFromXmlJsObject(attachmenTypetArray[0], service);
            }
        }
    };
    return CreateAttachmentResponse;
}(ServiceResponse));
exports.CreateAttachmentResponse = CreateAttachmentResponse;
var CreateFolderResponse = (function (_super) {
    __extends(CreateFolderResponse, _super);
    function CreateFolderResponse(folder) {
        var _this = _super.call(this) || this;
        _this.folder = null;
        _this.folder = folder;
        return _this;
    }
    CreateFolderResponse.prototype.GetObjectInstance = function (service, xmlElementName) {
        if (this.folder != null) {
            return this.folder;
        }
        else {
            var flinfo = new FolderInfo();
            return flinfo.CreateEwsObjectFromXmlElementName(service, xmlElementName);
        }
    };
    CreateFolderResponse.prototype.Loaded = function () {
        if (this.Result == ServiceResult.Success) {
            this.folder.ClearChangeLog();
        }
    };
    CreateFolderResponse.prototype.ReadElementsFromJson = function (responseObject, service) { throw new Error("CreateFolderResponse.ts - ReadElementsFromJson : Not implemented."); };
    CreateFolderResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        if (responseObject[XmlElementNames.Folders]) {
            var folders = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson(responseObject, service, XmlElementNames.Folders, this.GetObjectInstance.bind(this), false, /* clearPropertyBag */ null, /* requestedPropertySet */ false); /* summaryPropertiesOnly */
            this.folder = folders[0];
        }
    };
    return CreateFolderResponse;
}(ServiceResponse));
exports.CreateFolderResponse = CreateFolderResponse;
/**
 * @internal Represents the response to a delegate managent-related operation.
 */
var DelegateManagementResponse = (function (_super) {
    __extends(DelegateManagementResponse, _super);
    /**
     * @internal Initializes a new instance of the **DelegateManagementResponse** class.
     *
     * @param   {boolean}           readDelegateUsers   if set to *true* [read delegate users].
     * @param   {DelegateUser[]}    delegateUsers       List of existing delegate users to load.
     */
    function DelegateManagementResponse(readDelegateUsers, delegateUsers) {
        var _this = _super.call(this) || this;
        _this.readDelegateUsers = false;
        _this.delegateUsers = null;
        _this.delegateUserResponses = null;
        _this.readDelegateUsers = readDelegateUsers;
        _this.delegateUsers = delegateUsers;
        return _this;
    }
    Object.defineProperty(DelegateManagementResponse.prototype, "DelegateUserResponses", {
        /**
         * @internal Gets a collection of responses for each of the delegate users concerned by the operation.
         */
        get: function () {
            return this.delegateUserResponses;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    DelegateManagementResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        if (this.ErrorCode === ServiceError.NoError) {
            this.delegateUserResponses = [];
        }
        var jsResponses = responseObject[XmlElementNames.ResponseMessages];
        var delegateUserIndex = 0;
        for (var _a = 0, _b = EwsServiceJsonReader.ReadAsArray(jsResponses, XmlElementNames.DelegateUserResponseMessageType); _a < _b.length; _a++) {
            var jsResponse = _b[_a];
            var delegateUser = null;
            if (this.readDelegateUsers && (this.delegateUsers != null)) {
                delegateUser = this.delegateUsers[delegateUserIndex];
            }
            var delegateUserResponse = new DelegateUserResponse(this.readDelegateUsers, delegateUser);
            delegateUserResponse.LoadFromXmlJsObject(jsResponse, service);
            this.delegateUserResponses.push(delegateUserResponse);
            delegateUserIndex++;
        }
    };
    return DelegateManagementResponse;
}(ServiceResponse));
exports.DelegateManagementResponse = DelegateManagementResponse;
/**
 * Represents the response to an individual delegate user manipulation (add, remove, update) operation.
 *
 * @sealed
 */
var DelegateUserResponse = (function (_super) {
    __extends(DelegateUserResponse, _super);
    /**
     * @internal Initializes a new instance of the **DelegateUserResponse** class.
     *
     * @param   {boolean}       readDelegateUsers   if set to *true* [read delegate users].
     * @param   {DelegateUser}  delegateUser        Existing DelegateUser to use (may be null).
     */
    function DelegateUserResponse(readDelegateUser, delegateUser) {
        var _this = _super.call(this) || this;
        _this.readDelegateUser = false;
        _this.delegateUser = null;
        _this.readDelegateUser = readDelegateUser;
        _this.delegateUser = delegateUser;
        return _this;
    }
    Object.defineProperty(DelegateUserResponse.prototype, "DelegateUser", {
        /**
         * The delegate user that was involved in the operation.
         */
        get: function () {
            return this.delegateUser;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    DelegateUserResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        if (this.readDelegateUser) {
            if (this.delegateUser == null) {
                this.delegateUser = new DelegateUser();
            }
            this.delegateUser.LoadFromXmlJsObject(responseObject[XmlElementNames.DelegateUser], service);
        }
    };
    return DelegateUserResponse;
}(ServiceResponse));
exports.DelegateUserResponse = DelegateUserResponse;
/**
 * Represents the response to an individual attachment deletion operation.
 * @sealed
 */
var DeleteAttachmentResponse = (function (_super) {
    __extends(DeleteAttachmentResponse, _super);
    /**
     * Initializes a new instance of the **DeleteAttachmentResponse** class.
     *
     * @param   {Attachment}   attachment   The attachment.
     */
    function DeleteAttachmentResponse(attachment) {
        var _this = _super.call(this) || this;
        _this.attachment = null;
        EwsLogging.Assert(attachment != null, "CreateAttachmentResponse.ctor", "attachment is null");
        _this.attachment = attachment;
        return _this;
    }
    Object.defineProperty(DeleteAttachmentResponse.prototype, "Attachment", {
        /**
         * Gets the attachment that was deleted.
         */
        get: function () {
            return this.attachment;
        },
        enumerable: true,
        configurable: true
    });
    /**
      * @internal Reads response elements from Xml JsObject.
      *
      * @param   {any}               jsObject   The response object.
      * @param   {ExchangeService}   service    The service.
      */
    DeleteAttachmentResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        if (responseObject[XmlElementNames.RootItemId]) {
            var jsRootItemId = responseObject[XmlElementNames.RootItemId];
            var changeKey = void 0;
            if (jsRootItemId[XmlAttributeNames.RootItemChangeKey] &&
                !StringHelper.IsNullOrEmpty(changeKey = jsRootItemId[XmlAttributeNames.RootItemChangeKey]) &&
                this.attachment.Owner != null) {
                this.attachment.Owner.RootItemId.ChangeKey = changeKey;
            }
        }
    };
    return DeleteAttachmentResponse;
}(ServiceResponse));
exports.DeleteAttachmentResponse = DeleteAttachmentResponse;
/**
 * @internal  Represents the response to a DisableApp operation.
 * Today this class doesn't add extra functionality. Keep this class here so future we can return extension info up-on installation complete.
 *
 * @sealed
 */
var DisableAppResponse = (function (_super) {
    __extends(DisableAppResponse, _super);
    /**
     * @internal Initializes a new instance of the **DisableAppResponse** class.
     */
    function DisableAppResponse() {
        return _super.call(this) || this;
    }
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    DisableAppResponse.prototype.ReadElementsFromXmlJsObject = function (jsObject, service) {
        //does nothing, here to supress base class message about ReadElementsFromXmlJsObject when BatchProcessingStopped is false
    };
    return DisableAppResponse;
}(ServiceResponse));
exports.DisableAppResponse = DisableAppResponse;
/**
 * ## *Not Implemented*
 */
var ExecuteDiagnosticMethodResponse = (function (_super) {
    __extends(ExecuteDiagnosticMethodResponse, _super);
    function ExecuteDiagnosticMethodResponse() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**@internal */
    ExecuteDiagnosticMethodResponse.prototype.ReadElementsFromXmlJsObject = function (reader) { throw new Error("ExecuteDiagnosticMethodResponse.ts - ReadElementsFromXmlJsObject : Not implemented."); };
    return ExecuteDiagnosticMethodResponse;
}(ServiceResponse));
exports.ExecuteDiagnosticMethodResponse = ExecuteDiagnosticMethodResponse;
var ExpandGroupResponse = (function (_super) {
    __extends(ExpandGroupResponse, _super);
    function ExpandGroupResponse() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.members = new ExpandGroupResults();
        return _this;
    }
    Object.defineProperty(ExpandGroupResponse.prototype, "Members", {
        get: function () {
            return this.members;
        },
        enumerable: true,
        configurable: true
    });
    ExpandGroupResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        this.Members.LoadFromXmlJsObject(responseObject, service);
    };
    return ExpandGroupResponse;
}(ServiceResponse));
exports.ExpandGroupResponse = ExpandGroupResponse;
/**
 * @internal Represents the response to a Conversation search operation.
 *
 * @sealed
 */
var FindConversationResponse = (function (_super) {
    __extends(FindConversationResponse, _super);
    /**
     * @internal Initializes a new instance of the **FindConversationResponse** class.
     */
    function FindConversationResponse() {
        var _this = _super.call(this) || this;
        _this.Results = new FindConversationResults();
        return _this;
    }
    Object.defineProperty(FindConversationResponse.prototype, "Conversations", {
        /**
         * @internal Gets the collection of conversations in results.
         */
        get: function () {
            return this.Results.Conversations;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    FindConversationResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        EwsLogging.Assert(this.Results.Conversations != null, "FindConversationResponse.ReadElementsFromXml", "conversations is null.");
        EwsLogging.Assert(this.Results.HighlightTerms != null, "FindConversationResponse.ReadElementsFromXml", "highlightTerms is null.");
        if (responseObject[XmlElementNames.Conversations]) {
            for (var _a = 0, _b = EwsServiceJsonReader.ReadAsArray(responseObject[XmlElementNames.Conversations], XmlElementNames.Conversation); _a < _b.length; _a++) {
                var conversationObject = _b[_a];
                var jsonConversation = conversationObject; // as JsonObject;
                var item = (new ItemInfo()).CreateEwsObjectFromXmlElementName(service, XmlElementNames.Conversation);
                if (item != null) {
                    item.LoadFromXmlJsObject(jsonConversation, service, true, null, false);
                    this.Conversations.push(item);
                }
            }
        }
        if (responseObject[XmlElementNames.HighlightTerms]) {
            var highlightTermObjects = EwsServiceJsonReader.ReadAsArray(responseObject[XmlElementNames.HighlightTerms], XmlElementNames.HighlightTerm);
            if (highlightTermObjects != null) {
                for (var _c = 0, highlightTermObjects_1 = highlightTermObjects; _c < highlightTermObjects_1.length; _c++) {
                    var highlightTermObject = highlightTermObjects_1[_c];
                    var jsonHighlightTerm = highlightTermObject; // as JsonObject;
                    var term = new HighlightTerm();
                    term.LoadFromXmlJsObject(jsonHighlightTerm, service);
                    this.Results.HighlightTerms.push(term);
                }
            }
        }
        if (responseObject[XmlElementNames.TotalConversationsInView]) {
            this.Results.TotalCount = Convert.toNumber(responseObject[XmlElementNames.TotalConversationsInView]);
        }
        if (responseObject[XmlElementNames.IndexedOffset]) {
            this.Results.IndexedOffset = Convert.toNumber(responseObject[XmlElementNames.IndexedOffset]);
        }
    };
    return FindConversationResponse;
}(ServiceResponse));
exports.FindConversationResponse = FindConversationResponse;
var FindFolderResponse = (function (_super) {
    __extends(FindFolderResponse, _super);
    function FindFolderResponse(propertySet) {
        var _this = _super.call(this) || this;
        _this.results = new FindFoldersResults();
        _this.propertySet = propertySet;
        EwsLogging.Assert(_this.propertySet != null, "FindFolderResponse.ctor", "PropertySet should not be null");
        return _this;
    }
    Object.defineProperty(FindFolderResponse.prototype, "Results", {
        get: function () { return this.results; },
        enumerable: true,
        configurable: true
    });
    FindFolderResponse.prototype.CreateFolderInstance = function (service, xmlElementName) {
        var flinfo = new FolderInfo();
        return flinfo.CreateEwsObjectFromXmlElementName(service, xmlElementName);
    };
    FindFolderResponse.prototype.ReadElementsFromJson = function (responseObject, service) { throw new Error("FindFolderResponse.ts - ReadElementsFromJson : Not implemented."); };
    FindFolderResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        var _this = this;
        var rootFolder = responseObject[XmlElementNames.RootFolder];
        this.results.TotalCount = Number(rootFolder[XmlAttributeNames.TotalItemsInView]);
        this.results.MoreAvailable = !Convert.toBool(rootFolder[XmlAttributeNames.IncludesLastItemInRange]);
        // Ignore IndexedPagingOffset attribute if moreItemsAvailable is false.
        var nextPageOffset = null;
        if (this.results.MoreAvailable) {
            if (rootFolder[XmlAttributeNames.IndexedPagingOffset]) {
                nextPageOffset = Number(rootFolder[XmlAttributeNames.IndexedPagingOffset]);
            }
        }
        if (rootFolder[XmlElementNames.Folders]) {
            var folders = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson(rootFolder, service, XmlElementNames.Folders, this.CreateFolderInstance, true, /* clearPropertyBag */ this.propertySet, /* requestedPropertySet */ true); /* summaryPropertiesOnly */
            folders.forEach(function (item, index) { _this.results.Folders.push(item); });
        }
    };
    return FindFolderResponse;
}(ServiceResponse));
exports.FindFolderResponse = FindFolderResponse;
var FindItemResponse = (function (_super) {
    __extends(FindItemResponse, _super);
    function FindItemResponse(isGrouped, propertySet) {
        var _this = _super.call(this) || this;
        _this.isGrouped = false;
        _this.isGrouped = isGrouped;
        _this.propertySet = propertySet;
        EwsLogging.Assert(_this.propertySet != null, "FindItemResponse.ctor", "PropertySet should not be null");
        return _this;
    }
    Object.defineProperty(FindItemResponse.prototype, "GroupedFindResults", {
        get: function () { return this.groupedFindResults; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindItemResponse.prototype, "Results", {
        get: function () { return this.results; },
        enumerable: true,
        configurable: true
    });
    FindItemResponse.prototype.CreateItemInstance = function (service, xmlElementName) {
        var itemInfo = new ItemInfo();
        return itemInfo.CreateEwsObjectFromXmlElementName(service, xmlElementName);
        //return EwsUtilities.CreateEwsObjectFromXmlElementName<TItem>(service, xmlElementName);
    };
    FindItemResponse.prototype.InternalReadItemsFromJson = function (jsonObject /*JsonObject*/, propertySet, service, destinationList /*System.Collections.Generic.IList<TItem>*/) { throw new Error("FindItemResponse.ts - InternalReadItemsFromJson : Not implemented."); };
    FindItemResponse.prototype.InternalReadItemsFromXmlJsObject = function (jsonObject, propertySet, service, destinationList /*System.Collections.Generic.IList<TItem>*/) {
        EwsLogging.Assert(destinationList != null, "FindItemResponse.InternalReadItemsFromJson", "destinationList is null.");
        if (jsonObject[XmlElementNames.Items]) {
            var items = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson(jsonObject, service, XmlElementNames.Items, this.CreateItemInstance, true, /* clearPropertyBag */ this.propertySet, /* requestedPropertySet */ true); /* summaryPropertiesOnly */
            items.forEach(function (item, index) { destinationList.push(item); });
        }
    };
    FindItemResponse.prototype.ReadElementsFromJson = function (responseObject /*JsonObject*/, service) { throw new Error("FindItemResponse.ts - ReadElementsFromJson : Not implemented."); };
    FindItemResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        var rootFolder = responseObject[XmlElementNames.RootFolder];
        var totalItemsInView = Number(rootFolder[XmlAttributeNames.TotalItemsInView]);
        var moreItemsAvailable = !Convert.toBool(rootFolder[XmlAttributeNames.IncludesLastItemInRange]);
        // Ignore IndexedPagingOffset attribute if moreItemsAvailable is false.
        var nextPageOffset = null;
        if (moreItemsAvailable) {
            if (rootFolder[XmlAttributeNames.IndexedPagingOffset]) {
                nextPageOffset = Number(rootFolder[XmlAttributeNames.IndexedPagingOffset]);
            }
        }
        if (!this.isGrouped) {
            this.results = new FindItemsResults();
            this.results.TotalCount = totalItemsInView;
            this.results.NextPageOffset = nextPageOffset;
            this.results.MoreAvailable = moreItemsAvailable;
            this.InternalReadItemsFromXmlJsObject(rootFolder, this.propertySet, service, this.results.Items);
        }
        else {
            this.groupedFindResults = new GroupedFindItemsResults();
            this.groupedFindResults.TotalCount = totalItemsInView;
            this.groupedFindResults.NextPageOffset = nextPageOffset;
            this.groupedFindResults.MoreAvailable = moreItemsAvailable;
            if (rootFolder[XmlElementNames.Groups]) {
                var jsGroups = EwsServiceJsonReader.ReadAsArray(rootFolder, XmlElementNames.Groups);
                for (var _a = 0, jsGroups_1 = jsGroups; _a < jsGroups_1.length; _a++) {
                    var jsGroup = jsGroups_1[_a];
                    if (jsGroup[XmlElementNames.GroupedItems]) {
                        var jsGroupedItemCollection = EwsServiceJsonReader.ReadAsArray(jsGroup, XmlElementNames.GroupedItems);
                        for (var _b = 0, jsGroupedItemCollection_1 = jsGroupedItemCollection; _b < jsGroupedItemCollection_1.length; _b++) {
                            var jsGroupedItem = jsGroupedItemCollection_1[_b];
                            var groupIndex = jsGroupedItem[XmlElementNames.GroupIndex];
                            var itemList = []; // new List<TItem>();
                            this.InternalReadItemsFromXmlJsObject(jsGroupedItem, this.propertySet, service, itemList);
                            this.groupedFindResults.ItemGroups.push(new ItemGroup(groupIndex, itemList));
                        }
                    }
                }
            }
        }
        //debug: //ref: need to find example.
        //todo: check highlight terms and grouping.
        if (responseObject[XmlElementNames.HighlightTerms]) {
            var highlightTermElements = EwsServiceJsonReader.ReadAsArray(responseObject, XmlElementNames.HighlightTerms);
            for (var _c = 0, highlightTermElements_1 = highlightTermElements; _c < highlightTermElements_1.length; _c++) {
                var highlightTermElement = highlightTermElements_1[_c];
                if (highlightTermElement[XmlElementNames.HighlightTerm]) {
                    var highlightTermObjects = EwsServiceJsonReader.ReadAsArray(highlightTermElement, XmlElementNames.HighlightTerm);
                    for (var _d = 0, highlightTermObjects_2 = highlightTermObjects; _d < highlightTermObjects_2.length; _d++) {
                        var jsonHighlightTerm = highlightTermObjects_2[_d];
                        var term = new HighlightTerm();
                        term.LoadFromXmlJsObject(jsonHighlightTerm, service);
                        this.results.HighlightTerms.push(term);
                    }
                }
            }
        }
    };
    return FindItemResponse;
}(ServiceResponse));
exports.FindItemResponse = FindItemResponse;
/**
 * @internal Represents the response to a GetAppManifests operation.
 *
 * @sealed
 */
var GetAppManifestsResponse = (function (_super) {
    __extends(GetAppManifestsResponse, _super);
    /**
     * @internal Initializes a new instance of the **GetAppManifestsResponse** class.
     */
    function GetAppManifestsResponse() {
        var _this = _super.call(this) || this;
        /**
         * List of manifests returned in the response.
         */
        _this.manifests = []; //XmlDocument[]
        /**
         * List of extensions returned in the response.
         */
        _this.apps = [];
        return _this;
    }
    Object.defineProperty(GetAppManifestsResponse.prototype, "Manifests", {
        /**
         * Gets all manifests returned
         *
         * /remarks/	Provided for backwards compatibility with Exchange 2013.
         * base64 encoded xml file in string
         */
        get: function () {
            return this.manifests;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetAppManifestsResponse.prototype, "Apps", {
        /**
         * Gets all apps returned.
         *
         * /remarks/	Introduced for Exchange 2013 Sp1 to return additional metadata.
         */
        get: function () {
            return this.apps;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    GetAppManifestsResponse.prototype.ReadElementsFromXmlJsObject = function (jsObject, service) {
        this.Manifests.splice(0);
        // We can have a response from Exchange 2013 (first time this API was introduced)
        // or the newer response, starting in Exchange 2013 SP1, (X-EWS-TargetVersion: 2.5 or above) 
        var exchange2013Response = false;
        if (jsObject[XmlElementNames.Manifests]) {
            exchange2013Response = true;
        }
        else if (jsObject[XmlElementNames.Apps]) {
            exchange2013Response = false;
        }
        else {
            throw new ServiceXmlDeserializationException(StringHelper.Format(Strings.UnexpectedElement, EwsUtilities.GetNamespacePrefix(XmlNamespace.Messages), XmlElementNames.Manifests, "Element", "N/A", "N/A"));
        }
        if (exchange2013Response) {
            this.ReadFromExchange2013(jsObject, service);
        }
        else {
            this.ReadFromExchange2013Sp1(jsObject, service);
        }
    };
    /**
     * Read the response from Exchange 2013.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    GetAppManifestsResponse.prototype.ReadFromExchange2013 = function (jsObject, service) {
        ////<GetAppManifestsResponse ResponseClass="Success" xmlns="http://schemas.microsoft.com/exchange/services/2006/messages">
        ////<ResponseCode>NoError</ResponseCode>
        ////<m:Manifests xmlns:m="http://schemas.microsoft.com/exchange/services/2006/messages">   
        ////<m:Manifest>[base 64 encoded manifest]</m:Manifest>                              <--- reader should be at this node at the beginning of loop
        ////<m:Manifest>[base 64 encoded manifest]</m:Manifest>
        //// ....
        ////</m:Manifests>                                                                   <--- reader should be at this node at the end of the loop
        var responses = EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.Manifests], XmlElementNames.Manifest);
        for (var _a = 0, responses_1 = responses; _a < responses_1.length; _a++) {
            var response = responses_1[_a];
            this.manifests.push(response);
            var app = new ClientApp();
            app.Manifest = response;
            this.apps.push(app);
        }
    };
    /**
     * Read the response from Exchange 2013 SP1 and later.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    GetAppManifestsResponse.prototype.ReadFromExchange2013Sp1 = function (jsObject, service) {
        ////<GetAppManifestsResponse ResponseClass="Success" xmlns="http://schemas.microsoft.com/exchange/services/2006/messages">
        ////  <ResponseCode>NoError</ResponseCode>
        ////  <m:Apps xmlns:m="http://schemas.microsoft.com/exchange/services/2006/messages">
        ////    <t:App xmlns:t="http://schemas.microsoft.com/exchange/services/2006/types">       <--- reader should be at this node at the beginning of the loop
        ////      <t:Metadata>
        ////        <t:EndNodeUrl>http://o15.officeredir.microsoft.com/r/rlidMktplcExchRedirect?app=outlook.exe&amp;ver=15&amp;clid=1033&amp;p1=15d0d766d0&amp;p2=4&amp;p3=0&amp;p4=WA&amp;p5=en-US\WA102996382&amp;Scope=2&amp;CallBackURL=https%3a%2f%2fexhv-4880%2fecp%2fExtension%2finstallFromURL.slab%3fexsvurl%3d1&amp;DeployId=EXHV-4680dom.extest.microsoft.com</t:EndNodeUrl>
        ////        <t:AppStatus>2.3</t:AppStatus>
        ////        <t:ActionUrl>http://o15.officeredir.microsoft.com/r/rlidMktplcExchRedirect?app=outlook.exe&amp;ver=15&amp;clid=1033&amp;p1=15d0d766d0&amp;p2=4&amp;p3=0&amp;p4=WA&amp;p5=en-US\WA102996382&amp;Scope=2&amp;CallBackURL=https%3a%2f%2fexhv-4880%2fecp%2fExtension%2finstallFromURL.slab%3fexsvurl%3d1&amp;DeployId=EXHV-4680dom.extest.microsoft.com</t:ActionUrl>
        ////      </t:Metadata>
        ////      <t:Manifest>[base 64 encoded manifest]</t:Manifest>
        ////    </t:App>
        ////    <t:App xmlns:t="http://schemas.microsoft.com/exchange/services/2006/types">
        ////      ....
        ////  <m:Apps>    <----- reader should be at this node at the end of the loop
        var responses = EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.Apps], XmlElementNames.App);
        for (var _a = 0, responses_2 = responses; _a < responses_2.length; _a++) {
            var response = responses_2[_a];
            var clientApp = new ClientApp();
            clientApp.LoadFromXmlJsObject(response, service);
            this.apps.push(clientApp);
            this.manifests.push(clientApp.Manifest);
        }
    };
    return GetAppManifestsResponse;
}(ServiceResponse));
exports.GetAppManifestsResponse = GetAppManifestsResponse;
/**
 * @internal  Represents the response to a GetAppMarketplaceUrl operation
 *
 * @sealed
 */
var GetAppMarketplaceUrlResponse = (function (_super) {
    __extends(GetAppMarketplaceUrlResponse, _super);
    /**
     * @internal Initializes a new instance of the **GetAppMarketplaceUrlResponse** class.
     */
    function GetAppMarketplaceUrlResponse() {
        return _super.call(this) || this;
    }
    Object.defineProperty(GetAppMarketplaceUrlResponse.prototype, "AppMarketplaceUrl", {
        /**
         * App Marketplace Url
         */
        get: function () {
            return this.appMarketplaceUrl;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    GetAppMarketplaceUrlResponse.prototype.ReadElementsFromXmlJsObject = function (jsObject, service) {
        this.appMarketplaceUrl = jsObject[XmlElementNames.AppMarketplaceUrl];
    };
    return GetAppMarketplaceUrlResponse;
}(ServiceResponse));
exports.GetAppMarketplaceUrlResponse = GetAppMarketplaceUrlResponse;
/**
 * Represents the response to an individual attachment retrieval request.
 */
var GetAttachmentResponse = (function (_super) {
    __extends(GetAttachmentResponse, _super);
    /**
     * @internal Initializes a new instance of the **GetAttachmentResponse** class.
     *
     * @param   {Attachment}   attachment   The attachment.
     */
    function GetAttachmentResponse(attachment) {
        var _this = _super.call(this) || this;
        _this.attachment = null;
        _this.attachment = attachment;
        return _this;
    }
    Object.defineProperty(GetAttachmentResponse.prototype, "Attachment", {
        get: function () {
            return this.attachment;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from XMLJsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service          The service.
     */
    GetAttachmentResponse.prototype.ReadElementsFromXmlJsObject = function (jsObject, service) {
        if (jsObject[XmlElementNames.Attachments]) {
            var attachmentContainer = jsObject[XmlElementNames.Attachments];
            var attachment = attachmentContainer[XmlElementNames.FileAttachment] || attachmentContainer[XmlElementNames.ItemAttachment] || attachmentContainer;
            if (this.attachment == null) {
                if (attachmentContainer[XmlElementNames.FileAttachment]) {
                    this.attachment = new FileAttachment(service);
                }
                else if (attachmentContainer[XmlElementNames.ItemAttachment]) {
                    this.attachment = new ItemAttachment(service);
                }
            }
            if (this.attachment != null) {
                this.attachment.LoadFromXmlJsObject(attachment, service);
            }
        }
    };
    return GetAttachmentResponse;
}(ServiceResponse));
exports.GetAttachmentResponse = GetAttachmentResponse;
/**
 * Represents the response to a GetClientAccessToken operation.
 *
 * @sealed
 */
var GetClientAccessTokenResponse = (function (_super) {
    __extends(GetClientAccessTokenResponse, _super);
    function GetClientAccessTokenResponse(id, tokenType) {
        if (id === void 0) { id = null; }
        if (tokenType === void 0) { tokenType = ClientAccessTokenType.CallerIdentity; }
        var _this = _super.call(this) || this;
        _this.TokenValue = null;
        _this.TTL = 0;
        _this.Id = id;
        _this.TokenType = tokenType;
        return _this;
    }
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    GetClientAccessTokenResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        if (responseObject[XmlElementNames.Token]) {
            var jsObject = responseObject[XmlElementNames.Token];
            this.Id = jsObject[XmlElementNames.Id];
            this.TokenType = ClientAccessTokenType[jsObject[XmlElementNames.TokenType]];
            this.TokenValue = jsObject[XmlElementNames.TokenValue];
            this.TTL = Convert.toNumber(jsObject[XmlElementNames.TTL]);
        }
    };
    return GetClientAccessTokenResponse;
}(ServiceResponse));
exports.GetClientAccessTokenResponse = GetClientAccessTokenResponse;
/**
 * ## *Not Implemented*
 */
var GetClientExtensionResponse = (function (_super) {
    __extends(GetClientExtensionResponse, _super);
    function GetClientExtensionResponse() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**@internal */
    GetClientExtensionResponse.prototype.ReadElementsFromXmlJsObject = function (reader) { throw new Error("GetClientExtensionResponse.ts - ReadElementsFromXmlJsObject : Not implemented."); };
    return GetClientExtensionResponse;
}(ServiceResponse));
exports.GetClientExtensionResponse = GetClientExtensionResponse;
/**
 * Represents the response to a GetConversationItems operation.
 *
 * @sealed
 */
var GetConversationItemsResponse = (function (_super) {
    __extends(GetConversationItemsResponse, _super);
    /**
     * @internal Initializes a new instance of the **GetConversationItemsResponse** class.
     *
     * @param   {PropertySet}   propertySet   The property set.
     */
    function GetConversationItemsResponse(propertySet) {
        var _this = _super.call(this) || this;
        _this.propertySet = propertySet;
        return _this;
    }
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    GetConversationItemsResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        this.Conversation = new ConversationResponse(this.propertySet);
        this.Conversation.LoadFromXmlJsObject(responseObject[XmlElementNames.Conversation], service);
    };
    return GetConversationItemsResponse;
}(ServiceResponse));
exports.GetConversationItemsResponse = GetConversationItemsResponse;
/**
 * Represents the GetDiscoverySearchConfiguration response.
 *
 * @sealed
 */
var GetDiscoverySearchConfigurationResponse = (function (_super) {
    __extends(GetDiscoverySearchConfigurationResponse, _super);
    /**
     * @internal Initializes a new instance of the **GetDiscoverySearchConfigurationResponse** class.
     */
    function GetDiscoverySearchConfigurationResponse() {
        var _this = _super.call(this) || this;
        _this.configurations = [];
        return _this;
    }
    Object.defineProperty(GetDiscoverySearchConfigurationResponse.prototype, "DiscoverySearchConfigurations", {
        /**
         * Searchable mailboxes result
         */
        get: function () {
            return this.configurations;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    GetDiscoverySearchConfigurationResponse.prototype.ReadElementsFromXmlJsObject = function (jsObject, service) {
        this.configurations.splice(0);
        //super.ReadElementsFromXmlJsObject(jsObject, service);
        if (jsObject[XmlElementNames.DiscoverySearchConfigurations]) {
            for (var _a = 0, _b = EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.DiscoverySearchConfigurations], XmlElementNames.DiscoverySearchConfiguration); _a < _b.length; _a++) {
                var searchConfiguration = _b[_a];
                this.configurations.push(DiscoverySearchConfiguration.LoadFromXmlJsObject(searchConfiguration, service));
            }
        }
    };
    return GetDiscoverySearchConfigurationResponse;
}(ServiceResponse));
exports.GetDiscoverySearchConfigurationResponse = GetDiscoverySearchConfigurationResponse;
/**
 * ## *Not Implemented*
 */
var GetEncryptionConfigurationResponse = (function (_super) {
    __extends(GetEncryptionConfigurationResponse, _super);
    function GetEncryptionConfigurationResponse() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**@internal */
    GetEncryptionConfigurationResponse.prototype.ReadElementsFromXmlJsObject = function (reader) { throw new Error("GetEncryptionConfigurationResponse.ts - ReadElementsFromXmlJsObject : Not implemented."); };
    return GetEncryptionConfigurationResponse;
}(ServiceResponse));
exports.GetEncryptionConfigurationResponse = GetEncryptionConfigurationResponse;
/**
 * @internal Represents the response to a subscription event retrieval operation.
 *
 * @sealed
 */
var GetEventsResponse = (function (_super) {
    __extends(GetEventsResponse, _super);
    /**
     * @internal Initializes a new instance of the **GetEventsResponse** class.
     */
    function GetEventsResponse() {
        var _this = _super.call(this) || this;
        _this.results = new GetEventsResults();
        return _this;
    }
    Object.defineProperty(GetEventsResponse.prototype, "Results", {
        /**
         * @internal Gets event results from subscription.
         */
        get: function () {
            return this.results;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    GetEventsResponse.prototype.ReadElementsFromXmlJsObject = function (jsObject, service) {
        this.results.LoadFromXmlJsObject(jsObject, service);
    };
    return GetEventsResponse;
}(ServiceResponse));
exports.GetEventsResponse = GetEventsResponse;
var GetFolderResponse = (function (_super) {
    __extends(GetFolderResponse, _super);
    function GetFolderResponse(folder, propertySet) {
        var _this = _super.call(this) || this;
        _this.folder = folder;
        _this.propertySet = propertySet;
        EwsLogging.Assert(_this.propertySet != null, "GetFolderResponse.ctor", "PropertySet should not be null");
        return _this;
    }
    Object.defineProperty(GetFolderResponse.prototype, "Folder", {
        get: function () { return this.folder; },
        enumerable: true,
        configurable: true
    });
    GetFolderResponse.prototype.GetObjectInstance = function (service, xmlElementName) {
        if (this.Folder != null) {
            return this.Folder;
        }
        else {
            var flinfo = new FolderInfo();
            return flinfo.CreateEwsObjectFromXmlElementName(service, xmlElementName);
        }
    };
    GetFolderResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        if (responseObject[XmlElementNames.Folders]) {
            var folders = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson(responseObject, service, XmlElementNames.Folders, this.GetObjectInstance.bind(this), true, /* clearPropertyBag */ this.propertySet, /* requestedPropertySet */ false); /* summaryPropertiesOnly */
            this.folder = folders[0];
        }
    };
    return GetFolderResponse;
}(ServiceResponse));
exports.GetFolderResponse = GetFolderResponse;
/**
 * Represents the GetHoldOnMailboxes response.
 *
 * @sealed
 */
var GetHoldOnMailboxesResponse = (function (_super) {
    __extends(GetHoldOnMailboxesResponse, _super);
    /**
     * @internal Initializes a new instance of the **GetHoldOnMailboxesResponse** class.
     */
    function GetHoldOnMailboxesResponse() {
        var _this = _super.call(this) || this;
        _this.holdResult = null;
        return _this;
    }
    Object.defineProperty(GetHoldOnMailboxesResponse.prototype, "HoldResult", {
        /**
         * Mailbox hold result
         */
        get: function () {
            return this.holdResult;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    GetHoldOnMailboxesResponse.prototype.ReadElementsFromXmlJsObject = function (jsObject, service) {
        //super.ReadElementsFromXmlJsObject(jsObject, service);
        if (jsObject[XmlElementNames.MailboxHoldResult]) {
            this.holdResult = MailboxHoldResult.LoadFromXmlJsObject(jsObject[XmlElementNames.MailboxHoldResult], service);
        }
    };
    return GetHoldOnMailboxesResponse;
}(ServiceResponse));
exports.GetHoldOnMailboxesResponse = GetHoldOnMailboxesResponse;
/**
 * @internal Represents the response to a GetInboxRules operation.
 *
 * @sealed
 */
var GetInboxRulesResponse = (function (_super) {
    __extends(GetInboxRulesResponse, _super);
    /**
     * @internal Initializes a new instance of the **GetInboxRulesResponse** class.
     */
    function GetInboxRulesResponse() {
        var _this = _super.call(this) || this;
        _this.ruleCollection = new RuleCollection();
        return _this;
    }
    Object.defineProperty(GetInboxRulesResponse.prototype, "Rules", {
        /**
         * @internal Gets the rule collection in the response.
         */
        get: function () {
            return this.ruleCollection;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    GetInboxRulesResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        this.ruleCollection.OutlookRuleBlobExists = Convert.toBool(responseObject[XmlElementNames.OutlookRuleBlobExists]);
        if (responseObject[XmlElementNames.InboxRules]) {
            this.ruleCollection.LoadFromXmlJsObject(responseObject[XmlElementNames.InboxRules], service);
        }
    };
    return GetInboxRulesResponse;
}(ServiceResponse));
exports.GetInboxRulesResponse = GetInboxRulesResponse;
var GetItemResponse = (function (_super) {
    __extends(GetItemResponse, _super);
    function GetItemResponse(item, propertySet) {
        var _this = _super.call(this) || this;
        _this.item = null;
        _this.propertySet = null;
        _this.item = item;
        _this.propertySet = propertySet;
        EwsLogging.Assert(_this.propertySet !== null, "GetItemResponse.ctor", "PropertySet should not be null");
        return _this;
    }
    Object.defineProperty(GetItemResponse.prototype, "Item", {
        get: function () {
            return this.item;
        },
        enumerable: true,
        configurable: true
    });
    GetItemResponse.prototype.GetObjectInstance = function (service, xmlElementName) {
        if (this.Item != null) {
            return this.Item;
        }
        else {
            return new ItemInfo().CreateEwsObjectFromXmlElementName(service, xmlElementName);
        }
    };
    //ReadElementsFromJson(responseObject: any, service: ExchangeService): any { throw new Error("GetItemResponse.ts - ReadElementsFromJson : Not implemented."); }
    GetItemResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        var _this = this;
        var items = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson(responseObject, service, XmlElementNames.Items, function (s, e) { return _this.GetObjectInstance(s, e); }, true, /* clearPropertyBag         */ this.propertySet, /* requestedPropertySet     */ false); /* summaryPropertiesOnly    */
        this.item = items[0];
    };
    return GetItemResponse;
}(ServiceResponse));
exports.GetItemResponse = GetItemResponse;
/**
 * Represents the GetNonIndexableItemDetails response.
 *
 * @sealed
 */
var GetNonIndexableItemDetailsResponse = (function (_super) {
    __extends(GetNonIndexableItemDetailsResponse, _super);
    /**
     * @internal Initializes a new instance of the **GetDiscoverySearchConfigurationResponse** class.
     */
    function GetNonIndexableItemDetailsResponse() {
        var _this = _super.call(this) || this;
        /**
         * Non indexable item result
         *
         * internal set
         */
        _this.NonIndexableItemsResult = null;
        return _this;
    }
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    GetNonIndexableItemDetailsResponse.prototype.ReadElementsFromXmlJsObject = function (jsObject, service) {
        //super.ReadElementsFromXmlJsObject(jsObject,service);
        if (jsObject[XmlElementNames.NonIndexableItemDetailsResult]) {
            this.NonIndexableItemsResult = NonIndexableItemDetailsResult.LoadFromXmlJsObject(jsObject[XmlElementNames.NonIndexableItemDetailsResult], service);
        }
    };
    return GetNonIndexableItemDetailsResponse;
}(ServiceResponse));
exports.GetNonIndexableItemDetailsResponse = GetNonIndexableItemDetailsResponse;
/**
 * Represents the GetNonIndexableItemStatistics response.
 *
 * @sealed
 */
var GetNonIndexableItemStatisticsResponse = (function (_super) {
    __extends(GetNonIndexableItemStatisticsResponse, _super);
    /**
     * @internal Initializes a new instance of the **GetNonIndexableItemStatisticsResponse** class.
     */
    function GetNonIndexableItemStatisticsResponse() {
        var _this = _super.call(this) || this;
        /**
         * List of non indexable statistic
         */
        _this.NonIndexableStatistics = null;
        return _this;
    }
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    GetNonIndexableItemStatisticsResponse.prototype.ReadElementsFromXmlJsObject = function (jsObject, service) {
        //super.ReadElementsFromXmlJsObject(jsObject,service);
        this.NonIndexableStatistics = [];
        if (jsObject[XmlElementNames.NonIndexableItemStatistics]) {
            for (var _a = 0, _b = EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.NonIndexableItemStatistics], XmlElementNames.NonIndexableItemStatistic); _a < _b.length; _a++) {
                var nonIndexableItemStatistic = _b[_a];
                this.NonIndexableStatistics.push(NonIndexableItemStatistic.LoadFromXmlJsObject(nonIndexableItemStatistic, service));
            }
        }
    };
    return GetNonIndexableItemStatisticsResponse;
}(ServiceResponse));
exports.GetNonIndexableItemStatisticsResponse = GetNonIndexableItemStatisticsResponse;
var GetPasswordExpirationDateResponse = (function (_super) {
    __extends(GetPasswordExpirationDateResponse, _super);
    function GetPasswordExpirationDateResponse() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.passwordExpirationDate = null;
        return _this;
    }
    Object.defineProperty(GetPasswordExpirationDateResponse.prototype, "PasswordExpirationDate", {
        get: function () {
            return this.passwordExpirationDate;
        },
        enumerable: true,
        configurable: true
    });
    GetPasswordExpirationDateResponse.prototype.ReadElementsFromJson = function (responseObject, service) { throw new Error("GetPasswordExpirationDateResponse.ts - ReadElementsFromJson : Not implemented."); };
    GetPasswordExpirationDateResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        this.passwordExpirationDate = service.ConvertUniversalDateTimeStringToLocalDateTime(responseObject[XmlElementNames.PasswordExpirationDate]);
    };
    return GetPasswordExpirationDateResponse;
}(ServiceResponse));
exports.GetPasswordExpirationDateResponse = GetPasswordExpirationDateResponse;
/**
 * ## *Not Implemented*
 */
var GetPhoneCallResponse = (function (_super) {
    __extends(GetPhoneCallResponse, _super);
    function GetPhoneCallResponse() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**@internal */
    GetPhoneCallResponse.prototype.ReadElementsFromXmlJsObject = function (reader) { throw new Error("GetPhoneCallResponse.ts - ReadElementsFromXmlJsObject : Not implemented."); };
    return GetPhoneCallResponse;
}(ServiceResponse));
exports.GetPhoneCallResponse = GetPhoneCallResponse;
/**
 * @internal Represents the response to a GetRoomLists operation.
 */
var GetRoomListsResponse = (function (_super) {
    __extends(GetRoomListsResponse, _super);
    /**
     * @internal Initializes a new instance of the **GetRoomListsResponse** class.
     */
    function GetRoomListsResponse() {
        var _this = _super.call(this) || this;
        _this.roomLists = new EmailAddressCollection();
        return _this;
    }
    Object.defineProperty(GetRoomListsResponse.prototype, "RoomLists", {
        /**
         * Gets all room list returned
         */
        get: function () {
            return this.roomLists;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    GetRoomListsResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        this.roomLists.Clear();
        var responses = EwsServiceJsonReader.ReadAsArray(responseObject[XmlElementNames.RoomLists], XmlElementNames.Address);
        for (var _a = 0, responses_3 = responses; _a < responses_3.length; _a++) {
            var response = responses_3[_a];
            var emailAddress = new EmailAddress();
            emailAddress.LoadFromXmlJsObject(response, service);
            this.roomLists.Add(emailAddress);
        }
    };
    return GetRoomListsResponse;
}(ServiceResponse));
exports.GetRoomListsResponse = GetRoomListsResponse;
/**
 * @internal Represents the response to a GetRooms operation.
 *
 * @sealed
 */
var GetRoomsResponse = (function (_super) {
    __extends(GetRoomsResponse, _super);
    /**
     * @internal Initializes a new instance of the **GetRoomsResponse** class.
     */
    function GetRoomsResponse() {
        var _this = _super.call(this) || this;
        _this.rooms = [];
        return _this;
    }
    Object.defineProperty(GetRoomsResponse.prototype, "Rooms", {
        /**
         * Gets collection for all rooms returned
         */
        get: function () {
            return this.rooms;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    GetRoomsResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        this.rooms.splice(0);
        var responses = EwsServiceJsonReader.ReadAsArray(responseObject[XmlElementNames.Rooms], XmlElementNames.Room);
        for (var _a = 0, responses_4 = responses; _a < responses_4.length; _a++) {
            var response = responses_4[_a];
            var emailAddress = new EmailAddress();
            emailAddress.LoadFromXmlJsObject(response[XmlElementNames.RoomId], service);
            this.rooms.push(emailAddress);
        }
    };
    return GetRoomsResponse;
}(ServiceResponse));
exports.GetRoomsResponse = GetRoomsResponse;
/**
 * Represents the GetSearchableMailboxes response.
 *
 * @sealed
 */
var GetSearchableMailboxesResponse = (function (_super) {
    __extends(GetSearchableMailboxesResponse, _super);
    /**
     * @internal Initializes a new instance of the **GetSearchableMailboxesResponse** class.
     */
    function GetSearchableMailboxesResponse() {
        var _this = _super.call(this) || this;
        _this.searchableMailboxes = [];
        /**
         * Failed mailboxes
         */
        _this.FailedMailboxes = null;
        return _this;
    }
    Object.defineProperty(GetSearchableMailboxesResponse.prototype, "SearchableMailboxes", {
        /**
         * Searchable mailboxes result
         */
        get: function () {
            return this.searchableMailboxes;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    GetSearchableMailboxesResponse.prototype.ReadElementsFromXmlJsObject = function (jsObject, service) {
        this.searchableMailboxes.splice(0);
        //super.ReadElementsFromXmlJsObject(jsObject, service);
        if (jsObject[XmlElementNames.SearchableMailboxes]) {
            for (var _a = 0, _b = EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.SearchableMailboxes], XmlElementNames.SearchableMailbox); _a < _b.length; _a++) {
                var searchableMailboxObject = _b[_a];
                this.searchableMailboxes.push(SearchableMailbox.LoadFromXmlJsObject(searchableMailboxObject, service));
            }
        }
        if (jsObject[XmlElementNames.FailedMailboxes]) {
            this.FailedMailboxes = FailedSearchMailbox.LoadFromXmlJsObject(jsObject[XmlElementNames.FailedMailboxes], service);
        }
    };
    return GetSearchableMailboxesResponse;
}(ServiceResponse));
exports.GetSearchableMailboxesResponse = GetSearchableMailboxesResponse;
/**
 * internal Represents the response to a GetServerTimeZones request.
 */
var GetServerTimeZonesResponse = (function (_super) {
    __extends(GetServerTimeZonesResponse, _super);
    /**
     * @internal Initializes a new instance of the **GetServerTimeZonesResponse** class.
     */
    function GetServerTimeZonesResponse() {
        var _this = _super.call(this) || this;
        _this.timeZones = [];
        return _this;
    }
    Object.defineProperty(GetServerTimeZonesResponse.prototype, "TimeZones", {
        /**
         * Gets the time zones returned by the associated GetServerTimeZones request.
         * @value   The time zones.
         */
        get: function () {
            return this.timeZones;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    GetServerTimeZonesResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        if (responseObject[XmlElementNames.TimeZoneDefinitions]) {
            for (var _a = 0, _b = EwsServiceJsonReader.ReadAsArray(responseObject[XmlElementNames.TimeZoneDefinitions], XmlElementNames.TimeZoneDefinition); _a < _b.length; _a++) {
                var tzObject = _b[_a];
                var timeZoneDefinition = new TimeZoneDefinition();
                timeZoneDefinition.LoadFromXmlJsObject(tzObject, service);
                this.timeZones.push(timeZoneDefinition.ToTimeZoneInfo(service, true));
            }
        }
    };
    return GetServerTimeZonesResponse;
}(ServiceResponse));
exports.GetServerTimeZonesResponse = GetServerTimeZonesResponse;
/**
 * Enumeration of ConnectionStatus that can be returned by the server.
 */
var ConnectionStatus;
(function (ConnectionStatus) {
    ConnectionStatus[ConnectionStatus["OK"] = 0] = "OK";
    ConnectionStatus[ConnectionStatus["Closed"] = 1] = "Closed";
})(ConnectionStatus || (ConnectionStatus = {}));
/**
 * @internal Represents the response to a subscription event retrieval operation.
 *
 * @sealed
 */
var GetStreamingEventsResponse = (function (_super) {
    __extends(GetStreamingEventsResponse, _super);
    /**
     * Initializes a new instance of the **GetStreamingEventsResponse** class.
     *
     * @param   {HangingServiceRequestBase}   request   Request to disconnect when we get a close message.
     */
    function GetStreamingEventsResponse(request) {
        var _this = _super.call(this) || this;
        _this.results = new GetStreamingEventsResults();
        _this.request = null;
        /**
         * Gets the error subscription ids.
         *
         * @private set
         * @value	The error subscription ids.
         */
        _this.ErrorSubscriptionIds = [];
        _this.ErrorSubscriptionIds = [];
        _this.request = request;
        return _this;
    }
    Object.defineProperty(GetStreamingEventsResponse.prototype, "Results", {
        /**
         * Gets event results from subscription.
         */
        get: function () {
            return this.results;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads extra error details from XML
     *
     * @param   {any}   			responseObject      Json Object converted from XML.
     * @param   {ExchangeService}   service             The service.
     */
    GetStreamingEventsResponse.prototype.LoadExtraErrorDetailsFromXmlJsObject = function (responseObject, service) {
        var _this = this;
        _super.prototype.LoadExtraErrorDetailsFromXmlJsObject.call(this, responseObject, service);
        if (responseObject[XmlElementNames.ErrorSubscriptionIds]) {
            var errorSubscriptionIds = responseObject[XmlElementNames.ErrorSubscriptionIds];
            if (errorSubscriptionIds[XmlElementNames.SubscriptionId]) {
                var subscriptionIds = EwsServiceJsonReader.ReadAsArray(errorSubscriptionIds, XmlElementNames.SubscriptionId);
                subscriptionIds.forEach(function (subscriptionId) {
                    _this.ErrorSubscriptionIds.push(subscriptionId);
                });
            }
        }
    };
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    GetStreamingEventsResponse.prototype.ReadElementsFromXmlJsObject = function (jsObject, service) {
        if (jsObject[XmlElementNames.Notifications]) {
            this.results.LoadFromXmlJsObject(jsObject[XmlElementNames.Notifications], service);
        }
        if (jsObject[XmlElementNames.ConnectionStatus]) {
            var connectionStatus = jsObject[XmlElementNames.ConnectionStatus];
            if (connectionStatus === ConnectionStatus[ConnectionStatus.Closed]) {
                this.request.Disconnect(HangingRequestDisconnectReason.Clean, null);
            }
        }
    };
    return GetStreamingEventsResponse;
}(ServiceResponse));
exports.GetStreamingEventsResponse = GetStreamingEventsResponse;
/**
 * @internal Represents a response to a GetUserConfiguration request.
 *
 * @sealed
 */
var GetUserConfigurationResponse = (function (_super) {
    __extends(GetUserConfigurationResponse, _super);
    /**
     * @internal Initializes a new instance of the **GetUserConfigurationResponse** class.
     *
     * @param   {UserConfiguration}   userConfiguration   The userConfiguration.
     */
    function GetUserConfigurationResponse(userConfiguration) {
        var _this = _super.call(this) || this;
        _this.userConfiguration = null;
        EwsLogging.Assert(userConfiguration !== null, "GetUserConfigurationResponse.ctor", "userConfiguration is null");
        _this.userConfiguration = userConfiguration;
        return _this;
    }
    Object.defineProperty(GetUserConfigurationResponse.prototype, "UserConfiguration", {
        /**
         * Gets the user configuration that was created.
         */
        get: function () {
            return this.userConfiguration;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from XML parsed to JS Object.
     *
     * @param   {any}               responseObject   The response object.
     * @param   {ExchangeService}   service          The service.
     */
    GetUserConfigurationResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        this.UserConfiguration.LoadFromXmlJsObject(responseObject[XmlElementNames.UserConfiguration], service);
    };
    return GetUserConfigurationResponse;
}(ServiceResponse));
exports.GetUserConfigurationResponse = GetUserConfigurationResponse;
/**
 * @internal Represents response to GetUserOofSettings request.
 */
var GetUserOofSettingsResponse = (function (_super) {
    __extends(GetUserOofSettingsResponse, _super);
    /**
     * @internal Initializes a new instance of the **GetUserOofSettingsResponse** class.
     */
    function GetUserOofSettingsResponse() {
        var _this = _super.call(this) || this;
        _this.oofSettings = null;
        return _this;
    }
    Object.defineProperty(GetUserOofSettingsResponse.prototype, "OofSettings", {
        /**
         * Gets or sets the OOF settings.
         *
         * @value The oof settings.
         */
        get: function () {
            return this.oofSettings;
        },
        set: function (value) {
            this.oofSettings = value;
        },
        enumerable: true,
        configurable: true
    });
    return GetUserOofSettingsResponse;
}(ServiceResponse));
exports.GetUserOofSettingsResponse = GetUserOofSettingsResponse;
/**
 * Represents the GetUserRetentionPolicyTagsResponse response.
 *
 * @sealed
 */
var GetUserRetentionPolicyTagsResponse = (function (_super) {
    __extends(GetUserRetentionPolicyTagsResponse, _super);
    /**
     * @internal Initializes a new instance of the **GetUserRetentionPolicyTagsResponse** class.
     */
    function GetUserRetentionPolicyTagsResponse() {
        var _this = _super.call(this) || this;
        _this.retentionPolicyTags = [];
        return _this;
    }
    Object.defineProperty(GetUserRetentionPolicyTagsResponse.prototype, "RetentionPolicyTags", {
        /**
         * Retention policy tags result.
         */
        get: function () {
            return this.retentionPolicyTags;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    GetUserRetentionPolicyTagsResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        this.retentionPolicyTags.splice(0);
        if (responseObject[XmlElementNames.RetentionPolicyTags]) {
            for (var _a = 0, _b = EwsServiceJsonReader.ReadAsArray(responseObject[XmlElementNames.RetentionPolicyTags], XmlElementNames.RetentionPolicyTag); _a < _b.length; _a++) {
                var retentionPolicyTagObject = _b[_a];
                this.retentionPolicyTags.push(RetentionPolicyTag.LoadFromXmlJsObject(retentionPolicyTagObject));
            }
        }
    };
    return GetUserRetentionPolicyTagsResponse;
}(ServiceResponse));
exports.GetUserRetentionPolicyTagsResponse = GetUserRetentionPolicyTagsResponse;
/**
 * @internal  Represents the response to a InstallApp operation.
 * Today this class doesn't add extra functionality. Keep this class here so future we can return extension info up-on installation complete.
 *
 * @sealed
 */
var InstallAppResponse = (function (_super) {
    __extends(InstallAppResponse, _super);
    /**
     * @internal Initializes a new instance of the **InstallAppResponse** class.
     */
    function InstallAppResponse() {
        return _super.call(this) || this;
    }
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    InstallAppResponse.prototype.ReadElementsFromXmlJsObject = function (jsObject, service) {
        //does nothing, here to supress base class message about ReadElementsFromXmlJsObject when BatchProcessingStopped is false
    };
    return InstallAppResponse;
}(ServiceResponse));
exports.InstallAppResponse = InstallAppResponse;
var MarkAsJunkResponse = (function (_super) {
    __extends(MarkAsJunkResponse, _super);
    function MarkAsJunkResponse() {
        var _this = _super.call(this) || this;
        _this.MovedItemId = null;
        return _this;
    }
    //ReadElementsFromJson(responseObject: any, service: ExchangeService): any { throw new Error("MarkAsJunkResponse.ts - ReadElementsFromJson : Not implemented."); }
    MarkAsJunkResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        if (responseObject[XmlElementNames.Token]) {
            this.MovedItemId = new ItemId();
            this.MovedItemId.LoadFromXmlJsObject(responseObject[XmlElementNames.MovedItemId], service);
        }
    };
    return MarkAsJunkResponse;
}(ServiceResponse));
exports.MarkAsJunkResponse = MarkAsJunkResponse;
var MoveCopyFolderResponse = (function (_super) {
    __extends(MoveCopyFolderResponse, _super);
    function MoveCopyFolderResponse() {
        var _this = _super.call(this) || this;
        _this.folder = null;
        return _this;
    }
    Object.defineProperty(MoveCopyFolderResponse.prototype, "Folder", {
        get: function () {
            return this.folder;
        },
        enumerable: true,
        configurable: true
    });
    MoveCopyFolderResponse.prototype.GetObjectInstance = function (service, xmlElementName) {
        var flinfo = new FolderInfo();
        return flinfo.CreateEwsObjectFromXmlElementName(service, xmlElementName);
    };
    MoveCopyFolderResponse.prototype.ReadElementsFromJson = function (responseObject, service) { throw new Error("MoveCopyFolderResponse.ts - ReadElementsFromJson : Not implemented."); };
    MoveCopyFolderResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        if (responseObject[XmlElementNames.Folders]) {
            //debug: check if this works
            var folders = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson(responseObject, service, XmlElementNames.Folders, this.GetObjectInstance.bind(this), false, /* clearPropertyBag */ null, /* requestedPropertySet */ false); /* summaryPropertiesOnly */
            this.folder = folders[0];
        }
    };
    return MoveCopyFolderResponse;
}(ServiceResponse));
exports.MoveCopyFolderResponse = MoveCopyFolderResponse;
/**
 * Represents a response to a Move or Copy operation.
 *
 */
var MoveCopyItemResponse = (function (_super) {
    __extends(MoveCopyItemResponse, _super);
    /**
     * @internal Initializes a new instance of the *MoveCopyItemResponse* class.
     *
     */
    function MoveCopyItemResponse() {
        var _this = _super.call(this) || this;
        _this.item = null;
        return _this;
    }
    Object.defineProperty(MoveCopyItemResponse.prototype, "Item", {
        /**
         * Gets the copied or moved item. Item is null if the copy or move operation was between two mailboxes or between a mailbox and a public folder.
         *
         */
        get: function () {
            return this.item;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets Item instance.
     *
     * @param   {ExchangeService}   service          The service.
     * @param   {string}            xmlElementName   Name of the XML element.
     * @return  {Item}              Item.
     */
    MoveCopyItemResponse.prototype.GetObjectInstance = function (service, xmlElementName) {
        var itemInfo = new ItemInfo();
        return itemInfo.CreateEwsObjectFromXmlElementName(service, xmlElementName);
    };
    /**
     * @internal Reads response elements from XML parsed to JS Object.
     *
     * @param   {any}               responseObject   The response object.
     * @param   {ExchangeService}   service          The service.
     */
    MoveCopyItemResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        if (responseObject[XmlElementNames.Items]) {
            //debug: check if this works
            var items = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson(responseObject, service, XmlElementNames.Items, this.GetObjectInstance.bind(this), false, /* clearPropertyBag */ null, /* requestedPropertySet */ false); /* summaryPropertiesOnly */
            // We only receive the copied or moved items if the copy or move operation was within
            // a single mailbox. No item is returned if the operation is cross-mailbox, from a
            // mailbox to a public folder or from a public folder to a mailbox.
            this.item = items[0];
        }
    };
    return MoveCopyItemResponse;
}(ServiceResponse));
exports.MoveCopyItemResponse = MoveCopyItemResponse;
/**
 * ## *Not Implemented*
 */
var PlayOnPhoneResponse = (function (_super) {
    __extends(PlayOnPhoneResponse, _super);
    function PlayOnPhoneResponse() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PlayOnPhoneResponse.prototype.ReadElementsFromJson = function (responseObject, service) { throw new Error("PlayOnPhoneResponse.ts - ReadElementsFromJson : Not implemented."); };
    /**@internal */
    PlayOnPhoneResponse.prototype.ReadElementsFromXmlJsObject = function (reader) { throw new Error("PlayOnPhoneResponse.ts - ReadElementsFromXmlJsObject : Not implemented."); };
    return PlayOnPhoneResponse;
}(ServiceResponse));
exports.PlayOnPhoneResponse = PlayOnPhoneResponse;
var ResolveNamesResponse = (function (_super) {
    __extends(ResolveNamesResponse, _super);
    function ResolveNamesResponse(service) {
        var _this = _super.call(this) || this;
        _this.resolutions = null;
        EwsLogging.Assert(service !== null, "ResolveNamesResponse.ctor", "service is null");
        _this.resolutions = new NameResolutionCollection(service);
        return _this;
    }
    Object.defineProperty(ResolveNamesResponse.prototype, "Resolutions", {
        get: function () {
            return this.resolutions;
        },
        enumerable: true,
        configurable: true
    });
    ResolveNamesResponse.prototype.InternalThrowIfNecessary = function () {
        if (this.ErrorCode != ServiceError.ErrorNameResolutionNoResults) {
            _super.prototype.InternalThrowIfNecessary.call(this);
        }
    };
    ResolveNamesResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        this.Resolutions.LoadFromXmlJsObject(responseObject[XmlElementNames.ResolutionSet], service);
    };
    return ResolveNamesResponse;
}(ServiceResponse));
exports.ResolveNamesResponse = ResolveNamesResponse;
/**
 * Represents the SearchMailboxes response.
 *
 * @sealed
 */
var SearchMailboxesResponse = (function (_super) {
    __extends(SearchMailboxesResponse, _super);
    /**
     * @internal Initializes a new instance of the **SearchMailboxesResponse** class.
     */
    function SearchMailboxesResponse() {
        var _this = _super.call(this) || this;
        _this.searchResult = null;
        return _this;
    }
    Object.defineProperty(SearchMailboxesResponse.prototype, "SearchResult", {
        /**
         * Search mailboxes result
         */
        get: function () {
            return this.searchResult;
        },
        /**@internal set*/
        set: function (value) {
            this.searchResult = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    SearchMailboxesResponse.prototype.ReadElementsFromXmlJsObject = function (jsObject, service) {
        //super.ReadElementsFromXmlJsObject(jsObject, service);
        if (jsObject[XmlElementNames.SearchMailboxesResult]) {
            this.searchResult = SearchMailboxesResult.LoadFromXmlJsObject(jsObject[XmlElementNames.SearchMailboxesResult], service);
        }
    };
    return SearchMailboxesResponse;
}(ServiceResponse));
exports.SearchMailboxesResponse = SearchMailboxesResponse;
/**
 * ## *Not Implemented*
 */
var SetEncryptionConfigurationResponse = (function (_super) {
    __extends(SetEncryptionConfigurationResponse, _super);
    function SetEncryptionConfigurationResponse() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SetEncryptionConfigurationResponse;
}(ServiceResponse));
exports.SetEncryptionConfigurationResponse = SetEncryptionConfigurationResponse;
/**
 * Represents the SetHoldOnMailboxes response.
 *
 * @sealed
 */
var SetHoldOnMailboxesResponse = (function (_super) {
    __extends(SetHoldOnMailboxesResponse, _super);
    /**
     * @internal Initializes a new instance of the **SetHoldOnMailboxesResponse** class.
     */
    function SetHoldOnMailboxesResponse() {
        var _this = _super.call(this) || this;
        _this.holdResult = null;
        return _this;
    }
    Object.defineProperty(SetHoldOnMailboxesResponse.prototype, "HoldResult", {
        /**
         * Mailbox hold result
         */
        get: function () {
            return this.holdResult;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    SetHoldOnMailboxesResponse.prototype.ReadElementsFromXmlJsObject = function (jsObject, service) {
        _super.prototype.ReadElementsFromXmlJsObject.call(this, jsObject, service);
        if (jsObject[XmlElementNames.MailboxHoldResult]) {
            this.holdResult = MailboxHoldResult.LoadFromXmlJsObject(jsObject[XmlElementNames.MailboxHoldResult], service);
        }
    };
    return SetHoldOnMailboxesResponse;
}(ServiceResponse));
exports.SetHoldOnMailboxesResponse = SetHoldOnMailboxesResponse;
/**
 * @internal Represents the base response class to subscription creation operations.
 *
 * @sealed
 * @typeparam	{TSubscription}		The type of the subscription.
 */
var SubscribeResponse = (function (_super) {
    __extends(SubscribeResponse, _super);
    /**
     * @internal Initializes a new instance of the **SubscribeResponse<TSubscription>** class.
     *
     * @param   {TSubscription}   subscription   The subscription.
     */
    function SubscribeResponse(subscription) {
        var _this = _super.call(this) || this;
        EwsLogging.Assert(subscription != null, "SubscribeResponse.ctor", "subscription is null");
        _this.subscription = subscription;
        return _this;
    }
    Object.defineProperty(SubscribeResponse.prototype, "Subscription", {
        /**
         * Gets the subscription that was created.
         */
        get: function () {
            return this.subscription;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               responseObject      The response object.
     * @param   {ExchangeService}   service             The service.
     */
    SubscribeResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        this.subscription.LoadFromXmlJsObject(responseObject, service);
    };
    return SubscribeResponse;
}(ServiceResponse));
exports.SubscribeResponse = SubscribeResponse;
var SuggestionsResponse = (function (_super) {
    __extends(SuggestionsResponse, _super);
    function SuggestionsResponse() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.daySuggestions = []; //System.Collections.ObjectModel.Collection<Suggestion>;
        return _this;
    }
    Object.defineProperty(SuggestionsResponse.prototype, "Suggestions", {
        get: function () { return this.daySuggestions; } //System.Collections.ObjectModel.Collection<Suggestion>;
        ,
        enumerable: true,
        configurable: true
    });
    SuggestionsResponse.prototype.LoadSuggestedDaysFromXml = function (jsonProperty, service) {
        var SuggestionArrayObj = jsonProperty[XmlElementNames.SuggestionDayResultArray];
        if (typeof SuggestionArrayObj === 'undefined')
            throw new Error("SuggestionsResponse.ts - LoadSuggestedDaysFromXml - invalid object returned ");
        var suggestions = EwsServiceJsonReader.ReadAsArray(SuggestionArrayObj, XmlElementNames.SuggestionDayResult);
        for (var _a = 0, suggestions_2 = suggestions; _a < suggestions_2.length; _a++) {
            var suggestion = suggestions_2[_a];
            var daySuggestion = new Suggestion();
            daySuggestion.LoadFromXmlJsObject(suggestion, service);
            this.daySuggestions.push(daySuggestion);
        }
    };
    return SuggestionsResponse;
}(ServiceResponse));
exports.SuggestionsResponse = SuggestionsResponse;
/**
 * @internal Represents the response to a UninstallApp operation.
 * Today this class doesn't add extra functionality. Keep this class here so future we can return extension info up-on installation complete.
 *
 * @sealed
 */
var UninstallAppResponse = (function (_super) {
    __extends(UninstallAppResponse, _super);
    /**
     * @internal Initializes a new instance of the **UninstallAppResponse** class.
     */
    function UninstallAppResponse() {
        return _super.call(this) || this;
    }
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    UninstallAppResponse.prototype.ReadElementsFromXmlJsObject = function (jsObject, service) {
        //does nothing, here to supress base class message about ReadElementsFromXmlJsObject when BatchProcessingStopped is false
    };
    return UninstallAppResponse;
}(ServiceResponse));
exports.UninstallAppResponse = UninstallAppResponse;
var UpdateFolderResponse = (function (_super) {
    __extends(UpdateFolderResponse, _super);
    function UpdateFolderResponse(folder) {
        var _this = _super.call(this) || this;
        EwsLogging.Assert(folder != null, "UpdateFolderResponse.ctor", "folder is null");
        _this.folder = folder;
        return _this;
    }
    UpdateFolderResponse.prototype.GetObjectInstance = function (session, xmlElementName) { return this.folder; };
    UpdateFolderResponse.prototype.Loaded = function () {
        if (this.Result == ServiceResult.Success) {
            this.folder.ClearChangeLog();
        }
    };
    UpdateFolderResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        debugger; //todo: check if this is needed. 
        //throw new Error("UpdateFolderResponse.ts - ReadElementsFromXmlJsObject : Not implemented."); 
    };
    return UpdateFolderResponse;
}(ServiceResponse));
exports.UpdateFolderResponse = UpdateFolderResponse;
/**
 * @internal Represents the response to a UpdateInboxRulesResponse operation.
 *
 * @sealed
 */
var UpdateInboxRulesResponse = (function (_super) {
    __extends(UpdateInboxRulesResponse, _super);
    /**
     * @internal Initializes a new instance of the **UpdateInboxRulesResponse** class.
     */
    function UpdateInboxRulesResponse() {
        var _this = _super.call(this) || this;
        /**
         * Rule operation error collection.
         */
        _this.errors = null;
        _this.errors = new RuleOperationErrorCollection();
        return _this;
    }
    Object.defineProperty(UpdateInboxRulesResponse.prototype, "Errors", {
        /**
         * @internal Gets the rule operation errors in the response.
         */
        get: function () {
            return this.errors;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads extra error details from XML
     *
     * @param   {any}   			responseObject      Json Object converted from XML.
     * @param   {ExchangeService}   service             The service.
     */
    UpdateInboxRulesResponse.prototype.LoadExtraErrorDetailsFromXmlJsObject = function (responseObject, service) {
        _super.prototype.LoadExtraErrorDetailsFromXmlJsObject.call(this, responseObject, service);
        if (responseObject[XmlElementNames.RuleOperationErrors]) {
            this.errors.CreateFromXmlJsObjectCollection(responseObject[XmlElementNames.RuleOperationErrors][XmlElementNames.RuleOperationError], service);
        }
    };
    return UpdateInboxRulesResponse;
}(ServiceResponse));
exports.UpdateInboxRulesResponse = UpdateInboxRulesResponse;
var UpdateItemResponse = (function (_super) {
    __extends(UpdateItemResponse, _super);
    function UpdateItemResponse(item) {
        var _this = _super.call(this) || this;
        _this.item = null;
        _this.returnedItem = null;
        _this.conflictCount = 0;
        EwsLogging.Assert(item != null, "UpdateItemResponse.ctor", "item is null");
        _this.item = item;
        return _this;
    }
    Object.defineProperty(UpdateItemResponse.prototype, "ReturnedItem", {
        get: function () {
            return this.returnedItem;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UpdateItemResponse.prototype, "ConflictCount", {
        get: function () {
            return this.conflictCount;
        },
        enumerable: true,
        configurable: true
    });
    UpdateItemResponse.prototype.GetObjectInstance = function (service, xmlElementName) {
        this.returnedItem = new ItemInfo().CreateEwsObjectFromXmlElementName(service, xmlElementName);
        return this.returnedItem;
    };
    UpdateItemResponse.prototype.Loaded = function () {
        if (this.Result == ServiceResult.Success) {
            this.item.ClearChangeLog();
        }
    };
    UpdateItemResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson(responseObject, service, XmlElementNames.Items, this.GetObjectInstance.bind(this), false, /* clearPropertyBag */ null, /* requestedPropertySet */ false); /* summaryPropertiesOnly */
        // ConflictResults was only added in 2007 SP1 so if this was a 2007 RTM request we shouldn't expect to find the element
        if (!service.Exchange2007CompatibilityMode) {
            this.conflictCount = Convert.toNumber(responseObject[XmlElementNames.ConflictResults][XmlElementNames.Count]);
        }
        // If UpdateItem returned an item that has the same Id as the item that
        // is being updated, this is a "normal" UpdateItem operation, and we need
        // to update the ChangeKey of the item being updated with the one that was
        // returned. Also set returnedItem to indicate that no new item was returned.
        //
        // Otherwise, this in a "special" UpdateItem operation, such as a recurring
        // task marked as complete (the returned item in that case is the one-off
        // task that represents the completed instance).
        //
        // Note that there can be no returned item at all, as in an UpdateItem call
        // with MessageDisposition set to SendOnly or SendAndSaveCopy.
        if (this.returnedItem != null) {
            if (this.item.Id.UniqueId == this.returnedItem.Id.UniqueId) {
                this.item.Id.ChangeKey = this.returnedItem.Id.ChangeKey;
                this.returnedItem = null;
            }
        }
    };
    return UpdateItemResponse;
}(ServiceResponse));
exports.UpdateItemResponse = UpdateItemResponse;
var CreateItemResponseBase = (function (_super) {
    __extends(CreateItemResponseBase, _super);
    function CreateItemResponseBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(CreateItemResponseBase.prototype, "Items", {
        get: function () {
            return this.items;
        },
        enumerable: true,
        configurable: true
    });
    CreateItemResponseBase.prototype.GetObjectInstance = function (service, xmlElementName) { throw new Error("CreateItemResponseBase.ts - GetObjectInstance : abstract must implement."); };
    CreateItemResponseBase.prototype.ReadElementsFromJson = function (responseObject, service) { throw new Error("CreateItemResponseBase.ts - ReadElementsFromJson : Not implemented."); };
    CreateItemResponseBase.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        if (responseObject[XmlElementNames.Items]) {
            this.items = EwsServiceJsonReader.ReadServiceObjectsCollectionFromJson(responseObject, service, XmlElementNames.Items, this.GetObjectInstance.bind(this), false, /* clearPropertyBag */ null, /* requestedPropertySet */ false); /* summaryPropertiesOnly */
        }
    };
    return CreateItemResponseBase;
}(ServiceResponse));
exports.CreateItemResponseBase = CreateItemResponseBase;
var CreateItemResponse = (function (_super) {
    __extends(CreateItemResponse, _super);
    function CreateItemResponse(item) {
        var _this = _super.call(this) || this;
        _this.item = null;
        _this.item = item;
        return _this;
    }
    CreateItemResponse.prototype.GetObjectInstance = function (service, xmlElementName) { return this.item; };
    CreateItemResponse.prototype.Loaded = function () {
        if (this.Result == ServiceResult.Success) {
            this.item.ClearChangeLog();
        }
    };
    return CreateItemResponse;
}(CreateItemResponseBase));
exports.CreateItemResponse = CreateItemResponse;
var CreateResponseObjectResponse = (function (_super) {
    __extends(CreateResponseObjectResponse, _super);
    function CreateResponseObjectResponse() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CreateResponseObjectResponse.prototype.GetObjectInstance = function (service, xmlElementName) {
        var itemInfo = new ItemInfo();
        return itemInfo.CreateEwsObjectFromXmlElementName(service, xmlElementName);
        //return EwsUtilities.CreateEwsObjectFromXmlElementName<Item>(service, xmlElementName);
    };
    return CreateResponseObjectResponse;
}(CreateItemResponseBase));
exports.CreateResponseObjectResponse = CreateResponseObjectResponse;
/**
 * @internal Represents the response to a delegate user retrieval operation.
 *
 * @sealed
 */
var GetDelegateResponse = (function (_super) {
    __extends(GetDelegateResponse, _super);
    /**
     * @internal Initializes a new instance of the **GetDelegateResponse** class.
     *
     * @param   {boolean}   readDelegateUsers   if set to *true* [read delegate users].
     */
    function GetDelegateResponse(readDelegateUsers) {
        var _this = _super.call(this, readDelegateUsers, null) || this;
        _this.meetingRequestsDeliveryScope = MeetingRequestsDeliveryScope.NoForward;
        return _this;
    }
    Object.defineProperty(GetDelegateResponse.prototype, "MeetingRequestsDeliveryScope", {
        /**
         * @internal Gets a value indicating if and how meeting requests are delivered to delegates.
         */
        get: function () {
            return this.meetingRequestsDeliveryScope;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    GetDelegateResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        _super.prototype.ReadElementsFromXmlJsObject.call(this, responseObject, service);
        if (this.ErrorCode == ServiceError.NoError) {
            if (responseObject[XmlElementNames.DeliverMeetingRequests]) {
                this.meetingRequestsDeliveryScope = MeetingRequestsDeliveryScope[responseObject[XmlElementNames.DeliverMeetingRequests]];
            }
        }
    };
    return GetDelegateResponse;
}(DelegateManagementResponse));
exports.GetDelegateResponse = GetDelegateResponse;
var ServiceResponseCollection = (function () {
    function ServiceResponseCollection() {
        this.responses = []; // System.Collections.Generic.List<T>;
        this.overallResult = ServiceResult.Success;
    }
    Object.defineProperty(ServiceResponseCollection.prototype, "Count", {
        get: function () { return this.responses.length; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServiceResponseCollection.prototype, "Responses", {
        get: function () { return this.responses; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServiceResponseCollection.prototype, "OverallResult", {
        get: function () { return this.overallResult; },
        enumerable: true,
        configurable: true
    });
    ServiceResponseCollection.prototype.Add = function (response) {
        EwsLogging.Assert(response != null, "EwsResponseList.Add", "response is null");
        if (response.Result > this.overallResult) {
            this.overallResult = response.Result;
        }
        this.responses.push(response);
    };
    ServiceResponseCollection.prototype.GetEnumerator = function () { throw new Error("ServiceResponseCollection.ts - GetEnumerator : Not implemented."); };
    ServiceResponseCollection.prototype.__thisIndexer = function (index) {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }
        return this.responses[index];
    };
    return ServiceResponseCollection;
}());
exports.ServiceResponseCollection = ServiceResponseCollection;
/**
 * Represents the base response class for synchronuization operations.
 *
 * @sealed
 * @typeparam	{TServiceObject}	ServiceObject type.
 * @typeparam	{TChange}	Change type.
 */
var SyncResponse = (function (_super) {
    __extends(SyncResponse, _super);
    /**
     * @internal Initializes a new instance of the **SyncResponse<TServiceObject, TChange>** class.
     *
     * @param   {PropertySet}   propertySet   Property set.
     */
    function SyncResponse(propertySet) {
        var _this = _super.call(this) || this;
        _this.changes = new ChangeCollection();
        _this.propertySet = null;
        _this.propertySet = propertySet;
        EwsLogging.Assert(_this.propertySet != null, "SyncResponse.ctor", "PropertySet should not be null");
        return _this;
    }
    Object.defineProperty(SyncResponse.prototype, "Changes", {
        /**
         * Gets a list of changes that occurred on the synchronized folder.
         */
        get: function () {
            return this.changes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SyncResponse.prototype, "SummaryPropertiesOnly", {
        /**
         * @internal Gets a value indicating whether this request returns full or summary properties.
         */
        get: function () { return false; /* abstract */ },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Reads response elements from Xml JsObject.
     *
     * @param   {any}               jsObject   The response object.
     * @param   {ExchangeService}   service    The service.
     */
    SyncResponse.prototype.ReadElementsFromXmlJsObject = function (responseObject, service) {
        this.Changes.SyncState = responseObject[XmlElementNames.SyncState];
        this.Changes.MoreChangesAvailable = !Convert.toBool(responseObject[this.GetIncludesLastInRangeXmlElementName()]);
        var changesElement = responseObject[XmlElementNames.Changes];
        var folderInfo = new FolderInfo();
        var itemInfo = new ItemInfo();
        for (var changeElementKey in changesElement) {
            if (changeElementKey.indexOf("__") === 0)
                continue;
            var changeObjs = EwsServiceJsonReader.ReadAsArray(changesElement, changeElementKey);
            for (var _a = 0, changeObjs_1 = changeObjs; _a < changeObjs_1.length; _a++) {
                var changeObj = changeObjs_1[_a];
                var change = this.CreateChangeInstance();
                //let changeType:string = jsChange.ReadAsString(XmlElementNames.ChangeType);
                switch (changeElementKey) {
                    case XmlElementNames.Create:
                        change.ChangeType = ChangeType.Create;
                        break;
                    case XmlElementNames.Update:
                        change.ChangeType = ChangeType.Update;
                        break;
                    case XmlElementNames.Delete:
                        change.ChangeType = ChangeType.Delete;
                        break;
                    case XmlElementNames.ReadFlagChange:
                        change.ChangeType = ChangeType.ReadFlagChange;
                        break;
                    default:
                        break;
                }
                var changeObjectTypeName = TypeSystem.GetJsObjectOnlyChildName(changeObj);
                var serviceObjectInfo = ServiceObjectInfo.IsFolderType(changeObjectTypeName) ? folderInfo : itemInfo;
                if (change != null) {
                    var jsServiceObject = changeObj[changeObjectTypeName];
                    switch (change.ChangeType) {
                        case ChangeType.Delete:
                        case ChangeType.ReadFlagChange:
                            change.Id = change.CreateId();
                            var jsChangeId = changeObj[this.GetChangeIdElementName()];
                            change.Id.LoadFromXmlJsObject(jsChangeId, service);
                            if (change.ChangeType == ChangeType.ReadFlagChange) {
                                var itemChange = change;
                                EwsLogging.Assert(change instanceof ItemChange, "SyncResponse.ReadElementsFromXmlJsObject", "ReadFlagChange is only valid on ItemChange");
                                itemChange.IsRead = Convert.toBool(changeObj[XmlElementNames.IsRead]);
                            }
                            break;
                        default:
                            change.ServiceObject = serviceObjectInfo.CreateEwsObjectFromXmlElementName(service, changeObjectTypeName);
                            change.ServiceObject.LoadFromXmlJsObject(jsServiceObject, service, true, /* clearPropertyBag */ this.propertySet, this.SummaryPropertiesOnly);
                            break;
                    }
                    this.changes.Add(change);
                }
            }
        }
    };
    return SyncResponse;
}(ServiceResponse));
exports.SyncResponse = SyncResponse;
/**
 * Represents the response to a folder synchronization operation.
 *
 * @sealed
 */
var SyncFolderHierarchyResponse = (function (_super) {
    __extends(SyncFolderHierarchyResponse, _super);
    /**
     * @internal Initializes a new instance of the **SyncFolderHierarchyResponse** class.
     *
     * @param   {PropertySet}   propertySet   PropertySet from request.
     */
    function SyncFolderHierarchyResponse(propertySet) {
        return _super.call(this, propertySet) || this;
    }
    Object.defineProperty(SyncFolderHierarchyResponse.prototype, "SummaryPropertiesOnly", {
        /**
         * @internal Gets a value indicating whether this request returns full or summary properties.
         *
         * @value	*true* if summary properties only; otherwise, *false*.
         */
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates an item change instance.
     *
     * @return  {ItemChange}      ItemChange instance
     */
    SyncFolderHierarchyResponse.prototype.CreateChangeInstance = function () {
        return new FolderChange();
    };
    /**
     * @internal Gets the name of the change element.
     *
     * @return  {string}      Change element name.
     */
    SyncFolderHierarchyResponse.prototype.GetChangeElementName = function () {
        return XmlElementNames.Folder;
    };
    /**
     * @internal Gets the name of the change id element.
     *
     * @return  {string}      Change id element name.
     */
    SyncFolderHierarchyResponse.prototype.GetChangeIdElementName = function () {
        return XmlElementNames.FolderId;
    };
    /**
     * @internal Gets the name of the includes last in range XML element.
     *
     * @return  {string}      XML element name.
     */
    SyncFolderHierarchyResponse.prototype.GetIncludesLastInRangeXmlElementName = function () {
        return XmlElementNames.IncludesLastFolderInRange;
    };
    return SyncFolderHierarchyResponse;
}(SyncResponse));
exports.SyncFolderHierarchyResponse = SyncFolderHierarchyResponse;
/**
 * Represents the response to a folder items synchronization operation.
 *
 * @sealed
 */
var SyncFolderItemsResponse = (function (_super) {
    __extends(SyncFolderItemsResponse, _super);
    /**
     * @internal Initializes a new instance of the **SyncFolderItemsResponse** class.
     *
     * @param   {PropertySet}   propertySet   PropertySet from request.
     */
    function SyncFolderItemsResponse(propertySet) {
        return _super.call(this, propertySet) || this;
    }
    Object.defineProperty(SyncFolderItemsResponse.prototype, "SummaryPropertiesOnly", {
        /**
         * @internal Gets a value indicating whether this request returns full or summary properties.
         *
         * @value	*true* if summary properties only; otherwise, *false*.
         */
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates an item change instance.
     *
     * @return  {ItemChange}      ItemChange instance
     */
    SyncFolderItemsResponse.prototype.CreateChangeInstance = function () {
        return new ItemChange();
    };
    /**
     * @internal Gets the name of the change element.
     *
     * @return  {string}      Change element name.
     */
    SyncFolderItemsResponse.prototype.GetChangeElementName = function () {
        return XmlElementNames.Item;
    };
    /**
     * @internal Gets the name of the change id element.
     *
     * @return  {string}      Change id element name.
     */
    SyncFolderItemsResponse.prototype.GetChangeIdElementName = function () {
        return XmlElementNames.ItemId;
    };
    /**
     * @internal Gets the name of the includes last in range XML element.
     *
     * @return  {string}      XML element name.
     */
    SyncFolderItemsResponse.prototype.GetIncludesLastInRangeXmlElementName = function () {
        return XmlElementNames.IncludesLastItemInRange;
    };
    return SyncFolderItemsResponse;
}(SyncResponse));
exports.SyncFolderItemsResponse = SyncFolderItemsResponse;
/**
 * Represents the base abstract class for all item and folder types.
 */
var ServiceObject = (function () {
    /**
     * @internal Internal constructor.
     *
     * @param   {ExchangeService}   service   EWS service to which this object belongs.
     */
    function ServiceObject(service) {
        //EwsUtilities.ValidateParam(service, "service");
        //EwsUtilities.ValidateServiceObjectVersion(this, service.RequestedServerVersion);
        this.lockObject = {};
        /**
         * Defines an event that is triggered when the service object changes.
         */
        this.OnChange = [];
        //this.Service = service;
        var innerService = service;
        this.setService = function (service) { innerService = service; };
        this.getService = function () { return innerService; };
        this.propertyBag = new PropertyBag(this);
    }
    Object.defineProperty(ServiceObject.prototype, "PropertyBag", {
        /**
         * @internal The property bag holding property values for this object.
         */
        get: function () { return this.propertyBag; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServiceObject.prototype, "Schema", {
        /**
         * Gets the schema associated with this type of object.
         */
        get: function () { return this.GetSchema(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServiceObject.prototype, "Service", {
        /**
         * Gets the ExchangeService the object is bound to.
         */
        get: function () { return this.getService(); },
        /**@internal set*/
        set: function (value) { this.setService(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServiceObject.prototype, "IsNew", {
        /**
         * Indicates whether this object is a real store item, or if it's a local object that has yet to be saved.
         */
        get: function () {
            var id = this.GetId();
            return id == null ? true : !id.IsValid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServiceObject.prototype, "IsDirty", {
        /**
         * Gets a value indicating whether the object has been modified and should be saved.
         */
        get: function () {
            return this.PropertyBag.IsDirty;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the value of specified property in this instance.
     * This Indexer of c#
     *
     * @param   {PropertyDefinitionBase}   propertyDefinition   Definition of the property to get.
     */
    ServiceObject.prototype._getItem = function (propertyDefinition) {
        var propertyValue;
        var propDef = propertyDefinition;
        if (propDef instanceof PropertyDefinition) {
            return this.PropertyBag._getItem(propDef);
        }
        else {
            var extendedPropDef = propertyDefinition;
            if (extendedPropDef instanceof ExtendedPropertyDefinition) {
                if (this.TryGetExtendedProperty(extendedPropDef, propertyValue)) {
                    return propertyValue;
                }
                else {
                    throw new ServiceObjectPropertyException(Strings.MustLoadOrAssignPropertyBeforeAccess, propertyDefinition);
                }
            }
            else {
                // Other subclasses of PropertyDefinitionBase are not supported.
                var constructorName = "Chile of ServiceObject";
                if (propertyDefinition.constructor.name) {
                    constructorName = propertyDefinition.constructor.name;
                }
                throw new NotSupportedException(StringHelper.Format(Strings.OperationNotSupportedForPropertyDefinitionType, constructorName));
            }
        }
    };
    /**
     * @internal Triggers dispatch of the change event.
     */
    ServiceObject.prototype.Changed = function () {
        if (this.OnChange != null) {
            for (var _a = 0, _b = this.OnChange; _a < _b.length; _a++) {
                var changeDelegate = _b[_a];
                changeDelegate(this);
            }
        }
    };
    /**
     * @internal Clears the object's change log.
     */
    ServiceObject.prototype.ClearChangeLog = function () { this.PropertyBag.ClearChangeLog(); };
    /**
     * @internal Gets the name of the change XML element.
     *
     * @return  {string}      XML element name,
     */
    ServiceObject.prototype.GetChangeXmlElementName = function () { return XmlElementNames.ItemChange; };
    /**
     * @internal Gets the name of the delete field XML element.
     *
     * @return  {string}      XML element name,
     */
    ServiceObject.prototype.GetDeleteFieldXmlElementName = function () { return XmlElementNames.DeleteItemField; };
    /**
     * @internal Gets the extended properties collection.
     *
     * @return  {ExtendedPropertyCollection}      Extended properties collection.
     */
    ServiceObject.prototype.GetExtendedProperties = function () { return null; };
    /**
     * @internal The unique Id of this object.
     *
     * @return  {ServiceId}      A ServiceId instance..
     */
    ServiceObject.prototype.GetId = function () {
        var idPropertyDefinition = this.GetIdPropertyDefinition();
        var serviceId = { outValue: null };
        if (idPropertyDefinition != null) {
            this.PropertyBag.TryGetValue(idPropertyDefinition, serviceId);
        }
        return serviceId.outValue;
    };
    /**
     * @internal The property definition for the Id of this object.
     *
     * @return  {PropertyDefinition}      A PropertyDefinition instance.
     */
    ServiceObject.prototype.GetIdPropertyDefinition = function () { return null; };
    /**
     * @internal Determines whether properties defined with ScopedDateTimePropertyDefinition require custom time zone scoping.
     *
     * @return  {boolean}      true if this item type requires custom scoping for scoped date/time properties; otherwise, false.
     */
    ServiceObject.prototype.GetIsCustomDateTimeScopingRequired = function () { return false; };
    /**
     * @internal Gets a value indicating whether a time zone SOAP header should be emitted in a CreateItem or UpdateItem request so this item can be property saved or updated.
     *
     * @param   {boolean}     isUpdateOperation   Indicates whether the operation being petrformed is an update operation.
     * @return  {boolean}     true if a time zone SOAP header should be emitted; otherwise, false.
     */
    ServiceObject.prototype.GetIsTimeZoneHeaderRequired = function (isUpdateOperation) { return false; };
    /**
     * Gets the collection of loaded property definitions.
     *
     * @return  {PropertyDefinitionBase[]}      Collection of property definitions.
     */
    ServiceObject.prototype.GetLoadedPropertyDefinitions = function () {
        var propDefs = [];
        for (var _a = 0, _b = this.PropertyBag.Properties.Keys; _a < _b.length; _a++) {
            var propDef = _b[_a];
            propDefs.push(propDef);
        }
        if (this.GetExtendedProperties() != null) {
            for (var _c = 0, _d = this.GetExtendedProperties().Items; _c < _d.length; _c++) {
                var extProp = _d[_c];
                propDefs.push(extProp.PropertyDefinition);
            }
        }
        return propDefs;
    };
    /**
     * @internal Gets the name of the set field XML element.
     *
     * @return  {string}      XML element name,
     */
    ServiceObject.prototype.GetSetFieldXmlElementName = function () { return XmlElementNames.SetItemField; };
    /**
     * @internal GetXmlElementName retrieves the XmlElementName of this type based on the EwsObjectDefinition attribute that decorates it, if present.
     *
     * @return  {string}      The XML element name associated with this type.
     */
    ServiceObject.prototype.GetXmlElementName = function () {
        throw new Error("ServiceObject.ts - GetXmlElementName -  this must be overridden by derived class - can not use reflection to get class attribute in javascript");
        if (StringHelper.IsNullOrEmpty(this.xmlElementName)) {
            this.xmlElementName = this.GetXmlElementNameOverride();
            EwsLogging.Assert(!StringHelper.IsNullOrEmpty(this.xmlElementName), "EwsObject.GetXmlElementName", StringHelper.Format("The class {0} does not have an associated XML element name.", "unknown decendent of ServiceObject - in serviceObject.GetXmlElementname"));
        }
        return this.xmlElementName;
    };
    /**
     * @internal This methods lets subclasses of ServiceObject override the default mechanism by which the XML element name associated with their type is retrieved.
     *
     * @return  {string}      The XML element name associated with this type. If this method returns null or empty, the XML element name associated with this type is determined by the EwsObjectDefinition attribute that decorates the type, if present.
     */
    ServiceObject.prototype.GetXmlElementNameOverride = function () { return null; };
    ServiceObject.prototype.Load = function (propertySet) {
        return this.InternalLoad(propertySet || PropertySet.FirstClassProperties);
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     * @param   {boolean}             clearPropertyBag        if set to true [clear property bag].
     * @param   {PropertySet}         requestedPropertySet    The property set.
     * @param   {boolean}             summaryPropertiesOnly   if set to true [summary props only].
     */
    ServiceObject.prototype.LoadFromXmlJsObject = function (jsObject, service, clearPropertyBag, requestedPropertySet, summaryPropertiesOnly) {
        if (requestedPropertySet === void 0) { requestedPropertySet = null; }
        if (summaryPropertiesOnly === void 0) { summaryPropertiesOnly = false; }
        this.PropertyBag.LoadFromXmlJsObject(jsObject, service, clearPropertyBag, requestedPropertySet, summaryPropertiesOnly);
    };
    /**
     * @internal Throws exception if this is a new service object.
     */
    ServiceObject.prototype.ThrowIfThisIsNew = function () {
        if (this.IsNew) {
            throw new InvalidOperationException(Strings.ServiceObjectDoesNotHaveId);
        }
    };
    /**
     * @internal Throws exception if this is not a new service object.
     */
    ServiceObject.prototype.ThrowIfThisIsNotNew = function () {
        if (!this.IsNew) {
            throw new InvalidOperationException(Strings.ServiceObjectAlreadyHasId);
        }
    };
    /**
     * @internal Try to get the value of a specified extended property in this instance.
     *
     * @param   {ExtendedPropertyDefinition}  propertyDefinition   The property definition.
     * @param   {IOutParam<T>}                propertyValue        The property value.
     * @return  {boolean}                     True if property retrieved, false otherwise.
     */
    ServiceObject.prototype.TryGetExtendedProperty = function (propertyDefinition, propertyValue) {
        var propertyCollection = this.GetExtendedProperties();
        if ((propertyCollection != null) &&
            propertyCollection.TryGetValue(propertyDefinition, propertyValue)) {
            return true;
        }
        else {
            propertyValue.outValue = null; //default(T);
            return false;
        }
    };
    //todo:fix - implement type casting on specific type request version. 
    //TryGetProperty<T>(propertyDefinition: PropertyDefinitionBase, propertyValue: any): boolean { throw new Error("Need implementation."); }
    //TryGetProperty(propertyDefinition: PropertyDefinitionBase, propertyValue: any): boolean { throw new Error("ServiceObject.ts - TryGetProperty : Not implemented."); }
    /**
     * Try to get the value of a specified property in this instance.
     *
     * @param   {PropertyDefinitionBase}  propertyDefinition   The property definition.
     * @param   {IOutParam<T>}            propertyValue        The property value.
     * @return  {boolean}                 True if property retrieved, false otherwise.
     */
    ServiceObject.prototype.TryGetProperty = function (propertyDefinition, propertyValue) {
        var propDef = propertyDefinition; // as PropertyDefinition;
        //info: fix for compatibility checking, if this is propertydefinition or extendedpropertydefinitionbase
        if (propDef instanceof PropertyDefinition) {
            return this.PropertyBag.TryGetPropertyAs(propDef, propertyValue);
        }
        else {
            //info: fix for compatibility of extendedpropertydefition or propertydefition type.
            var extPropDef = propertyDefinition; // as ExtendedPropertyDefinition;
            if (extPropDef instanceof ExtendedPropertyDefinition) {
                return this.TryGetExtendedProperty(extPropDef, propertyValue);
            }
            else {
                // Other subclasses of PropertyDefinitionBase are not supported.
                var constructorName = "Child of ServiceObject";
                if (propertyDefinition.constructor.name) {
                    constructorName = propertyDefinition.constructor.name;
                }
                throw new NotSupportedException(StringHelper.Format(Strings.OperationNotSupportedForPropertyDefinitionType, propertyDefinition.Type));
            }
        }
    };
    /**
     * @internal Validates this instance.
     */
    ServiceObject.prototype.Validate = function () { this.PropertyBag.Validate(); };
    /**
     * @internal Writes service object as XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ServiceObject.prototype.WriteToXml = function (writer) { this.PropertyBag.WriteToXml(writer); };
    /**
     * @internal Writes service object for update as XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ServiceObject.prototype.WriteToXmlForUpdate = function (writer) { this.PropertyBag.WriteToXmlForUpdate(writer); };
    return ServiceObject;
}());
exports.ServiceObject = ServiceObject;
/**
 * Moved part of CreateEwsObjectFromXmlElementName to different object type like FolderInfo, itemInfo etc
 */
var ServiceObjectInfo = (function () {
    function ServiceObjectInfo() {
        this.xmlElementNameToServiceObjectClassMap = {};
        this.serviceObjectConstructorsWithServiceParam = {};
        this.serviceObjectConstructorsWithAttachmentParam = {};
        this.InitializeServiceObjectClassMap();
    }
    Object.defineProperty(ServiceObjectInfo.prototype, "XmlElementNameToServiceObjectClassMap", {
        get: function () { return this.xmlElementNameToServiceObjectClassMap; } //  System.Collections.Generic.Dictionary<string, System.Type>;
        ,
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServiceObjectInfo.prototype, "ServiceObjectConstructorsWithServiceParam", {
        get: function () { return this.serviceObjectConstructorsWithServiceParam; } // System.Collections.Generic.Dictionary<System.Type, CreateServiceObjectWithServiceParam>;
        ,
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServiceObjectInfo.prototype, "ServiceObjectConstructorsWithAttachmentParam", {
        get: function () { return this.serviceObjectConstructorsWithAttachmentParam; } //System.Collections.Generic.Dictionary<System.Type, CreateServiceObjectWithAttachmentParam>;
        ,
        enumerable: true,
        configurable: true
    });
    ServiceObjectInfo.prototype.AddServiceObjectType = function (xmlElementName, type /*System.Type*/, createServiceObjectWithServiceParam, createServiceObjectWithAttachmentParam) {
        this.xmlElementNameToServiceObjectClassMap[xmlElementName] = type;
        this.serviceObjectConstructorsWithServiceParam[xmlElementName] = createServiceObjectWithServiceParam;
        if (createServiceObjectWithAttachmentParam) {
            this.serviceObjectConstructorsWithAttachmentParam[xmlElementName] = createServiceObjectWithAttachmentParam;
        }
    };
    ServiceObjectInfo.prototype.InitializeServiceObjectClassMap = function () {
        throw new Error("abstract - ServiceObjectInfo.ts - InitializeServiceObjectClassMap: must be implemented");
        /**
         * Folder Types ->  folderinfo
              
        // CalendarFolder
        this.AddServiceObjectType(
            XmlElementNames.CalendarFolder,
            "CalendarFolder",
            (srv) => { return new CalendarFolder(srv); },
            null);
                 
        // ContactsFolder
        this.AddServiceObjectType(
            XmlElementNames.ContactsFolder,
            "ContactsFolder",
            (srv) => { return new ContactsFolder(srv); },
            null);

        // Folder
        this.AddServiceObjectType(
            XmlElementNames.Folder,
            "Folder",
            (srv) => { return new Folder(srv); },
            null);

        // SearchFolder
        this.AddServiceObjectType(
            XmlElementNames.SearchFolder,
            "SearchFolder",
            (srv) => { return new SearchFolder(srv); },
            null);

        // TasksFolder
        this.AddServiceObjectType(
            XmlElementNames.TasksFolder,
            "TasksFolder",
            (srv) => { return new TasksFolder(srv); },
            null);
            
        */
        /**
         * Item Types -> iteminfo
        
        // Appointment
        this.AddServiceObjectType(
            XmlElementNames.CalendarItem,
            "Appointment",
            (srv) => { return new Appointment(srv); },
            (itemAttachment, isNew) => { return new Appointment(itemAttachment, isNew); });


        // Contact
        this.AddServiceObjectType(
            XmlElementNames.Contact,
            "Contact",
            (srv) => { return new Contact(srv); },
            (itemAttachment, isNew) => { return new Contact(itemAttachment); });

        // ContactGroup
        this.AddServiceObjectType(
            XmlElementNames.DistributionList,
            "ContactGroup",
            (srv) => { return new ContactGroup(srv); },
            (itemAttachment, isNew) => { return new ContactGroup(itemAttachment); });

        // Conversation
        this.AddServiceObjectType(
            XmlElementNames.Conversation,
            "Conversation",
            (srv) => { return new Conversation(srv); },
            null);

        // EmailMessage
        this.AddServiceObjectType(
            XmlElementNames.Message,
            "EmailMessage",
            (srv) => { return new EmailMessage(srv); },
            (itemAttachment, isNew) => { return new EmailMessage(itemAttachment); });

        // Item
        this.AddServiceObjectType(
            XmlElementNames.Item,
            "Item",
            (srv) => { return new Item(srv); },
            (itemAttachment, isNew) => { return new Item(itemAttachment); });

        // MeetingCancellation
        this.AddServiceObjectType(
            XmlElementNames.MeetingCancellation,
            "MeetingCancellation",
            (srv) => { return new MeetingCancellation(srv); },
            (itemAttachment, isNew) => { return new MeetingCancellation(itemAttachment); });

        // MeetingMessage
        this.AddServiceObjectType(
            XmlElementNames.MeetingMessage,
            "MeetingMessage",
            (srv) => { return new MeetingMessage(srv); },
            (itemAttachment, isNew) => { return new MeetingMessage(itemAttachment); });

        // MeetingRequest
        this.AddServiceObjectType(
            XmlElementNames.MeetingRequest,
            "MeetingRequest",
            (srv) => { return new MeetingRequest(srv); },
            (itemAttachment, isNew) => { return new MeetingRequest(itemAttachment); });

        // MeetingResponse
        this.AddServiceObjectType(
            XmlElementNames.MeetingResponse,
            "MeetingResponse",
            (srv) => { return new MeetingResponse(srv); },
            (itemAttachment, isNew) => { return new MeetingResponse(itemAttachment); });

        // PostItem
        this.AddServiceObjectType(
            XmlElementNames.PostItem,
            "PostItem",
            (srv) => { return new PostItem(srv); },
            (itemAttachment, isNew) => { return new PostItem(itemAttachment); });

        // Task
        this.AddServiceObjectType(
            XmlElementNames.Task,
            "Task",
            (srv) => { return new Task(srv); },
            (itemAttachment, isNew) => { return new Task(itemAttachment); });

        */
    };
    ServiceObjectInfo.prototype.CreateEwsObjectFromXmlElementName = function (service, xmlElementName) {
        //var itemClass = this.XmlElementNameToServiceObjectClassMap[xmlElementName];
        //if (itemClass) {
        //    return new itemClass(service);
        //no need of itemclass due to lack of type conversion and dictionary implementation in javascript
        var creationDelegate = this.ServiceObjectConstructorsWithServiceParam[xmlElementName];
        if (creationDelegate) {
            return creationDelegate(service);
        }
        else {
            return null;
        }
    };
    ServiceObjectInfo.prototype.CreateItemFromItemClass = function (itemAttachment, itemClass /*System.Type*/, isNew) {
        var creationDelegate = this.ServiceObjectConstructorsWithAttachmentParam[itemClass];
        if (creationDelegate) {
            return creationDelegate(itemAttachment, isNew);
        }
        else {
            return null;
        }
    };
    ServiceObjectInfo.IsFolderType = function (xmlElementName) {
        var folderTypes = [
            XmlElementNames.CalendarFolder,
            XmlElementNames.ContactsFolder,
            XmlElementNames.Folder,
            XmlElementNames.SearchFolder,
            XmlElementNames.TasksFolder,
        ];
        var itemType = [
            XmlElementNames.CalendarItem,
            XmlElementNames.Contact,
            XmlElementNames.DistributionList,
            XmlElementNames.Conversation,
            XmlElementNames.Message,
            XmlElementNames.Item,
            XmlElementNames.MeetingCancellation,
            XmlElementNames.MeetingMessage,
            XmlElementNames.MeetingRequest,
            XmlElementNames.MeetingResponse,
            XmlElementNames.PostItem,
            XmlElementNames.Task,
        ];
        return folderTypes.indexOf(xmlElementName) >= 0;
    };
    return ServiceObjectInfo;
}());
exports.ServiceObjectInfo = ServiceObjectInfo;
/**
 * this is partial section of CreateEwsObjectFromXmlElementName from serviceobjectinfo, other parts are moved to different object type like itemInfo etc.
 * this to is to avoid circular referencing with requirejs/commonjs/nodejs
 */
var FolderInfo = (function (_super) {
    __extends(FolderInfo, _super);
    function FolderInfo() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FolderInfo.prototype.InitializeServiceObjectClassMap = function () {
        // CalendarFolder
        this.AddServiceObjectType(XmlElementNames.CalendarFolder, "CalendarFolder", function (srv) { return new CalendarFolder(srv); }, null);
        // ContactsFolder
        this.AddServiceObjectType(XmlElementNames.ContactsFolder, "ContactsFolder", function (srv) { return new ContactsFolder(srv); }, null);
        // Folder
        this.AddServiceObjectType(XmlElementNames.Folder, "Folder", function (srv) { return new Folder(srv); }, null);
        // SearchFolder
        this.AddServiceObjectType(XmlElementNames.SearchFolder, "SearchFolder", function (srv) { return new SearchFolder(srv); }, null);
        // TasksFolder
        this.AddServiceObjectType(XmlElementNames.TasksFolder, "TasksFolder", function (srv) { return new TasksFolder(srv); }, null);
    };
    FolderInfo.prototype.CreateEwsObjectFromXmlElementName = function (service, xmlElementName) {
        //var itemClass = this.XmlElementNameToServiceObjectClassMap[xmlElementName];
        //if (itemClass) {
        //    return new itemClass(service);
        //no need of itemclass due to lack of type conversion and dictionary implementation in javascript
        var creationDelegate = this.ServiceObjectConstructorsWithServiceParam[xmlElementName];
        if (creationDelegate) {
            return creationDelegate(service);
        }
        else
            return null;
    };
    return FolderInfo;
}(ServiceObjectInfo));
exports.FolderInfo = FolderInfo;
/**
 ** this is partial section of CreateEwsObjectFromXmlElementName from serviceobjectinfo, other parts are moved to different object type like folderinfo etc.
 * this to is to avoid circular referencing with requirejs/commonjs/nodejs
 */
var ItemInfo = (function (_super) {
    __extends(ItemInfo, _super);
    function ItemInfo() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ItemInfo.prototype.InitializeServiceObjectClassMap = function () {
        // Appointment
        this.AddServiceObjectType(XmlElementNames.CalendarItem, "Appointment", function (srv) { return new Appointment(srv); }, function (itemAttachment, isNew) { return new Appointment(itemAttachment, isNew); });
        // Contact
        this.AddServiceObjectType(XmlElementNames.Contact, "Contact", function (srv) { return new Contact(srv); }, function (itemAttachment, isNew) { return new Contact(itemAttachment); });
        // ContactGroup
        this.AddServiceObjectType(XmlElementNames.DistributionList, "ContactGroup", function (srv) { return new ContactGroup(srv); }, function (itemAttachment, isNew) { return new ContactGroup(itemAttachment); });
        // Conversation
        this.AddServiceObjectType(XmlElementNames.Conversation, "Conversation", function (srv) { return new Conversation(srv); }, null);
        // EmailMessage
        this.AddServiceObjectType(XmlElementNames.Message, "EmailMessage", function (srv) { return new EmailMessage(srv); }, function (itemAttachment, isNew) { return new EmailMessage(itemAttachment); });
        // Item
        this.AddServiceObjectType(XmlElementNames.Item, "Item", function (srv) { return new Item(srv); }, function (itemAttachment, isNew) { return new Item(itemAttachment); });
        // MeetingCancellation
        this.AddServiceObjectType(XmlElementNames.MeetingCancellation, "MeetingCancellation", function (srv) { return new MeetingCancellation(srv); }, function (itemAttachment, isNew) { return new MeetingCancellation(itemAttachment); });
        // MeetingMessage
        this.AddServiceObjectType(XmlElementNames.MeetingMessage, "MeetingMessage", function (srv) { return new MeetingMessage(srv); }, function (itemAttachment, isNew) { return new MeetingMessage(itemAttachment); });
        // MeetingRequest
        this.AddServiceObjectType(XmlElementNames.MeetingRequest, "MeetingRequest", function (srv) { return new MeetingRequest(srv); }, function (itemAttachment, isNew) { return new MeetingRequest(itemAttachment); });
        // MeetingResponse
        this.AddServiceObjectType(XmlElementNames.MeetingResponse, "MeetingResponse", function (srv) { return new MeetingResponse(srv); }, function (itemAttachment, isNew) { return new MeetingResponse(itemAttachment); });
        // PostItem
        this.AddServiceObjectType(XmlElementNames.PostItem, "PostItem", function (srv) { return new PostItem(srv); }, function (itemAttachment, isNew) { return new PostItem(itemAttachment); });
        // Task
        this.AddServiceObjectType(XmlElementNames.Task, "Task", function (srv) { return new Task(srv); }, function (itemAttachment, isNew) { return new Task(itemAttachment); });
    };
    return ItemInfo;
}(ServiceObjectInfo));
exports.ItemInfo = ItemInfo;
var Folder = (function (_super) {
    __extends(Folder, _super);
    /**
     * _FolderTYpe -> type of folder, use to avoid folder type detection using instanceof. some cases it has circular loop in nodejs/requirejs
     */
    //get _FolderType(): string { return XmlElementNames.Folder; }
    /**
     * Initializes an unsaved local instance of **Folder**. To bind to an existing folder, use Folder.Bind() instead.
     *
     * @param   {ExchangeService}   service   EWS service to which this object belongs.
     */
    function Folder(service) {
        return _super.call(this, service) || this;
    }
    Object.defineProperty(Folder.prototype, "Id", {
        /**
         * Gets the Id of the folder.
         *
         */
        get: function () { return this.PropertyBag._getItem(this.GetIdPropertyDefinition()); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "ParentFolderId", {
        /**
         * Gets the Id of this folder's parent folder.
         *
         */
        get: function () { return this.PropertyBag._getItem(Schemas.FolderSchema.ParentFolderId); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "ChildFolderCount", {
        /**
         * Gets the number of child folders this folder has.
         *
         */
        get: function () { return this.PropertyBag._getItem(Schemas.FolderSchema.ChildFolderCount); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "DisplayName", {
        /**
         * Gets or sets the display name of the folder.
         *
         */
        get: function () { return this.PropertyBag._getItem(Schemas.FolderSchema.DisplayName); },
        set: function (value) { this.PropertyBag._setItem(Schemas.FolderSchema.DisplayName, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "FolderClass", {
        /**
         * Gets or sets the custom class name of this folder.
         *
         */
        get: function () { return this.PropertyBag._getItem(Schemas.FolderSchema.FolderClass); },
        set: function (value) { this.PropertyBag._setItem(Schemas.FolderSchema.FolderClass, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "TotalCount", {
        /**
         * Gets the total number of items contained in the folder.
         *
         */
        get: function () { return this.PropertyBag._getItem(Schemas.FolderSchema.TotalCount); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "ExtendedProperties", {
        /**
         * Gets a list of extended properties associated with the folder. **Unstable Need testing**
         *
         */
        get: function () { return this.PropertyBag._getItem(ServiceObjectSchema.ExtendedProperties); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "ManagedFolderInformation", {
        /**
         * Gets the Email Lifecycle Management (ELC) information associated with the folder.
         *
         */
        get: function () { return this.PropertyBag._getItem(Schemas.FolderSchema.ManagedFolderInformation); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "EffectiveRights", {
        /**
         * Gets a value indicating the effective rights the current authenticated user has on the folder.
         *
         */
        get: function () { return this.PropertyBag._getItem(Schemas.FolderSchema.EffectiveRights); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "Permissions", {
        /**
         * Gets a list of permissions for the folder.
         *
         */
        get: function () { return this.PropertyBag._getItem(Schemas.FolderSchema.Permissions); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "UnreadCount", {
        /**
         * Gets the number of unread items in the folder.
         *
         */
        get: function () { return this.PropertyBag._getItem(Schemas.FolderSchema.UnreadCount); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "PolicyTag", {
        /**
         * Gets or sets the policy tag.
         *
         */
        get: function () { return this.PropertyBag._getItem(Schemas.FolderSchema.PolicyTag); },
        set: function (value) { this.PropertyBag._setItem(Schemas.FolderSchema.PolicyTag, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "ArchiveTag", {
        /**
         * Gets or sets the archive tag.
         *
         */
        get: function () { return this.PropertyBag._getItem(Schemas.FolderSchema.ArchiveTag); },
        set: function (value) { this.PropertyBag._setItem(Schemas.FolderSchema.ArchiveTag, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "WellKnownFolderNameAsString", {
        /**
         * Gets the well known name of this folder, if any, as a string.
         * **value** - The well known name of this folder as a string, or null if this folder isn't a well known folder.
         *
         */
        get: function () { return WellKnownFolderName[this.PropertyBag._getItem(Schemas.FolderSchema.WellKnownFolderName)]; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "WellKnownFolderName", {
        /**
         * Gets the well known name of this folder, if any.
         * **value** - The well known name of this folder, or null if this folder isn't a well known folder.
         *
         */
        get: function () { return WellKnownFolderName[this.WellKnownFolderNameAsString] || null; },
        enumerable: true,
        configurable: true
    });
    Folder.Bind = function (service, idOrName, propertySet) {
        if (propertySet === void 0) { propertySet = PropertySet.FirstClassProperties; }
        if (idOrName instanceof FolderId) {
            return service.BindToFolder(idOrName, propertySet);
        }
        else if (typeof idOrName === 'number') {
            return service.BindToFolder(new FolderId(idOrName), propertySet);
        }
        EwsLogging.Assert(false, "Folder.Bind", "unknown paramete type");
        throw new Error("unknow parameter type. this should not be  reached");
    };
    Folder.prototype.Copy = function (destinationFolderIdOrName) {
        this.ThrowIfThisIsNew();
        //EwsUtilities.ValidateParam(destinationFolderId, "destinationFolderId");
        if (typeof destinationFolderIdOrName === 'undefined') {
            EwsLogging.Assert(false, "Folder.Copy", "unknown paramete type");
            throw new Error("unknow parameter type. this should not be  reached");
        }
        var folderId = destinationFolderIdOrName;
        if (typeof destinationFolderIdOrName === 'number')
            folderId = new FolderId(destinationFolderIdOrName);
        return this.Service.CopyFolder(this.Id, folderId);
    };
    /**
     * Deletes the folder. Calling this method results in a call to EWS.
     *
     * @param   {DeleteMode}   deleteMode   Deletion mode.
     */
    Folder.prototype.Delete = function (deleteMode) { return this.InternalDelete(deleteMode, null, null); };
    /**
     * Empties the folder. Calling this method results in a call to EWS.
     *
     * @param   {DeleteMode}    deleteMode         The deletion mode.
     * @param   {boolean}       deleteSubFolders   Indicates whether sub-folders should also be deleted.
     */
    Folder.prototype.Empty = function (deleteMode, deleteSubFolders) {
        this.ThrowIfThisIsNew();
        return this.Service.EmptyFolder(this.Id, deleteMode, deleteSubFolders);
    };
    Folder.prototype.FindFolders = function (viewOrSearchFilter, view) {
        this.ThrowIfThisIsNew();
        //todo: better argument check with ewsutilities
        var argsLength = arguments.length;
        if (argsLength < 1 && argsLength > 2) {
            throw new Error("invalid arguments, check documentation and try again.");
        }
        if (viewOrSearchFilter instanceof FolderView) {
            return this.Service.FindFolders(this.Id, viewOrSearchFilter);
        }
        else if (viewOrSearchFilter instanceof SearchFilter) {
            if (typeof view === 'undefined' || !(view instanceof FolderView)) {
                throw new Error("Folder.ts - FindFolders - incorrect uses of parameters at 2nd position, must be FolderView");
            }
            return this.Service.FindFolders(this.Id, viewOrSearchFilter, view);
        }
        else {
            throw new Error("Folder.ts - FindFolders - incorrect uses of parameters at 1st position, must be FolderView or SearchFilter");
        }
    };
    Folder.prototype.FindItems = function (viewQueryStringOrSearchFilter, viewOrGroupBy, groupBy) {
        var argsLength = arguments.length;
        if (argsLength < 1 && argsLength > 3) {
            throw new Error("invalid arguments, check documentation and try again.");
        }
        //todo: better argument check with ewsutilities
        //EwsUtilities.ValidateParam(groupBy, "groupBy");
        //EwsUtilities.ValidateParamAllowNull(searchFilter, "searchFilter");
        //EwsUtilities.ValidateParamAllowNull(queryString, "queryString");
        //position 1 - viewQueryStringOrSearchFilter
        var queryString = null;
        var searchFilter = null;
        var view = null;
        if (typeof viewQueryStringOrSearchFilter === 'string') {
            queryString = viewQueryStringOrSearchFilter;
        }
        else if (viewQueryStringOrSearchFilter instanceof SearchFilter) {
            searchFilter = viewQueryStringOrSearchFilter;
        }
        else if (viewQueryStringOrSearchFilter instanceof ViewBase) {
            view = viewQueryStringOrSearchFilter;
        }
        else {
            throw new Error("Folder.ts - FindItems - incorrect uses of parameters at 1st position, must be string, Itemview or SearchFilter");
        }
        var groupResultBy = null;
        var isGroupped = false; // to resturn GroupedFindItemsResults<Item>
        //position 2 - viewOrGroupBy
        if (argsLength >= 2) {
            if (viewOrGroupBy instanceof Grouping) {
                if (!(viewQueryStringOrSearchFilter instanceof ItemView)) {
                    throw new Error("Folder.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 1nd position, it must be Itemview when using Grouping at 2nd place");
                }
                groupResultBy = viewOrGroupBy;
                isGroupped = true;
            }
            else if (viewOrGroupBy instanceof ItemView) {
                view = viewOrGroupBy;
            }
            else {
                throw new Error("ExchangeService.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 2nd position, must be Itemsview or Grouping");
            }
        }
        //position 3 - groupBy
        if (argsLength === 3) {
            if (!(viewOrGroupBy instanceof ItemView)) {
                throw new Error("Folder.ts - FindItems with " + argsLength + " parameters - incorrect uses of parameter at 1nd position, it must be Itemview when using Grouping at 3rd place");
            }
            groupResultBy = groupBy;
            isGroupped = true;
        }
        return this.InternalFindItems(searchFilter || queryString, view, groupResultBy /* groupBy */)
            .then(function (res) {
            if (isGroupped) {
                return res.__thisIndexer(0).GroupedFindResults;
            }
            return res.__thisIndexer(0).Results;
        });
    };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    Folder.prototype.GetXmlElementName = function () { return XmlElementNames.Folder; };
    /**
     * @internal Gets the name of the change XML element.
     *
     * @return  {string}      XML element name,
     */
    Folder.prototype.GetChangeXmlElementName = function () { return XmlElementNames.FolderChange; };
    /**
     * @internal Gets the name of the delete field XML element.
     *
     * @return  {string}      XML element name,
     */
    Folder.prototype.GetDeleteFieldXmlElementName = function () { return XmlElementNames.DeleteFolderField; };
    /**
     * @internal Gets a list of extended properties defined on this object.
     *
     * @return  {ExtendedPropertyCollection}      Extended properties collection.
     */
    Folder.prototype.GetExtendedProperties = function () { return this.ExtendedProperties; };
    /**
     * @internal Get the property definition for the Id property.
     *
     * @return  {PropertyDefinition}      A PropertyDefinition instance.
     */
    Folder.prototype.GetIdPropertyDefinition = function () { return Schemas.FolderSchema.Id; };
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    Folder.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    Folder.prototype.GetSchema = function () { return Schemas.FolderSchema.Instance; };
    /**
     * @internal Gets the name of the set field XML element.
     *
     * @return  {string}      XML element name,
     */
    Folder.prototype.GetSetFieldXmlElementName = function () { return XmlElementNames.SetFolderField; };
    /**
     * @internal Deletes the object.
     *
     * @param   {DeleteMode}                deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}     sendCancellationsMode     Indicates whether meeting cancellation messages should be sent.
     * @param   {AffectedTaskOccurrence}    affectedTaskOccurrences   Indicate which occurrence of a recurring task should be deleted.
     */
    Folder.prototype.InternalDelete = function (deleteMode, sendCancellationsMode, affectedTaskOccurrences) {
        this.ThrowIfThisIsNew();
        return this.Service.DeleteFolder(this.Id, deleteMode);
    };
    Folder.prototype.InternalFindItems = function (searchFilterOrQueryString, view, groupBy) {
        this.ThrowIfThisIsNew();
        var searchFilter = null;
        var queryString = null;
        if (searchFilterOrQueryString instanceof SearchFilter) {
            searchFilter = searchFilterOrQueryString;
        }
        else if (typeof searchFilterOrQueryString === 'string') {
            queryString = searchFilterOrQueryString;
        }
        //debug: //todo: //ref: verify if querystring is null
        return this.Service.FindItems([this.Id], // FolderId[]
        searchFilter, /* searchFilter */ queryString, /* queryString */ view, groupBy, ServiceErrorHandling.ThrowOnError);
    };
    /**
     * @internal Loads the specified set of properties on the object.
     *
     * @param   {PropertySet}   propertySet   The properties to load.
     */
    Folder.prototype.InternalLoad = function (propertySet) {
        this.ThrowIfThisIsNew();
        return this.Service.LoadPropertiesForFolder(this, propertySet);
    };
    /**
     * Marks all items in folder as read. Calling this method results in a call to EWS.
     *
     * @param   {boolean}   suppressReadReceipts   If true, suppress sending read receipts for items.
     */
    Folder.prototype.MarkAllItemsAsRead = function (suppressReadReceipts) {
        this.ThrowIfThisIsNew();
        return this.Service.MarkAllItemsAsRead(this.Id, true, suppressReadReceipts);
    };
    /**
     * Marks all items in folder as read. Calling this method results in a call to EWS.
     *
     * @param   {boolean}   suppressReadReceipts   If true, suppress sending read receipts for items.
     */
    Folder.prototype.MarkAllItemsAsUnread = function (suppressReadReceipts) {
        this.ThrowIfThisIsNew();
        return this.Service.MarkAllItemsAsRead(this.Id, false, suppressReadReceipts);
    };
    Folder.prototype.Move = function (destinationFolderIdOrName) {
        this.ThrowIfThisIsNew();
        if (typeof destinationFolderIdOrName === 'undefined') {
            EwsLogging.Assert(false, "Folder.Move", "unknown paramete type");
            throw new Error("unknow parameter type. this should not be  reached");
        }
        //EwsUtilities.ValidateParam(destinationFolderId, "destinationFolderId");
        var folderId = destinationFolderIdOrName;
        if (typeof destinationFolderIdOrName === 'number')
            folderId = new FolderId(destinationFolderIdOrName);
        return this.Service.MoveFolder(this.Id, folderId);
    };
    /**
     * Removes an extended property.
     *
     * @param   {ExtendedPropertyDefinition}   extendedPropertyDefinition   The extended property definition.
     * @return  {boolean}       True if property was removed.
     */
    Folder.prototype.RemoveExtendedProperty = function (extendedPropertyDefinition) { return this.ExtendedProperties.RemoveExtendedProperty(extendedPropertyDefinition); };
    Folder.prototype.Save = function (parentFolderIdOrname) {
        this.ThrowIfThisIsNotNew();
        if (typeof parentFolderIdOrname === 'undefined') {
            EwsLogging.Assert(false, "Folder.Save", "unknown paramete type");
            throw new Error("unknow parameter type. this should not be  reached");
        }
        //EwsUtilities.ValidateParam(parentFolderId, "parentFolderId");
        var folderId = parentFolderIdOrname;
        if (typeof parentFolderIdOrname === 'number')
            folderId = new FolderId(parentFolderIdOrname);
        if (this.IsDirty) {
            return this.Service.CreateFolder(this, folderId);
        }
        else
            return null;
    };
    /**
     * Sets the extended property.
     *
     * @param   {ExtendedPropertyDefinition}    extendedPropertyDefinition   The extended property definition.
     * @param   {any}                           value                        The value.
     */
    Folder.prototype.SetExtendedProperty = function (extendedPropertyDefinition, value) { this.ExtendedProperties.SetExtendedProperty(extendedPropertyDefinition, value); };
    /**
     * Applies the local changes that have been made to this folder. Calling this method results in a call to EWS.
     *
     */
    Folder.prototype.Update = function () {
        if (this.IsDirty) {
            if (this.PropertyBag.GetIsUpdateCallNecessary()) {
                return this.Service.UpdateFolder(this);
            }
        }
        return undefined;
    };
    /**
     * @internal Validates this instance.
     *
     */
    Folder.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        // Validate folder permissions
        if (this.PropertyBag.Contains(Schemas.FolderSchema.Permissions)) {
            this.Permissions.Validate();
        }
    };
    return Folder;
}(ServiceObject));
exports.Folder = Folder;
/**
 * Represents a folder containing appointments.
 */
var CalendarFolder = (function (_super) {
    __extends(CalendarFolder, _super);
    /**
     * Initializes an unsaved local instance of **CalendarFolder**. To bind to an existing calendar folder, use CalendarFolder.Bind() instead.
     *
     * @param   {ExchangeService}   service   The ExchangeService object to which the calendar folder will be bound.
     */
    function CalendarFolder(service) {
        return _super.call(this, service) || this;
    }
    CalendarFolder.Bind = function (service, idOrName, propertySet) {
        if (propertySet === void 0) { propertySet = PropertySet.FirstClassProperties; }
        if (idOrName instanceof FolderId) {
            return service.BindToFolder(idOrName, propertySet, TypeContainer.CalendarFolder);
        }
        else if (typeof idOrName === 'number') {
            return service.BindToFolder(new FolderId(idOrName), propertySet, TypeContainer.CalendarFolder);
        }
        EwsLogging.Assert(false, "CalendarFolder.Bind", "unknown paramete type");
        throw new Error("unknow parameter type. this should not be  reached");
    };
    /**
     * Obtains a list of appointments by searching the contents of this folder and performing recurrence expansion for recurring appointments. Calling this method results in a call to EWS.
     *
     * @param   {CalendarView}   view   The view controlling the range of appointments returned.
     * @return  {FindItemsResults<Appointment>}          An object representing the results of the search operation.
     */
    CalendarFolder.prototype.FindAppointments = function (view) {
        EwsUtilities.ValidateParam(view, "view");
        return this.InternalFindItems(null, view, null /* groupBy */).then(function (responses) {
            return responses.__thisIndexer(0).Results;
        });
    };
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    CalendarFolder.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    CalendarFolder.prototype.GetXmlElementName = function () { return XmlElementNames.CalendarFolder; };
    return CalendarFolder;
}(Folder));
exports.CalendarFolder = CalendarFolder;
/**
 * Represents a folder containing contacts.
 */
var ContactsFolder = (function (_super) {
    __extends(ContactsFolder, _super);
    /**
     * Initializes an unsaved local instance of **ContactsFolder**. To bind to an existing contacts folder, use ContactsFolder.Bind() instead.
     *
     * @param   {ExchangeService}   service   The ExchangeService object to which the contacts folder will be bound.
     */
    function ContactsFolder(service) {
        return _super.call(this, service) || this;
    }
    ContactsFolder.Bind = function (service, idOrName, propertySet) {
        if (propertySet === void 0) { propertySet = PropertySet.FirstClassProperties; }
        if (idOrName instanceof FolderId) {
            return service.BindToFolder(idOrName, propertySet, TypeContainer.ContactsFolder);
        }
        else if (typeof idOrName === 'number') {
            return service.BindToFolder(new FolderId(idOrName), propertySet, TypeContainer.ContactsFolder);
        }
        EwsLogging.Assert(false, "ContactsFolder.Bind", "unknown paramete type");
        throw new Error("unknow parameter type. this should not be  reached");
    };
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    ContactsFolder.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    ContactsFolder.prototype.GetXmlElementName = function () { return XmlElementNames.ContactsFolder; };
    return ContactsFolder;
}(Folder));
exports.ContactsFolder = ContactsFolder;
/**
 * Represents a search folder.
 */
var SearchFolder = (function (_super) {
    __extends(SearchFolder, _super);
    /**
     * Initializes an unsaved local instance of **SearchFolder**. To bind to an existing contacts folder, use SearchFolder.Bind() instead.
     *
     * @param   {ExchangeService}   service   The ExchangeService object to which the contacts folder will be bound.
     */
    function SearchFolder(service) {
        return _super.call(this, service) || this;
    }
    Object.defineProperty(SearchFolder.prototype, "SearchParameters", {
        /**
         * Gets the search parameters associated with the search folder.
         */
        get: function () { return this.PropertyBag._getItem(Schemas.SearchFolderSchema.SearchParameters); },
        enumerable: true,
        configurable: true
    });
    SearchFolder.Bind = function (service, idOrName, propertySet) {
        if (propertySet === void 0) { propertySet = PropertySet.FirstClassProperties; }
        if (idOrName instanceof FolderId) {
            return service.BindToFolder(idOrName, propertySet, TypeContainer.SearchFolder);
        }
        else if (typeof idOrName === 'number') {
            return service.BindToFolder(new FolderId(idOrName), propertySet, TypeContainer.SearchFolder);
        }
        EwsLogging.Assert(false, "SearchFolder.Bind", "unknown paramete type");
        throw new Error("unknow parameter type. this should not be  reached");
    };
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    SearchFolder.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    SearchFolder.prototype.GetSchema = function () { return Schemas.SearchFolderSchema.Instance; };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    SearchFolder.prototype.GetXmlElementName = function () { return XmlElementNames.SearchFolder; };
    /**
     * @internal Validates this instance.
     */
    SearchFolder.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        if (this.SearchParameters != null) {
            this.SearchParameters.Validate();
        }
    };
    return SearchFolder;
}(Folder));
exports.SearchFolder = SearchFolder;
/**
 * Represents a folder containing task items.
 */
var TasksFolder = (function (_super) {
    __extends(TasksFolder, _super);
    /**
     * Initializes an unsaved local instance of **SearchFolder**. To bind to an existing contacts folder, use SearchFolder.Bind() instead.
     *
     * @param   {ExchangeService}   service   The ExchangeService object to which the contacts folder will be bound.
     */
    function TasksFolder(service) {
        return _super.call(this, service) || this;
    }
    TasksFolder.Bind = function (service, idOrName, propertySet) {
        if (propertySet === void 0) { propertySet = PropertySet.FirstClassProperties; }
        if (idOrName instanceof FolderId) {
            return service.BindToFolder(idOrName, propertySet, TypeContainer.TasksFolder);
        }
        else if (typeof idOrName === 'number') {
            return service.BindToFolder(new FolderId(idOrName), propertySet, TypeContainer.TasksFolder);
        }
        EwsLogging.Assert(false, "TasksFolder.Bind", "unknown paramete type");
        throw new Error("unknow parameter type. this should not be  reached");
    };
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    TasksFolder.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    TasksFolder.prototype.GetXmlElementName = function () { return XmlElementNames.TasksFolder; };
    return TasksFolder;
}(Folder));
exports.TasksFolder = TasksFolder;
/**
 * Represents a generic **Item**. Properties available on items are defined in the *ItemSchema* class.
 *
 */
var Item = (function (_super) {
    __extends(Item, _super);
    function Item(obj) {
        var _this = _super.call(this, obj instanceof TypeContainer.ExchangeService ? obj : obj instanceof TypeContainer.ItemAttachment ? obj.Service : null) || this;
        _this.parentAttachment = null;
        if (obj instanceof TypeContainer.ItemAttachment) {
            var parentAttachment = obj;
            EwsLogging.Assert(parentAttachment != null, "Item.ctor", "parentAttachment is null");
            _this.parentAttachment = parentAttachment;
        }
        return _this;
    }
    Object.defineProperty(Item, "Attachable", {
        /** required to check [Attachable] attribute, AttachmentCollection.AddItemAttachment<TItem>() checks for non inherited [Attachable] attribute. */
        get: function () { return this.name === "Item"; },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(Item.prototype, "ParentAttachment", {
        /**
         * @internal Gets the parent attachment of this item.
         *
         */
        get: function () {
            return this.parentAttachment;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "RootItemId", {
        /**
         * @internal Gets Id of the root item for this item.
         *
         */
        get: function () {
            if (this.IsAttachment && this.ParentAttachment.Owner !== null) {
                return this.ParentAttachment.Owner.RootItemId;
            }
            return this.Id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "IsAttachment", {
        /**
         * Gets a value indicating whether the item is an attachment.
         *
         */
        get: function () { return this.parentAttachment != null && typeof this.parentAttachment !== 'undefined'; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "IsNew", {
        /**
         * Gets a value indicating whether this object is a real store item, or if it's a local object that has yet to be saved.
         *
         */
        get: function () {
            // Item attachments don't have an Id, need to check whether the
            // parentAttachment is new or not.
            if (this.IsAttachment) {
                return this.ParentAttachment.IsNew;
            }
            else {
                var id = this.GetId();
                return id == null ? true : !id.IsValid;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "Id", {
        /**
         * Gets the Id of this item.
         *
         */
        get: function () { return this.PropertyBag._getItem(this.GetIdPropertyDefinition()); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "MimeContent", {
        /**
         * Get or sets the MIME content of this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.MimeContent);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.MimeContent, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "ParentFolderId", {
        /**
         * Gets the Id of the parent folder of this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.ParentFolderId);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "Sensitivity", {
        /**
         * Gets or sets the sensitivity of this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.Sensitivity);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.Sensitivity, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "Attachments", {
        /**
         * Gets a list of the attachments to this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.Attachments);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "DateTimeReceived", {
        /**
         * Gets the time when this item was received.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.DateTimeReceived);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "Size", {
        /**
         * Gets the size of this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.Size);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "Categories", {
        /**
         * Gets or sets the list of categories associated with this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.Categories);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.Categories, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "Culture", {
        /**
         * Gets or sets the culture associated with this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.Culture);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.Culture, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "Importance", {
        /**
         * Gets or sets the importance of this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.Importance);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.Importance, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "InReplyTo", {
        /**
         * Gets or sets the In-Reply-To reference of this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.InReplyTo);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.InReplyTo, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "IsSubmitted", {
        /**
         * Gets a value indicating whether the message has been submitted to be sent.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.IsSubmitted);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "IsAssociated", {
        /**
         * Gets a value indicating whether this is an associated item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.IsAssociated);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "IsDraft", {
        /**
         * Gets a value indicating whether the item is is a draft. An item is a draft when it has not yet been sent.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.IsDraft);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "IsFromMe", {
        /**
         * Gets a value indicating whether the item has been sent by the current authenticated user.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.IsFromMe);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "IsResend", {
        /**
         * Gets a value indicating whether the item is a resend of another item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.IsResend);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "IsUnmodified", {
        /**
         * Gets a value indicating whether the item has been modified since it was created.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.IsUnmodified);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "InternetMessageHeaders", {
        /**
         * Gets a list of Internet headers for this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.InternetMessageHeaders);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "DateTimeSent", {
        /**
         * Gets the date and time this item was sent.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.DateTimeSent);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "DateTimeCreated", {
        /**
         * Gets the date and time this item was created.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.DateTimeCreated);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "AllowedResponseActions", {
        /**
         * Gets a value indicating which response actions are allowed on this item. Examples of response actions are Reply and Forward.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.AllowedResponseActions);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "ReminderDueBy", {
        /**
         * Gets or sets the date and time when the reminder is due for this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.ReminderDueBy);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.ReminderDueBy, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "IsReminderSet", {
        /**
         * Gets or sets a value indicating whether a reminder is set for this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.IsReminderSet);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.IsReminderSet, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "ReminderMinutesBeforeStart", {
        /**
         * Gets or sets the number of minutes before the start of this item when the reminder should be triggered.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.ReminderMinutesBeforeStart);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.ReminderMinutesBeforeStart, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "DisplayCc", {
        /**
         * Gets a text summarizing the Cc receipients of this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.DisplayCc);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "DisplayTo", {
        /**
         * Gets a text summarizing the To recipients of this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.DisplayTo);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "HasAttachments", {
        /**
         * Gets a value indicating whether the item has attachments.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.HasAttachments);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "Body", {
        /**
         * Gets or sets the body of this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.Body);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.Body, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "ItemClass", {
        /**
         * Gets or sets the custom class name of this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.ItemClass);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.ItemClass, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "Subject", {
        /**
         * Gets or sets the subject of this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.Subject);
        },
        set: function (value) {
            this.SetSubject(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "WebClientReadFormQueryString", {
        /**
         * Gets the query string that should be appended to the Exchange Web client URL to open this item using the appropriate read form in a web browser.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.WebClientReadFormQueryString);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "WebClientEditFormQueryString", {
        /**
         * Gets the query string that should be appended to the Exchange Web client URL to open this item using the appropriate edit form in a web browser.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.WebClientEditFormQueryString);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "ExtendedProperties", {
        /**
         * Gets a list of extended properties defined on this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(ServiceObjectSchema.ExtendedProperties);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "EffectiveRights", {
        /**
         * Gets a value indicating the effective rights the current authenticated user has on this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.EffectiveRights);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "LastModifiedName", {
        /**
         * Gets the name of the user who last modified this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.LastModifiedName);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "LastModifiedTime", {
        /**
         * Gets the date and time this item was last modified.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.LastModifiedTime);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "ConversationId", {
        /**
         * Gets the Id of the conversation this item is part of.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.ConversationId);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "UniqueBody", {
        /**
         * Gets the body part that is unique to the conversation this item is part of.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.UniqueBody);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "StoreEntryId", {
        /**
         * Gets the store entry id.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.StoreEntryId);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "InstanceKey", {
        /**
         * Gets the item instance key.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.InstanceKey);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "Flag", {
        /**
         * Get or set the Flag value for this item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.Flag);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.Flag, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "NormalizedBody", {
        /**
         * Gets the normalized body of the item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.NormalizedBody);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "EntityExtractionResult", {
        /**
         * Gets the EntityExtractionResult of the item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.EntityExtractionResult);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "PolicyTag", {
        /**
         * Gets or sets the policy tag.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.PolicyTag);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.PolicyTag, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "ArchiveTag", {
        /**
         * Gets or sets the archive tag.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.ArchiveTag);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.ArchiveTag, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "RetentionDate", {
        /**
         * Gets the retention date.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.RetentionDate);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "Preview", {
        /**
         * Gets the item Preview.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.Preview);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "TextBody", {
        /**
         * Gets the text body of the item.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.TextBody);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "IconIndex", {
        /**
         * Gets the icon index.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.IconIndex);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "DefaultAffectedTaskOccurrences", {
        /**
         * @internal Gets the default setting for how to treat affected task occurrences on Delete.
         * Subclasses will override this for different default behavior.
         *
         */
        get: function () {
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "DefaultSendCancellationsMode", {
        /**
         * @internal Gets the default setting for sending cancellations on Delete.
         * Subclasses will override this for different default behavior.
         *
         */
        get: function () {
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "DefaultSendInvitationsMode", {
        /**
         * @internal Gets the default settings for sending invitations on Save.
         * Subclasses will override this for different default behavior.
         *
         */
        get: function () {
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "DefaultSendInvitationsOrCancellationsMode", {
        /**
         * @internal Gets the default settings for sending invitations or cancellations on Update.
         * Subclasses will override this for different default behavior.
         *
         */
        get: function () {
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Item.Bind = function (service, id, propertySet) {
        if (propertySet === void 0) { propertySet = PropertySet.FirstClassProperties; }
        return service.BindToItem(id, propertySet, Item);
    };
    Item.prototype.Copy = function (destinationFolderIdOrName) {
        this.ThrowIfThisIsNew();
        this.ThrowIfThisIsAttachment();
        var folderId = null;
        if (destinationFolderIdOrName instanceof FolderId) {
            folderId = destinationFolderIdOrName;
        }
        else {
            folderId = new FolderId(destinationFolderIdOrName);
        }
        //todo: EwsUtilities.ValidateParam(destinationFolderId, "destinationFolderId");
        return this.Service.CopyItem(this.Id, folderId);
    };
    Item.prototype.Delete = function (deleteMode, suppressReadReceipts) {
        if (suppressReadReceipts === void 0) { suppressReadReceipts = false; }
        return this.InternalDelete(deleteMode, null, null, suppressReadReceipts);
    };
    /**
     * @internal Gets a list of extended properties defined on this object.
     *
     * @return  {ExtendedPropertyCollection}      Extended properties collection.
     */
    Item.prototype.GetExtendedProperties = function () { return this.ExtendedProperties; };
    /**
     * @inrtnal The property definition for the Id of this object.
     *
     * @return  {PropertyDefinition}      A PropertyDefinition instance.
     */
    Item.prototype.GetIdPropertyDefinition = function () { return Schemas.ItemSchema.Id; };
    /**
     * Gets a value indicating whether a time zone SOAP header should be emitted in a CreateItem or UpdateItem request so this item can be property saved or updated.
     *
     * @param   {boolean}   isUpdateOperation   Indicates whether the operation being petrformed is an update operation.
     * @return  {boolean}                       true if a time zone SOAP header should be emitted; otherwise, false.
     */
    Item.prototype.GetIsTimeZoneHeaderRequired = function (isUpdateOperation) {
        // Starting E14SP2, attachment will be sent along with CreateItem requests. 
        // if the attachment used to require the Timezone header, CreateItem request should do so too.
        //
        debugger; //filtering of specific type needed.
        if (!isUpdateOperation &&
            (this.Service.RequestedServerVersion >= ExchangeVersion.Exchange2010_SP2)) {
            for (var _a = 0, _b = ArrayHelper.OfType(this.Attachments.Items, function (a) { return a instanceof TypeContainer.ItemAttachment; }); _a < _b.length; _a++) {
                var itemAttachment = _b[_a];
                if ((itemAttachment.Item != null) && itemAttachment.Item.GetIsTimeZoneHeaderRequired(false /* isUpdateOperation */)) {
                    return true;
                }
            }
        }
        return _super.prototype.GetIsTimeZoneHeaderRequired.call(this, isUpdateOperation);
    };
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    Item.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    Item.prototype.GetSchema = function () { return Schemas.ItemSchema.Instance; };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    Item.prototype.GetXmlElementName = function () { return XmlElementNames.Item; };
    /**
     * @internal Gets a value indicating whether this instance has unprocessed attachment collection changes.
     *
     * @return  {boolean}      true or false.
     *
     */
    Item.prototype.HasUnprocessedAttachmentChanges = function () { return this.Attachments.HasUnprocessedChanges(); };
    /**
     * @internal Create item.
     *
     * @param   {FolderId}              parentFolderId        The parent folder id.
     * @param   {MessageDisposition}    messageDisposition    The message disposition.
     * @param   {SendInvitationsMode}   sendInvitationsMode   The send invitations mode.
     */
    Item.prototype.InternalCreate = function (parentFolderId, messageDisposition, sendInvitationsMode) {
        var _this = this;
        this.ThrowIfThisIsNotNew();
        this.ThrowIfThisIsAttachment();
        if (this.IsNew || this.IsDirty) {
            return this.Service.CreateItem(this, parentFolderId, messageDisposition, sendInvitationsMode !== null ? sendInvitationsMode : this.DefaultSendInvitationsMode)
                .then(function (response) {
                return _this.Attachments.Save();
            });
        }
        return;
    };
    Item.prototype.InternalDelete = function (deleteMode, sendCancellationsMode, affectedTaskOccurrences, suppressReadReceipts) {
        if (sendCancellationsMode === void 0) { sendCancellationsMode = this.DefaultSendCancellationsMode; }
        if (affectedTaskOccurrences === void 0) { affectedTaskOccurrences = this.DefaultAffectedTaskOccurrences; }
        if (suppressReadReceipts === void 0) { suppressReadReceipts = false; }
        this.ThrowIfThisIsNew();
        this.ThrowIfThisIsAttachment();
        // If sendCancellationsMode is null, use the default value that's appropriate for item type.
        // if (!sendCancellationsMode)
        // {
        //     sendCancellationsMode = this.DefaultSendCancellationsMode;
        // }
        // If affectedTaskOccurrences is null, use the default value that's appropriate for item type.
        // if (!affectedTaskOccurrences)
        // {
        //     affectedTaskOccurrences = this.DefaultAffectedTaskOccurrences;
        // }
        return this.Service.DeleteItem(this.Id, deleteMode, sendCancellationsMode, affectedTaskOccurrences, suppressReadReceipts);
    };
    /**
     * @internal Loads the specified set of properties on the object.
     *
     * @param   {PropertySet}   propertySet   The properties to load.
     */
    Item.prototype.InternalLoad = function (propertySet) {
        this.ThrowIfThisIsNew();
        this.ThrowIfThisIsAttachment();
        return this.Service.InternalLoadPropertiesForItems([this], //new Item[] { this },
        propertySet, ServiceErrorHandling.ThrowOnError);
    };
    Item.prototype.InternalUpdate = function (parentFolderId, conflictResolutionMode, messageDisposition, sendInvitationsOrCancellationsMode, suppressReadReceipts) {
        var _this = this;
        if (suppressReadReceipts === void 0) { suppressReadReceipts = false; }
        this.ThrowIfThisIsNew();
        this.ThrowIfThisIsAttachment();
        var returnedPromise = null;
        var returnedItem = null;
        if (this.IsDirty && this.PropertyBag.GetIsUpdateCallNecessary()) {
            returnedPromise = this.Service.UpdateItem(this, parentFolderId, conflictResolutionMode, messageDisposition, sendInvitationsOrCancellationsMode !== null ? sendInvitationsOrCancellationsMode : this.DefaultSendInvitationsOrCancellationsMode, suppressReadReceipts);
        }
        return exports.Promise.resolve(returnedPromise).then(function (item) {
            // Regardless of whether item is dirty or not, if it has unprocessed
            // attachment changes, validate them and process now.
            if (_this.HasUnprocessedAttachmentChanges()) {
                _this.Attachments.Validate();
                return _this.Attachments.Save().then(function () {
                    return item;
                });
            }
            return item;
        });
        //return Promise.resolve(returnedItem);
    };
    Item.prototype.Move = function (destinationFolderIdOrName) {
        this.ThrowIfThisIsNew();
        this.ThrowIfThisIsAttachment();
        var folderId = null;
        if (destinationFolderIdOrName instanceof FolderId) {
            folderId = destinationFolderIdOrName;
        }
        else {
            folderId = new FolderId(destinationFolderIdOrName);
        }
        //EwsUtilities.ValidateParam(destinationFolderId, "destinationFolderId");
        return this.Service.MoveItem(this.Id, folderId);
    };
    /**
     * Removes an extended property.
     *
     * @param   {ExtendedPropertyDefinition}    extendedPropertyDefinition   The extended property definition.
     * @return  {boolean}                       True if property was removed.
     */
    Item.prototype.RemoveExtendedProperty = function (extendedPropertyDefinition) { return this.ExtendedProperties.RemoveExtendedProperty(extendedPropertyDefinition); };
    Item.prototype.Save = function (parentFolderIdOrName) {
        if (parentFolderIdOrName === void 0) { parentFolderIdOrName = null; }
        var parentFolderId = null;
        if (parentFolderIdOrName !== null) {
            parentFolderId = parentFolderIdOrName;
            if (typeof parentFolderIdOrName === 'number') {
                parentFolderId = new FolderId(parentFolderIdOrName);
            }
        }
        return this.InternalCreate(parentFolderId, MessageDisposition.SaveOnly, null);
    };
    /**
     * Sets the extended property.
     *
     * @param   {ExtendedPropertyDefinition}    extendedPropertyDefinition   The extended property definition.
     * @param   {value}                         value                        The value.
     */
    Item.prototype.SetExtendedProperty = function (extendedPropertyDefinition, value) { this.ExtendedProperties.SetExtendedProperty(extendedPropertyDefinition, value); };
    /**
     * @internal Sets the subject.
     *
     */
    Item.prototype.SetSubject = function (subject) { this.PropertyBag._setItem(Schemas.ItemSchema.Subject, subject); };
    /**
     * Throws exception if this is attachment.
     *
     */
    Item.prototype.ThrowIfThisIsAttachment = function () {
        if (this.IsAttachment) {
            throw new Error(Strings.OperationDoesNotSupportAttachments); //InvalidOperationException
        }
    };
    Item.prototype.Update = function (conflictResolutionMode, suppressReadReceipts) {
        if (suppressReadReceipts === void 0) { suppressReadReceipts = false; }
        return this.InternalUpdate(null /* parentFolder */, conflictResolutionMode, MessageDisposition.SaveOnly, null, suppressReadReceipts);
    };
    /**
     * @internal Validates this instance.
     *
     */
    Item.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        this.Attachments.Validate();
        // Flag parameter is only valid for Exchange2013 or higher
        //
        var flag = { outValue: null };
        if (this.TryGetProperty(Schemas.ItemSchema.Flag, flag) && flag.outValue != null) {
            if (this.Service.RequestedServerVersion < ExchangeVersion.Exchange2013) {
                throw new ServiceVersionException(StringHelper.Format(Strings.ParameterIncompatibleWithRequestVersion, "Flag", ExchangeVersion[ExchangeVersion.Exchange2013]));
            }
            flag.outValue.Validate();
        }
    };
    return Item;
}(ServiceObject));
exports.Item = Item;
/**
 * Represents an **appointment or a meeting**. Properties available on appointments are defined in the *AppointmentSchema* class.
 */
var Appointment = (function (_super) {
    __extends(Appointment, _super);
    function Appointment(svcOrAttachment, isNew) {
        if (isNew === void 0) { isNew = false; }
        var _this = _super.call(this, svcOrAttachment) || this;
        if (svcOrAttachment instanceof ItemAttachment) {
            var parentAttachment = svcOrAttachment;
            // If we're running against Exchange 2007, we need to explicitly preset
            // the StartTimeZone property since Exchange 2007 will otherwise scope
            // start and end to UTC.
            if (parentAttachment.Service.RequestedServerVersion == ExchangeVersion.Exchange2007_SP1) {
                if (isNew) {
                    _this.StartTimeZone = parentAttachment.Service.TimeZone;
                }
            }
        }
        return _this;
    }
    Object.defineProperty(Appointment, "Attachable", {
        /** required to check [Attachable] attribute, AttachmentCollection.AddItemAttachment<TItem>() checks for non inherited [Attachable] attribute.*/
        get: function () { return this.name === "Appointment"; },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(Appointment.prototype, "DefaultSendCancellationsMode", {
        /**
         * @internal Gets the default setting for sending cancellations on Delete.
         *
         * @return  {SendCancellationsMode}      If Delete() is called on Appointment, we want to send cancellations and save a copy.
         */
        get: function () {
            return SendCancellationsMode.SendToAllAndSaveCopy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "DefaultSendInvitationsMode", {
        /**
         * @internal Gets the default settings for sending invitations on Save.
         */
        get: function () {
            return SendInvitationsMode.SendToAllAndSaveCopy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "DefaultSendInvitationsOrCancellationsMode", {
        /**
         * @internal Gets the default settings for sending invitations or cancellations on Update.
         */
        get: function () {
            return SendInvitationsOrCancellationsMode.SendToAllAndSaveCopy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "Start", {
        /**
         * Gets or sets the start time of the appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.Start);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.AppointmentSchema.Start, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "End", {
        /**
         * Gets or sets the end time of the appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.End);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.AppointmentSchema.End, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "OriginalStart", {
        /**
         * Gets the original start time of this appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.OriginalStart);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "IsAllDayEvent", {
        /**
         * Gets or sets a value indicating whether this appointment is an all day event.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.IsAllDayEvent);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.AppointmentSchema.IsAllDayEvent, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "LegacyFreeBusyStatus", {
        /**
         * Gets or sets a value indicating the free/busy status of the owner of this appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.LegacyFreeBusyStatus);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.AppointmentSchema.LegacyFreeBusyStatus, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "Location", {
        /**
         * Gets or sets the location of this appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.Location);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.AppointmentSchema.Location, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "When", {
        /**
         * Gets a text indicating when this appointment occurs.
         * The text returned by When is localized using the Exchange Server culture or using the culture specified in the PreferredCulture property of the ExchangeService object this appointment is bound to.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.When);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "IsMeeting", {
        /**
         * Gets a value indicating whether the appointment is a meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.IsMeeting);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "IsCancelled", {
        /**
         * Gets a value indicating whether the appointment has been cancelled.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.IsCancelled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "IsRecurring", {
        /**
         * Gets a value indicating whether the appointment is recurring.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.IsRecurring);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "MeetingRequestWasSent", {
        /**
         * Gets a value indicating whether the meeting request has already been sent.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.MeetingRequestWasSent);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "IsResponseRequested", {
        /**
         * Gets or sets a value indicating whether responses are requested when invitations are sent for this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.IsResponseRequested);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.AppointmentSchema.IsResponseRequested, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "AppointmentType", {
        /**
         * Gets a value indicating the type of this appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.AppointmentType);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "MyResponseType", {
        /**
         * Gets a value indicating what was the last response of the user that loaded this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.MyResponseType);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "Organizer", {
        /**
         * Gets the organizer of this meeting. The Organizer property is read-only and is only relevant for attendees.
         * The organizer of a meeting is automatically set to the user that created the meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.Organizer);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "RequiredAttendees", {
        /**
         * Gets a list of required attendees for this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.RequiredAttendees);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "OptionalAttendees", {
        /**
         * Gets a list of optional attendeed for this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.OptionalAttendees);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "Resources", {
        /**
         * Gets a list of resources for this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.Resources);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "ConflictingMeetingCount", {
        /**
         * Gets the number of calendar entries that conflict with this appointment in the authenticated user's calendar.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.ConflictingMeetingCount);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "AdjacentMeetingCount", {
        /**
         * Gets the number of calendar entries that are adjacent to this appointment in the authenticated user's calendar.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.AdjacentMeetingCount);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "ConflictingMeetings", {
        /**
         * Gets a list of meetings that conflict with this appointment in the authenticated user's calendar.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.ConflictingMeetings);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "AdjacentMeetings", {
        /**
         * Gets a list of meetings that is adjacent to this appointment in the authenticated user's calendar.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.AdjacentMeetings);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "Duration", {
        /**
         * Gets the duration of this appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.Duration);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "TimeZone", {
        /**
         * Gets the name of the time zone this appointment is defined in.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.TimeZone);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "AppointmentReplyTime", {
        /**
         * Gets the time when the attendee replied to the meeting request.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.AppointmentReplyTime);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "AppointmentSequenceNumber", {
        /**
         * Gets the sequence number of this appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.AppointmentSequenceNumber);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "AppointmentState", {
        /**
         * Gets the state of this appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.AppointmentState);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "Recurrence", {
        /**
         * Gets or sets the recurrence pattern for this appointment. Available recurrence pattern classes include
         * Recurrence.DailyPattern, Recurrence.MonthlyPattern and Recurrence.YearlyPattern.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.Recurrence);
        },
        set: function (value) {
            if (value !== null && value.IsRegenerationPattern) {
                throw new ServiceLocalException(Strings.RegenerationPatternsOnlyValidForTasks);
            }
            this.PropertyBag._setItem(Schemas.AppointmentSchema.Recurrence, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "FirstOccurrence", {
        /**
         * Gets an OccurrenceInfo identifying the first occurrence of this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.FirstOccurrence);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "LastOccurrence", {
        /**
         * Gets an OccurrenceInfo identifying the last occurrence of this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.LastOccurrence);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "ModifiedOccurrences", {
        /**
         * Gets a list of modified occurrences for this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.ModifiedOccurrences);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "DeletedOccurrences", {
        /**
         * Gets a list of deleted occurrences for this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.DeletedOccurrences);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "StartTimeZone", {
        /**
         * Gets or sets time zone of the start property of this appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.StartTimeZone);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.AppointmentSchema.StartTimeZone, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "EndTimeZone", {
        /**
         * Gets or sets time zone of the end property of this appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.EndTimeZone);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.AppointmentSchema.EndTimeZone, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "ConferenceType", {
        /**
         * Gets or sets the type of conferencing that will be used during the meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.ConferenceType);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.AppointmentSchema.ConferenceType, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "AllowNewTimeProposal", {
        /**
         * Gets or sets a value indicating whether new time proposals are allowed for attendees of this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.AllowNewTimeProposal);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.AppointmentSchema.AllowNewTimeProposal, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "IsOnlineMeeting", {
        /**
         * Gets or sets a value indicating whether this is an online meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.IsOnlineMeeting);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.AppointmentSchema.IsOnlineMeeting, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "MeetingWorkspaceUrl", {
        /**
         * Gets or sets the URL of the meeting workspace. A meeting workspace is a shared Web site for planning meetings and tracking results.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.MeetingWorkspaceUrl);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.AppointmentSchema.MeetingWorkspaceUrl, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "NetShowUrl", {
        /**
         * Gets or sets the URL of the Microsoft NetShow online meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.NetShowUrl);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.AppointmentSchema.NetShowUrl, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "ICalUid", {
        /**
         * Gets or sets the ICalendar Uid.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.ICalUid);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.AppointmentSchema.ICalUid, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "ICalRecurrenceId", {
        /**
         * Gets the ICalendar RecurrenceId.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.ICalRecurrenceId);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "ICalDateTimeStamp", {
        /**
         * Gets the ICalendar DateTimeStamp.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.ICalDateTimeStamp);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "EnhancedLocation", {
        /**
         * Gets or sets the Enhanced location object.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.EnhancedLocation);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.AppointmentSchema.EnhancedLocation, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "JoinOnlineMeetingUrl", {
        /**
         * Gets the Url for joining an online meeting
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.JoinOnlineMeetingUrl);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Appointment.prototype, "OnlineMeetingSettings", {
        /**
         * Gets the Online Meeting Settings
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.OnlineMeetingSettings);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Accepts the meeting. Calling this method results in a call to EWS.
     *
     * @param   {boolean}   sendResponse   Indicates whether to send a response to the organizer.
     * @return  {Promise<CalendarActionResults>}   A CalendarActionResults object containing the various items that were created or modified as a results of this operation :Promise.
     */
    Appointment.prototype.Accept = function (sendResponse) {
        return this.InternalAccept(false, sendResponse);
    };
    /**
     * Tentatively accepts the meeting. Calling this method results in a call to EWS.
     *
     * @param   {boolean}   sendResponse   Indicates whether to send a response to the organizer.
     * @return  {Promise<CalendarActionResults>}   A CalendarActionResults object containing the various items that were created or modified as a results of this operation :Promise.
     */
    Appointment.prototype.AcceptTentatively = function (sendResponse) {
        return this.InternalAccept(true, sendResponse);
    };
    Appointment.Bind = function (service, id, propertySet) {
        if (propertySet === void 0) { propertySet = PropertySet.FirstClassProperties; }
        return service.BindToItem(id, propertySet, Appointment);
    };
    Appointment.BindToOccurrence = function (service, recurringMasterId, occurenceIndex, propertySet) {
        if (propertySet === void 0) { propertySet = PropertySet.FirstClassProperties; }
        var occurenceId = new AppointmentOccurrenceId(recurringMasterId.UniqueId, occurenceIndex);
        return Appointment.Bind(service, occurenceId, propertySet);
    };
    Appointment.BindToRecurringMaster = function (service, occurrenceId, propertySet) {
        if (propertySet === void 0) { propertySet = PropertySet.FirstClassProperties; }
        var recurringMasterId = new RecurringAppointmentMasterId(occurrenceId.UniqueId);
        return Appointment.Bind(service, recurringMasterId, propertySet);
    };
    Appointment.prototype.CancelMeeting = function (cancellationMessageText) {
        if (arguments.length === 0) {
            return this.CreateCancelMeetingMessage().SendAndSaveCopy();
        }
        var cancelMsg = this.CreateCancelMeetingMessage();
        cancelMsg.Body = new MessageBody(cancellationMessageText); //todo:fix - cant use implicit operator of c#, using explicit. Assumed HTML body used in c# implicit conversion
        return cancelMsg.SendAndSaveCopy();
    };
    /**
     * Creates a local meeting acceptance message that can be customized and sent.
     *
     * @param   {boolean}   tentative   Specifies whether the meeting will be tentatively accepted.
     * @return  {AcceptMeetingInvitationMessage}  An AcceptMeetingInvitationMessage representing the meeting acceptance message.
     */
    Appointment.prototype.CreateAcceptMessage = function (tentative) {
        return new AcceptMeetingInvitationMessage(this, tentative);
    };
    /**
     * Creates a local meeting cancellation message that can be customized and sent.
     *
     * @return  {CancelMeetingMessage}    A CancelMeetingMessage representing the meeting cancellation message.
     */
    Appointment.prototype.CreateCancelMeetingMessage = function () {
        return new CancelMeetingMessage(this);
    };
    /**
     * Creates a local meeting declination message that can be customized and sent.
     *
     * @return  {DeclineMeetingInvitationMessage}      A DeclineMeetingInvitation representing the meeting declination message.
     */
    Appointment.prototype.CreateDeclineMessage = function () {
        return new DeclineMeetingInvitationMessage(this);
    };
    /**
     * Creates a forward message from this appointment.
     *
     * @return  {ResponseMessage} A ResponseMessage representing the forward response that can subsequently be modified and sent.
     */
    Appointment.prototype.CreateForward = function () {
        this.ThrowIfThisIsNew();
        return new ResponseMessage(this, ResponseMessageType.Forward);
    };
    /**
     * Creates a reply response to the organizer and/or attendees of the meeting.
     *
     * @param   {boolean}   replyAll   Indicates whether the reply should go to the organizer only or to all the attendees.
     * @return  {ResponseMessage} A ResponseMessage representing the reply response that can subsequently be modified and sent.
     */
    Appointment.prototype.CreateReply = function (replyAll) {
        this.ThrowIfThisIsNew();
        return new ResponseMessage(this, replyAll ? ResponseMessageType.ReplyAll : ResponseMessageType.Reply);
    };
    /**
     * Declines the meeting invitation. Calling this method results in a call to EWS.
     *
     * @param   {boolean}   sendResponse   Indicates whether to send a response to the organizer.
     * @return  {Promise<CalendarActionResults>}   A CalendarActionResults object containing the various items that were created or modified as aresults of this operation :Promise.
     */
    Appointment.prototype.Decline = function (sendResponse) {
        var decline = this.CreateDeclineMessage();
        if (sendResponse) {
            return decline.SendAndSaveCopy();
        }
        else {
            return decline.Save();
        }
    };
    Appointment.prototype.Delete = function (deleteMode, sendCancellationsMode) {
        return this.InternalDelete(deleteMode, sendCancellationsMode, null);
    };
    Appointment.prototype.Forward = function (bodyPrefix, _toRecipients) {
        var responseMessage = this.CreateForward();
        var toRecipients = [];
        responseMessage.BodyPrefix = bodyPrefix;
        if (ArrayHelper.isArray(_toRecipients)) {
            toRecipients = _toRecipients;
        }
        else {
            for (var _i = 1; _i < arguments.length; _i++) {
                toRecipients[_i - 1] = arguments[_i];
            }
        }
        responseMessage.ToRecipients.AddRange(toRecipients);
        return responseMessage.SendAndSaveCopy();
    };
    /**
     * @internal Determines whether properties defined with ScopedDateTimePropertyDefinition require custom time zone scoping.
     *
     * @return  {boolean}      true if this item type requires custom scoping for scoped date/time properties; otherwise, false.
     */
    Appointment.prototype.GetIsCustomDateTimeScopingRequired = function () {
        return true;
    };
    /**
     * @internal Gets a value indicating whether a time zone SOAP header should be emitted in a CreateItem or UpdateItem request so this item can be property saved or updated.
     *
     * @param   {boolean}   isUpdateOperation   Indicates whether the operation being petrformed is an update operation.
     * @return  {boolean}                       true if a time zone SOAP header should be emitted; otherwise, false.
     */
    Appointment.prototype.GetIsTimeZoneHeaderRequired = function (isUpdateOperation) {
        if (isUpdateOperation) {
            return false;
        }
        else {
            var isStartTimeZoneSetOrUpdated = this.PropertyBag.IsPropertyUpdated(Schemas.AppointmentSchema.StartTimeZone);
            var isEndTimeZoneSetOrUpdated = this.PropertyBag.IsPropertyUpdated(Schemas.AppointmentSchema.EndTimeZone);
            if (isStartTimeZoneSetOrUpdated && isEndTimeZoneSetOrUpdated) {
                // If both StartTimeZone and EndTimeZone have been set or updated and are the same as the service's
                // time zone, we emit the time zone header and StartTimeZone and EndTimeZone are not emitted.
                var startTimeZone = { outValue: null };
                var endTimeZone = { outValue: null };
                ;
                this.PropertyBag.TryGetPropertyAs(Schemas.AppointmentSchema.StartTimeZone, startTimeZone);
                this.PropertyBag.TryGetPropertyAs(Schemas.AppointmentSchema.EndTimeZone, endTimeZone);
                return startTimeZone.outValue == this.Service.TimeZone || endTimeZone.outValue == this.Service.TimeZone;
            }
            else {
                return true;
            }
        }
    };
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    Appointment.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    Appointment.prototype.GetSchema = function () {
        return Schemas.AppointmentSchema.Instance;
    };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    Appointment.prototype.GetXmlElementName = function () {
        return XmlElementNames.CalendarItem;
    };
    /**
     * @internal Accepts the meeting.
     *
     * @param   {boolean}   tentative      True if tentative accept.
     * @param   {boolean}   sendResponse   Indicates whether to send a response to the organizer.
     * @return  {Promise<CalendarActionResults>}    A CalendarActionResults object containing the various items that were created or modified as aresults of this operation :Promise.
     */
    Appointment.prototype.InternalAccept = function (tentative, sendResponse) {
        var accept = this.CreateAcceptMessage(tentative);
        if (sendResponse) {
            return accept.SendAndSaveCopy();
        }
        else {
            return accept.Save();
        }
    };
    /**
     * Replies to the organizer and/or the attendees of the meeting. Calling this method results in a call to EWS.
     *
     * @param   {MessageBody}     bodyPrefix   The prefix to prepend to the body of the meeting.
     * @param   {boolean}         replyAll     Indicates whether the reply should go to the organizer only or to all the attendees.
     */
    Appointment.prototype.Reply = function (bodyPrefix, replyAll) {
        var responseMessage = this.CreateReply(replyAll);
        responseMessage.BodyPrefix = bodyPrefix;
        return responseMessage.SendAndSaveCopy();
    };
    Appointment.prototype.Save = function (destinationFolderNameOrIdOrSendInvitationMode, sendInvitationsMode) {
        var argsLength = arguments.length;
        if (argsLength < 1 || argsLength > 2) {
            throw new Error("Appointment.ts - Save : Invalid number of arguments");
        }
        var simode = sendInvitationsMode;
        if (argsLength === 1) {
            simode = destinationFolderNameOrIdOrSendInvitationMode;
            return this.InternalCreate(null, null, simode);
        }
        var destinationFolderId = destinationFolderNameOrIdOrSendInvitationMode;
        if (argsLength === 2) {
            if (typeof destinationFolderNameOrIdOrSendInvitationMode === "number") {
                destinationFolderId = new FolderId(destinationFolderNameOrIdOrSendInvitationMode);
            }
            return this.InternalCreate(destinationFolderId, null, sendInvitationsMode);
        }
    };
    Appointment.prototype.Update = function (conflictResolutionMode, sendInvitationsOrCancellationsMode) {
        return this.InternalUpdate(null, conflictResolutionMode, null, sendInvitationsOrCancellationsMode);
    };
    /**
     * @internal Validates this instance.
     *
     */
    Appointment.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        //  Make sure that if we're on the Exchange2007_SP1 schema version, if any of the following
        //  properties are set or updated:
        //      o   Start
        //      o   End
        //      o   IsAllDayEvent
        //      o   Recurrence
        //  ... then, we must send the MeetingTimeZone element (which is generated from StartTimeZone for
        //  Exchange2007_SP1 requests (see StartTimeZonePropertyDefinition.cs).  If the StartTimeZone isn't
        //  in the property bag, then throw, because clients must supply the proper time zone - either by
        //  loading it from a currently-existing appointment, or by setting it directly.  Otherwise, to dirty
        //  the StartTimeZone property, we just set it to its current value.
        if ((this.Service.RequestedServerVersion == ExchangeVersion.Exchange2007_SP1) &&
            !this.Service.Exchange2007CompatibilityMode) {
            if (this.PropertyBag.IsPropertyUpdated(Schemas.AppointmentSchema.Start) ||
                this.PropertyBag.IsPropertyUpdated(Schemas.AppointmentSchema.End) ||
                this.PropertyBag.IsPropertyUpdated(Schemas.AppointmentSchema.IsAllDayEvent) ||
                this.PropertyBag.IsPropertyUpdated(Schemas.AppointmentSchema.Recurrence)) {
                //  If the property isn't in the property bag, throw....
                if (!this.PropertyBag.Contains(Schemas.AppointmentSchema.StartTimeZone)) {
                    throw new ServiceLocalException(Strings.StartTimeZoneRequired);
                }
                //  Otherwise, set the time zone to its current value to force it to be sent with the request.
                this.StartTimeZone = this.StartTimeZone;
            }
        }
    };
    return Appointment;
}(Item));
exports.Appointment = Appointment;
/**
 * Represents a **contact**. Properties available on contacts are defined in the *ContactSchema* class.
 *
 */
var Contact = (function (_super) {
    __extends(Contact, _super);
    function Contact(serviceOrParentAttachment) {
        return _super.call(this, serviceOrParentAttachment instanceof ItemAttachment ? serviceOrParentAttachment.Service : serviceOrParentAttachment) || this;
    }
    Object.defineProperty(Contact, "Attachable", {
        /** required to check [Attachable] attribute, AttachmentCollection.AddItemAttachment<TItem>() checks for non inherited [Attachable] attribute. */
        get: function () { return this.name === "Contact"; },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(Contact.prototype, "FileAs", {
        /**
         * Gets or set the name under which this contact is filed as. FileAs can be manually set or can be automatically calculated based on the value of the FileAsMapping property.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.FileAs);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.FileAs, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "FileAsMapping", {
        /**
         * Gets or sets a value indicating how the FileAs property should be automatically calculated.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.FileAsMapping);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.FileAsMapping, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "DisplayName", {
        /**
         * Gets or sets the display name of the contact.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.DisplayName);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.DisplayName, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "GivenName", {
        /**
         * Gets or sets the given name of the contact.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.GivenName);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.GivenName, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "Initials", {
        /**
         * Gets or sets the initials of the contact.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.Initials);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.Initials, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "MiddleName", {
        /**
         * Gets or sets the middle mame of the contact.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.MiddleName);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.MiddleName, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "NickName", {
        /**
         * Gets or sets the nick name of the contact.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.NickName);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.NickName, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "CompleteName", {
        /**
         * Gets the complete name of the contact.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.CompleteName);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "CompanyName", {
        /**
         * Gets or sets the compnay name of the contact.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.CompanyName);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.CompanyName, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "EmailAddresses", {
        /**
         * Gets an indexed list of e-mail addresses for the contact. For example, to set the first e-mail address,
         * use the following syntax: EmailAddresses[EmailAddressKey.EmailAddress1] = "john.doe@contoso.com"
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.EmailAddresses);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "PhysicalAddresses", {
        /**
         * Gets an indexed list of physical addresses for the contact. For example, to set the business address,
         * use the following syntax: PhysicalAddresses[PhysicalAddressKey.Business] = new PhysicalAddressEntry()
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.PhysicalAddresses);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "PhoneNumbers", {
        /**
         * Gets an indexed list of phone numbers for the contact. For example, to set the home phone number,
         * use the following syntax: PhoneNumbers[PhoneNumberKey.HomePhone] = "phone number"
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.PhoneNumbers);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "AssistantName", {
        /**
         * Gets or sets the contact's assistant name.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.AssistantName);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.AssistantName, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "Birthday", {
        /**
         * Gets or sets the birthday of the contact.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.Birthday);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.Birthday, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "BusinessHomePage", {
        /**
         * Gets or sets the business home page of the contact.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.BusinessHomePage);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.BusinessHomePage, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "Children", {
        /**
         * Gets or sets a list of children for the contact.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.Children);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.Children, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "Companies", {
        /**
         * Gets or sets a list of companies for the contact.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.Companies);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.Companies, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "ContactSource", {
        /**
         * Gets the source of the contact.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.ContactSource);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "Department", {
        /**
         * Gets or sets the department of the contact.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.Department);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.Department, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "Generation", {
        /**
         * Gets or sets the generation of the contact.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.Generation);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.Generation, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "ImAddresses", {
        /**
         * Gets an indexed list of Instant Messaging addresses for the contact.
         * For example, to set the first IM address, use the following syntax: ImAddresses[ImAddressKey.ImAddress1] = "john.doe@contoso.com"
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.ImAddresses);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "JobTitle", {
        /**
         * Gets or sets the contact's job title.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.JobTitle);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.JobTitle, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "Manager", {
        /**
         * Gets or sets the name of the contact's manager.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.Manager);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.Manager, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "Mileage", {
        /**
         * Gets or sets the mileage for the contact.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.Mileage);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.Mileage, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "OfficeLocation", {
        /**
         * Gets or sets the location of the contact's office.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.OfficeLocation);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.OfficeLocation, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "PostalAddressIndex", {
        /**
         * Gets or sets the index of the contact's postal address. When set, PostalAddressIndex refers to an entry in the PhysicalAddresses indexed list.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.PostalAddressIndex);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.PostalAddressIndex, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "Profession", {
        /**
         * Gets or sets the contact's profession.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.Profession);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.Profession, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "SpouseName", {
        /**
         * Gets or sets the name of the contact's spouse.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.SpouseName);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.SpouseName, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "Surname", {
        /**
         * Gets or sets the surname of the contact.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.Surname);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.Surname, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "WeddingAnniversary", {
        /**
         * Gets or sets the date of the contact's wedding anniversary.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.WeddingAnniversary);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.WeddingAnniversary, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "HasPicture", {
        /**
         * Gets a value indicating whether this contact has a picture associated with it.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.HasPicture);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "PhoneticFullName", {
        /**
         * Gets the full phonetic name from the directory
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.PhoneticFullName);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "PhoneticFirstName", {
        /**
         * Gets the phonetic first name from the directory
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.PhoneticFirstName);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "PhoneticLastName", {
        /**
         * Gets the phonetic last name from the directory
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.PhoneticLastName);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "Alias", {
        /**
         * Gets the Alias from the directory
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.Alias);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "Notes", {
        /**
         * Get the Notes from the directory
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.Notes);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "DirectoryPhoto", {
        /**
         * Gets the Photo from the directory **Unstable: needs testing**
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.Photo);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "UserSMIMECertificate", {
        /**
         * Gets the User SMIME certificate from the directory **Unstable: needs testing**
         * //ref: cant use bytearray, using base64 decoded string instead -  number[][]
         *
         */
        get: function () {
            var byteArrayArray = this.PropertyBag._getItem(Schemas.ContactSchema.UserSMIMECertificate);
            return byteArrayArray.Content;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "MSExchangeCertificate", {
        /**
         * Gets the MSExchange certificate from the directory **Unstable: needs testing**
         * //ref: cant use bytearray, using base64 decoded string instead -  number[][]
         *
         */
        get: function () {
            var byteArrayArray = this.PropertyBag._getItem(Schemas.ContactSchema.MSExchangeCertificate);
            return byteArrayArray.Content;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "DirectoryId", {
        /**
         * Gets the DirectoryID as Guid or DN string
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.DirectoryId);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "ManagerMailbox", {
        /**
         * Gets the manager mailbox information
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.ManagerMailbox);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contact.prototype, "DirectReports", {
        /**
         * Get the direct reports mailbox information
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.DirectReports);
        },
        enumerable: true,
        configurable: true
    });
    // Bind(service: ExchangeService, id: ItemId, propertySet: PropertySet = PropertySet.FirstClassProperties): Promise<Contact> { //removed
    //     return Contact.Bind(service, id, propertySet);
    // }
    Contact.Bind = function (service, id, propertySet) {
        if (propertySet === void 0) { propertySet = PropertySet.FirstClassProperties; }
        return service.BindToItem(id, propertySet, Contact);
    };
    /**
     * Retrieves the file attachment that holds the contact's picture. **Unstable: needs testing**
     *
     * @return  {FileAttachment}      The file attachment that holds the contact's picture.
     */
    Contact.prototype.GetContactPictureAttachment = function () {
        EwsUtilities.ValidateMethodVersion(this.Service, ExchangeVersion.Exchange2010, "GetContactPictureAttachment");
        if (!this.PropertyBag.IsPropertyLoaded(Schemas.ContactSchema.Attachments)) {
            throw new PropertyException(Strings.AttachmentCollectionNotLoaded);
        }
        for (var _a = 0, _b = this.Attachments.Items; _a < _b.length; _a++) {
            var attachment = _b[_a];
            //todo: implement typecasting
            var fileAttachment = attachment;
            if (fileAttachment.IsContactPhoto) {
                return fileAttachment;
            }
        }
        return null;
    };
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    Contact.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    Contact.prototype.GetSchema = function () { return Schemas.ContactSchema.Instance; };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    Contact.prototype.GetXmlElementName = function () { return XmlElementNames.Contact; };
    /**
     * Removes the picture from local attachment collection.     *
     */
    Contact.prototype.InternalRemoveContactPicture = function () {
        // Iterates in reverse order to remove file attachments that have IsContactPhoto set to true.
        for (var index = this.Attachments.Count - 1; index >= 0; index--) {
            //todo: implement safe typecasting
            var fileAttachment = this.Attachments._getItem(index);
            if (fileAttachment != null) {
                if (fileAttachment.IsContactPhoto) {
                    this.Attachments.Remove(fileAttachment);
                }
            }
        }
    };
    /**
     * Removes the contact's picture.     *
     */
    Contact.prototype.RemoveContactPicture = function () {
        EwsUtilities.ValidateMethodVersion(this.Service, ExchangeVersion.Exchange2010, "RemoveContactPicture");
        if (!this.PropertyBag.IsPropertyLoaded(Schemas.ContactSchema.Attachments)) {
            throw new PropertyException(Strings.AttachmentCollectionNotLoaded);
        }
        this.InternalRemoveContactPicture();
    };
    //ref: //todo: Not Implemented
    //SetContactPicture(contentStream: any /*System.IO.Stream*/): any { throw new Error("Contact.ts - SetContactPicture : Not implemented."); }
    //SetContactPicture(content: number[] /*System.Byte[]*/): any { throw new Error("Contact.ts - SetContactPicture : Not implemented."); }
    //SetContactPicture(fileName: string): any { throw new Error("Contact.ts - SetContactPicture : Not implemented."); }
    /**
     * Sets the contact's picture using the base64 content of file.
     *
     * @param   {string}    base64Content       base64 content of picture attachment.
     * @param   {string}    attachmentName      name of the picture attachment.
     *
     */
    Contact.prototype.SetContactPicture = function (base64Content, attachmentName) {
        EwsUtilities.ValidateMethodVersion(this.Service, ExchangeVersion.Exchange2010, "SetContactPicture");
        this.InternalRemoveContactPicture();
        var fileAttachment = this.Attachments.AddFileAttachment(attachmentName, base64Content);
        fileAttachment.IsContactPhoto = true;
    };
    /**
     * @internal Validates this instance.     *
     */
    Contact.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        var fileAsMapping = { outValue: null };
        if (this.TryGetProperty(Schemas.ContactSchema.FileAsMapping, fileAsMapping)) {
            // FileAsMapping is extended by 5 new values in 2010 mode. Validate that they are used according the version.
            EwsUtilities.ValidateEnumVersionValue(FileAsMapping, fileAsMapping.outValue, this.Service.RequestedServerVersion, "FileAsMapping");
        }
    };
    Contact.ContactPictureName = "ContactPicture.jpg";
    return Contact;
}(Item));
exports.Contact = Contact;
/**
 * Represents a Contact Group. Properties available on contact groups are defined in the ContactGroupSchema class.
 */
var ContactGroup = (function (_super) {
    __extends(ContactGroup, _super);
    function ContactGroup(serviceOrParentAttachment) {
        return _super.call(this, serviceOrParentAttachment) || this;
    }
    Object.defineProperty(ContactGroup.prototype, "FileAs", {
        /**
         * Gets the name under which this contact group is filed as.
         *
         * [RequiredServerVersion(ExchangeVersion.Exchange2010)]
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.FileAs);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContactGroup.prototype, "DisplayName", {
        /**
         * Gets or sets the display name of the contact group.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactSchema.DisplayName);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ContactSchema.DisplayName, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContactGroup.prototype, "Members", {
        /**
         * Gets the members of the contact group.
         *
         * [RequiredServerVersion(ExchangeVersion.Exchange2010)]
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ContactGroupSchema.Members);
        },
        enumerable: true,
        configurable: true
    });
    ContactGroup.Bind = function (service, id, propertySet) {
        if (propertySet === void 0) { propertySet = PropertySet.FirstClassProperties; }
        return service.BindToItem(id, propertySet, ContactGroup);
    };
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    ContactGroup.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    ContactGroup.prototype.GetSchema = function () {
        return Schemas.ContactGroupSchema.Instance;
    };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    ContactGroup.prototype.GetXmlElementName = function () {
        return XmlElementNames.DistributionList;
    };
    /**
     *  @internal Sets the subject.
     *
     * @param   {string}   subject   The subject.
     */
    ContactGroup.prototype.SetSubject = function (subject) {
        // Set is disabled in client API even though it is implemented in protocol for Item.Subject.
        // Setting Subject out of sync with DisplayName breaks interop with OLK.
        throw new ServiceObjectPropertyException(Strings.PropertyIsReadOnly, Schemas.ContactGroupSchema.Subject);
    };
    return ContactGroup;
}(Item));
exports.ContactGroup = ContactGroup;
/**
 * Represents an **e-mail message**. Properties available on e-mail messages are defined in the *EmailMessageSchema* class.
 *
 */
var EmailMessage = (function (_super) {
    __extends(EmailMessage, _super);
    function EmailMessage(serviceOrParentAttachment) {
        return _super.call(this, serviceOrParentAttachment) || this;
    }
    Object.defineProperty(EmailMessage, "Attachable", {
        /** required to check [Attachable] attribute, AttachmentCollection.AddItemAttachment<TItem>() checks for non inherited [Attachable] attribute. */
        get: function () { return this.name === "EmailMessage"; },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(EmailMessage.prototype, "ToRecipients", {
        /**
         * Gets the list of To recipients for the e-mail message.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.ToRecipients);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailMessage.prototype, "BccRecipients", {
        /**
         * Gets the list of Bcc recipients for the e-mail message.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.BccRecipients);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailMessage.prototype, "CcRecipients", {
        /**
         * Gets the list of Cc recipients for the e-mail message.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.CcRecipients);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailMessage.prototype, "ConversationTopic", {
        /**
         * Gets the conversation topic of the e-mail message.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.ConversationTopic);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailMessage.prototype, "ConversationIndex", {
        /**
         * Gets the conversation index of the e-mail message.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.ConversationIndex);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailMessage.prototype, "From", {
        /**
         * Gets or sets the "on behalf" sender of the e-mail message.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.From);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.EmailMessageSchema.From, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailMessage.prototype, "IsAssociated", {
        /**
         * Gets or sets a value indicating whether this is an associated message.
         *
         */
        get: function () {
            return this.IsAssociated;
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.IsAssociated, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailMessage.prototype, "IsDeliveryReceiptRequested", {
        /**
         * Gets or sets a value indicating whether a read receipt is requested for the e-mail message.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.IsDeliveryReceiptRequested);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.EmailMessageSchema.IsDeliveryReceiptRequested, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailMessage.prototype, "IsRead", {
        /**
         * Gets or sets a value indicating whether the e-mail message is read.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.IsRead);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.EmailMessageSchema.IsRead, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailMessage.prototype, "IsReadReceiptRequested", {
        /**
         * Gets or sets a value indicating whether a read receipt is requested for the e-mail message.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.IsReadReceiptRequested);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.EmailMessageSchema.IsReadReceiptRequested, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailMessage.prototype, "IsResponseRequested", {
        /**
         * Gets or sets a value indicating whether a response is requested for the e-mail message.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.IsResponseRequested);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.EmailMessageSchema.IsResponseRequested, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailMessage.prototype, "InternetMessageId", {
        /**
         * Gets the Internat Message Id of the e-mail message.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.InternetMessageId);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailMessage.prototype, "References", {
        /**
         * Gets or sets the references of the e-mail message.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.References);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.EmailMessageSchema.References, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailMessage.prototype, "ReplyTo", {
        /**
         * Gets a list of e-mail addresses to which replies should be addressed.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.ReplyTo);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailMessage.prototype, "Sender", {
        /**
         * Gets or sets the sender of the e-mail message.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.Sender);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.EmailMessageSchema.Sender, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailMessage.prototype, "ReceivedBy", {
        /**
         * Gets the ReceivedBy property of the e-mail message.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.ReceivedBy);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailMessage.prototype, "ReceivedRepresenting", {
        /**
         * Gets the ReceivedRepresenting property of the e-mail message.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.ReceivedRepresenting);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailMessage.prototype, "ApprovalRequestData", {
        /**
         * Gets the ApprovalRequestData property of the e-mail message.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.ApprovalRequestData);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmailMessage.prototype, "VotingInformation", {
        /**
         * Gets the VotingInformation property of the e-mail message.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.VotingInformation);
        },
        enumerable: true,
        configurable: true
    });
    EmailMessage.Bind = function (service, id, propertySet) {
        if (propertySet === void 0) { propertySet = PropertySet.FirstClassProperties; }
        return service.BindToItem(id, propertySet, EmailMessage);
    };
    /**
     * Creates a forward response to the message.
     *
     * @return  {ResponseMessage}      A ResponseMessage representing the forward response that can subsequently be modified and sent.
     */
    EmailMessage.prototype.CreateForward = function () {
        this.ThrowIfThisIsNew();
        return new ResponseMessage(this, ResponseMessageType.Forward);
    };
    /**
     * Creates a reply response to the message.
     *
     * @param   {boolean}             replyAll   Indicates whether the reply should go to all of the original recipients of the message.
     * @return  {ResponseMessage}     A ResponseMessage representing the reply response that can subsequently be modified and sent.
     */
    EmailMessage.prototype.CreateReply = function (replyAll) {
        this.ThrowIfThisIsNew();
        return new ResponseMessage(this, replyAll ? ResponseMessageType.ReplyAll : ResponseMessageType.Reply);
    };
    //Forward(bodyPrefix: MessageBody, toRecipients: EmailAddress[]): Promise<void> { throw new Error("EmailMessage.ts - Forward : Not implemented."); }
    //Forward(bodyPrefix: MessageBody, toRecipients: System.Collections.Generic.IEnumerable<T>): Promise<void> { throw new Error("EmailMessage.ts - Forward : Not implemented."); }
    /**
     * Forwards the message. Calling this method results in a call to EWS.
     *
     * @param   {MessageBody}   bodyPrefix     The prefix to prepend to the original body of the message.
     * @param   {EmailAddress[]}   toRecipients   The recipients to forward the message to.
     */
    EmailMessage.prototype.Forward = function (bodyPrefix, toRecipients) {
        var responseMessage = this.CreateForward();
        responseMessage.BodyPrefix = bodyPrefix;
        responseMessage.ToRecipients.AddRange(toRecipients);
        return responseMessage.SendAndSaveCopy();
    };
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    EmailMessage.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    EmailMessage.prototype.GetSchema = function () { return Schemas.EmailMessageSchema.Instance; };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    EmailMessage.prototype.GetXmlElementName = function () { return XmlElementNames.Message; };
    /**
     * Send message.
     *
     * @param   {FolderId}            parentFolderId       The parent folder id.
     * @param   {MessageDisposition}  messageDisposition   The message disposition.
     */
    EmailMessage.prototype.InternalSend = function (parentFolderId, messageDisposition) {
        var _this = this;
        this.ThrowIfThisIsAttachment();
        if (this.IsNew) {
            if ((this.Attachments.Count == 0) || (messageDisposition == MessageDisposition.SaveOnly)) {
                return this.InternalCreate(parentFolderId, messageDisposition, null);
            }
            else {
                // If the message has attachments, save as a draft (and add attachments) before sending.
                return this.InternalCreate(null, // null means use the Drafts folder in the mailbox of the authenticated user.
                MessageDisposition.SaveOnly, null).then(function () {
                    return _this.Service.SendItem(_this, parentFolderId);
                });
            }
        }
        else {
            // Regardless of whether item is dirty or not, if it has unprocessed
            // attachment changes, process them now.
            debugger; //todo: check - check for attachment save() promise. 
            return exports.Promise.resolve(
            // Validate and save attachments before sending.
            this.HasUnprocessedAttachmentChanges() ? this.Attachments.ValidateAndSave() : void 0)
                .then(function () {
                if (_this.PropertyBag.GetIsUpdateCallNecessary()) {
                    return _this.InternalUpdate(//ref: //info: <any> to supress cast error, returning promise is required, this time it is not void but no action is taken on this promise. 
                    parentFolderId, ConflictResolutionMode.AutoResolve, messageDisposition, null);
                }
                else {
                    return _this.Service.SendItem(_this, parentFolderId);
                }
            });
        }
    };
    /**
     * Replies to the message. Calling this method results in a call to EWS.
     *
     * @param   {MessageBody}   bodyPrefix   The prefix to prepend to the original body of the message.
     * @param   {boolean}   replyAll     Indicates whether the reply should be sent to all of the original recipients of the message.
     */
    EmailMessage.prototype.Reply = function (bodyPrefix, replyAll) {
        var responseMessage = this.CreateReply(replyAll);
        responseMessage.BodyPrefix = bodyPrefix;
        return responseMessage.SendAndSaveCopy();
    };
    /**
     * Sends this e-mail message. Calling this method results in at least one call to EWS.
     */
    EmailMessage.prototype.Send = function () { return this.InternalSend(null, MessageDisposition.SendOnly); };
    EmailMessage.prototype.SendAndSaveCopy = function (destinationFolderIdOrName) {
        var destinationFolderId = new FolderId(WellKnownFolderName.SentItems);
        if (arguments.length === 1) {
            if (typeof destinationFolderIdOrName === "number") {
                destinationFolderId = new FolderId(destinationFolderIdOrName);
            }
            else {
                //EwsUtilities.ValidateParam(destinationFolderIdOrName, "destinationFolderId");
                destinationFolderId = destinationFolderIdOrName;
            }
        }
        return this.InternalSend(destinationFolderId, MessageDisposition.SendAndSaveCopy);
    };
    /**
     * Suppresses the read receipt on the message. Calling this method results in a call to EWS.
     *
     */
    EmailMessage.prototype.SuppressReadReceipt = function () {
        this.ThrowIfThisIsNew();
        return (new SuppressReadReceipt(this)).InternalCreate(null, null);
    };
    return EmailMessage;
}(Item));
exports.EmailMessage = EmailMessage;
/**
 * Represents a meeting-related message. Properties available on meeting messages are defined in the MeetingMessageSchema class.
 */
var MeetingMessage = (function (_super) {
    __extends(MeetingMessage, _super);
    function MeetingMessage(serviceOrParentAttachment) {
        return _super.call(this, serviceOrParentAttachment) || this;
    }
    Object.defineProperty(MeetingMessage.prototype, "AssociatedAppointmentId", {
        /**
         * Gets the Id of the appointment associated with the meeting message.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingMessageSchema.AssociatedAppointmentId);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingMessage.prototype, "IsDelegated", {
        /**
         * Gets a value indicating whether the meeting message is delegated.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingMessageSchema.IsDelegated);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingMessage.prototype, "IsOutOfDate", {
        /**
         * Gets a value indicating whether the meeting message is out of date.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingMessageSchema.IsOutOfDate);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingMessage.prototype, "HasBeenProcessed", {
        /**
         * Gets a value indicating whether the meeting message has been processed by Exchange (i.e. Exchange has noted the arrival of a meeting request and has created the associated meeting item in the calendar).
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingMessageSchema.HasBeenProcessed);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingMessage.prototype, "IsOrganizer", {
        /**
         * Gets the isorganizer property for this meeting
         *
         * @Nullable
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingMessageSchema.IsOrganizer);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingMessage.prototype, "ResponseType", {
        /**
         * Gets the type of response the meeting message represents.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingMessageSchema.ResponseType);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingMessage.prototype, "ICalUid", {
        /**
         * Gets the ICalendar Uid.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingMessageSchema.ICalUid);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingMessage.prototype, "ICalRecurrenceId", {
        /**
         * Gets the ICalendar RecurrenceId.
         *
         * @Nullable
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingMessageSchema.ICalRecurrenceId);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingMessage.prototype, "ICalDateTimeStamp", {
        /**
         * Gets the ICalendar DateTimeStamp.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingMessageSchema.ICalDateTimeStamp);
        },
        enumerable: true,
        configurable: true
    });
    MeetingMessage.Bind = function (service, id, propertySet) {
        if (propertySet === void 0) { propertySet = PropertySet.FirstClassProperties; }
        return service.BindToItem(id, propertySet, MeetingMessage);
    };
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    MeetingMessage.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    MeetingMessage.prototype.GetSchema = function () {
        return Schemas.MeetingMessageSchema.Instance;
    };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    MeetingMessage.prototype.GetXmlElementName = function () {
        return XmlElementNames.MeetingMessage;
    };
    return MeetingMessage;
}(EmailMessage));
exports.MeetingMessage = MeetingMessage;
/**
 * Represents a meeting cancellation message. Properties available on meeting messages are defined in the MeetingMessageSchema class.
 */
var MeetingCancellation = (function (_super) {
    __extends(MeetingCancellation, _super);
    function MeetingCancellation(serviceOrParentAttachment) {
        return _super.call(this, serviceOrParentAttachment) || this;
    }
    Object.defineProperty(MeetingCancellation.prototype, "Start", {
        /**
         * Gets the start time of the appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingCancellationSchema.Start);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingCancellation.prototype, "End", {
        /**
         * Gets the end time of the appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingCancellationSchema.End);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingCancellation.prototype, "Location", {
        /**
         * Gets the location of this appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingCancellationSchema.Location);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingCancellation.prototype, "Recurrence", {
        /**
         * Gets the recurrence pattern for this meeting request.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.Recurrence);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingCancellation.prototype, "EnhancedLocation", {
        /**
         * Gets the Enhanced location object.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingCancellationSchema.EnhancedLocation);
        },
        enumerable: true,
        configurable: true
    });
    MeetingCancellation.Bind = function (service, id, propertySet) {
        if (propertySet === void 0) { propertySet = PropertySet.FirstClassProperties; }
        return service.BindToItem(id, propertySet, MeetingCancellation);
    };
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    MeetingCancellation.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    MeetingCancellation.prototype.GetSchema = function () {
        return Schemas.MeetingCancellationSchema.Instance;
    };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    MeetingCancellation.prototype.GetXmlElementName = function () {
        return XmlElementNames.MeetingCancellation;
    };
    /**
     * Removes the meeting associated with the cancellation message from the user's calendar.
     *
     * @return  {Promise<CalendarActionResults>}      A CalendarActionResults object containing the various items that were created or modified as a results of this operation.
     */
    MeetingCancellation.prototype.RemoveMeetingFromCalendar = function () {
        var removeFromCalendar = new RemoveFromCalendar(this);
        return removeFromCalendar.InternalCreate(null, null).then(function (items) {
            return new CalendarActionResults(items);
        });
    };
    return MeetingCancellation;
}(MeetingMessage));
exports.MeetingCancellation = MeetingCancellation;
/**
 * Represents a meeting request that an attendee can accept or decline. Properties available on meeting requests are defined in the MeetingRequestSchema class.
 */
var MeetingRequest = (function (_super) {
    __extends(MeetingRequest, _super);
    function MeetingRequest(parentAttachmentOrService) {
        return _super.call(this, parentAttachmentOrService) || this;
    }
    Object.defineProperty(MeetingRequest.prototype, "MeetingRequestType", {
        /**
         * Gets the type of this meeting request.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingRequestSchema.MeetingRequestType);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "IntendedFreeBusyStatus", {
        /**
         * Gets the a value representing the intended free/busy status of the meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingRequestSchema.IntendedFreeBusyStatus);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "ChangeHighlights", {
        /**
         * Gets the change highlights of the meeting request.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingRequestSchema.ChangeHighlights);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "EnhancedLocation", {
        /**
         * Gets the Enhanced location object.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingRequestSchema.EnhancedLocation);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "Start", {
        /**
         * Gets the start time of the appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.Start);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "End", {
        /**
         * Gets the end time of the appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.End);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "OriginalStart", {
        /**
         * Gets the original start time of this appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.OriginalStart);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "IsAllDayEvent", {
        /**
         * Gets a value indicating whether this appointment is an all day event.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.IsAllDayEvent);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "LegacyFreeBusyStatus", {
        /**
         * Gets a value indicating the free/busy status of the owner of this appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.LegacyFreeBusyStatus);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "Location", {
        /**
         * Gets the location of this appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.Location);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "When", {
        /**
         * Gets a text indicating when this appointment occurs.
         * The text returned by When is localized using the Exchange Server culture or using the culture specified in the PreferredCulture property of the ExchangeService object this appointment is bound to.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.When);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "IsMeeting", {
        /**
         * Gets a value indicating whether the appointment is a meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.IsMeeting);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "IsCancelled", {
        /**
         * Gets a value indicating whether the appointment has been cancelled.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.IsCancelled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "IsRecurring", {
        /**
         * Gets a value indicating whether the appointment is recurring.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.IsRecurring);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "MeetingRequestWasSent", {
        /**
         * Gets a value indicating whether the meeting request has already been sent.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.MeetingRequestWasSent);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "AppointmentType", {
        /**
         * Gets a value indicating the type of this appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.AppointmentType);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "MyResponseType", {
        /**
         * Gets a value indicating what was the last response of the user that loaded this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.MyResponseType);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "Organizer", {
        /**
         * Gets the organizer of this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.Organizer);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "RequiredAttendees", {
        /**
         * Gets a list of required attendees for this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.RequiredAttendees);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "OptionalAttendees", {
        /**
         * Gets a list of optional attendeed for this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.OptionalAttendees);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "Resources", {
        /**
         * Gets a list of resources for this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.Resources);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "ConflictingMeetingCount", {
        /**
         * Gets the number of calendar entries that conflict with this appointment in the authenticated user's calendar.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.ConflictingMeetingCount);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "AdjacentMeetingCount", {
        /**
         * Gets the number of calendar entries that are adjacent to this appointment in the authenticated user's calendar.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.AdjacentMeetingCount);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "ConflictingMeetings", {
        /**
         * Gets a list of meetings that conflict with this appointment in the authenticated user's calendar.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.ConflictingMeetings);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "AdjacentMeetings", {
        /**
         * Gets a list of meetings that are adjucent to this appointment in the authenticated user's calendar.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.AdjacentMeetings);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "Duration", {
        /**
         * Gets the duration of this appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.Duration);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "TimeZone", {
        /**
         * Gets the name of the time zone this appointment is defined in.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.TimeZone);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "AppointmentReplyTime", {
        /**
         * Gets the time when the attendee replied to the meeting request.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.AppointmentReplyTime);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "AppointmentSequenceNumber", {
        /**
         * Gets the sequence number of this appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.AppointmentSequenceNumber);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "AppointmentState", {
        /**
         * Gets the state of this appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.AppointmentState);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "Recurrence", {
        /**
         * Gets the recurrence pattern for this meeting request.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.Recurrence);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "FirstOccurrence", {
        /**
         * Gets an OccurrenceInfo identifying the first occurrence of this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.FirstOccurrence);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "LastOccurrence", {
        /**
         * Gets an OccurrenceInfo identifying the last occurrence of this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.LastOccurrence);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "ModifiedOccurrences", {
        /**
         * Gets a list of modified occurrences for this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.ModifiedOccurrences);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "DeletedOccurrences", {
        /**
         * Gets a list of deleted occurrences for this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.DeletedOccurrences);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "StartTimeZone", {
        /**
         * Gets time zone of the start property of this meeting request.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.StartTimeZone);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "EndTimeZone", {
        /**
         * Gets time zone of the end property of this meeting request.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.EndTimeZone);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "ConferenceType", {
        /**
         * Gets the type of conferencing that will be used during the meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.ConferenceType);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "AllowNewTimeProposal", {
        /**
         * Gets a value indicating whether new time proposals are allowed for attendees of this meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.AllowNewTimeProposal);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "IsOnlineMeeting", {
        /**
         * Gets a value indicating whether this is an online meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.IsOnlineMeeting);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "MeetingWorkspaceUrl", {
        /**
         * Gets the URL of the meeting workspace. A meeting workspace is a shared Web site for planning meetings and tracking results.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.MeetingWorkspaceUrl);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingRequest.prototype, "NetShowUrl", {
        /**
         * Gets the URL of the Microsoft NetShow online meeting.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.NetShowUrl);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Accepts the meeting. Calling this method results in a call to EWS.
     *
     * @param   {boolean}   sendResponse   Indicates whether to send a response to the organizer.
     * @return  {Promise<CalendarActionResults>}   A CalendarActionResults object containing the various items that were created or modified as a results of this operation    :Promise.
     */
    MeetingRequest.prototype.Accept = function (sendResponse) {
        return this.InternalAccept(false, sendResponse);
    };
    /**
     * Tentatively accepts the meeting. Calling this method results in a call to EWS.
     *
     * @param   {boolean}   sendResponse   Indicates whether to send a response to the organizer.
     * @return  {Promise<CalendarActionResults>}       A CalendarActionResults object containing the various items that were created or modified as a results of this operation    :Promise.
     */
    MeetingRequest.prototype.AcceptTentatively = function (sendResponse) {
        return this.InternalAccept(true, sendResponse);
    };
    MeetingRequest.Bind = function (service, id, propertySet) {
        if (propertySet === void 0) { propertySet = PropertySet.FirstClassProperties; }
        return service.BindToItem(id, propertySet, MeetingRequest);
    };
    /**
     * Creates a local meeting acceptance message that can be customized and sent.
     *
     * @param   {boolean}   tentative   Specifies whether the meeting will be tentatively accepted.
     * @return  {AcceptMeetingInvitationMessage}        An AcceptMeetingInvitationMessage representing the meeting acceptance message.
     */
    MeetingRequest.prototype.CreateAcceptMessage = function (tentative) {
        return new AcceptMeetingInvitationMessage(this, tentative);
    };
    /**
     * Creates a local meeting declination message that can be customized and sent.
     *
     * @return  {DeclineMeetingInvitationMessage}      A DeclineMeetingInvitation representing the meeting declination message.
     */
    MeetingRequest.prototype.CreateDeclineMessage = function () {
        return new DeclineMeetingInvitationMessage(this);
    };
    /**
     * Declines the meeting invitation. Calling this method results in a call to EWS.
     *
     * @param   {boolean}   sendResponse   Indicates whether to send a response to the organizer.
     * @return  {Promise<CalendarActionResults>}       A CalendarActionResults object containing the various items that were created or modified as a results of this operation    :Promise.
     */
    MeetingRequest.prototype.Decline = function (sendResponse) {
        var decline = this.CreateDeclineMessage();
        if (sendResponse) {
            return decline.SendAndSaveCopy();
        }
        else {
            return decline.Save();
        }
    };
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    MeetingRequest.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    MeetingRequest.prototype.GetSchema = function () {
        return Schemas.MeetingRequestSchema.Instance;
    };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    MeetingRequest.prototype.GetXmlElementName = function () {
        return XmlElementNames.MeetingRequest;
    };
    /**
     * @internal Accepts the meeting.
     *
     * @param   {boolean}   tentative      True if tentative accept.
     * @param   {boolean}   sendResponse   Indicates whether to send a response to the organizer.
     * @return  {Promise<CalendarActionResults>}       A CalendarActionResults object containing the various items that were created or modified as a results of this operation    :Promise.
     */
    MeetingRequest.prototype.InternalAccept = function (tentative, sendResponse) {
        var accept = this.CreateAcceptMessage(tentative);
        if (sendResponse) {
            return accept.SendAndSaveCopy();
        }
        else {
            return accept.Save();
        }
    };
    return MeetingRequest;
}(MeetingMessage));
exports.MeetingRequest = MeetingRequest;
/**
 * Represents a response to a meeting request. Properties available on meeting messages are defined in the MeetingMessageSchema class.
 */
var MeetingResponse = (function (_super) {
    __extends(MeetingResponse, _super);
    function MeetingResponse(parentAttachmentOrService) {
        return _super.call(this, parentAttachmentOrService) || this;
    }
    Object.defineProperty(MeetingResponse.prototype, "Start", {
        /**
         * Gets the start time of the appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingResponseSchema.Start);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingResponse.prototype, "End", {
        /**
         * Gets the end time of the appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingResponseSchema.End);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingResponse.prototype, "Location", {
        /**
         * Gets the location of this appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingResponseSchema.Location);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingResponse.prototype, "Recurrence", {
        /**
         * Gets the recurrence pattern for this meeting request.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.AppointmentSchema.Recurrence);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingResponse.prototype, "ProposedStart", {
        /**
         * Gets the proposed start time of the appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingResponseSchema.ProposedStart);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingResponse.prototype, "ProposedEnd", {
        /**
         * Gets the proposed end time of the appointment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingResponseSchema.ProposedEnd);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeetingResponse.prototype, "EnhancedLocation", {
        /**
         * Gets the Enhanced location object.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.MeetingResponseSchema.EnhancedLocation);
        },
        enumerable: true,
        configurable: true
    });
    MeetingResponse.Bind = function (service, id, propertySet) {
        if (propertySet === void 0) { propertySet = PropertySet.FirstClassProperties; }
        return service.BindToItem(id, propertySet, MeetingResponse);
    };
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    MeetingResponse.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    MeetingResponse.prototype.GetSchema = function () {
        return Schemas.MeetingResponseSchema.Instance;
    };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    MeetingResponse.prototype.GetXmlElementName = function () { return XmlElementNames.MeetingResponse; };
    return MeetingResponse;
}(MeetingMessage));
exports.MeetingResponse = MeetingResponse;
/**
 * Represents a post item. Properties available on post items are defined in the PostItemSchema class.
 *
 * @sealed
 */
var PostItem = (function (_super) {
    __extends(PostItem, _super);
    function PostItem(serviceOrParentAttachment) {
        return _super.call(this, serviceOrParentAttachment) || this;
    }
    Object.defineProperty(PostItem, "Attachable", {
        /** required to check [Attachable] attribute, AttachmentCollection.AddItemAttachment<TItem>() checks for non inherited [Attachable] attribute. */
        get: function () { return this.name === "PostItem"; },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PostItem.prototype, "ConversationIndex", {
        /**
         * Gets the conversation index of the post item.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.ConversationIndex);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PostItem.prototype, "ConversationTopic", {
        /**
         * Gets the conversation topic of the post item.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.ConversationTopic);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PostItem.prototype, "From", {
        /**
         * Gets or sets the "on behalf" poster of the post item.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.From);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.EmailMessageSchema.From, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PostItem.prototype, "InternetMessageId", {
        /**
         * Gets the Internet message Id of the post item.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.InternetMessageId);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PostItem.prototype, "IsRead", {
        /**
         * Gets or sets a value indicating whether the post item is read.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.IsRead);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.EmailMessageSchema.IsRead, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PostItem.prototype, "PostedTime", {
        /**
         * Gets the the date and time when the post item was posted.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.PostItemSchema.PostedTime);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PostItem.prototype, "References", {
        /**
         * Gets or sets the references of the post item.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.References);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.EmailMessageSchema.References, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PostItem.prototype, "Sender", {
        /**
         * Gets or sets the sender (poster) of the post item.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.Sender);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.EmailMessageSchema.Sender, value);
        },
        enumerable: true,
        configurable: true
    });
    PostItem.Bind = function (service, id, propertySet) {
        if (propertySet === void 0) { propertySet = PropertySet.FirstClassProperties; }
        return service.BindToItem(id, propertySet, PostItem);
    };
    /**
     * Creates a forward response to the post item.
     *
     * @return  {ResponseMessage}      A ResponseMessage representing the forward response that can subsequently be modified and sent.
     */
    PostItem.prototype.CreateForward = function () {
        this.ThrowIfThisIsNew();
        return new ResponseMessage(this, ResponseMessageType.Forward);
    };
    /**
     * Creates a post reply to this post item.
     *
     * @return  {PostReply}      A PostReply that can be modified and saved.
     */
    PostItem.prototype.CreatePostReply = function () {
        this.ThrowIfThisIsNew();
        return new PostReply(this);
    };
    /**
     * Creates a e-mail reply response to the post item.
     *
     * @param   {boolean}   replyAll   Indicates whether the reply should go to everyone involved in the thread.
     * @return  {ResponseMessage}      A ResponseMessage representing the e-mail reply response that can subsequently be modified and sent.
     */
    PostItem.prototype.CreateReply = function (replyAll) {
        this.ThrowIfThisIsNew();
        return new ResponseMessage(this, replyAll ? ResponseMessageType.ReplyAll : ResponseMessageType.Reply);
    };
    PostItem.prototype.Forward = function (bodyPrefix, _toRecipients) {
        var toRecipients = [];
        if (arguments.length <= 2) {
            if (ArrayHelper.isArray(_toRecipients)) {
                toRecipients = _toRecipients;
            }
            else {
                toRecipients.push(arguments[1]);
            }
        }
        else {
            for (var _i = 1; _i < arguments.length; _i++) {
                toRecipients[_i - 1] = arguments[_i];
            }
        }
        var responseMessage = this.CreateForward();
        responseMessage.BodyPrefix = bodyPrefix;
        responseMessage.ToRecipients.AddRange(toRecipients);
        return responseMessage.SendAndSaveCopy();
    };
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    PostItem.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    PostItem.prototype.GetSchema = function () {
        return Schemas.PostItemSchema.Instance;
    };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    PostItem.prototype.GetXmlElementName = function () {
        return XmlElementNames.PostItem;
    };
    /**
     * Posts a reply to this post item. Calling this method results in a call to EWS.
     *
     * @param   {MessageBody}   bodyPrefix   Body prefix.
     * @return  {Promise<void>}    :Promise.
     */
    PostItem.prototype.PostReply = function (bodyPrefix) {
        var postReply = this.CreatePostReply();
        postReply.BodyPrefix = bodyPrefix;
        return postReply.Save();
    };
    /**
     * Replies to the post item. Calling this method results in a call to EWS.
     *
     * @param   {MessageBody}   bodyPrefix   The prefix to prepend to the original body of the post item.
     * @param   {boolean}       replyAll     Indicates whether the reply should be sent to everyone involved in the thread.
     * @return  {Promise<void>}    :Promise.
     */
    PostItem.prototype.Reply = function (bodyPrefix, replyAll) {
        var responseMessage = this.CreateReply(replyAll);
        responseMessage.BodyPrefix = bodyPrefix;
        return responseMessage.SendAndSaveCopy();
    };
    return PostItem;
}(Item));
exports.PostItem = PostItem;
/**
 * Represents a Task item. Properties available on tasks are defined in the TaskSchema class.
 */
var Task = (function (_super) {
    __extends(Task, _super);
    function Task(serviceOrParentAttachment) {
        return _super.call(this, serviceOrParentAttachment) || this;
    }
    Object.defineProperty(Task, "Attachable", {
        /** required to check [Attachable] attribute, AttachmentCollection.AddItemAttachment<TItem>() checks for non inherited [Attachable] attribute. */
        get: function () { return this.name === "Task"; },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(Task.prototype, "ActualWork", {
        /**
         * @nullable Gets or sets the actual amount of time that is spent on the task.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.ActualWork);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.TaskSchema.ActualWork, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "AssignedTime", {
        /**
         * @nullable Gets the date and time the task was assigned.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.AssignedTime);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "BillingInformation", {
        /**
         * Gets or sets the billing information of the task.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.BillingInformation);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.TaskSchema.BillingInformation, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "ChangeCount", {
        /**
         * Gets the number of times the task has changed since it was created.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.ChangeCount);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "Companies", {
        /**
         * Gets or sets a list of companies associated with the task.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.Companies);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.TaskSchema.Companies, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "CompleteDate", {
        /**
         * @nullable Gets or sets the date and time on which the task was completed.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.CompleteDate);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.TaskSchema.CompleteDate, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "Contacts", {
        /**
         * Gets or sets a list of contacts associated with the task.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.Contacts);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.TaskSchema.Contacts, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "DelegationState", {
        /**
         * Gets the current delegation state of the task.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.DelegationState);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "Delegator", {
        /**
         * Gets the name of the delegator of this task.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.Delegator);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "DueDate", {
        /**
         * @nullable    Gets or sets the date and time on which the task is due.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.DueDate);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.TaskSchema.DueDate, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "Mode", {
        /**
         * Gets a value indicating the mode of the task.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.Mode);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "IsComplete", {
        /**
         * Gets a value indicating whether the task is complete.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.IsComplete);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "IsRecurring", {
        /**
         * Gets a value indicating whether the task is recurring.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.IsRecurring);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "IsTeamTask", {
        /**
         * Gets a value indicating whether the task is a team task.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.IsTeamTask);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "Mileage", {
        /**
         * Gets or sets the mileage of the task.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.Mileage);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.TaskSchema.Mileage, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "Owner", {
        /**
         * Gets the name of the owner of the task.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.Owner);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "PercentComplete", {
        /**
         * Gets or sets the completeion percentage of the task. PercentComplete must be between 0 and 100.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.PercentComplete);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.TaskSchema.PercentComplete, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "Recurrence", {
        /**
         * Gets or sets the recurrence pattern for this task. Available recurrence pattern classes include Recurrence.
         * DailyPattern, Recurrence.MonthlyPattern and Recurrence.YearlyPattern.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.Recurrence);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.TaskSchema.Recurrence, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "StartDate", {
        /**
         * @nullable    Gets or sets the date and time on which the task starts.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.StartDate);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.TaskSchema.StartDate, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "Status", {
        /**
         * Gets or sets the status of the task.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.Status);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.TaskSchema.Status, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "StatusDescription", {
        /**
         * Gets a string representing the status of the task, localized according to the PreferredCulture property of the ExchangeService object the task is bound to.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.StatusDescription);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "TotalWork", {
        /**
         * @nullable Gets or sets the total amount of work spent on the task.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.TaskSchema.TotalWork);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.TaskSchema.TotalWork, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Task.prototype, "DefaultAffectedTaskOccurrences", {
        /**
         * @internal    @nullable   Gets the default setting for how to treat affected task occurrences on Delete.
         */
        get: function () {
            return AffectedTaskOccurrence.AllOccurrences;
        },
        enumerable: true,
        configurable: true
    });
    Task.Bind = function (service, id, propertySet) {
        if (propertySet === void 0) { propertySet = PropertySet.FirstClassProperties; }
        return service.BindToItem(id, propertySet, Task);
    };
    /**
     * Deletes the current occurrence of a recurring task. After the current occurrence isdeleted, the task represents the next occurrence.
     * Developers should call Load to retrieve the new property values of the task.
     * Calling this method results in a call to EWS.
     *
     * @param   {DeleteMode}   deleteMode   The deletion mode.
     * @return  {Promise<void>}            :Promise.
     */
    Task.prototype.DeleteCurrentOccurrence = function (deleteMode) {
        return this.InternalDelete(deleteMode, null, AffectedTaskOccurrence.SpecifiedOccurrenceOnly);
    };
    /**
     * @internal Gets a value indicating whether a time zone SOAP header should be emitted in a CreateItem or UpdateItem request so this item can be property saved or updated.
     *
     * @param   {boolean}   isUpdateOperation   Indicates whether the operation being petrformed is an update operation.
     * @return  {boolean}   *true* if a time zone SOAP header should be emitted; otherwise, *false*.
     */
    Task.prototype.GetIsTimeZoneHeaderRequired = function (isUpdateOperation) {
        return true;
    };
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    Task.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    Task.prototype.GetSchema = function () {
        return Schemas.TaskSchema.Instance;
    };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    Task.prototype.GetXmlElementName = function () {
        return XmlElementNames.Task;
    };
    Task.prototype.Update = function (conflictResolutionMode) {
        return this.InternalUpdate(null /* parentFolder */, conflictResolutionMode, MessageDisposition.SaveOnly, null);
    };
    return Task;
}(Item));
exports.Task = Task;
/**
 * Represents a collection of Conversation related properties.
 * Properties available on this object are defined in the ConversationSchema class.
 */
var Conversation = (function (_super) {
    __extends(Conversation, _super);
    /**
     * @internal Initializes an unsaved local instance of **Conversation** class.
     *
     * @param   {ExchangeService}   service   The ExchangeService object to which the item will be bound.
     */
    function Conversation(service) {
        return _super.call(this, service) || this;
    }
    Object.defineProperty(Conversation.prototype, "Id", {
        /**
         * Gets the Id of this Conversation.
         */
        get: function () {
            return this.PropertyBag._getItem(this.GetIdPropertyDefinition());
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "Topic", {
        /**
         * Gets the topic of this Conversation.
         */
        get: function () {
            var returnValue = { outValue: StringHelper.Empty };
            // This property need not be present hence the property bag may not contain it.
            // Check for the presence of this property before accessing it.
            if (this.PropertyBag.Contains(Schemas.ConversationSchema.Topic)) {
                this.PropertyBag.TryGetPropertyAs(Schemas.ConversationSchema.Topic, returnValue);
            }
            return returnValue.outValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "UniqueRecipients", {
        /**
         * Gets a list of all the people who have received messages in this conversation in the current folder only.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.UniqueRecipients);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "GlobalUniqueRecipients", {
        /**
         * Gets a list of all the people who have received messages in this conversation across all folders in the mailbox.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalUniqueRecipients);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "UniqueUnreadSenders", {
        /**
         * Gets a list of all the people who have sent messages that are currently unread in this conversation in the current folder only.
         */
        get: function () {
            var unreadSenders = { outValue: null };
            // This property need not be present hence the property bag may not contain it.
            // Check for the presence of this property before accessing it.
            if (this.PropertyBag.Contains(Schemas.ConversationSchema.UniqueUnreadSenders)) {
                this.PropertyBag.TryGetPropertyAs(Schemas.ConversationSchema.UniqueUnreadSenders, unreadSenders);
            }
            return unreadSenders.outValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "GlobalUniqueUnreadSenders", {
        /**
         * Gets a list of all the people who have sent messages that are currently unread in this conversation across all folders in the mailbox.
         */
        get: function () {
            var unreadSenders = { outValue: null };
            // This property need not be present hence the property bag may not contain it.
            // Check for the presence of this property before accessing it.
            if (this.PropertyBag.Contains(Schemas.ConversationSchema.GlobalUniqueUnreadSenders)) {
                this.PropertyBag.TryGetPropertyAs(Schemas.ConversationSchema.GlobalUniqueUnreadSenders, unreadSenders);
            }
            return unreadSenders.outValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "UniqueSenders", {
        /**
         * Gets a list of all the people who have sent messages in this conversation in the current folder only.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.UniqueSenders);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "GlobalUniqueSenders", {
        /**
         * Gets a list of all the people who have sent messages in this conversation across all folders in the mailbox.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalUniqueSenders);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "LastDeliveryTime", {
        /**
         * Gets the delivery time of the message that was last received in this conversation in the current folder only.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.LastDeliveryTime);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "GlobalLastDeliveryTime", {
        /**
         * Gets the delivery time of the message that was last received in this conversation across all folders in the mailbox.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalLastDeliveryTime);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "Categories", {
        /**
         * Gets a list summarizing the categories stamped on messages in this conversation, in the current folder only.
         */
        get: function () {
            var returnValue = { outValue: null };
            // This property need not be present hence the property bag may not contain it.
            // Check for the presence of this property before accessing it.
            if (this.PropertyBag.Contains(Schemas.ConversationSchema.Categories)) {
                this.PropertyBag.TryGetPropertyAs(Schemas.ConversationSchema.Categories, returnValue);
            }
            return returnValue.outValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "GlobalCategories", {
        /**
         * Gets a list summarizing the categories stamped on messages in this conversation, across all folders in the mailbox.
         */
        get: function () {
            var returnValue = { outValue: null };
            // This property need not be present hence the property bag may not contain it.
            // Check for the presence of this property before accessing it.
            if (this.PropertyBag.Contains(Schemas.ConversationSchema.GlobalCategories)) {
                this.PropertyBag.TryGetPropertyAs(Schemas.ConversationSchema.GlobalCategories, returnValue);
            }
            return returnValue.outValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "FlagStatus", {
        /**
         * Gets the flag status for this conversation, calculated by aggregating individual messages flag status in the current folder.
         */
        get: function () {
            var returnValue = { outValue: null };
            // This property need not be present hence the property bag may not contain it.
            // Check for the presence of this property before accessing it.
            if (this.PropertyBag.Contains(Schemas.ConversationSchema.FlagStatus)) {
                this.PropertyBag.TryGetPropertyAs(Schemas.ConversationSchema.FlagStatus, returnValue);
            }
            return returnValue.outValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "GlobalFlagStatus", {
        /**
         * Gets the flag status for this conversation, calculated by aggregating individual messages flag status across all folders in the mailbox.
         */
        get: function () {
            var returnValue = { outValue: null };
            // This property need not be present hence the property bag may not contain it.
            // Check for the presence of this property before accessing it.
            if (this.PropertyBag.Contains(Schemas.ConversationSchema.GlobalFlagStatus)) {
                this.PropertyBag.TryGetPropertyAs(Schemas.ConversationSchema.GlobalFlagStatus, returnValue);
            }
            return returnValue.outValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "HasAttachments", {
        /**
         * Gets a value indicating if at least one message in this conversation, in the current folder only, has an attachment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.HasAttachments);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "GlobalHasAttachments", {
        /**
         * Gets a value indicating if at least one message in this conversation, across all folders in the mailbox, has an attachment.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalHasAttachments);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "MessageCount", {
        /**
         * Gets the total number of messages in this conversation in the current folder only.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.MessageCount);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "GlobalMessageCount", {
        /**
         * Gets the total number of messages in this conversation across all folders in the mailbox.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalMessageCount);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "UnreadCount", {
        /**
         * Gets the total number of unread messages in this conversation in the current folder only.
         */
        get: function () {
            var returnValue = { outValue: 0 };
            // This property need not be present hence the property bag may not contain it.
            // Check for the presence of this property before accessing it.
            if (this.PropertyBag.Contains(Schemas.ConversationSchema.UnreadCount)) {
                this.PropertyBag.TryGetPropertyAs(Schemas.ConversationSchema.UnreadCount, returnValue);
            }
            return returnValue.outValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "GlobalUnreadCount", {
        /**
         * Gets the total number of unread messages in this conversation across all folders in the mailbox.
         */
        get: function () {
            var returnValue = { outValue: 0 };
            // This property need not be present hence the property bag may not contain it.
            // Check for the presence of this property before accessing it.
            if (this.PropertyBag.Contains(Schemas.ConversationSchema.GlobalUnreadCount)) {
                this.PropertyBag.TryGetPropertyAs(Schemas.ConversationSchema.GlobalUnreadCount, returnValue);
            }
            return returnValue.outValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "Size", {
        /**
         * Gets the size of this conversation, calculated by adding the sizes of all messages in the conversation in the current folder only.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.Size);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "GlobalSize", {
        /**
         * Gets the size of this conversation, calculated by adding the sizes of all messages in the conversation across all folders in the mailbox.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalSize);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "ItemClasses", {
        /**
         * Gets a list summarizing the classes of the items in this conversation, in the current folder only.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.ItemClasses);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "GlobalItemClasses", {
        /**
         * Gets a list summarizing the classes of the items in this conversation, across all folders in the mailbox.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalItemClasses);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "Importance", {
        /**
         * Gets the importance of this conversation, calculated by aggregating individual messages importance in the current folder only.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.Importance);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "GlobalImportance", {
        /**
         * Gets the importance of this conversation, calculated by aggregating individual messages importance across all folders in the mailbox.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalImportance);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "ItemIds", {
        /**
         * Gets the Ids of the messages in this conversation, in the current folder only.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.ItemIds);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "GlobalItemIds", {
        /**
         * Gets the Ids of the messages in this conversation, across all folders in the mailbox.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalItemIds);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "LastModifiedTime", {
        /**
         * Gets the date and time this conversation was last modified.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.LastModifiedTime);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "InstanceKey", {
        /**
         * Gets the conversation instance key.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.InstanceKey);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "Preview", {
        /**
         * Gets the conversation Preview.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.Preview);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "IconIndex", {
        /**
         * Gets the conversation IconIndex.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.IconIndex);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "GlobalIconIndex", {
        /**
         * Gets the conversation global IconIndex.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalIconIndex);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "DraftItemIds", {
        /**
         * Gets the draft item ids.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.DraftItemIds);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "HasIrm", {
        /**
         * Gets a value indicating if at least one message in this conversation, in the current folder only, is an IRM.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.HasIrm);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Conversation.prototype, "GlobalHasIrm", {
        /**
         * Gets a value indicating if at least one message in this conversation, across all folders in the mailbox, is an IRM.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ConversationSchema.GlobalHasIrm);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clear flags for conversation items. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}   contextFolderId   The Id of the folder items must belong to in order to be unflagged. If contextFolderId is null, flags for items in conversation across the entire mailbox are cleared.
     * @return  {Promise<void>}    Promise
     */
    Conversation.prototype.ClearItemFlags = function (contextFolderId) {
        var flag = new Flag();
        flag.FlagStatus = ItemFlagStatus.NotFlagged;
        return this.Service.SetFlagStatusForItemsInConversations([{ key: this.Id, value: this.GlobalLastDeliveryTime }], contextFolderId, flag).then(function (responses) {
            responses.__thisIndexer(0).ThrowIfNecessary();
        });
    };
    /**
     * Copies items in the specified conversation to a specific folder. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}   contextFolderId       The Id of the folder items must belong to in order to be copied. If contextFolderId is null, items across the entire mailbox are copied.
     * @param   {FolderId}   destinationFolderId   The Id of the destination folder.
     * @return  {Promise<void>}    Promise
     */
    Conversation.prototype.CopyItemsInConversation = function (contextFolderId, destinationFolderId) {
        return this.Service.CopyItemsInConversations([{ key: this.Id, value: this.GlobalLastDeliveryTime }], contextFolderId, destinationFolderId).then(function (responses) {
            responses.__thisIndexer(0).ThrowIfNecessary();
        });
    };
    /**
     * Deletes items in the specified conversation.
     * Calling this method results in a call to EWS.
     *
     * @param   {FolderId}      contextFolderId   The Id of the folder items must belong to in order to be deleted. If contextFolderId is null, items across the entire mailbox are deleted.
     * @param   {DeleteMode}    deleteMode        The deletion mode.
     * @return  {Promise<void>}    Promise
     */
    Conversation.prototype.DeleteItems = function (contextFolderId, deleteMode) {
        return this.Service.DeleteItemsInConversations([{ key: this.Id, value: this.GlobalLastDeliveryTime }], contextFolderId, deleteMode).then(function (responses) {
            responses.__thisIndexer(0).ThrowIfNecessary();
        });
    };
    /**
     * Sets up a conversation so that any item received within that conversation is no longer categorized.
     * Calling this method results in a call to EWS.
     *
     * @param   {boolean}   processSynchronously   **<not used>**Indicates whether the method should return only once disabling this rule and removing the categories from existing items in the conversation is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<void>}    Promise
     */
    Conversation.prototype.DisableAlwaysCategorizeItems = function (processSynchronously) {
        return this.Service.DisableAlwaysCategorizeItemsInConversations([this.Id], processSynchronously).then(function (responses) {
            responses.__thisIndexer(0).ThrowIfNecessary();
        });
    };
    /**
     * Sets up a conversation so that any item received within that conversation is no longer moved to Deleted Items folder.
     * Calling this method results in a call to EWS.
     *
     * @param   {boolean}   processSynchronously   Indicates whether the method should return only once disabling this rule and restoring the items in the conversation is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<void>}    Promise
     */
    Conversation.prototype.DisableAlwaysDeleteItems = function (processSynchronously) {
        return this.Service.DisableAlwaysDeleteItemsInConversations([this.Id], processSynchronously).then(function (responses) {
            responses.__thisIndexer(0).ThrowIfNecessary();
        });
    };
    /**
     * Sets up a conversation so that any item received within that conversation is no longer moved to a specific folder.
     * Calling this method results in a call to EWS.
     *
     * @param   {boolean}   processSynchronously   Indicates whether the method should return only once disabling this rule is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<void>}    Promise
     */
    Conversation.prototype.DisableAlwaysMoveItemsInConversation = function (processSynchronously) {
        return this.Service.DisableAlwaysMoveItemsInConversations([this.Id], processSynchronously).then(function (responses) {
            responses.__thisIndexer(0).ThrowIfNecessary();
        });
    };
    /**
     * Sets up a conversation so that any item received within that conversation is always categorized.
     * Calling this method results in a call to EWS.
     *
     * @param   {string[]}  categories             The categories that should be stamped on items in the conversation.
     * @param   {boolean}   processSynchronously   Indicates whether the method should return only once enabling this rule and stamping existing items in the conversation is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<void>}    Promise
     */
    Conversation.prototype.EnableAlwaysCategorizeItems = function (categories, processSynchronously) {
        return this.Service.EnableAlwaysCategorizeItemsInConversations([this.Id], categories, processSynchronously).then(function (responses) {
            responses.__thisIndexer(0).ThrowIfNecessary();
        });
    };
    /**
     * Sets up a conversation so that any item received within that conversation is always moved to Deleted Items folder.
     * Calling this method results in a call to EWS.
     *
     * @param   {boolean}   processSynchronously   Indicates whether the method should return only once enabling this rule and deleting existing items in the conversation is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<void>}    Promise
     */
    Conversation.prototype.EnableAlwaysDeleteItems = function (processSynchronously) {
        return this.Service.EnableAlwaysDeleteItemsInConversations([this.Id], processSynchronously).then(function (responses) {
            responses.__thisIndexer(0).ThrowIfNecessary();
        });
    };
    /**
     * Sets up a conversation so that any item received within that conversation is always moved to a specific folder.
     * Calling this method results in a call to EWS.
     *
     * @param   {FolderId}  destinationFolderId    The Id of the folder to which conversation items should be moved.
     * @param   {boolean}   processSynchronously   Indicates whether the method should return only once enabling this rule and moving existing items in the conversation is completely done. If processSynchronously is false, the method returns immediately.
     * @return  {Promise<void>}    Promise
     */
    Conversation.prototype.EnableAlwaysMoveItems = function (destinationFolderId, processSynchronously) {
        return this.Service.EnableAlwaysMoveItemsInConversations([this.Id], destinationFolderId, processSynchronously).then(function (responses) {
            responses.__thisIndexer(0).ThrowIfNecessary();
        });
    };
    /**
     * Flags conversation items. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}   contextFolderId   The Id of the folder items must belong to in order to be flagged. If contextFolderId is null, items in conversation across the entire mailbox are flagged.
     * @param   {DateTime}   startDate         The start date (can be null).
     * @param   {DateTime}   dueDate           The due date (can be null).
     * @return  {Promise<void>}    Promise
     */
    Conversation.prototype.FlagItems = function (contextFolderId, startDate, dueDate) {
        var flag = new Flag();
        flag.FlagStatus = ItemFlagStatus.Flagged;
        if (startDate) {
            flag.StartDate = startDate;
        }
        if (dueDate) {
            flag.DueDate = dueDate;
        }
        return this.Service.SetFlagStatusForItemsInConversations([{ key: this.Id, value: this.GlobalLastDeliveryTime }], contextFolderId, flag).then(function (responses) {
            responses.__thisIndexer(0).ThrowIfNecessary();
        });
    };
    /**
     * Flag conversation items as complete. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}   contextFolderId   The Id of the folder items must belong to in order to be flagged as complete. If contextFolderId is null, items in conversation across the entire mailbox are marked as complete.
     * @param   {DateTime}   completeDate      The complete date (can be null).
     * @return  {Promise<void>}    Promise
     */
    Conversation.prototype.FlagItemsComplete = function (contextFolderId, completeDate) {
        var flag = new Flag();
        flag.FlagStatus = ItemFlagStatus.Complete;
        if (completeDate) {
            flag.CompleteDate = completeDate;
        }
        return this.Service.SetFlagStatusForItemsInConversations([{ key: this.Id, value: this.GlobalLastDeliveryTime }], contextFolderId, flag).then(function (responses) {
            responses.__thisIndexer(0).ThrowIfNecessary();
        });
    };
    /**
     * @internal This method is not supported in this object.
     * Gets the name of the change XML element.
     *
     * @return  {string}      XML element name,
     */
    Conversation.prototype.GetChangeXmlElementName = function () {
        throw new NotSupportedException();
    };
    /**
     * @internal This method is not supported in this object.
     * Gets the name of the delete field XML element.
     *
     * @return  {string}      XML element name,
     */
    Conversation.prototype.GetDeleteFieldXmlElementName = function () {
        throw new NotSupportedException();
    };
    /**
     * The property definition for the Id of this object.
     *
     * @return  {PropertyDefinition}      A PropertyDefinition instance.
     */
    Conversation.prototype.GetIdPropertyDefinition = function () {
        return Schemas.ConversationSchema.Id;
    };
    /**
     * @internal This method is not supported in this object.
     * Gets a value indicating whether a time zone SOAP header should be emitted in a CreateItem or UpdateItem request so this item can be property saved or updated.
     *
     * @param   {boolean}   isUpdateOperation   Indicates whether the operation being petrformed is an update operation.
     * @return  {boolean}                       true if a time zone SOAP header should be emitted; otherwise, false.
     */
    Conversation.prototype.GetIsTimeZoneHeaderRequired = function (isUpdateOperation) {
        throw new NotSupportedException();
    };
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    Conversation.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2010_SP1;
    };
    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    Conversation.prototype.GetSchema = function () {
        return Schemas.ConversationSchema.Instance;
    };
    /**
     * @internal This method is not supported in this object.
     * Gets the name of the set field XML element.
     *
     * @return  {string}      XML element name,
     */
    Conversation.prototype.GetSetFieldXmlElementName = function () {
        throw new NotSupportedException();
    };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    Conversation.prototype.GetXmlElementName = function () {
        return XmlElementNames.Conversation;
    };
    /**
     * @internal This is not supported in this object.
     * Deletes the object.
     *
     * @param   {DeleteMode}                deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}     sendCancellationsMode     Indicates whether meeting cancellation messages should be sent.
     * @param   {AffectedTaskOccurrence}    affectedTaskOccurrences   Indicate which occurrence of a recurring task should be deleted.
     */
    Conversation.prototype.InternalDelete = function (deleteMode, sendCancellationsMode, affectedTaskOccurrences) {
        throw new NotSupportedException();
    };
    /**
     * @internal This method is not supported in this object.
     * Loads the specified set of properties on the object.
     *
     * @param   {PropertySet}   propertySet   The properties to load.
     */
    Conversation.prototype.InternalLoad = function (propertySet) {
        throw new NotSupportedException();
    };
    /**
     * Moves items in the specified conversation to a specific folder.
     * Calling this method results in a call to EWS.
     *
     * @param   {FolderId}   contextFolderId       The Id of the folder items must belong to in order to be moved. If contextFolderId is null, items across the entire mailbox are moved.
     * @param   {FolderId}   destinationFolderId   The Id of the destination folder.
     * @return  {Promise<void>}    Promise
     */
    Conversation.prototype.MoveItemsInConversation = function (contextFolderId, destinationFolderId) {
        return this.Service.MoveItemsInConversations([{ key: this.Id, value: this.GlobalLastDeliveryTime }], contextFolderId, destinationFolderId).then(function (responses) {
            responses.__thisIndexer(0).ThrowIfNecessary();
        });
    };
    Conversation.prototype.SetReadStateForItemsInConversation = function (contextFolderId, isRead, suppressReadReceipts) {
        if (suppressReadReceipts === void 0) { suppressReadReceipts = null; }
        return this.Service.SetReadStateForItemsInConversations([{ key: this.Id, value: this.GlobalLastDeliveryTime }], contextFolderId, isRead, suppressReadReceipts).then(function (responses) {
            responses.__thisIndexer(0).ThrowIfNecessary();
        });
    };
    /**
     * Sets the retention policy of items in the specified conversation. Calling this method results in a call to EWS.
     *
     * @param   {FolderId}          contextFolderId        The Id of the folder items must belong to in order for their retention policy to be set. If contextFolderId is null, the retention policy of items across the entire mailbox are set.
     * @param   {RetentionType}     retentionPolicyType    Retention policy type.
     * @param   {Guid}              retentionPolicyTagId   Retention policy tag id.  Null will clear the policy.
     * @return  {Promise<void>}    Promise
     */
    Conversation.prototype.SetRetentionPolicyForItemsInConversation = function (contextFolderId, retentionPolicyType, retentionPolicyTagId) {
        return this.Service.SetRetentionPolicyForItemsInConversations([{ key: this.Id, value: this.GlobalLastDeliveryTime }], contextFolderId, retentionPolicyType, retentionPolicyTagId).then(function (responses) {
            responses.__thisIndexer(0).ThrowIfNecessary();
        });
    };
    return Conversation;
}(ServiceObject));
exports.Conversation = Conversation;
/**
 * Represents the base class for all responses that can be sent.
 *
 * @typeparam   {TMessage}     Type of message.
 */
var ResponseObject = (function (_super) {
    __extends(ResponseObject, _super);
    /**
     * @internal Initializes a new instance of the **ResponseObject** class.
     *
     * @param   {type}   referenceItem   The reference item.
     */
    function ResponseObject(referenceItem) {
        var _this = _super.call(this, referenceItem.Service) || this;
        _this.referenceItem = null;
        EwsLogging.Assert(referenceItem !== null, "ResponseObject.ctor", "referenceItem is null");
        referenceItem.ThrowIfThisIsNew();
        _this.referenceItem = referenceItem;
        return _this;
    }
    Object.defineProperty(ResponseObject.prototype, "IsReadReceiptRequested", {
        /**
         * Gets or sets a value indicating whether read receipts will be requested from recipients of this response.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.IsReadReceiptRequested);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.EmailMessageSchema.IsReadReceiptRequested, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResponseObject.prototype, "IsDeliveryReceiptRequested", {
        /**
         * Gets or sets a value indicating whether delivery receipts should be sent to the sender.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.IsDeliveryReceiptRequested);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.EmailMessageSchema.IsDeliveryReceiptRequested, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    ResponseObject.prototype.GetSchema = function () { return Schemas.ResponseObjectSchema.Instance; };
    /**
    * @internal Create the response object.
    *
    * @param   {FolderId}             destinationFolderId   The destination folder id.
    * @param   {MessageDisposition}   messageDisposition    The message disposition.
    * @return  {Promise<Item[]>}               The list of items returned by EWS.
    */
    ResponseObject.prototype.InternalCreate = function (destinationFolderId, messageDisposition) {
        this.PropertyBag._getItem(Schemas.ResponseObjectSchema.ReferenceItemId).Assign(this.referenceItem.Id);
        return this.Service.InternalCreateResponseObject(this, destinationFolderId, messageDisposition);
    };
    /**
     * @internal Deletes the object.
     *
     * @param   {DeleteMode}                  deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}       sendCancellationsMode     Indicates whether meeting cancellation messages should be sent.
     * @param   {affectedTaskOccurrences}     affectedTaskOccurrences   Indicate which occurrence of a recurring task should be deleted.
     */
    ResponseObject.prototype.InternalDelete = function (deleteMode, sendCancellationsMode, affectedTaskOccurrences) {
        throw new NotSupportedException();
    };
    /**
     * @internal Loads the specified set of properties on the object.
     *
     * @param   {PropertySet}   propertySet   The properties to load.
     */
    ResponseObject.prototype.InternalLoad = function (propertySet) {
        throw new NotSupportedException();
    };
    ResponseObject.prototype.Save = function (destinationFolderIdOrName) {
        var destinationFolderId = null;
        if (arguments.length === 1) {
            if (typeof destinationFolderIdOrName === "number") {
                destinationFolderId = new FolderId(destinationFolderIdOrName);
            }
            else {
                //EwsUtilities.ValidateParam(destinationFolderIdOrName, "destinationFolderId");
                destinationFolderId = destinationFolderIdOrName;
            }
        }
        return this.InternalCreate(destinationFolderId, MessageDisposition.SaveOnly).then(function (result) {
            return result[0];
        });
    };
    /**
     * Sends this response without saving a copy. Calling this method results in a call to EWS.
     */
    ResponseObject.prototype.Send = function () {
        return this.InternalCreate(null, MessageDisposition.SendOnly);
    };
    ResponseObject.prototype.SendAndSaveCopy = function (destinationFolderIdOrName) {
        var destinationFolderId = null;
        if (arguments.length === 1) {
            if (typeof destinationFolderIdOrName === "number") {
                destinationFolderId = new FolderId(destinationFolderIdOrName);
            }
            else {
                //EwsUtilities.ValidateParam(destinationFolderIdOrName, "destinationFolderId");
                destinationFolderId = destinationFolderIdOrName;
            }
        }
        return this.InternalCreate(destinationFolderId, MessageDisposition.SendAndSaveCopy);
    };
    return ResponseObject;
}(ServiceObject));
exports.ResponseObject = ResponseObject;
/**
 * Represents the base class for all calendar-related response messages.
 *
 * @typeparam   {TMessage}     The type of message that is created when this response message is saved.
 */
var CalendarResponseMessageBase = (function (_super) {
    __extends(CalendarResponseMessageBase, _super);
    /**
    * @internal Initializes a new instance of the **CalendarResponseMessageBase** class.
    *
    * @param   {Item}   referenceItem   The reference item.
    */
    function CalendarResponseMessageBase(referenceItem) {
        return _super.call(this, referenceItem) || this;
    }
    CalendarResponseMessageBase.prototype.Save = function (destinationFolderIdOrName) {
        var destinationFolderId = null;
        if (arguments.length === 1) {
            if (typeof destinationFolderIdOrName === "number") {
                destinationFolderId = new FolderId(destinationFolderIdOrName);
            }
            else {
                //EwsUtilities.ValidateParam(destinationFolderIdOrName, "destinationFolderId");
                destinationFolderId = destinationFolderIdOrName;
            }
        }
        return this.InternalCreate(destinationFolderId, MessageDisposition.SaveOnly).then(function (results) {
            return new CalendarActionResults(results);
        });
    };
    /**
     * Sends this response without saving a copy. Calling this method results in a call to EWS.
     *
     * @return  {CalendarActionResults}      A CalendarActionResults object containing the various items that were created or modified as a results of this operation.
     */
    CalendarResponseMessageBase.prototype.Send = function () {
        return this.InternalCreate(null, MessageDisposition.SendOnly).then(function (results) {
            return new CalendarActionResults(results);
        });
    };
    CalendarResponseMessageBase.prototype.SendAndSaveCopy = function (destinationFolderIdOrName) {
        var destinationFolderId = null;
        if (arguments.length === 1) {
            if (typeof destinationFolderIdOrName === "number") {
                destinationFolderId = new FolderId(destinationFolderIdOrName);
            }
            else {
                //EwsUtilities.ValidateParam(destinationFolderIdOrName, "destinationFolderId");
                destinationFolderId = destinationFolderIdOrName;
            }
        }
        return this.InternalCreate(destinationFolderId, MessageDisposition.SendAndSaveCopy)
            .then(function (results) {
            return new CalendarActionResults(results);
        });
    };
    return CalendarResponseMessageBase;
}(ResponseObject));
exports.CalendarResponseMessageBase = CalendarResponseMessageBase;
/**
 * Represents the base class for accept, tentatively accept and decline response messages.
 *
 * @typeparam   {TMessage}     The type of message that is created when this response message is saved.
 */
var CalendarResponseMessage = (function (_super) {
    __extends(CalendarResponseMessage, _super);
    /**
     * @internal Initializes a new instance of the **CalendarResponseMessage** class.
     *
     * @param   {Item}   referenceItem   The reference item.
     */
    function CalendarResponseMessage(referenceItem) {
        return _super.call(this, referenceItem) || this;
    }
    Object.defineProperty(CalendarResponseMessage.prototype, "Body", {
        /**
         * Gets or sets the body of the response.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.Body);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.Body, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarResponseMessage.prototype, "ToRecipients", {
        /**
         * Gets a list of recipients the response will be sent to.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.ToRecipients);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarResponseMessage.prototype, "CcRecipients", {
        /**
         * Gets a list of recipients the response will be sent to as Cc.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.CcRecipients);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarResponseMessage.prototype, "BccRecipients", {
        /**
         * Gets a list of recipients this response will be sent to as Bcc.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.BccRecipients);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarResponseMessage.prototype, "ItemClass", {
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.ItemClass);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.ItemClass, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarResponseMessage.prototype, "Sensitivity", {
        /**
         * Gets or sets the sensitivity of this response.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.Sensitivity);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.Sensitivity, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarResponseMessage.prototype, "Attachments", {
        /**
         * Gets a list of attachments to this response.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.Attachments);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarResponseMessage.prototype, "InternetMessageHeaders", {
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.InternetMessageHeaders);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarResponseMessage.prototype, "Sender", {
        /**
         * Gets or sets the sender of this response.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.Sender);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.EmailMessageSchema.Sender, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    CalendarResponseMessage.prototype.GetSchema = function () { return Schemas.CalendarResponseObjectSchema.Instance; };
    return CalendarResponseMessage;
}(CalendarResponseMessageBase));
exports.CalendarResponseMessage = CalendarResponseMessage;
/**
 * Represents a meeting acceptance message.
 *
 */
var AcceptMeetingInvitationMessage = (function (_super) {
    __extends(AcceptMeetingInvitationMessage, _super);
    /**
     * Initializes a new instance of the **AcceptMeetingInvitationMessage** class.
     *
     * @param   {Item}            referenceItem   The reference item.
     * @param   {boolean}         tentative       if set to true accept invitation tentatively.
     */
    function AcceptMeetingInvitationMessage(referenceItem, tentative) {
        var _this = _super.call(this, referenceItem) || this;
        _this.tentative = false;
        _this.tentative = tentative;
        return _this;
    }
    Object.defineProperty(AcceptMeetingInvitationMessage.prototype, "Tentative", {
        /**
         * Gets a value indicating whether the associated meeting is tentatively accepted.
         *
         */
        get: function () {
            return this.tentative;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    AcceptMeetingInvitationMessage.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    /**
     * @internal This methods lets subclasses of ServiceObject override the default mechanism by which the XML element name associated with their type is retrieved.
     *
     * @return  {string}      The XML element name associated with this type. If this method returns null or empty, the XML element name associated with this type is determined by the EwsObjectDefinition attribute that decorates the type, if present.
     */
    AcceptMeetingInvitationMessage.prototype.GetXmlElementNameOverride = function () {
        if (this.tentative) {
            return XmlElementNames.TentativelyAcceptItem;
        }
        else {
            return XmlElementNames.AcceptItem;
        }
    };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    AcceptMeetingInvitationMessage.prototype.GetXmlElementName = function () { return this.GetXmlElementNameOverride(); };
    return AcceptMeetingInvitationMessage;
}(CalendarResponseMessage));
exports.AcceptMeetingInvitationMessage = AcceptMeetingInvitationMessage;
/**
 * Represents a meeting cancellation message.
 *
 */
var CancelMeetingMessage = (function (_super) {
    __extends(CancelMeetingMessage, _super);
    /**
     * Initializes a new instance of the **CancelMeetingMessage** class.
     *
     * @param   {Item}   referenceItem   The reference item.
     */
    function CancelMeetingMessage(referenceItem) {
        return _super.call(this, referenceItem) || this;
    }
    Object.defineProperty(CancelMeetingMessage.prototype, "Body", {
        /**
         * Gets or sets the body of the response.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.CancelMeetingMessageSchema.Body);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.CancelMeetingMessageSchema.Body, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    CancelMeetingMessage.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    /**
     * Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    CancelMeetingMessage.prototype.GetSchema = function () { return Schemas.CancelMeetingMessageSchema.Instance; };
    /**
     * Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    CancelMeetingMessage.prototype.GetXmlElementName = function () { return XmlElementNames.CancelCalendarItem; };
    return CancelMeetingMessage;
}(CalendarResponseMessageBase));
exports.CancelMeetingMessage = CancelMeetingMessage;
/**
 * Represents a meeting declination message.
 */
var DeclineMeetingInvitationMessage = (function (_super) {
    __extends(DeclineMeetingInvitationMessage, _super);
    /**
     * Initializes a new instance of the **DeclineMeetingInvitationMessage** class.
     *
     * @param   {Item}   referenceItem   The reference item.
     */
    function DeclineMeetingInvitationMessage(referenceItem) {
        return _super.call(this, referenceItem) || this;
    }
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    DeclineMeetingInvitationMessage.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    DeclineMeetingInvitationMessage.prototype.GetXmlElementName = function () { return XmlElementNames.DeclineItem; };
    return DeclineMeetingInvitationMessage;
}(CalendarResponseMessage));
exports.DeclineMeetingInvitationMessage = DeclineMeetingInvitationMessage;
/**
 * Represents the base class for e-mail related responses (Reply, Reply all and Forward).
 *
 */
var ResponseMessage = (function (_super) {
    __extends(ResponseMessage, _super);
    /**
     * Initializes a new instance of the **ResponseMessage** class.
     *
     * @param   {Item}                    referenceItem   The reference item.
     * @param   {ResponseMessageType}     responseType    Type of the response.
     */
    function ResponseMessage(referenceItem, responseType) {
        var _this = _super.call(this, referenceItem) || this;
        _this.responseType = ResponseMessageType.Reply;
        _this.responseType = responseType;
        return _this;
    }
    Object.defineProperty(ResponseMessage.prototype, "ResponseType", {
        /**
         * Gets a value indicating the type of response this object represents.
         *
         */
        get: function () {
            return this.responseType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResponseMessage.prototype, "Body", {
        /**
         * Gets or sets the body of the response.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.Body);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.Body, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResponseMessage.prototype, "ToRecipients", {
        /**
         * Gets a list of recipients the response will be sent to.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.ToRecipients);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResponseMessage.prototype, "CcRecipients", {
        /**
         * Gets a list of recipients the response will be sent to as Cc.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.CcRecipients);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResponseMessage.prototype, "BccRecipients", {
        /**
         * Gets a list of recipients this response will be sent to as Bcc.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.EmailMessageSchema.BccRecipients);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResponseMessage.prototype, "Subject", {
        /**
         * Gets or sets the subject of this response.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.Subject);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.Subject, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResponseMessage.prototype, "BodyPrefix", {
        /**
         * Gets or sets the body prefix of this response. The body prefix will be prepended to the original
        message's body when the response is created.
         *
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ResponseObjectSchema.BodyPrefix);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ResponseObjectSchema.BodyPrefix, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the minimum required server version.
     *
     * @return  {type}      Earliest Exchange version in which this service object type is supported.
     */
    ResponseMessage.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    /**
     * Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    ResponseMessage.prototype.GetSchema = function () { return Schemas.ResponseMessageSchema.Instance; };
    /**
     * Get XML Element Name - workaround for c# attributes
     */
    ResponseMessage.prototype.GetXmlElementName = function () { return this.GetXmlElementNameOverride(); };
    /**
     * This methods lets subclasses of ServiceObject override the default mechanism by which the XML element name associated with their type is retrieved.
     *
     * @return  {string}      The XML element name associated with this type. If this method returns null or empty, the XML element name associated with this type is determined by the EwsObjectDefinition attribute that decorates the type, if present.
     */
    ResponseMessage.prototype.GetXmlElementNameOverride = function () {
        switch (this.responseType) {
            case ResponseMessageType.Reply:
                return XmlElementNames.ReplyToItem;
            case ResponseMessageType.ReplyAll:
                return XmlElementNames.ReplyAllToItem;
            case ResponseMessageType.Forward:
                return XmlElementNames.ForwardItem;
            default:
                EwsLogging.Assert(false, "ResponseMessage.GetXmlElementNameOverride", "An unexpected value for responseType could not be handled.");
                return null; // Because the compiler wants it
        }
    };
    return ResponseMessage;
}(ResponseObject));
exports.ResponseMessage = ResponseMessage;
/**
 * Represents a reply to a post item.
 *
 * @sealed
 */
var PostReply = (function (_super) {
    __extends(PostReply, _super);
    /**
     * @internal Initializes a new instance of the **PostReply** class.
     *
     * @param   {Item}   referenceItem   The reference item.
     */
    function PostReply(referenceItem) {
        var _this = _super.call(this, referenceItem.Service) || this;
        _this.referenceItem = null;
        EwsLogging.Assert(referenceItem != null, "PostReply.ctor", "referenceItem is null");
        referenceItem.ThrowIfThisIsNew();
        _this.referenceItem = referenceItem;
        return _this;
    }
    Object.defineProperty(PostReply.prototype, "Subject", {
        /**
         * Gets or sets the subject of the post reply.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.Subject);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.Subject, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PostReply.prototype, "Body", {
        /**
         * Gets or sets the body of the post reply.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ItemSchema.Body);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ItemSchema.Body, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PostReply.prototype, "BodyPrefix", {
        /**
         * Gets or sets the body prefix that should be prepended to the original post item's body.
         */
        get: function () {
            return this.PropertyBag._getItem(Schemas.ResponseObjectSchema.BodyPrefix);
        },
        set: function (value) {
            this.PropertyBag._setItem(Schemas.ResponseObjectSchema.BodyPrefix, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    PostReply.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    PostReply.prototype.GetSchema = function () {
        return Schemas.PostReplySchema.Instance;
    };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    PostReply.prototype.GetXmlElementName = function () {
        return XmlElementNames.PostReplyItem;
    };
    /**
     * @internal Create a PostItem response.
     *
     * @param   {FolderId}              parentFolderId       The parent folder id.
     * @param   {MessageDisposition}    messageDisposition   The message disposition.
     * @return  {Promise<PostItem>}    Created PostItem    :Promise.
     */
    PostReply.prototype.InternalCreate = function (parentFolderId, messageDisposition) {
        this.PropertyBag._getItem(Schemas.ResponseObjectSchema.ReferenceItemId).Assign(this.referenceItem.Id);
        return this.Service.InternalCreateResponseObject(this, parentFolderId, messageDisposition).then(function (items) {
            var postItem = EwsUtilities.FindFirstItemOfType(items, PostItem);
            // This should never happen. If it does, we have a bug.
            EwsLogging.Assert(postItem != null, "PostReply.InternalCreate", "postItem is null. The CreateItem call did not return the expected PostItem.");
            return postItem;
        });
    };
    /**
     * @internal Deletes the object.
     *
     * @param   {DeleteMode}                deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}     sendCancellationsMode     Indicates whether meeting cancellation messages should be sent.
     * @param   {AffectedTaskOccurrence}    affectedTaskOccurrences   Indicate which occurrence of a recurring task should be deleted.
     * @return  {Promise<void>}    :Promise.
     */
    PostReply.prototype.InternalDelete = function (deleteMode, sendCancellationsMode, affectedTaskOccurrences) {
        throw new InvalidOperationException(Strings.DeletingThisObjectTypeNotAuthorized);
    };
    /**
     * @internal Loads the specified set of properties on the object.
     *
     * @param   {PropertySet}   propertySet   The properties to load.
     * @return  {Promise<void>}    :Promise.
     */
    PostReply.prototype.InternalLoad = function (propertySet) {
        throw new InvalidOperationException(Strings.LoadingThisObjectTypeNotSupported);
    };
    PostReply.prototype.Save = function (destinationFolderIdOrFolderName) {
        if (destinationFolderIdOrFolderName === void 0) { destinationFolderIdOrFolderName = null; }
        var destinationFolderId = destinationFolderIdOrFolderName;
        if (arguments.length > 0) {
            EwsUtilities.ValidateParam(destinationFolderIdOrFolderName, "destinationFolderId");
        }
        if (typeof destinationFolderIdOrFolderName === 'number') {
            destinationFolderId = new FolderId(destinationFolderIdOrFolderName);
        }
        return this.InternalCreate(destinationFolderId, null);
    };
    return PostReply;
}(ServiceObject));
exports.PostReply = PostReply;
/**
 * @internal Represents a response object created to remove a calendar item from a meeting cancellation.
 *
 * @sealed
 */
var RemoveFromCalendar = (function (_super) {
    __extends(RemoveFromCalendar, _super);
    /**
     * Initializes a new instance of the **RemoveFromCalendar** class.
     *
     * @param   {Item}   referenceItem   The reference item.
     */
    function RemoveFromCalendar(referenceItem) {
        var _this = _super.call(this, referenceItem.Service) || this;
        EwsLogging.Assert(referenceItem != null, "RemoveFromCalendar.ctor", "referenceItem is null");
        referenceItem.ThrowIfThisIsNew();
        _this.referenceItem = referenceItem;
        return _this;
    }
    /**
     * @internal Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    RemoveFromCalendar.prototype.GetMinimumRequiredServerVersion = function () {
        return ExchangeVersion.Exchange2007_SP1;
    };
    /**
     * @internal Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    RemoveFromCalendar.prototype.GetSchema = function () {
        return Schemas.ResponseObjectSchema.Instance;
    };
    /**
     * @internal Gets the element name of item in XML
     *
     * @return  {string} name of elelment
     */
    RemoveFromCalendar.prototype.GetXmlElementName = function () {
        return XmlElementNames.RemoveItem;
    };
    /**
     * @internal Create response object.
     *
     * @param   {FolderId}              parentFolderId       The parent folder id.
     * @param   {MessageDisposition}    messageDisposition   The message disposition.
     * @return  {Item[]}                A list of items that were created or modified as a results of this operation.
     */
    RemoveFromCalendar.prototype.InternalCreate = function (parentFolderId, messageDisposition) {
        this.PropertyBag._getItem(Schemas.ResponseObjectSchema.ReferenceItemId).Assign(this.referenceItem.Id);
        return this.Service.InternalCreateResponseObject(this, parentFolderId, messageDisposition);
    };
    /**
     * @internal Deletes the object.
     *
     * @param   {DeleteMode}                deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}     sendCancellationsMode     Indicates whether meeting cancellation messages should be sent.
     * @param   {AffectedTaskOccurrence}    affectedTaskOccurrences   Indicate which occurrence of a recurring task should be deleted.
     * @return  {Promise<void>}            :Promise.
     */
    RemoveFromCalendar.prototype.InternalDelete = function (deleteMode, sendCancellationsMode, affectedTaskOccurrences) {
        throw new NotSupportedException();
    };
    /**
     * @internal Loads the specified set of properties on the object.
     *
     * @param   {PropertySet}   propertySet   The properties to load.
     * @return  {Promise<void>}              :Promise.
     */
    RemoveFromCalendar.prototype.InternalLoad = function (propertySet) {
        throw new NotSupportedException();
    };
    return RemoveFromCalendar;
}(ServiceObject));
exports.RemoveFromCalendar = RemoveFromCalendar;
/**
 * Represents a response object created to supress read receipts for an item.
 *
 */
var SuppressReadReceipt = (function (_super) {
    __extends(SuppressReadReceipt, _super);
    /**
     * Initializes a new instance of the **SuppressReadReceipt** class.
     *
     * @param   {Item}   referenceItem   The reference item.
     */
    function SuppressReadReceipt(referenceItem) {
        var _this = _super.call(this, referenceItem.Service) || this;
        _this.referenceItem = null;
        EwsLogging.Assert(referenceItem !== null, "SuppressReadReceipt.ctor", "referenceItem is null");
        referenceItem.ThrowIfThisIsNew();
        _this.referenceItem = referenceItem;
        return _this;
    }
    /**
     * Gets the minimum required server version.
     *
     * @return  {ExchangeVersion}      Earliest Exchange version in which this service object type is supported.
     */
    SuppressReadReceipt.prototype.GetMinimumRequiredServerVersion = function () { return ExchangeVersion.Exchange2007_SP1; };
    /**
     * Internal method to return the schema associated with this type of object.
     *
     * @return  {ServiceObjectSchema}      The schema associated with this type of object.
     */
    SuppressReadReceipt.prototype.GetSchema = function () { return Schemas.ResponseObjectSchema.Instance; };
    SuppressReadReceipt.prototype.GetXmlElementName = function () { return XmlElementNames.SuppressReadReceipt; };
    /**
     * Create the response object.
     *
     * @param   {FolderId}            parentFolderId       The parent folder id.
     * @param   {MessageDisposition}  messageDisposition   The message disposition.
     */
    SuppressReadReceipt.prototype.InternalCreate = function (parentFolderId, messageDisposition) {
        this.PropertyBag._getItem(Schemas.ResponseObjectSchema.ReferenceItemId).Assign(this.referenceItem.Id);
        return this.Service.InternalCreateResponseObject(this, parentFolderId, messageDisposition);
    };
    /**
     * Deletes the object.
     *
     * @param   {DeleteMode}              deleteMode                The deletion mode.
     * @param   {SendCancellationsMode}   sendCancellationsMode     Indicates whether meeting cancellation messages should be sent.
     * @param   {AffectedTaskOccurrence}  affectedTaskOccurrences   Indicate which occurrence of a recurring task should be deleted.
     */
    SuppressReadReceipt.prototype.InternalDelete = function (deleteMode, sendCancellationsMode, affectedTaskOccurrences) {
        throw new NotSupportedException();
    };
    /**
     * Loads the specified set of properties on the object.
     *
     * @param   {PropertySet}   propertySet   The properties to load.
     */
    SuppressReadReceipt.prototype.InternalLoad = function (propertySet) {
        throw new NotSupportedException();
    };
    return SuppressReadReceipt;
}(ServiceObject));
exports.SuppressReadReceipt = SuppressReadReceipt;
// /**
//  * FieldURIs for persona.
//  */
// module FieldUris {
//     export var PersonaId: string = "persona:PersonaId";
//     export var PersonaType: string = "persona:PersonaType";
//     export var CreationTime: string = "persona:CreationTime";
//     export var DisplayNameFirstLastHeader: string = "persona:DisplayNameFirstLastHeader";
//     export var DisplayNameLastFirstHeader: string = "persona:DisplayNameLastFirstHeader";
//     export var DisplayName: string = "persona:DisplayName";
//     export var DisplayNameFirstLast: string = "persona:DisplayNameFirstLast";
//     export var DisplayNameLastFirst: string = "persona:DisplayNameLastFirst";
//     export var FileAs: string = "persona:FileAs";
//     export var Generation: string = "persona:Generation";
//     export var DisplayNamePrefix: string = "persona:DisplayNamePrefix";
//     export var GivenName: string = "persona:GivenName";
//     export var Surname: string = "persona:Surname";
//     export var Title: string = "persona:Title";
//     export var CompanyName: string = "persona:CompanyName";
//     export var EmailAddress: string = "persona:EmailAddress";
//     export var EmailAddresses: string = "persona:EmailAddresses";
//     export var ImAddress: string = "persona:ImAddress";
//     export var HomeCity: string = "persona:HomeCity";
//     export var WorkCity: string = "persona:WorkCity";
//     export var Alias: string = "persona:Alias";
//     export var RelevanceScore: string = "persona:RelevanceScore";
//     export var Attributions: string = "persona:Attributions";
//     export var OfficeLocations: string = "persona:OfficeLocations";
//     export var ImAddresses: string = "persona:ImAddresses";
//     export var Departments: string = "persona:Departments";
//     export var ThirdPartyPhotoUrls: string = "persona:ThirdPartyPhotoUrls";
// }
// /**
//  * Represents the schema for persona.
//  */
// export class PersonaSchema extends ItemSchema {
//     public PersonaId: PropertyDefinition;
//     public PersonaType: PropertyDefinition;
//     public CreationTime: PropertyDefinition;
//     public DisplayNameFirstLastHeader: PropertyDefinition;
//     public DisplayNameLastFirstHeader: PropertyDefinition;
//     public DisplayName: PropertyDefinition;
//     public DisplayNameFirstLast: PropertyDefinition;
//     public DisplayNameLastFirst: PropertyDefinition;
//     public FileAs: PropertyDefinition;
//     public Generation: PropertyDefinition;
//     public DisplayNamePrefix: PropertyDefinition;
//     public GivenName: PropertyDefinition;
//     public Surname: PropertyDefinition;
//     public Title: PropertyDefinition;
//     public CompanyName: PropertyDefinition;
//     public EmailAddress: PropertyDefinition;
//     public EmailAddresses: PropertyDefinition;
//     public ImAddress: PropertyDefinition;
//     public HomeCity: PropertyDefinition;
//     public WorkCity: PropertyDefinition;
//     public Alias: PropertyDefinition;
//     public RelevanceScore: PropertyDefinition;
//     public Attributions: PropertyDefinition;
//     public OfficeLocations: PropertyDefinition;
//     public ImAddresses: PropertyDefinition;
//     public Departments: PropertyDefinition;
//     public ThirdPartyPhotoUrls: PropertyDefinition;
//     /**
//      * @internal Instance of **PostItemSchema** 
//      */
//     static Instance: PersonaSchema = new PersonaSchema();
//     /**
//      * Registers properties.
//      * 
//      * /remarks/ IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
//      */
//     RegisterProperties(): void {
//         super.RegisterProperties();
//         this.RegisterProperty(this.PersonaId);
//         this.RegisterProperty(this.PersonaType);
//         this.RegisterProperty(this.CreationTime);
//         this.RegisterProperty(this.DisplayNameFirstLastHeader);
//         this.RegisterProperty(this.DisplayNameLastFirstHeader);
//         this.RegisterProperty(this.DisplayName);
//         this.RegisterProperty(this.DisplayNameFirstLast);
//         this.RegisterProperty(this.DisplayNameLastFirst);
//         this.RegisterProperty(this.FileAs);
//         this.RegisterProperty(this.Generation);
//         this.RegisterProperty(this.DisplayNamePrefix);
//         this.RegisterProperty(this.GivenName);
//         this.RegisterProperty(this.Surname);
//         this.RegisterProperty(this.Title);
//         this.RegisterProperty(this.CompanyName);
//         this.RegisterProperty(this.EmailAddress);
//         this.RegisterProperty(this.EmailAddresses);
//         this.RegisterProperty(this.ImAddress);
//         this.RegisterProperty(this.HomeCity);
//         this.RegisterProperty(this.WorkCity);
//         this.RegisterProperty(this.Alias);
//         this.RegisterProperty(this.RelevanceScore);
//         this.RegisterProperty(this.Attributions);
//         this.RegisterProperty(this.OfficeLocations);
//         this.RegisterProperty(this.ImAddresses);
//         this.RegisterProperty(this.Departments);
//         this.RegisterProperty(this.ThirdPartyPhotoUrls);
//     }
//     protected init() {
//         super.init();
//         this.PersonaId =
//             new ComplexPropertyDefinition<ItemId>(
//                 "PersonaId",
//                 XmlElementNames.PersonaId,
//                 FieldUris.PersonaId,
//                 PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1,
//                 () => { return new ItemId(); });
//         this.PersonaType =
//             new StringPropertyDefinition(
//                 "PersonaType",
//                 XmlElementNames.PersonaType,
//                 FieldUris.PersonaType,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);
//         this.CreationTime =
//             new DateTimePropertyDefinition(
//                 "CreationTime",
//                 XmlElementNames.CreationTime,
//                 FieldUris.CreationTime,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);
//         this.DisplayNameFirstLastHeader =
//             new StringPropertyDefinition(
//                 "DisplayNameFirstLastHeader",
//                 XmlElementNames.DisplayNameFirstLastHeader,
//                 FieldUris.DisplayNameFirstLastHeader,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);
//         this.DisplayNameLastFirstHeader =
//             new StringPropertyDefinition(
//                 "DisplayNameLastFirstHeader",
//                 XmlElementNames.DisplayNameLastFirstHeader,
//                 FieldUris.DisplayNameLastFirstHeader,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);
//         this.DisplayName =
//             new StringPropertyDefinition(
//                 "DisplayName",
//                 XmlElementNames.DisplayName,
//                 FieldUris.DisplayName,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);
//         this.DisplayNameFirstLast =
//             new StringPropertyDefinition(
//                 "DisplayNameFirstLast",
//                 XmlElementNames.DisplayNameFirstLast,
//                 FieldUris.DisplayNameFirstLast,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);
//         this.DisplayNameLastFirst =
//             new StringPropertyDefinition(
//                 "DisplayNameLastFirst",
//                 XmlElementNames.DisplayNameLastFirst,
//                 FieldUris.DisplayNameLastFirst,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);
//         this.FileAs =
//             new StringPropertyDefinition(
//                 "FileAs",
//                 XmlElementNames.FileAs,
//                 FieldUris.FileAs,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);
//         this.Generation =
//             new StringPropertyDefinition(
//                 "Generation",
//                 XmlElementNames.Generation,
//                 FieldUris.Generation,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);
//         this.DisplayNamePrefix =
//             new StringPropertyDefinition(
//                 "DisplayNamePrefix",
//                 XmlElementNames.DisplayNamePrefix,
//                 FieldUris.DisplayNamePrefix,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);
//         this.GivenName =
//             new StringPropertyDefinition(
//                 "GivenName",
//                 XmlElementNames.GivenName,
//                 FieldUris.GivenName,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);
//         this.Surname =
//             new StringPropertyDefinition(
//                 "Surname",
//                 XmlElementNames.Surname,
//                 FieldUris.Surname,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);
//         this.Title =
//             new StringPropertyDefinition(
//                 "Title",
//                 XmlElementNames.Title,
//                 FieldUris.Title,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);
//         this.CompanyName =
//             new StringPropertyDefinition(
//                 "CompanyName",
//                 XmlElementNames.CompanyName,
//                 FieldUris.CompanyName,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);
//         this.EmailAddress =
//             new ComplexPropertyDefinition<PersonaEmailAddress>(
//                 "EmailAddress",
//                 XmlElementNames.EmailAddress,
//                 FieldUris.EmailAddress,
//                 PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1,
//                 () => { return new PersonaEmailAddress(); });
//         this.EmailAddresses =
//             new ComplexPropertyDefinition<PersonaEmailAddressCollection>(
//                 "EmailAddresses",
//                 XmlElementNames.EmailAddresses,
//                 FieldUris.EmailAddresses,
//                 PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1,
//                 () => { return new PersonaEmailAddressCollection(); });
//         this.ImAddress =
//             new StringPropertyDefinition(
//                 "ImAddress",
//                 XmlElementNames.ImAddress,
//                 FieldUris.ImAddress,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);
//         this.HomeCity =
//             new StringPropertyDefinition(
//                 "HomeCity",
//                 XmlElementNames.HomeCity,
//                 FieldUris.HomeCity,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);
//         this.WorkCity =
//             new StringPropertyDefinition(
//                 "WorkCity",
//                 XmlElementNames.WorkCity,
//                 FieldUris.WorkCity,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);
//         this.Alias =
//             new StringPropertyDefinition(
//                 "Alias",
//                 XmlElementNames.Alias,
//                 FieldUris.Alias,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1);
//         this.RelevanceScore =
//             new IntPropertyDefinition(
//                 "RelevanceScore",
//                 XmlElementNames.RelevanceScore,
//                 FieldUris.RelevanceScore,
//                 PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1,
//                 true);
//         this.Attributions =
//             new ComplexPropertyDefinition<AttributionCollection>(
//                 "Attributions",
//                 XmlElementNames.Attributions,
//                 FieldUris.Attributions,
//                 PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1,
//                 () => { return new AttributionCollection(); });
//         this.OfficeLocations =
//             new ComplexPropertyDefinition<AttributedStringCollection>(
//                 "OfficeLocations",
//                 XmlElementNames.OfficeLocations,
//                 FieldUris.OfficeLocations,
//                 PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1,
//                 () => { return new AttributedStringCollection(); });
//         this.ImAddresses =
//             new ComplexPropertyDefinition<AttributedStringCollection>(
//                 "ImAddresses",
//                 XmlElementNames.ImAddresses,
//                 FieldUris.ImAddresses,
//                 PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1,
//                 () => { return new AttributedStringCollection(); });
//         this.Departments =
//             new ComplexPropertyDefinition<AttributedStringCollection>(
//                 "Departments",
//                 XmlElementNames.Departments,
//                 FieldUris.Departments,
//                 PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1,
//                 () => { return new AttributedStringCollection(); });
//         this.ThirdPartyPhotoUrls =
//             new ComplexPropertyDefinition<AttributedStringCollection>(
//                 "ThirdPartyPhotoUrls",
//                 XmlElementNames.ThirdPartyPhotoUrls,
//                 FieldUris.ThirdPartyPhotoUrls,
//                 PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind,
//                 ExchangeVersion.Exchange2013_SP1,
//                 () => { return new AttributedStringCollection(); });
//     }
// }
/**
 * Schemas - container for all schema objects
 */
var Schemas = (function () {
    function Schemas() {
    }
    Schemas.throwError = function () {
        throw "Bootstrapcode not initiated this Schema";
    };
    return Schemas;
}());
exports.Schemas = Schemas;
/**
 * Represents the base class for all item and folder schemas.
 */
var ServiceObjectSchema = (function () {
    //    static ForeachPublicStaticPropertyFieldInType(type: string /*System.Type*/, propFieldDelegate: (propertyDefinition: PropertyDefinition, fieldInfo: any /*FieldInfo*/) => void /*ServiceObjectSchema.PropertyFieldInfoDelegate*/): void {
    //        
    //        var keys = Object.keys(type);
    //        keys.forEach((s) => {
    //            if (typeof (type[s]) != "function" && type[s] instanceof (PropertyDefinition)) {
    //                var propertyDefinition = <PropertyDefinition> type[s];
    //                propFieldDelegate(propertyDefinition, s);
    //            }
    //        });
    //        //var staticfields = TypeSystem.GetObjectStaticPropertiesByClassName("Microsoft.Exchange.WebServices.Data." + type);
    //
    //        //for (var field in staticfields) {
    //        //    if (fieldInfo.FieldType == typeof (PropertyDefinition) || fieldInfo.FieldType.IsSubclassOf(typeof (PropertyDefinition))) {
    //        //        PropertyDefinition propertyDefinition = (PropertyDefinition) fieldInfo.GetValue(null);
    //        //        propFieldDelegate(propertyDefinition, fieldInfo);
    //        //    }
    //        //}
    //    }
    //    static InitializeSchemaPropertyNames(): void {
    //        
    //        //lock(lockObject)
    //        //{
    //        for (var type of ServiceObjectSchema.allSchemaTypes.Member) {
    //            //var type: string = item;
    //            ServiceObjectSchema.ForeachPublicStaticPropertyFieldInType(
    //                type,
    //                (propDef: PropertyDefinition, fieldName: string) => { propDef.Name = fieldName; });
    //        }
    //        //}
    //    }
    /**
     * @internal Initializes a new instance of the **ServiceObjectSchema** class.
     */
    function ServiceObjectSchema() {
        //todo: fixing difficulties with following c# code. - ref: added as delegate PropertyDefinitionDictionary in AltDictionary
        //using PropertyDefinitionDictionary = LazyMember < System.Collections.Generic.Dictionary<string, PropertyDefinitionBase>>;
        //type SchemaTypeList = LazyMember <string[]>;
        this.properties = new Dictionary(function (key) { return key; }); // System.Collections.Generic.Dictionary<TKey, TValue>;
        this.visibleProperties = []; //System.Collections.Generic.List<PropertyDefinition>;
        this.firstClassProperties = []; //System.Collections.Generic.List<PropertyDefinition>;
        this.firstClassSummaryProperties = []; //System.Collections.Generic.List<PropertyDefinition>;
        this.indexedProperties = []; //System.Collections.Generic.List<IndexedPropertyDefinition>;
        this.RegisterProperties();
    }
    Object.defineProperty(ServiceObjectSchema.prototype, "FirstClassProperties", {
        //static appointmentSchema: AppointmentSchema; - moved to Schemas
        /**
         * @internal Gets the list of first class properties for this service object type.
         */
        get: function () { return this.firstClassProperties; } //System.Collections.Generic.List<PropertyDefinition>;
        ,
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServiceObjectSchema.prototype, "FirstClassSummaryProperties", {
        /**
         * @internal Gets the list of first class summary properties for this service object type.
         */
        get: function () { return this.firstClassSummaryProperties; } //System.Collections.Generic.List<PropertyDefinition>;
        ,
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServiceObjectSchema.prototype, "IndexedProperties", {
        /**
         * @internal Gets the list of indexed properties for this service object type.
         */
        get: function () { return this.indexedProperties; } //System.Collections.Generic.List<IndexedPropertyDefinition>;
        ,
        enumerable: true,
        configurable: true
    });
    //    private static lockObject: any = {};
    //    private static allSchemaTypes: LazyMember<string[]> = new LazyMember<string[]>(() => { //SchemaTypeList - LazyMember<T>; - using typenames[] temporarily
    //        var typeList: string[] = [];
    //        return typeList;
    //        typeList.push("AppointmentSchema");
    //        typeList.push("CalendarResponseObjectSchema");
    //        typeList.push("CancelMeetingMessageSchema");
    //        typeList.push("ContactGroupSchema");
    //        typeList.push("ContactSchema");
    //        typeList.push("ConversationSchema");
    //        typeList.push("EmailMessageSchema");
    //        typeList.push("FolderSchema");
    //        typeList.push("ItemSchema");
    //        typeList.push("MeetingMessageSchema");
    //        typeList.push("MeetingRequestSchema");
    //        typeList.push("MeetingCancellationSchema");
    //        typeList.push("MeetingResponseSchema");
    //        typeList.push("PostItemSchema");
    //        typeList.push("PostReplySchema");
    //        typeList.push("ResponseMessageSchema");
    //        typeList.push("ResponseObjectSchema");
    //        typeList.push("ServiceObjectSchema");
    //        typeList.push("SearchFolderSchema");
    //        typeList.push("TaskSchema");
    //
    //        return typeList;
    //    });
    //    
    ////    private static allSchemaTypes: LazyMember<any[]> = new LazyMember<any[]>(() => { //SchemaTypeList - LazyMember<T>; - using typenames[] temporarily
    ////        var typeList: any[] = [];
    ////        return typeList;
    ////        typeList.push(AppointmentSchema);
    ////        typeList.push(CalendarResponseObjectSchema);
    ////        typeList.push(CancelMeetingMessageSchema);
    ////        typeList.push(ContactGroupSchema);
    ////        typeList.push(ContactSchema);
    ////        typeList.push(ConversationSchema);
    ////        typeList.push(EmailMessageSchema);
    ////        typeList.push(FolderSchema);
    ////        typeList.push(ItemSchema);
    ////        typeList.push(MeetingMessageSchema);
    ////        typeList.push(MeetingRequestSchema);
    ////        typeList.push(MeetingCancellationSchema);
    ////        typeList.push(MeetingResponseSchema);
    ////        typeList.push(PostItemSchema);
    ////        typeList.push(PostReplySchema);
    ////        typeList.push(ResponseMessageSchema);
    ////        typeList.push(ResponseObjectSchema);
    ////        typeList.push(ServiceObjectSchema);
    ////        typeList.push(SearchFolderSchema);
    ////        typeList.push(TaskSchema);
    ////
    ////        return typeList;
    ////    });
    //    private static allSchemaProperties = new LazyMember<StringPropertyDefinitionBaseDictionary<string, PropertyDefinitionBase>>(()=> {// string[] //LazyMember<T>;PropertyDefinitionDictionary => LazyMember<System.Collections.Generic.Dictionary<string, PropertyDefinitionBase>>;
    //        var propDefDictionary: StringPropertyDefinitionBaseDictionary<string, PropertyDefinitionBase> = new StringPropertyDefinitionBaseDictionary<string, PropertyDefinitionBase>();
    //        for (var type of ServiceObjectSchema.allSchemaTypes.Member) {
    //            //var type: string = item;
    //            ServiceObjectSchema.AddSchemaPropertiesToDictionary(type, propDefDictionary);
    //        }
    //        
    //        return propDefDictionary;
    //    });
    //    static AddSchemaPropertiesToDictionary(type: string /*System.Type*/, propDefDictionary: StringPropertyDefinitionBaseDictionary<string, PropertyDefinitionBase> /*System.Collections.Generic.Dictionary<TKey, TValue>*/): void {
    //        ServiceObjectSchema.ForeachPublicStaticPropertyFieldInType(
    //            type,
    //            (propertyDefinition: PropertyDefinition, fieldName: string) => {
    //                // Some property definitions descend from ServiceObjectPropertyDefinition but don't have
    //                // a Uri, like ExtendedProperties. Ignore them.
    //                if (!StringHelper.IsNullOrEmpty(propertyDefinition.Uri)) {
    //                    var existingPropertyDefinition: IOutParam<PropertyDefinitionBase> = { outValue: null };
    //                    if (propDefDictionary.tryGetValue(propertyDefinition.Uri, existingPropertyDefinition)) {
    //                        EwsLogging.Assert(
    //                            existingPropertyDefinition == propertyDefinition,
    //                            "Schema.allSchemaProperties.delegate",
    //                            StringHelper.Format("There are at least two distinct property definitions with the following URI: {0}", propertyDefinition.Uri));
    //                    }
    //                    else {
    //                        propDefDictionary.add(propertyDefinition.Uri, propertyDefinition);
    //
    //                        // The following is a "generic hack" to register properties that are not public and
    //                        // thus not returned by the above GetFields call. It is currently solely used to register
    //                        // the MeetingTimeZone property.
    //                        var associatedInternalProperties: PropertyDefinition[] = propertyDefinition.GetAssociatedInternalProperties();
    //
    //                        for (var associatedInternalProperty of associatedInternalProperties) {
    //                            //var associatedInternalProperty: PropertyDefinition = item;
    //                            propDefDictionary.add(associatedInternalProperty.Uri, associatedInternalProperty);
    //                        }
    //                    }
    //                }
    //            });
    //    }
    //    private static AddSchemaPropertyNamesToDictionary(type: string /*System.Type*/, propertyNameDictionary: PropDictionary<PropertyDefinition, string>  /*System.Collections.Generic.Dictionary<TKey, TValue>*/): void {
    //        ServiceObjectSchema.ForeachPublicStaticPropertyFieldInType(
    //            type,
    //            (propertyDefinition: PropertyDefinition, fieldName: string) =>
    //            { propertyNameDictionary.add(propertyDefinition, fieldName); });
    //    }
    /**
     * @internal Finds the property definition.
     *
     * @param   {string}   uri   The URI.
     * @return  {PropertyDefinitionBase}    Property definition.
     */
    ServiceObjectSchema.FindPropertyDefinition = function (uri) {
        return ServiceObjectSchema.allSchemaProperties.get(uri);
    };
    /**
     *  Returns an enumerator that iterates through the collection. this case this.visibleProperties
     */
    ServiceObjectSchema.prototype.GetEnumerator = function () {
        return this.visibleProperties;
    };
    ServiceObjectSchema.prototype.init = function () { };
    /**
     * @internal Registers an indexed property.
     *
     * @param   {IndexedPropertyDefinition}   indexedProperty   The indexed property to register.
     */
    ServiceObjectSchema.prototype.RegisterIndexedProperty = function (indexedProperty) { this.indexedProperties.push(indexedProperty); };
    /**
     * @internal Registers an internal schema property.
     *
     * @param   {any}                   registeringSchemaClass     SchemaClass calling this method - workaround for fieldUri registration oterhwise it registers super/parent class static properties as well. TypeScript does not provide a way to detect inherited property, hasOwnProperty returns true for parent static property
     * @param   {PropertyDefinition}   property   The property to register.
     */
    ServiceObjectSchema.prototype.RegisterInternalProperty = function (registeringSchemaClass, property) { this.RegisterProperty(registeringSchemaClass, property, true); };
    /**
     * @internal Registers properties.
     *
     * /remarks/ IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    ServiceObjectSchema.prototype.RegisterProperties = function () { };
    ServiceObjectSchema.prototype.RegisterProperty = function (registeringSchemaClass, property, isInternal) {
        if (isInternal === void 0) { isInternal = false; }
        this.properties.Add(property.XmlElementName, property);
        if (!StringHelper.IsNullOrEmpty(property.Uri) && registeringSchemaClass === this.constructor) {
            if (ServiceObjectSchema.allSchemaProperties.containsKey(property.Uri)) {
                EwsLogging.Assert(ServiceObjectSchema.allSchemaProperties.get(property.Uri) == property, "Schema.allSchemaProperties.delegate", StringHelper.Format("There are at least two distinct property definitions with the following URI: {0}", property.Uri));
            }
            else {
                ServiceObjectSchema.allSchemaProperties.Add(property.Uri, property);
            }
        }
        if (!isInternal) {
            this.visibleProperties.push(property);
        }
        // If this property does not have to be requested explicitly, add
        // it to the list of firstClassProperties.
        if (!property.HasFlag(PropertyDefinitionFlags.MustBeExplicitlyLoaded)) {
            this.firstClassProperties.push(property);
        }
        // If this property can be found, add it to the list of firstClassSummaryProperties
        if (property.HasFlag(PropertyDefinitionFlags.CanFind)) {
            this.firstClassSummaryProperties.push(property);
        }
    };
    /**
     * @internal Tries to get property definition.
     *
     * @param   {string}   xmlElementName           Name of the XML element.
     * @param   {IOutParam<PropertyDefinition>}     propertyDefinition   The property definition.
     * @return  {boolean}                           True if property definition exists.
     */
    ServiceObjectSchema.prototype.TryGetPropertyDefinition = function (xmlElementName, propertyDefinition) {
        return this.properties.tryGetValue(xmlElementName, propertyDefinition);
    };
    /**
     * Defines the **ExtendedProperties** property.
     */
    ServiceObjectSchema.ExtendedProperties = new ComplexPropertyDefinition("ExtendedProperties", XmlElementNames.ExtendedProperty, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.ReuseInstance | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate, ExchangeVersion.Exchange2007_SP1, function () { return new ExtendedPropertyCollection(); });
    ServiceObjectSchema.allSchemaProperties = new PropertyDefinitionDictionary(function (s) { return s; });
    return ServiceObjectSchema;
}());
exports.ServiceObjectSchema = ServiceObjectSchema;
Schemas.ServiceObjectSchema = ServiceObjectSchema;
/**
 * Field URIs for Conversation.
 */
var FieldUris;
(function (FieldUris) {
    FieldUris.ConversationId = "conversation:ConversationId";
    FieldUris.ConversationTopic = "conversation:ConversationTopic";
    FieldUris.UniqueRecipients = "conversation:UniqueRecipients";
    FieldUris.GlobalUniqueRecipients = "conversation:GlobalUniqueRecipients";
    FieldUris.UniqueUnreadSenders = "conversation:UniqueUnreadSenders";
    FieldUris.GlobalUniqueUnreadSenders = "conversation:GlobalUniqueUnreadSenders";
    FieldUris.UniqueSenders = "conversation:UniqueSenders";
    FieldUris.GlobalUniqueSenders = "conversation:GlobalUniqueSenders";
    FieldUris.LastDeliveryTime = "conversation:LastDeliveryTime";
    FieldUris.GlobalLastDeliveryTime = "conversation:GlobalLastDeliveryTime";
    FieldUris.Categories = "conversation:Categories";
    FieldUris.GlobalCategories = "conversation:GlobalCategories";
    FieldUris.FlagStatus = "conversation:FlagStatus";
    FieldUris.GlobalFlagStatus = "conversation:GlobalFlagStatus";
    FieldUris.HasAttachments = "conversation:HasAttachments";
    FieldUris.GlobalHasAttachments = "conversation:GlobalHasAttachments";
    FieldUris.MessageCount = "conversation:MessageCount";
    FieldUris.GlobalMessageCount = "conversation:GlobalMessageCount";
    FieldUris.UnreadCount = "conversation:UnreadCount";
    FieldUris.GlobalUnreadCount = "conversation:GlobalUnreadCount";
    FieldUris.Size = "conversation:Size";
    FieldUris.GlobalSize = "conversation:GlobalSize";
    FieldUris.ItemClasses = "conversation:ItemClasses";
    FieldUris.GlobalItemClasses = "conversation:GlobalItemClasses";
    FieldUris.Importance = "conversation:Importance";
    FieldUris.GlobalImportance = "conversation:GlobalImportance";
    FieldUris.ItemIds = "conversation:ItemIds";
    FieldUris.GlobalItemIds = "conversation:GlobalItemIds";
    FieldUris.LastModifiedTime = "conversation:LastModifiedTime";
    FieldUris.InstanceKey = "conversation:InstanceKey";
    FieldUris.Preview = "conversation:Preview";
    FieldUris.IconIndex = "conversation:IconIndex";
    FieldUris.GlobalIconIndex = "conversation:GlobalIconIndex";
    FieldUris.DraftItemIds = "conversation:DraftItemIds";
    FieldUris.HasIrm = "conversation:HasIrm";
    FieldUris.GlobalHasIrm = "conversation:GlobalHasIrm";
})(FieldUris || (FieldUris = {}));
/**
 * Represents the schema for Conversation.
 */
var ConversationSchema = (function (_super) {
    __extends(ConversationSchema, _super);
    function ConversationSchema() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Registers properties.
     *
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    ConversationSchema.prototype.RegisterProperties = function () {
        _super.prototype.RegisterProperties.call(this);
        this.RegisterProperty(ConversationSchema, ConversationSchema.Id);
        this.RegisterProperty(ConversationSchema, ConversationSchema.Topic);
        this.RegisterProperty(ConversationSchema, ConversationSchema.UniqueRecipients);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalUniqueRecipients);
        this.RegisterProperty(ConversationSchema, ConversationSchema.UniqueUnreadSenders);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalUniqueUnreadSenders);
        this.RegisterProperty(ConversationSchema, ConversationSchema.UniqueSenders);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalUniqueSenders);
        this.RegisterProperty(ConversationSchema, ConversationSchema.LastDeliveryTime);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalLastDeliveryTime);
        this.RegisterProperty(ConversationSchema, ConversationSchema.Categories);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalCategories);
        this.RegisterProperty(ConversationSchema, ConversationSchema.FlagStatus);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalFlagStatus);
        this.RegisterProperty(ConversationSchema, ConversationSchema.HasAttachments);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalHasAttachments);
        this.RegisterProperty(ConversationSchema, ConversationSchema.MessageCount);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalMessageCount);
        this.RegisterProperty(ConversationSchema, ConversationSchema.UnreadCount);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalUnreadCount);
        this.RegisterProperty(ConversationSchema, ConversationSchema.Size);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalSize);
        this.RegisterProperty(ConversationSchema, ConversationSchema.ItemClasses);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalItemClasses);
        this.RegisterProperty(ConversationSchema, ConversationSchema.Importance);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalImportance);
        this.RegisterProperty(ConversationSchema, ConversationSchema.ItemIds);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalItemIds);
        this.RegisterProperty(ConversationSchema, ConversationSchema.LastModifiedTime);
        this.RegisterProperty(ConversationSchema, ConversationSchema.InstanceKey);
        this.RegisterProperty(ConversationSchema, ConversationSchema.Preview);
        this.RegisterProperty(ConversationSchema, ConversationSchema.IconIndex);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalIconIndex);
        this.RegisterProperty(ConversationSchema, ConversationSchema.DraftItemIds);
        this.RegisterProperty(ConversationSchema, ConversationSchema.HasIrm);
        this.RegisterProperty(ConversationSchema, ConversationSchema.GlobalHasIrm);
    };
    /**
     * Defines the **Id** property.
     */
    ConversationSchema.Id = new ComplexPropertyDefinition("ConversationId", XmlElementNames.ConversationId, FieldUris.ConversationId, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, function () { return new ConversationId(); });
    /**
     * Defines the **Topic** property.
     */
    ConversationSchema.Topic = new StringPropertyDefinition("ConversationTopic", XmlElementNames.ConversationTopic, FieldUris.ConversationTopic, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1);
    /**
     * Defines the **UniqueRecipients** property.
     */
    ConversationSchema.UniqueRecipients = new ComplexPropertyDefinition("UniqueRecipients", XmlElementNames.UniqueRecipients, FieldUris.UniqueRecipients, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, function () { return new StringList(); });
    /**
     * Defines the **GlobalUniqueRecipients** property.
     */
    ConversationSchema.GlobalUniqueRecipients = new ComplexPropertyDefinition("GlobalUniqueRecipients", XmlElementNames.GlobalUniqueRecipients, FieldUris.GlobalUniqueRecipients, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, function () { return new StringList(); });
    /**
     * Defines the **UniqueUnreadSenders** property.
     */
    ConversationSchema.UniqueUnreadSenders = new ComplexPropertyDefinition("UniqueUnreadSenders", XmlElementNames.UniqueUnreadSenders, FieldUris.UniqueUnreadSenders, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, function () { return new StringList(); });
    /**
     * Defines the **GlobalUniqueUnreadSenders** property.
     */
    ConversationSchema.GlobalUniqueUnreadSenders = new ComplexPropertyDefinition("GlobalUniqueUnreadSenders", XmlElementNames.GlobalUniqueUnreadSenders, FieldUris.GlobalUniqueUnreadSenders, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, function () { return new StringList(); });
    /**
     * Defines the **UniqueSenders** property.
     */
    ConversationSchema.UniqueSenders = new ComplexPropertyDefinition("UniqueSenders", XmlElementNames.UniqueSenders, FieldUris.UniqueSenders, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, function () { return new StringList(); });
    /**
     * Defines the **GlobalUniqueSenders** property.
     */
    ConversationSchema.GlobalUniqueSenders = new ComplexPropertyDefinition("GlobalUniqueSenders", XmlElementNames.GlobalUniqueSenders, FieldUris.GlobalUniqueSenders, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, function () { return new StringList(); });
    /**
     * Defines the **LastDeliveryTime** property.
     */
    ConversationSchema.LastDeliveryTime = new DateTimePropertyDefinition("LastDeliveryTime", XmlElementNames.LastDeliveryTime, FieldUris.LastDeliveryTime, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1);
    /**
     * Defines the **GlobalLastDeliveryTime** property.
     */
    ConversationSchema.GlobalLastDeliveryTime = new DateTimePropertyDefinition("GlobalLastDeliveryTime", XmlElementNames.GlobalLastDeliveryTime, FieldUris.GlobalLastDeliveryTime, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1);
    /**
     * Defines the **Categories** property.
     */
    ConversationSchema.Categories = new ComplexPropertyDefinition("Categories", XmlElementNames.Categories, FieldUris.Categories, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, function () { return new StringList(); });
    /**
     * Defines the **GlobalCategories** property.
     */
    ConversationSchema.GlobalCategories = new ComplexPropertyDefinition("GlobalCategories", XmlElementNames.GlobalCategories, FieldUris.GlobalCategories, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, function () { return new StringList(); });
    /**
     * Defines the **FlagStatus** property.
     */
    ConversationSchema.FlagStatus = new GenericPropertyDefinition("FlagStatus", XmlElementNames.FlagStatus, FieldUris.FlagStatus, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, ConversationFlagStatus);
    /**
     * Defines the **GlobalFlagStatus** property.
     */
    ConversationSchema.GlobalFlagStatus = new GenericPropertyDefinition("GlobalFlagStatus", XmlElementNames.GlobalFlagStatus, FieldUris.GlobalFlagStatus, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, ConversationFlagStatus);
    /**
     * Defines the **HasAttachments** property.
     */
    ConversationSchema.HasAttachments = new BoolPropertyDefinition("HasAttachments", XmlElementNames.HasAttachments, FieldUris.HasAttachments, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1);
    /**
     * Defines the **GlobalHasAttachments** property.
     */
    ConversationSchema.GlobalHasAttachments = new BoolPropertyDefinition("GlobalHasAttachments", XmlElementNames.GlobalHasAttachments, FieldUris.GlobalHasAttachments, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1);
    /**
     * Defines the **MessageCount** property.
     */
    ConversationSchema.MessageCount = new IntPropertyDefinition("MessageCount", XmlElementNames.MessageCount, FieldUris.MessageCount, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1);
    /**
     * Defines the **GlobalMessageCount** property.
     */
    ConversationSchema.GlobalMessageCount = new IntPropertyDefinition("GlobalMessageCount", XmlElementNames.GlobalMessageCount, FieldUris.GlobalMessageCount, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1);
    /**
     * Defines the **UnreadCount** property.
     */
    ConversationSchema.UnreadCount = new IntPropertyDefinition("UnreadCount", XmlElementNames.UnreadCount, FieldUris.UnreadCount, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1);
    /**
     * Defines the **GlobalUnreadCount** property.
     */
    ConversationSchema.GlobalUnreadCount = new IntPropertyDefinition("GlobalUnreadCount", XmlElementNames.GlobalUnreadCount, FieldUris.GlobalUnreadCount, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1);
    /**
     * Defines the **Size** property.
     */
    ConversationSchema.Size = new IntPropertyDefinition("Size", XmlElementNames.Size, FieldUris.Size, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1);
    /**
     * Defines the **GlobalSize** property.
     */
    ConversationSchema.GlobalSize = new IntPropertyDefinition("GlobalSize", XmlElementNames.GlobalSize, FieldUris.GlobalSize, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1);
    /**
     * Defines the **ItemClasses** property.
     */
    ConversationSchema.ItemClasses = new ComplexPropertyDefinition("ItemClasses", XmlElementNames.ItemClasses, FieldUris.ItemClasses, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, function () { return new StringList("ItemClass"); });
    /**
     * Defines the **GlobalItemClasses** property.
     */
    ConversationSchema.GlobalItemClasses = new ComplexPropertyDefinition("GlobalItemClasses", XmlElementNames.GlobalItemClasses, FieldUris.GlobalItemClasses, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, function () { return new StringList("ItemClass"); });
    /**
     * Defines the **Importance** property.
     */
    ConversationSchema.Importance = new GenericPropertyDefinition("Importance", XmlElementNames.Importance, FieldUris.Importance, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, Importance);
    /**
     * Defines the **GlobalImportance** property.
     */
    ConversationSchema.GlobalImportance = new GenericPropertyDefinition("GlobalImportance", XmlElementNames.GlobalImportance, FieldUris.GlobalImportance, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, Importance);
    /**
     * Defines the **ItemIds** property.
     */
    ConversationSchema.ItemIds = new ComplexPropertyDefinition("ItemIds", XmlElementNames.ItemIds, FieldUris.ItemIds, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, function () { return new ItemIdCollection(); });
    /**
     * Defines the **GlobalItemIds** property.
     */
    ConversationSchema.GlobalItemIds = new ComplexPropertyDefinition("GlobalItemIds", XmlElementNames.GlobalItemIds, FieldUris.GlobalItemIds, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, function () { return new ItemIdCollection(); });
    /**
     * Defines the **LastModifiedTime** property.
     */
    ConversationSchema.LastModifiedTime = new DateTimePropertyDefinition("LastModifiedTime", XmlElementNames.LastModifiedTime, FieldUris.LastModifiedTime, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013);
    /**
     * Defines the **InstanceKey** property.
     */
    ConversationSchema.InstanceKey = new ByteArrayPropertyDefinition("InstanceKey", XmlElementNames.InstanceKey, FieldUris.InstanceKey, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013);
    /**
     * Defines the **Preview** property.
     */
    ConversationSchema.Preview = new StringPropertyDefinition("Preview", XmlElementNames.Preview, FieldUris.Preview, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013);
    /**
     * Defines the **IconIndex** property.
     */
    ConversationSchema.IconIndex = new GenericPropertyDefinition("IconIndex", XmlElementNames.IconIndex, FieldUris.IconIndex, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013, IconIndex);
    /**
     * Defines the **GlobalIconIndex** property.
     */
    ConversationSchema.GlobalIconIndex = new GenericPropertyDefinition("GlobalIconIndex", XmlElementNames.GlobalIconIndex, FieldUris.GlobalIconIndex, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013, IconIndex);
    /**
     * Defines the **DraftItemIds** property.
     */
    ConversationSchema.DraftItemIds = new ComplexPropertyDefinition("DraftItemIds", XmlElementNames.DraftItemIds, FieldUris.DraftItemIds, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013, function () { return new ItemIdCollection(); });
    /**
     * Defines the **HasIrm** property.
     */
    ConversationSchema.HasIrm = new BoolPropertyDefinition("HasIrm", XmlElementNames.HasIrm, FieldUris.HasIrm, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013);
    /**
     * Defines the **GlobalHasIrm** property.
     */
    ConversationSchema.GlobalHasIrm = new BoolPropertyDefinition("GlobalHasIrm", XmlElementNames.GlobalHasIrm, FieldUris.GlobalHasIrm, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013);
    /**
     * @internal Instance of **ConversationSchema**
     */
    ConversationSchema.Instance = new ConversationSchema();
    return ConversationSchema;
}(ServiceObjectSchema));
exports.ConversationSchema = ConversationSchema;
Schemas.ConversationSchema = ConversationSchema;
/**
 * Field URIs for folders.
 */
(function (FieldUris) {
    FieldUris.FolderId = "folder:FolderId";
    FieldUris.ParentFolderId = "folder:ParentFolderId";
    FieldUris.DisplayName = "folder:DisplayName";
    FieldUris.UnreadCount = "folder:UnreadCount";
    FieldUris.TotalCount = "folder:TotalCount";
    FieldUris.ChildFolderCount = "folder:ChildFolderCount";
    FieldUris.FolderClass = "folder:FolderClass";
    FieldUris.ManagedFolderInformation = "folder:ManagedFolderInformation";
    FieldUris.EffectiveRights = "folder:EffectiveRights";
    FieldUris.PermissionSet = "folder:PermissionSet";
    FieldUris.PolicyTag = "folder:PolicyTag";
    FieldUris.ArchiveTag = "folder:ArchiveTag";
    FieldUris.DistinguishedFolderId = "folder:DistinguishedFolderId";
})(FieldUris || (FieldUris = {}));
/**
 * Represents the schema for folders.
 */
var FolderSchema = (function (_super) {
    __extends(FolderSchema, _super);
    function FolderSchema() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Registers properties.
     *
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    FolderSchema.prototype.RegisterProperties = function () {
        _super.prototype.RegisterProperties.call(this);
        this.RegisterProperty(FolderSchema, FolderSchema.Id);
        this.RegisterProperty(FolderSchema, FolderSchema.ParentFolderId);
        this.RegisterProperty(FolderSchema, FolderSchema.FolderClass);
        this.RegisterProperty(FolderSchema, FolderSchema.DisplayName);
        this.RegisterProperty(FolderSchema, FolderSchema.TotalCount);
        this.RegisterProperty(FolderSchema, FolderSchema.ChildFolderCount);
        this.RegisterProperty(FolderSchema, ServiceObjectSchema.ExtendedProperties);
        this.RegisterProperty(FolderSchema, FolderSchema.ManagedFolderInformation);
        this.RegisterProperty(FolderSchema, FolderSchema.EffectiveRights);
        this.RegisterProperty(FolderSchema, FolderSchema.Permissions);
        this.RegisterProperty(FolderSchema, FolderSchema.UnreadCount);
        this.RegisterProperty(FolderSchema, FolderSchema.WellKnownFolderName);
        this.RegisterProperty(FolderSchema, FolderSchema.PolicyTag);
        this.RegisterProperty(FolderSchema, FolderSchema.ArchiveTag);
    };
    /**
     * Defines the **Id** property.
     */
    FolderSchema.Id = new ComplexPropertyDefinition("Id", XmlElementNames.FolderId, FieldUris.FolderId, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, function () { return new FolderId(); });
    /**
     * Defines the **FolderClass** property.
     */
    FolderSchema.FolderClass = new StringPropertyDefinition("FolderClass", XmlElementNames.FolderClass, FieldUris.FolderClass, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **ParentFolderId** property.
     */
    FolderSchema.ParentFolderId = new ComplexPropertyDefinition("ParentFolderId", XmlElementNames.ParentFolderId, FieldUris.ParentFolderId, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, function () { return new FolderId(); });
    /**
     * Defines the **ChildFolderCount** property.
     */
    FolderSchema.ChildFolderCount = new IntPropertyDefinition("ChildFolderCount", XmlElementNames.ChildFolderCount, FieldUris.ChildFolderCount, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **DisplayName** property.
     */
    FolderSchema.DisplayName = new StringPropertyDefinition("DisplayName", XmlElementNames.DisplayName, FieldUris.DisplayName, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **UnreadCount** property.
     */
    FolderSchema.UnreadCount = new IntPropertyDefinition("UnreadCount", XmlElementNames.UnreadCount, FieldUris.UnreadCount, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **TotalCount** property.
     */
    FolderSchema.TotalCount = new IntPropertyDefinition("TotalCount", XmlElementNames.TotalCount, FieldUris.TotalCount, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **ManagedFolderInformation** property.
     */
    FolderSchema.ManagedFolderInformation = new ComplexPropertyDefinition("ManagedFolderInformation", XmlElementNames.ManagedFolderInformation, FieldUris.ManagedFolderInformation, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, function () { return new ManagedFolderInformation(); });
    /**
     * Defines the **EffectiveRights** property.
     */
    FolderSchema.EffectiveRights = new EffectiveRightsPropertyDefinition("EffectiveRights", XmlElementNames.EffectiveRights, FieldUris.EffectiveRights, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **Permissions** property.
     */
    FolderSchema.Permissions = new PermissionSetPropertyDefinition("Permissions", XmlElementNames.PermissionSet, FieldUris.PermissionSet, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.MustBeExplicitlyLoaded, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **WellKnownFolderName** property.
     */
    FolderSchema.WellKnownFolderName = new GenericPropertyDefinition("WellKnownFolderName", XmlElementNames.DistinguishedFolderId, FieldUris.DistinguishedFolderId, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013, WellKnownFolderName);
    /**
     * Defines the **PolicyTag** property.
     */
    FolderSchema.PolicyTag = new ComplexPropertyDefinition("PolicyTag", XmlElementNames.PolicyTag, FieldUris.PolicyTag, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013, function () { return new PolicyTag(); });
    /**
     * Defines the **ArchiveTag** property.
     */
    FolderSchema.ArchiveTag = new ComplexPropertyDefinition("ArchiveTag", XmlElementNames.ArchiveTag, FieldUris.ArchiveTag, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013, function () { return new ArchiveTag(); });
    /**
     * @internal Instance of **FolderSchema**
     */
    FolderSchema.Instance = new FolderSchema();
    return FolderSchema;
}(ServiceObjectSchema));
exports.FolderSchema = FolderSchema;
Schemas.FolderSchema = FolderSchema;
/**
 * Field URIs for search folders.
 */
(function (FieldUris) {
    FieldUris.SearchParameters = "folder:SearchParameters";
})(FieldUris || (FieldUris = {}));
/**
 * Represents the schema for search folders.
 */
var SearchFolderSchema = (function (_super) {
    __extends(SearchFolderSchema, _super);
    function SearchFolderSchema() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Registers properties.
     *
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    SearchFolderSchema.prototype.RegisterProperties = function () {
        _super.prototype.RegisterProperties.call(this);
        this.RegisterProperty(SearchFolderSchema, SearchFolderSchema.SearchParameters);
    };
    /**
     * Defines the **SearchParameters** property.
     */
    SearchFolderSchema.SearchParameters = new ComplexPropertyDefinition("SearchParameters", XmlElementNames.SearchParameters, FieldUris.SearchParameters, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate, ExchangeVersion.Exchange2007_SP1, function () { return new SearchFolderParameters(); });
    /**
     * @internal Instance of **SearchFolderSchema**
     */
    SearchFolderSchema.Instance = new SearchFolderSchema();
    return SearchFolderSchema;
}(FolderSchema));
exports.SearchFolderSchema = SearchFolderSchema;
Schemas.SearchFolderSchema = SearchFolderSchema;
/**
 * Field URIs for Item.
 */
(function (FieldUris) {
    FieldUris.ArchiveTag = "item:ArchiveTag";
    FieldUris.Attachments = "item:Attachments";
    FieldUris.Body = "item:Body";
    FieldUris.Categories = "item:Categories";
    FieldUris.ConversationId = "item:ConversationId";
    FieldUris.Culture = "item:Culture";
    FieldUris.DateTimeCreated = "item:DateTimeCreated";
    FieldUris.DateTimeReceived = "item:DateTimeReceived";
    FieldUris.DateTimeSent = "item:DateTimeSent";
    FieldUris.DisplayCc = "item:DisplayCc";
    FieldUris.DisplayTo = "item:DisplayTo";
    FieldUris.EffectiveRights = "item:EffectiveRights";
    FieldUris.EntityExtractionResult = "item:EntityExtractionResult";
    FieldUris.Flag = "item:Flag";
    FieldUris.HasAttachments = "item:HasAttachments";
    FieldUris.IconIndex = "item:IconIndex";
    FieldUris.Importance = "item:Importance";
    FieldUris.InReplyTo = "item:InReplyTo";
    FieldUris.InstanceKey = "item:InstanceKey";
    FieldUris.InternetMessageHeaders = "item:InternetMessageHeaders";
    FieldUris.IsAssociated = "item:IsAssociated";
    FieldUris.IsDraft = "item:IsDraft";
    FieldUris.IsFromMe = "item:IsFromMe";
    FieldUris.IsResend = "item:IsResend";
    FieldUris.IsSubmitted = "item:IsSubmitted";
    FieldUris.IsUnmodified = "item:IsUnmodified";
    FieldUris.ItemClass = "item:ItemClass";
    FieldUris.ItemId = "item:ItemId";
    FieldUris.LastModifiedName = "item:LastModifiedName";
    FieldUris.LastModifiedTime = "item:LastModifiedTime";
    FieldUris.MimeContent = "item:MimeContent";
    FieldUris.NormalizedBody = "item:NormalizedBody";
    FieldUris.ParentFolderId = "item:ParentFolderId";
    FieldUris.PolicyTag = "item:PolicyTag";
    FieldUris.Preview = "item:Preview";
    FieldUris.ReminderDueBy = "item:ReminderDueBy";
    FieldUris.ReminderIsSet = "item:ReminderIsSet";
    FieldUris.ReminderMinutesBeforeStart = "item:ReminderMinutesBeforeStart";
    FieldUris.ResponseObjects = "item:ResponseObjects";
    FieldUris.RetentionDate = "item:RetentionDate";
    FieldUris.Sensitivity = "item:Sensitivity";
    FieldUris.Size = "item:Size";
    FieldUris.StoreEntryId = "item:StoreEntryId";
    FieldUris.Subject = "item:Subject";
    FieldUris.TextBody = "item:TextBody";
    FieldUris.UniqueBody = "item:UniqueBody";
    FieldUris.WebClientEditFormQueryString = "item:WebClientEditFormQueryString";
    FieldUris.WebClientReadFormQueryString = "item:WebClientReadFormQueryString";
})(FieldUris || (FieldUris = {}));
/**
 * Represents the schema for generic items.
 */
var ItemSchema = (function (_super) {
    __extends(ItemSchema, _super);
    function ItemSchema() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Registers properties.
     *
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    ItemSchema.prototype.RegisterProperties = function () {
        _super.prototype.RegisterProperties.call(this);
        this.RegisterProperty(ItemSchema, ItemSchema.MimeContent);
        this.RegisterProperty(ItemSchema, ItemSchema.Id);
        this.RegisterProperty(ItemSchema, ItemSchema.ParentFolderId);
        this.RegisterProperty(ItemSchema, ItemSchema.ItemClass);
        this.RegisterProperty(ItemSchema, ItemSchema.Subject);
        this.RegisterProperty(ItemSchema, ItemSchema.Sensitivity);
        this.RegisterProperty(ItemSchema, ItemSchema.Body);
        this.RegisterProperty(ItemSchema, ItemSchema.Attachments);
        this.RegisterProperty(ItemSchema, ItemSchema.DateTimeReceived);
        this.RegisterProperty(ItemSchema, ItemSchema.Size);
        this.RegisterProperty(ItemSchema, ItemSchema.Categories);
        this.RegisterProperty(ItemSchema, ItemSchema.Importance);
        this.RegisterProperty(ItemSchema, ItemSchema.InReplyTo);
        this.RegisterProperty(ItemSchema, ItemSchema.IsSubmitted);
        this.RegisterProperty(ItemSchema, ItemSchema.IsDraft);
        this.RegisterProperty(ItemSchema, ItemSchema.IsFromMe);
        this.RegisterProperty(ItemSchema, ItemSchema.IsResend);
        this.RegisterProperty(ItemSchema, ItemSchema.IsUnmodified);
        this.RegisterProperty(ItemSchema, ItemSchema.InternetMessageHeaders);
        this.RegisterProperty(ItemSchema, ItemSchema.DateTimeSent);
        this.RegisterProperty(ItemSchema, ItemSchema.DateTimeCreated);
        this.RegisterProperty(ItemSchema, ItemSchema.AllowedResponseActions);
        this.RegisterProperty(ItemSchema, ItemSchema.ReminderDueBy);
        this.RegisterProperty(ItemSchema, ItemSchema.IsReminderSet);
        this.RegisterProperty(ItemSchema, ItemSchema.ReminderMinutesBeforeStart);
        this.RegisterProperty(ItemSchema, ItemSchema.DisplayCc);
        this.RegisterProperty(ItemSchema, ItemSchema.DisplayTo);
        this.RegisterProperty(ItemSchema, ItemSchema.HasAttachments);
        this.RegisterProperty(ItemSchema, ServiceObjectSchema.ExtendedProperties);
        this.RegisterProperty(ItemSchema, ItemSchema.Culture);
        this.RegisterProperty(ItemSchema, ItemSchema.EffectiveRights);
        this.RegisterProperty(ItemSchema, ItemSchema.LastModifiedName);
        this.RegisterProperty(ItemSchema, ItemSchema.LastModifiedTime);
        this.RegisterProperty(ItemSchema, ItemSchema.IsAssociated);
        this.RegisterProperty(ItemSchema, ItemSchema.WebClientReadFormQueryString);
        this.RegisterProperty(ItemSchema, ItemSchema.WebClientEditFormQueryString);
        this.RegisterProperty(ItemSchema, ItemSchema.ConversationId);
        this.RegisterProperty(ItemSchema, ItemSchema.UniqueBody);
        this.RegisterProperty(ItemSchema, ItemSchema.Flag);
        this.RegisterProperty(ItemSchema, ItemSchema.StoreEntryId);
        this.RegisterProperty(ItemSchema, ItemSchema.InstanceKey);
        this.RegisterProperty(ItemSchema, ItemSchema.NormalizedBody);
        this.RegisterProperty(ItemSchema, ItemSchema.EntityExtractionResult);
        this.RegisterProperty(ItemSchema, ItemSchema.PolicyTag);
        this.RegisterProperty(ItemSchema, ItemSchema.ArchiveTag);
        this.RegisterProperty(ItemSchema, ItemSchema.RetentionDate);
        this.RegisterProperty(ItemSchema, ItemSchema.Preview);
        this.RegisterProperty(ItemSchema, ItemSchema.TextBody);
        this.RegisterProperty(ItemSchema, ItemSchema.IconIndex);
    };
    /**
     * Defines the **Id** property.
     */
    ItemSchema.Id = new ComplexPropertyDefinition("Id", XmlElementNames.ItemId, FieldUris.ItemId, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, function () { return new ItemId(); });
    /**
     * Defines the **Body** property.
     */
    ItemSchema.Body = new ComplexPropertyDefinition("Body", XmlElementNames.Body, FieldUris.Body, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete, ExchangeVersion.Exchange2007_SP1, function () { return new MessageBody(); });
    /**
     * Defines the **ItemClass** property.
     */
    ItemSchema.ItemClass = new StringPropertyDefinition("ItemClass", XmlElementNames.ItemClass, FieldUris.ItemClass, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **Subject** property.
     */
    ItemSchema.Subject = new StringPropertyDefinition("Subject", XmlElementNames.Subject, FieldUris.Subject, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **MimeContent** property.
     */
    ItemSchema.MimeContent = new ComplexPropertyDefinition("MimeContent", XmlElementNames.MimeContent, FieldUris.MimeContent, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.MustBeExplicitlyLoaded, ExchangeVersion.Exchange2007_SP1, function () { return new MimeContent(); });
    /**
     * Defines the **ParentFolderId** property.
     */
    ItemSchema.ParentFolderId = new ComplexPropertyDefinition("ParentFolderId", XmlElementNames.ParentFolderId, FieldUris.ParentFolderId, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, function () { return new FolderId(); });
    /**
     * Defines the **Sensitivity** property.
     */
    ItemSchema.Sensitivity = new GenericPropertyDefinition("Sensitivity", XmlElementNames.Sensitivity, FieldUris.Sensitivity, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, Sensitivity);
    /**
     * Defines the **Attachments** property.
     */
    ItemSchema.Attachments = new AttachmentsPropertyDefinition("Attachments");
    /**
     * Defines the **DateTimeReceived** property.
     */
    ItemSchema.DateTimeReceived = new DateTimePropertyDefinition("DateTimeReceived", XmlElementNames.DateTimeReceived, FieldUris.DateTimeReceived, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **Size** property.
     */
    ItemSchema.Size = new IntPropertyDefinition("Size", XmlElementNames.Size, FieldUris.Size, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **Categories** property.
     */
    ItemSchema.Categories = new ComplexPropertyDefinition("Categories", XmlElementNames.Categories, FieldUris.Categories, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, function () { return new StringList(); });
    /**
     * Defines the **Importance** property.
     */
    ItemSchema.Importance = new GenericPropertyDefinition("Importance", XmlElementNames.Importance, FieldUris.Importance, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, Importance);
    /**
     * Defines the **InReplyTo** property.
     */
    ItemSchema.InReplyTo = new StringPropertyDefinition("InReplyTo", XmlElementNames.InReplyTo, FieldUris.InReplyTo, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **IsSubmitted** property.
     */
    ItemSchema.IsSubmitted = new BoolPropertyDefinition("IsSubmitted", XmlElementNames.IsSubmitted, FieldUris.IsSubmitted, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **IsAssociated** property.
     */
    ItemSchema.IsAssociated = new BoolPropertyDefinition("IsAssociated", XmlElementNames.IsAssociated, FieldUris.IsAssociated, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010);
    /**
     * Defines the **IsDraft** property.
     */
    ItemSchema.IsDraft = new BoolPropertyDefinition("IsDraft", XmlElementNames.IsDraft, FieldUris.IsDraft, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **IsFromMe** property.
     */
    ItemSchema.IsFromMe = new BoolPropertyDefinition("IsFromMe", XmlElementNames.IsFromMe, FieldUris.IsFromMe, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **IsResend** property.
     */
    ItemSchema.IsResend = new BoolPropertyDefinition("IsResend", XmlElementNames.IsResend, FieldUris.IsResend, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **IsUnmodified** property.
     */
    ItemSchema.IsUnmodified = new BoolPropertyDefinition("IsUnmodified", XmlElementNames.IsUnmodified, FieldUris.IsUnmodified, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **InternetMessageHeaders** property.
     */
    ItemSchema.InternetMessageHeaders = new ComplexPropertyDefinition("InternetMessageHeaders", XmlElementNames.InternetMessageHeaders, FieldUris.InternetMessageHeaders, PropertyDefinitionFlags.None, ExchangeVersion.Exchange2007_SP1, function () { return new InternetMessageHeaderCollection(); });
    /**
     * Defines the **DateTimeSent** property.
     */
    ItemSchema.DateTimeSent = new DateTimePropertyDefinition("DateTimeSent", XmlElementNames.DateTimeSent, FieldUris.DateTimeSent, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **DateTimeCreated** property.
     */
    ItemSchema.DateTimeCreated = new DateTimePropertyDefinition("DateTimeCreated", XmlElementNames.DateTimeCreated, FieldUris.DateTimeCreated, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **AllowedResponseActions** property.
     */
    ItemSchema.AllowedResponseActions = new ResponseObjectsPropertyDefinition("ResponseObjects", XmlElementNames.ResponseObjects, FieldUris.ResponseObjects, PropertyDefinitionFlags.None, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **ReminderDueBy** property.
     */
    ItemSchema.ReminderDueBy = new ScopedDateTimePropertyDefinition("ReminderDueBy", XmlElementNames.ReminderDueBy, FieldUris.ReminderDueBy, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, function (version) { debugger; return Schemas.AppointmentSchema.StartTimeZone; });
    /**
     * Defines the **IsReminderSet** property.
     */
    ItemSchema.IsReminderSet = new BoolPropertyDefinition("ReminderIsSet", XmlElementNames.ReminderIsSet, FieldUris.ReminderIsSet, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **ReminderMinutesBeforeStart** property.
     */
    ItemSchema.ReminderMinutesBeforeStart = new IntPropertyDefinition("ReminderMinutesBeforeStart", XmlElementNames.ReminderMinutesBeforeStart, FieldUris.ReminderMinutesBeforeStart, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **DisplayCc** property.
     */
    ItemSchema.DisplayCc = new StringPropertyDefinition("DisplayCc", XmlElementNames.DisplayCc, FieldUris.DisplayCc, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **DisplayTo** property.
     */
    ItemSchema.DisplayTo = new StringPropertyDefinition("DisplayTo", XmlElementNames.DisplayTo, FieldUris.DisplayTo, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **HasAttachments** property.
     */
    ItemSchema.HasAttachments = new BoolPropertyDefinition("HasAttachments", XmlElementNames.HasAttachments, FieldUris.HasAttachments, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **Culture** property.
     */
    ItemSchema.Culture = new StringPropertyDefinition("Culture", XmlElementNames.Culture, FieldUris.Culture, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **EffectiveRights** property.
     */
    ItemSchema.EffectiveRights = new EffectiveRightsPropertyDefinition("EffectiveRights", XmlElementNames.EffectiveRights, FieldUris.EffectiveRights, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **LastModifiedName** property.
     */
    ItemSchema.LastModifiedName = new StringPropertyDefinition("LastModifiedName", XmlElementNames.LastModifiedName, FieldUris.LastModifiedName, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **LastModifiedTime** property.
     */
    ItemSchema.LastModifiedTime = new DateTimePropertyDefinition("LastModifiedTime", XmlElementNames.LastModifiedTime, FieldUris.LastModifiedTime, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **WebClientReadFormQueryString** property.
     */
    ItemSchema.WebClientReadFormQueryString = new StringPropertyDefinition("WebClientReadFormQueryString", XmlElementNames.WebClientReadFormQueryString, FieldUris.WebClientReadFormQueryString, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010);
    /**
     * Defines the **WebClientEditFormQueryString** property.
     */
    ItemSchema.WebClientEditFormQueryString = new StringPropertyDefinition("WebClientEditFormQueryString", XmlElementNames.WebClientEditFormQueryString, FieldUris.WebClientEditFormQueryString, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010);
    /**
     * Defines the **ConversationId** property.
     */
    ItemSchema.ConversationId = new ComplexPropertyDefinition("ConversationId", XmlElementNames.ConversationId, FieldUris.ConversationId, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010, function () { return new ConversationId(); });
    /**
     * Defines the **UniqueBody** property.
     */
    ItemSchema.UniqueBody = new ComplexPropertyDefinition("UniqueBody", XmlElementNames.UniqueBody, FieldUris.UniqueBody, PropertyDefinitionFlags.MustBeExplicitlyLoaded, ExchangeVersion.Exchange2010, function () { return new UniqueBody(); });
    /**
     * Defines the **StoreEntryId** property.
     */
    ItemSchema.StoreEntryId = new ByteArrayPropertyDefinition("StoreEntryId", XmlElementNames.StoreEntryId, FieldUris.StoreEntryId, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP2);
    /**
     * Defines the **InstanceKey** property.
     */
    ItemSchema.InstanceKey = new ByteArrayPropertyDefinition("InstanceKey", XmlElementNames.InstanceKey, FieldUris.InstanceKey, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013);
    /**
     * Defines the **NormalizedBody** property.
     */
    ItemSchema.NormalizedBody = new ComplexPropertyDefinition("NormalizedBody", XmlElementNames.NormalizedBody, FieldUris.NormalizedBody, PropertyDefinitionFlags.MustBeExplicitlyLoaded, ExchangeVersion.Exchange2013, function () { return new NormalizedBody(); });
    /**
     * Defines the **EntityExtractionResult** property.
     */
    ItemSchema.EntityExtractionResult = new ComplexPropertyDefinition("EntityExtractionResult", XmlElementNames.NlgEntityExtractionResult, FieldUris.EntityExtractionResult, PropertyDefinitionFlags.MustBeExplicitlyLoaded, ExchangeVersion.Exchange2013, function () { return new EntityExtractionResult(); });
    /**
     * Defines the **Flag** property.
     */
    ItemSchema.Flag = new ComplexPropertyDefinition("Flag", XmlElementNames.Flag, FieldUris.Flag, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013, function () { return new Flag(); });
    /**
     * Defines the **PolicyTag** property.
     */
    ItemSchema.PolicyTag = new ComplexPropertyDefinition("PolicyTag", XmlElementNames.PolicyTag, FieldUris.PolicyTag, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013, function () { return new PolicyTag(); });
    /**
     * Defines the **ArchiveTag** property.
     */
    ItemSchema.ArchiveTag = new ComplexPropertyDefinition("ArchiveTag", XmlElementNames.ArchiveTag, FieldUris.ArchiveTag, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013, function () { return new ArchiveTag(); });
    /**
     * Defines the **RetentionDate** property.
     */
    ItemSchema.RetentionDate = new DateTimePropertyDefinition("RetentionDate", XmlElementNames.RetentionDate, FieldUris.RetentionDate, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013, true);
    /**
     * Defines the **Preview** property.
     */
    ItemSchema.Preview = new StringPropertyDefinition("Preview", XmlElementNames.Preview, FieldUris.Preview, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013);
    /**
     * Defines the **TextBody** property.
     */
    ItemSchema.TextBody = new ComplexPropertyDefinition("TextBody", XmlElementNames.TextBody, FieldUris.TextBody, PropertyDefinitionFlags.MustBeExplicitlyLoaded, ExchangeVersion.Exchange2013, function () { return new TextBody(); });
    /**
     * Defines the **IconIndex** property.
     */
    ItemSchema.IconIndex = new GenericPropertyDefinition("IconIndex", XmlElementNames.IconIndex, FieldUris.IconIndex, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013, IconIndex);
    /**
     * @internal Instance of **ItemSchema**
     */
    ItemSchema.Instance = new ItemSchema();
    return ItemSchema;
}(ServiceObjectSchema));
exports.ItemSchema = ItemSchema;
Schemas.ItemSchema = ItemSchema;
/**
 * Field URIs for Appointment.
 */
(function (FieldUris) {
    FieldUris.Start = "calendar:Start";
    FieldUris.End = "calendar:End";
    FieldUris.OriginalStart = "calendar:OriginalStart";
    FieldUris.IsAllDayEvent = "calendar:IsAllDayEvent";
    FieldUris.LegacyFreeBusyStatus = "calendar:LegacyFreeBusyStatus";
    FieldUris.Location = "calendar:Location";
    FieldUris.When = "calendar:When";
    FieldUris.IsMeeting = "calendar:IsMeeting";
    FieldUris.IsCancelled = "calendar:IsCancelled";
    FieldUris.IsRecurring = "calendar:IsRecurring";
    FieldUris.MeetingRequestWasSent = "calendar:MeetingRequestWasSent";
    FieldUris.IsResponseRequested = "calendar:IsResponseRequested";
    FieldUris.CalendarItemType = "calendar:CalendarItemType";
    FieldUris.MyResponseType = "calendar:MyResponseType";
    FieldUris.Organizer = "calendar:Organizer";
    FieldUris.RequiredAttendees = "calendar:RequiredAttendees";
    FieldUris.OptionalAttendees = "calendar:OptionalAttendees";
    FieldUris.Resources = "calendar:Resources";
    FieldUris.ConflictingMeetingCount = "calendar:ConflictingMeetingCount";
    FieldUris.AdjacentMeetingCount = "calendar:AdjacentMeetingCount";
    FieldUris.ConflictingMeetings = "calendar:ConflictingMeetings";
    FieldUris.AdjacentMeetings = "calendar:AdjacentMeetings";
    FieldUris.Duration = "calendar:Duration";
    FieldUris.TimeZone = "calendar:TimeZone";
    FieldUris.AppointmentReplyTime = "calendar:AppointmentReplyTime";
    FieldUris.AppointmentSequenceNumber = "calendar:AppointmentSequenceNumber";
    FieldUris.AppointmentState = "calendar:AppointmentState";
    FieldUris.Recurrence = "calendar:Recurrence";
    FieldUris.FirstOccurrence = "calendar:FirstOccurrence";
    FieldUris.LastOccurrence = "calendar:LastOccurrence";
    FieldUris.ModifiedOccurrences = "calendar:ModifiedOccurrences";
    FieldUris.DeletedOccurrences = "calendar:DeletedOccurrences";
    FieldUris.MeetingTimeZone = "calendar:MeetingTimeZone";
    FieldUris.StartTimeZone = "calendar:StartTimeZone";
    FieldUris.EndTimeZone = "calendar:EndTimeZone";
    FieldUris.ConferenceType = "calendar:ConferenceType";
    FieldUris.AllowNewTimeProposal = "calendar:AllowNewTimeProposal";
    FieldUris.IsOnlineMeeting = "calendar:IsOnlineMeeting";
    FieldUris.MeetingWorkspaceUrl = "calendar:MeetingWorkspaceUrl";
    FieldUris.NetShowUrl = "calendar:NetShowUrl";
    FieldUris.Uid = "calendar:UID";
    FieldUris.RecurrenceId = "calendar:RecurrenceId";
    FieldUris.DateTimeStamp = "calendar:DateTimeStamp";
    FieldUris.EnhancedLocation = "calendar:EnhancedLocation";
    FieldUris.JoinOnlineMeetingUrl = "calendar:JoinOnlineMeetingUrl";
    FieldUris.OnlineMeetingSettings = "calendar:OnlineMeetingSettings";
})(FieldUris || (FieldUris = {}));
/**
 * Represents the schema for appointment and meeting requests.
 */
var AppointmentSchema = (function (_super) {
    __extends(AppointmentSchema, _super);
    function AppointmentSchema() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Registers properties.
     *
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    AppointmentSchema.prototype.RegisterProperties = function () {
        _super.prototype.RegisterProperties.call(this);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.ICalUid);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.ICalRecurrenceId);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.ICalDateTimeStamp);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.Start);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.End);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.OriginalStart);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.IsAllDayEvent);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.LegacyFreeBusyStatus);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.Location);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.When);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.IsMeeting);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.IsCancelled);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.IsRecurring);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.MeetingRequestWasSent);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.IsResponseRequested);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.AppointmentType);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.MyResponseType);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.Organizer);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.RequiredAttendees);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.OptionalAttendees);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.Resources);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.ConflictingMeetingCount);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.AdjacentMeetingCount);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.ConflictingMeetings);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.AdjacentMeetings);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.Duration);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.TimeZone);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.AppointmentReplyTime);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.AppointmentSequenceNumber);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.AppointmentState);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.Recurrence);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.FirstOccurrence);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.LastOccurrence);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.ModifiedOccurrences);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.DeletedOccurrences);
        this.RegisterInternalProperty(AppointmentSchema, AppointmentSchema.MeetingTimeZone);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.StartTimeZone);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.EndTimeZone);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.ConferenceType);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.AllowNewTimeProposal);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.IsOnlineMeeting);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.MeetingWorkspaceUrl);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.NetShowUrl);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.EnhancedLocation);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.JoinOnlineMeetingUrl);
        this.RegisterProperty(AppointmentSchema, AppointmentSchema.OnlineMeetingSettings);
    };
    /**
     * Defines the **StartTimeZone** property.
     */
    AppointmentSchema.StartTimeZone = new StartTimeZonePropertyDefinition("StartTimeZone", XmlElementNames.StartTimeZone, FieldUris.StartTimeZone, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **EndTimeZone** property.
     */
    AppointmentSchema.EndTimeZone = new TimeZonePropertyDefinition("EndTimeZone", XmlElementNames.EndTimeZone, FieldUris.EndTimeZone, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010);
    /**
     * Defines the **Start** property.
     */
    AppointmentSchema.Start = new ScopedDateTimePropertyDefinition("Start", XmlElementNames.Start, FieldUris.Start, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, function (version) { return AppointmentSchema.StartTimeZone; });
    /**
     * Defines the **End** property.
     */
    AppointmentSchema.End = new ScopedDateTimePropertyDefinition("End", XmlElementNames.End, FieldUris.End, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, function (version) {
        if (version !== ExchangeVersion.Exchange2007_SP1) {
            return AppointmentSchema.EndTimeZone;
        }
        return AppointmentSchema.StartTimeZone;
    });
    /**
     * Defines the **OriginalStart** property.
     */
    AppointmentSchema.OriginalStart = new DateTimePropertyDefinition("OriginalStart", XmlElementNames.OriginalStart, FieldUris.OriginalStart, PropertyDefinitionFlags.None, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **IsAllDayEvent** property.
     */
    AppointmentSchema.IsAllDayEvent = new BoolPropertyDefinition("IsAllDayEvent", XmlElementNames.IsAllDayEvent, FieldUris.IsAllDayEvent, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **LegacyFreeBusyStatus** property.
     */
    AppointmentSchema.LegacyFreeBusyStatus = new GenericPropertyDefinition("LegacyFreeBusyStatus", XmlElementNames.LegacyFreeBusyStatus, FieldUris.LegacyFreeBusyStatus, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, LegacyFreeBusyStatus);
    /**
     * Defines the **Location** property.
     */
    AppointmentSchema.Location = new StringPropertyDefinition("Location", XmlElementNames.Location, FieldUris.Location, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **When** property.
     */
    AppointmentSchema.When = new StringPropertyDefinition("When", XmlElementNames.When, FieldUris.When, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **IsMeeting** property.
     */
    AppointmentSchema.IsMeeting = new BoolPropertyDefinition("IsMeeting", XmlElementNames.IsMeeting, FieldUris.IsMeeting, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **IsCancelled** property.
     */
    AppointmentSchema.IsCancelled = new BoolPropertyDefinition("IsCancelled", XmlElementNames.IsCancelled, FieldUris.IsCancelled, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **IsRecurring** property.
     */
    AppointmentSchema.IsRecurring = new BoolPropertyDefinition("IsRecurring", XmlElementNames.IsRecurring, FieldUris.IsRecurring, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **MeetingRequestWasSent** property.
     */
    AppointmentSchema.MeetingRequestWasSent = new BoolPropertyDefinition("MeetingRequestWasSent", XmlElementNames.MeetingRequestWasSent, FieldUris.MeetingRequestWasSent, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **IsResponseRequested** property.
     */
    AppointmentSchema.IsResponseRequested = new BoolPropertyDefinition("IsResponseRequested", XmlElementNames.IsResponseRequested, FieldUris.IsResponseRequested, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **AppointmentType** property.
     */
    AppointmentSchema.AppointmentType = new GenericPropertyDefinition("CalendarItemType", XmlElementNames.CalendarItemType, FieldUris.CalendarItemType, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, AppointmentType);
    /**
     * Defines the **MyResponseType** property.
     */
    AppointmentSchema.MyResponseType = new GenericPropertyDefinition("MyResponseType", XmlElementNames.MyResponseType, FieldUris.MyResponseType, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, MeetingResponseType);
    /**
     * Defines the **Organizer** property.
     */
    AppointmentSchema.Organizer = new ContainedPropertyDefinition("Organizer", XmlElementNames.Organizer, FieldUris.Organizer, XmlElementNames.Mailbox, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, function () { return new EmailAddress(); });
    /**
     * Defines the **RequiredAttendees** property.
     */
    AppointmentSchema.RequiredAttendees = new ComplexPropertyDefinition("RequiredAttendees", XmlElementNames.RequiredAttendees, FieldUris.RequiredAttendees, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete, ExchangeVersion.Exchange2007_SP1, function () { return new AttendeeCollection(); });
    /**
     * Defines the **OptionalAttendees** property.
     */
    AppointmentSchema.OptionalAttendees = new ComplexPropertyDefinition("OptionalAttendees", XmlElementNames.OptionalAttendees, FieldUris.OptionalAttendees, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete, ExchangeVersion.Exchange2007_SP1, function () { return new AttendeeCollection(); });
    /**
     * Defines the **Resources** property.
     */
    AppointmentSchema.Resources = new ComplexPropertyDefinition("Resources", XmlElementNames.Resources, FieldUris.Resources, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete, ExchangeVersion.Exchange2007_SP1, function () { return new AttendeeCollection(); });
    /**
     * Defines the **ConflictingMeetingCount** property.
     */
    AppointmentSchema.ConflictingMeetingCount = new IntPropertyDefinition("ConflictingMeetingCount", XmlElementNames.ConflictingMeetingCount, FieldUris.ConflictingMeetingCount, PropertyDefinitionFlags.None, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **AdjacentMeetingCount** property.
     */
    AppointmentSchema.AdjacentMeetingCount = new IntPropertyDefinition("AdjacentMeetingCount", XmlElementNames.AdjacentMeetingCount, FieldUris.AdjacentMeetingCount, PropertyDefinitionFlags.None, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **ConflictingMeetings** property.
     */
    AppointmentSchema.ConflictingMeetings = new ComplexPropertyDefinition("ConflictingMeetings", XmlElementNames.ConflictingMeetings, FieldUris.ConflictingMeetings, PropertyDefinitionFlags.None, ExchangeVersion.Exchange2007_SP1, function () { return new ItemCollection(); });
    /**
     * Defines the **AdjacentMeetings** property.
     */
    AppointmentSchema.AdjacentMeetings = new ComplexPropertyDefinition("AdjacentMeetings", XmlElementNames.AdjacentMeetings, FieldUris.AdjacentMeetings, PropertyDefinitionFlags.None, ExchangeVersion.Exchange2007_SP1, function () { return new ItemCollection(); });
    /**
     * Defines the **Duration** property.
     */
    AppointmentSchema.Duration = new TimeSpanPropertyDefinition("Duration", XmlElementNames.Duration, FieldUris.Duration, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **TimeZone** property.
     */
    AppointmentSchema.TimeZone = new StringPropertyDefinition("TimeZone", XmlElementNames.TimeZone, FieldUris.TimeZone, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **AppointmentReplyTime** property.
     */
    AppointmentSchema.AppointmentReplyTime = new DateTimePropertyDefinition("AppointmentReplyTime", XmlElementNames.AppointmentReplyTime, FieldUris.AppointmentReplyTime, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **AppointmentSequenceNumber** property.
     */
    AppointmentSchema.AppointmentSequenceNumber = new IntPropertyDefinition("AppointmentSequenceNumber", XmlElementNames.AppointmentSequenceNumber, FieldUris.AppointmentSequenceNumber, PropertyDefinitionFlags.None, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **AppointmentState** property.
     */
    AppointmentSchema.AppointmentState = new IntPropertyDefinition("AppointmentState", XmlElementNames.AppointmentState, FieldUris.AppointmentState, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **Recurrence** property.
     */
    AppointmentSchema.Recurrence = new RecurrencePropertyDefinition("Recurrence", XmlElementNames.Recurrence, FieldUris.Recurrence, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **FirstOccurrence** property.
     */
    AppointmentSchema.FirstOccurrence = new ComplexPropertyDefinition("FirstOccurrence", XmlElementNames.FirstOccurrence, FieldUris.FirstOccurrence, PropertyDefinitionFlags.None, ExchangeVersion.Exchange2007_SP1, function () { return new OccurrenceInfo(); });
    /**
     * Defines the **LastOccurrence** property.
     */
    AppointmentSchema.LastOccurrence = new ComplexPropertyDefinition("LastOccurrence", XmlElementNames.LastOccurrence, FieldUris.LastOccurrence, PropertyDefinitionFlags.None, ExchangeVersion.Exchange2007_SP1, function () { return new OccurrenceInfo(); });
    /**
     * Defines the **ModifiedOccurrences** property.
     */
    AppointmentSchema.ModifiedOccurrences = new ComplexPropertyDefinition("ModifiedOccurrences", XmlElementNames.ModifiedOccurrences, FieldUris.ModifiedOccurrences, PropertyDefinitionFlags.None, ExchangeVersion.Exchange2007_SP1, function () { return new OccurrenceInfoCollection(); });
    /**
     * Defines the **DeletedOccurrences** property.
     */
    AppointmentSchema.DeletedOccurrences = new ComplexPropertyDefinition("DeletedOccurrences", XmlElementNames.DeletedOccurrences, FieldUris.DeletedOccurrences, PropertyDefinitionFlags.None, ExchangeVersion.Exchange2007_SP1, function () { return new DeletedOccurrenceInfoCollection(); });
    /**
     * Defines the **MeetingTimeZone** property.
     */
    AppointmentSchema.MeetingTimeZone = new MeetingTimeZonePropertyDefinition("MeetingTimeZone", XmlElementNames.MeetingTimeZone, FieldUris.MeetingTimeZone, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **ConferenceType** property.
     */
    AppointmentSchema.ConferenceType = new IntPropertyDefinition("ConferenceType", XmlElementNames.ConferenceType, FieldUris.ConferenceType, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **AllowNewTimeProposal** property.
     */
    AppointmentSchema.AllowNewTimeProposal = new BoolPropertyDefinition("AllowNewTimeProposal", XmlElementNames.AllowNewTimeProposal, FieldUris.AllowNewTimeProposal, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **IsOnlineMeeting** property.
     */
    AppointmentSchema.IsOnlineMeeting = new BoolPropertyDefinition("IsOnlineMeeting", XmlElementNames.IsOnlineMeeting, FieldUris.IsOnlineMeeting, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **MeetingWorkspaceUrl** property.
     */
    AppointmentSchema.MeetingWorkspaceUrl = new StringPropertyDefinition("MeetingWorkspaceUrl", XmlElementNames.MeetingWorkspaceUrl, FieldUris.MeetingWorkspaceUrl, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **NetShowUrl** property.
     */
    AppointmentSchema.NetShowUrl = new StringPropertyDefinition("NetShowUrl", XmlElementNames.NetShowUrl, FieldUris.NetShowUrl, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **ICalUid** property.
     */
    AppointmentSchema.ICalUid = new StringPropertyDefinition("ICalUid", XmlElementNames.Uid, FieldUris.Uid, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **ICalRecurrenceId** property.
     */
    AppointmentSchema.ICalRecurrenceId = new DateTimePropertyDefinition("ICalRecurrenceId", XmlElementNames.RecurrenceId, FieldUris.RecurrenceId, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, true);
    /**
     * Defines the **ICalDateTimeStamp** property.
     */
    AppointmentSchema.ICalDateTimeStamp = new DateTimePropertyDefinition("ICalDateTimeStamp", XmlElementNames.DateTimeStamp, FieldUris.DateTimeStamp, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, true);
    /**
     * Defines the **EnhancedLocation** property.
     */
    AppointmentSchema.EnhancedLocation = new ComplexPropertyDefinition("EnhancedLocation", XmlElementNames.EnhancedLocation, FieldUris.EnhancedLocation, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013, function () { return new EnhancedLocation(); });
    /**
     * Defines the **JoinOnlineMeetingUrl** property.
     */
    AppointmentSchema.JoinOnlineMeetingUrl = new StringPropertyDefinition("JoinOnlineMeetingUrl", XmlElementNames.JoinOnlineMeetingUrl, FieldUris.JoinOnlineMeetingUrl, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013);
    /**
     * Defines the **OnlineMeetingSettings** property.
     */
    AppointmentSchema.OnlineMeetingSettings = new ComplexPropertyDefinition("OnlineMeetingSettings", XmlElementNames.OnlineMeetingSettings, FieldUris.OnlineMeetingSettings, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013, function () { return new OnlineMeetingSettings(); });
    /**
     * @internal Instance of **AppointmentSchema**
     */
    AppointmentSchema.Instance = new AppointmentSchema();
    return AppointmentSchema;
}(ItemSchema));
exports.AppointmentSchema = AppointmentSchema;
Schemas.AppointmentSchema = AppointmentSchema;
/**
 * FieldURIs for contacts.
 */
(function (FieldUris) {
    FieldUris.FileAs = "contacts:FileAs";
    FieldUris.FileAsMapping = "contacts:FileAsMapping";
    FieldUris.DisplayName = "contacts:DisplayName";
    FieldUris.GivenName = "contacts:GivenName";
    FieldUris.Initials = "contacts:Initials";
    FieldUris.MiddleName = "contacts:MiddleName";
    FieldUris.NickName = "contacts:Nickname";
    FieldUris.CompleteName = "contacts:CompleteName";
    FieldUris.CompanyName = "contacts:CompanyName";
    FieldUris.EmailAddress = "contacts:EmailAddress";
    FieldUris.EmailAddresses = "contacts:EmailAddresses";
    FieldUris.PhysicalAddresses = "contacts:PhysicalAddresses";
    FieldUris.PhoneNumber = "contacts:PhoneNumber";
    FieldUris.PhoneNumbers = "contacts:PhoneNumbers";
    FieldUris.AssistantName = "contacts:AssistantName";
    FieldUris.Birthday = "contacts:Birthday";
    FieldUris.BusinessHomePage = "contacts:BusinessHomePage";
    FieldUris.Children = "contacts:Children";
    FieldUris.Companies = "contacts:Companies";
    FieldUris.ContactSource = "contacts:ContactSource";
    FieldUris.Department = "contacts:Department";
    FieldUris.Generation = "contacts:Generation";
    FieldUris.ImAddress = "contacts:ImAddress";
    FieldUris.ImAddresses = "contacts:ImAddresses";
    FieldUris.JobTitle = "contacts:JobTitle";
    FieldUris.Manager = "contacts:Manager";
    FieldUris.Mileage = "contacts:Mileage";
    FieldUris.OfficeLocation = "contacts:OfficeLocation";
    FieldUris.PhysicalAddressCity = "contacts:PhysicalAddress:City";
    FieldUris.PhysicalAddressCountryOrRegion = "contacts:PhysicalAddress:CountryOrRegion";
    FieldUris.PhysicalAddressState = "contacts:PhysicalAddress:State";
    FieldUris.PhysicalAddressStreet = "contacts:PhysicalAddress:Street";
    FieldUris.PhysicalAddressPostalCode = "contacts:PhysicalAddress:PostalCode";
    FieldUris.PostalAddressIndex = "contacts:PostalAddressIndex";
    FieldUris.Profession = "contacts:Profession";
    FieldUris.SpouseName = "contacts:SpouseName";
    FieldUris.Surname = "contacts:Surname";
    FieldUris.WeddingAnniversary = "contacts:WeddingAnniversary";
    FieldUris.HasPicture = "contacts:HasPicture";
    FieldUris.PhoneticFullName = "contacts:PhoneticFullName";
    FieldUris.PhoneticFirstName = "contacts:PhoneticFirstName";
    FieldUris.PhoneticLastName = "contacts:PhoneticLastName";
    FieldUris.Alias = "contacts:Alias";
    FieldUris.Notes = "contacts:Notes";
    FieldUris.Photo = "contacts:Photo";
    FieldUris.UserSMIMECertificate = "contacts:UserSMIMECertificate";
    FieldUris.MSExchangeCertificate = "contacts:MSExchangeCertificate";
    FieldUris.DirectoryId = "contacts:DirectoryId";
    FieldUris.ManagerMailbox = "contacts:ManagerMailbox";
    FieldUris.DirectReports = "contacts:DirectReports";
})(FieldUris || (FieldUris = {}));
/**
 * Represents the schem for contacts.
 */
var ContactSchema = (function (_super) {
    __extends(ContactSchema, _super);
    function ContactSchema() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Registers properties.
     *
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    ContactSchema.prototype.RegisterProperties = function () {
        _super.prototype.RegisterProperties.call(this);
        this.RegisterProperty(ContactSchema, ContactSchema.FileAs);
        this.RegisterProperty(ContactSchema, ContactSchema.FileAsMapping);
        this.RegisterProperty(ContactSchema, ContactSchema.DisplayName);
        this.RegisterProperty(ContactSchema, ContactSchema.GivenName);
        this.RegisterProperty(ContactSchema, ContactSchema.Initials);
        this.RegisterProperty(ContactSchema, ContactSchema.MiddleName);
        this.RegisterProperty(ContactSchema, ContactSchema.NickName);
        this.RegisterProperty(ContactSchema, ContactSchema.CompleteName);
        this.RegisterProperty(ContactSchema, ContactSchema.CompanyName);
        this.RegisterProperty(ContactSchema, ContactSchema.EmailAddresses);
        this.RegisterProperty(ContactSchema, ContactSchema.PhysicalAddresses);
        this.RegisterProperty(ContactSchema, ContactSchema.PhoneNumbers);
        this.RegisterProperty(ContactSchema, ContactSchema.AssistantName);
        this.RegisterProperty(ContactSchema, ContactSchema.Birthday);
        this.RegisterProperty(ContactSchema, ContactSchema.BusinessHomePage);
        this.RegisterProperty(ContactSchema, ContactSchema.Children);
        this.RegisterProperty(ContactSchema, ContactSchema.Companies);
        this.RegisterProperty(ContactSchema, ContactSchema.ContactSource);
        this.RegisterProperty(ContactSchema, ContactSchema.Department);
        this.RegisterProperty(ContactSchema, ContactSchema.Generation);
        this.RegisterProperty(ContactSchema, ContactSchema.ImAddresses);
        this.RegisterProperty(ContactSchema, ContactSchema.JobTitle);
        this.RegisterProperty(ContactSchema, ContactSchema.Manager);
        this.RegisterProperty(ContactSchema, ContactSchema.Mileage);
        this.RegisterProperty(ContactSchema, ContactSchema.OfficeLocation);
        this.RegisterProperty(ContactSchema, ContactSchema.PostalAddressIndex);
        this.RegisterProperty(ContactSchema, ContactSchema.Profession);
        this.RegisterProperty(ContactSchema, ContactSchema.SpouseName);
        this.RegisterProperty(ContactSchema, ContactSchema.Surname);
        this.RegisterProperty(ContactSchema, ContactSchema.WeddingAnniversary);
        this.RegisterProperty(ContactSchema, ContactSchema.HasPicture);
        this.RegisterProperty(ContactSchema, ContactSchema.PhoneticFullName);
        this.RegisterProperty(ContactSchema, ContactSchema.PhoneticFirstName);
        this.RegisterProperty(ContactSchema, ContactSchema.PhoneticLastName);
        this.RegisterProperty(ContactSchema, ContactSchema.Alias);
        this.RegisterProperty(ContactSchema, ContactSchema.Notes);
        this.RegisterProperty(ContactSchema, ContactSchema.Photo);
        this.RegisterProperty(ContactSchema, ContactSchema.UserSMIMECertificate);
        this.RegisterProperty(ContactSchema, ContactSchema.MSExchangeCertificate);
        this.RegisterProperty(ContactSchema, ContactSchema.DirectoryId);
        this.RegisterProperty(ContactSchema, ContactSchema.ManagerMailbox);
        this.RegisterProperty(ContactSchema, ContactSchema.DirectReports);
        this.RegisterIndexedProperty(ContactSchema.EmailAddress1);
        this.RegisterIndexedProperty(ContactSchema.EmailAddress2);
        this.RegisterIndexedProperty(ContactSchema.EmailAddress3);
        this.RegisterIndexedProperty(ContactSchema.ImAddress1);
        this.RegisterIndexedProperty(ContactSchema.ImAddress2);
        this.RegisterIndexedProperty(ContactSchema.ImAddress3);
        this.RegisterIndexedProperty(ContactSchema.AssistantPhone);
        this.RegisterIndexedProperty(ContactSchema.BusinessFax);
        this.RegisterIndexedProperty(ContactSchema.BusinessPhone);
        this.RegisterIndexedProperty(ContactSchema.BusinessPhone2);
        this.RegisterIndexedProperty(ContactSchema.Callback);
        this.RegisterIndexedProperty(ContactSchema.CarPhone);
        this.RegisterIndexedProperty(ContactSchema.CompanyMainPhone);
        this.RegisterIndexedProperty(ContactSchema.HomeFax);
        this.RegisterIndexedProperty(ContactSchema.HomePhone);
        this.RegisterIndexedProperty(ContactSchema.HomePhone2);
        this.RegisterIndexedProperty(ContactSchema.Isdn);
        this.RegisterIndexedProperty(ContactSchema.MobilePhone);
        this.RegisterIndexedProperty(ContactSchema.OtherFax);
        this.RegisterIndexedProperty(ContactSchema.OtherTelephone);
        this.RegisterIndexedProperty(ContactSchema.Pager);
        this.RegisterIndexedProperty(ContactSchema.PrimaryPhone);
        this.RegisterIndexedProperty(ContactSchema.RadioPhone);
        this.RegisterIndexedProperty(ContactSchema.Telex);
        this.RegisterIndexedProperty(ContactSchema.TtyTddPhone);
        this.RegisterIndexedProperty(ContactSchema.BusinessAddressStreet);
        this.RegisterIndexedProperty(ContactSchema.BusinessAddressCity);
        this.RegisterIndexedProperty(ContactSchema.BusinessAddressState);
        this.RegisterIndexedProperty(ContactSchema.BusinessAddressCountryOrRegion);
        this.RegisterIndexedProperty(ContactSchema.BusinessAddressPostalCode);
        this.RegisterIndexedProperty(ContactSchema.HomeAddressStreet);
        this.RegisterIndexedProperty(ContactSchema.HomeAddressCity);
        this.RegisterIndexedProperty(ContactSchema.HomeAddressState);
        this.RegisterIndexedProperty(ContactSchema.HomeAddressCountryOrRegion);
        this.RegisterIndexedProperty(ContactSchema.HomeAddressPostalCode);
        this.RegisterIndexedProperty(ContactSchema.OtherAddressStreet);
        this.RegisterIndexedProperty(ContactSchema.OtherAddressCity);
        this.RegisterIndexedProperty(ContactSchema.OtherAddressState);
        this.RegisterIndexedProperty(ContactSchema.OtherAddressCountryOrRegion);
        this.RegisterIndexedProperty(ContactSchema.OtherAddressPostalCode);
    };
    /**
     * Defines the **FileAs** property.
     */
    ContactSchema.FileAs = new StringPropertyDefinition("FileAs", XmlElementNames.FileAs, FieldUris.FileAs, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **FileAsMapping** property.
     */
    ContactSchema.FileAsMapping = new GenericPropertyDefinition("FileAsMapping", XmlElementNames.FileAsMapping, FieldUris.FileAsMapping, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, FileAsMapping);
    /**
     * Defines the **DisplayName** property.
     */
    ContactSchema.DisplayName = new StringPropertyDefinition("DisplayName", XmlElementNames.DisplayName, FieldUris.DisplayName, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **GivenName** property.
     */
    ContactSchema.GivenName = new StringPropertyDefinition("GivenName", XmlElementNames.GivenName, FieldUris.GivenName, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **Initials** property.
     */
    ContactSchema.Initials = new StringPropertyDefinition("Initials", XmlElementNames.Initials, FieldUris.Initials, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **MiddleName** property.
     */
    ContactSchema.MiddleName = new StringPropertyDefinition("MiddleName", XmlElementNames.MiddleName, FieldUris.MiddleName, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **NickName** property.
     */
    ContactSchema.NickName = new StringPropertyDefinition("Nickname", XmlElementNames.NickName, FieldUris.NickName, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **CompleteName** property.
     */
    ContactSchema.CompleteName = new ComplexPropertyDefinition("CompleteName", XmlElementNames.CompleteName, FieldUris.CompleteName, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, function () { return new CompleteName(); });
    /**
     * Defines the **CompanyName** property.
     */
    ContactSchema.CompanyName = new StringPropertyDefinition("CompanyName", XmlElementNames.CompanyName, FieldUris.CompanyName, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **EmailAddresses** property.
     */
    ContactSchema.EmailAddresses = new ComplexPropertyDefinition("EmailAddresses", XmlElementNames.EmailAddresses, FieldUris.EmailAddresses, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate, ExchangeVersion.Exchange2007_SP1, function () { return new EmailAddressDictionary(); });
    /**
     * Defines the **PhysicalAddresses** property.
     */
    ContactSchema.PhysicalAddresses = new ComplexPropertyDefinition("PhysicalAddresses", XmlElementNames.PhysicalAddresses, FieldUris.PhysicalAddresses, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate, ExchangeVersion.Exchange2007_SP1, function () { return new PhysicalAddressDictionary(); });
    /**
     * Defines the **PhoneNumbers** property.
     */
    ContactSchema.PhoneNumbers = new ComplexPropertyDefinition("PhoneNumbers", XmlElementNames.PhoneNumbers, FieldUris.PhoneNumbers, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate, ExchangeVersion.Exchange2007_SP1, function () { return new PhoneNumberDictionary(); });
    /**
     * Defines the **AssistantName** property.
     */
    ContactSchema.AssistantName = new StringPropertyDefinition("AssistantName", XmlElementNames.AssistantName, FieldUris.AssistantName, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **Birthday** property.
     */
    ContactSchema.Birthday = new DateTimePropertyDefinition("Birthday", XmlElementNames.Birthday, FieldUris.Birthday, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **BusinessHomePage** property.
     */
    ContactSchema.BusinessHomePage = new StringPropertyDefinition("BusinessHomePage", XmlElementNames.BusinessHomePage, FieldUris.BusinessHomePage, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **Children** property.
     */
    ContactSchema.Children = new ComplexPropertyDefinition("Children", XmlElementNames.Children, FieldUris.Children, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, function () { return new StringList(); });
    /**
     * Defines the **Companies** property.
     */
    ContactSchema.Companies = new ComplexPropertyDefinition("Companies", XmlElementNames.Companies, FieldUris.Companies, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, function () { return new StringList(); });
    /**
     * Defines the **ContactSource** property.
     */
    ContactSchema.ContactSource = new GenericPropertyDefinition("ContactSource", XmlElementNames.ContactSource, FieldUris.ContactSource, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, ContactSource);
    /**
     * Defines the **Department** property.
     */
    ContactSchema.Department = new StringPropertyDefinition("Department", XmlElementNames.Department, FieldUris.Department, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **Generation** property.
     */
    ContactSchema.Generation = new StringPropertyDefinition("Generation", XmlElementNames.Generation, FieldUris.Generation, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **ImAddresses** property.
     */
    ContactSchema.ImAddresses = new ComplexPropertyDefinition("ImAddresses", XmlElementNames.ImAddresses, FieldUris.ImAddresses, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate, ExchangeVersion.Exchange2007_SP1, function () { return new ImAddressDictionary(); });
    /**
     * Defines the **JobTitle** property.
     */
    ContactSchema.JobTitle = new StringPropertyDefinition("JobTitle", XmlElementNames.JobTitle, FieldUris.JobTitle, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **Manager** property.
     */
    ContactSchema.Manager = new StringPropertyDefinition("Manager", XmlElementNames.Manager, FieldUris.Manager, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **Mileage** property.
     */
    ContactSchema.Mileage = new StringPropertyDefinition("Mileage", XmlElementNames.Mileage, FieldUris.Mileage, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **OfficeLocation** property.
     */
    ContactSchema.OfficeLocation = new StringPropertyDefinition("OfficeLocation", XmlElementNames.OfficeLocation, FieldUris.OfficeLocation, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **PostalAddressIndex** property.
     */
    ContactSchema.PostalAddressIndex = new GenericPropertyDefinition("PostalAddressIndex", XmlElementNames.PostalAddressIndex, FieldUris.PostalAddressIndex, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, PhysicalAddressIndex);
    /**
     * Defines the **Profession** property.
     */
    ContactSchema.Profession = new StringPropertyDefinition("Profession", XmlElementNames.Profession, FieldUris.Profession, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **SpouseName** property.
     */
    ContactSchema.SpouseName = new StringPropertyDefinition("SpouseName", XmlElementNames.SpouseName, FieldUris.SpouseName, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **Surname** property.
     */
    ContactSchema.Surname = new StringPropertyDefinition("Surname", XmlElementNames.Surname, FieldUris.Surname, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **WeddingAnniversary** property.
     */
    ContactSchema.WeddingAnniversary = new DateTimePropertyDefinition("WeddingAnniversary", XmlElementNames.WeddingAnniversary, FieldUris.WeddingAnniversary, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **HasPicture** property.
     */
    ContactSchema.HasPicture = new BoolPropertyDefinition("HasPicture", XmlElementNames.HasPicture, FieldUris.HasPicture, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010);
    /**
     * Defines the **PhoneticFullName** property.
     */
    ContactSchema.PhoneticFullName = new StringPropertyDefinition("PhoneticFullName", XmlElementNames.PhoneticFullName, FieldUris.PhoneticFullName, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1);
    /**
     * Defines the **PhoneticFirstName** property.
     */
    ContactSchema.PhoneticFirstName = new StringPropertyDefinition("PhoneticFirstName", XmlElementNames.PhoneticFirstName, FieldUris.PhoneticFirstName, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1);
    /**
     * Defines the **PhoneticLastName** property.
     */
    ContactSchema.PhoneticLastName = new StringPropertyDefinition("PhoneticLastName", XmlElementNames.PhoneticLastName, FieldUris.PhoneticLastName, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1);
    /**
     * Defines the **Alias** property.
     */
    ContactSchema.Alias = new StringPropertyDefinition("Alias", XmlElementNames.Alias, FieldUris.Alias, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1);
    /**
     * Defines the **Notes** property.
     */
    ContactSchema.Notes = new StringPropertyDefinition("Notes", XmlElementNames.Notes, FieldUris.Notes, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1);
    /**
     * Defines the **Photo** property.
     */
    ContactSchema.Photo = new ByteArrayPropertyDefinition("Photo", XmlElementNames.Photo, FieldUris.Photo, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1);
    /**
     * Defines the **UserSMIMECertificate** property.
     */
    ContactSchema.UserSMIMECertificate = new ComplexPropertyDefinition("UserSMIMECertificate", XmlElementNames.UserSMIMECertificate, FieldUris.UserSMIMECertificate, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, function () { return new ByteArrayArray(); });
    /**
     * Defines the **MSExchangeCertificate** property.
     */
    ContactSchema.MSExchangeCertificate = new ComplexPropertyDefinition("MSExchangeCertificate", XmlElementNames.MSExchangeCertificate, FieldUris.MSExchangeCertificate, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, function () { return new ByteArrayArray(); });
    /**
     * Defines the **DirectoryId** property.
     */
    ContactSchema.DirectoryId = new StringPropertyDefinition("DirectoryId", XmlElementNames.DirectoryId, FieldUris.DirectoryId, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1);
    /**
     * Defines the **ManagerMailbox** property.
     */
    ContactSchema.ManagerMailbox = new ContainedPropertyDefinition("ManagerMailbox", XmlElementNames.ManagerMailbox, FieldUris.ManagerMailbox, XmlElementNames.Mailbox, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, function () { return new EmailAddress(); });
    /**
     * Defines the **DirectReports** property.
     */
    ContactSchema.DirectReports = new ComplexPropertyDefinition("DirectReports", XmlElementNames.DirectReports, FieldUris.DirectReports, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2010_SP1, function () { return new EmailAddressCollection(); });
    /**
     * Defines the **EmailAddress1** property.
     */
    ContactSchema.EmailAddress1 = new IndexedPropertyDefinition(FieldUris.EmailAddress, "EmailAddress1");
    /**
     * Defines the **EmailAddress2** property.
     */
    ContactSchema.EmailAddress2 = new IndexedPropertyDefinition(FieldUris.EmailAddress, "EmailAddress2");
    /**
     * Defines the **EmailAddress3** property.
     */
    ContactSchema.EmailAddress3 = new IndexedPropertyDefinition(FieldUris.EmailAddress, "EmailAddress3");
    /**
     * Defines the **ImAddress1** property.
     */
    ContactSchema.ImAddress1 = new IndexedPropertyDefinition(FieldUris.ImAddress, "ImAddress1");
    /**
     * Defines the **ImAddress2** property.
     */
    ContactSchema.ImAddress2 = new IndexedPropertyDefinition(FieldUris.ImAddress, "ImAddress2");
    /**
     * Defines the **ImAddress3** property.
     */
    ContactSchema.ImAddress3 = new IndexedPropertyDefinition(FieldUris.ImAddress, "ImAddress3");
    /**
     * Defines the **AssistantPhone** property.
     */
    ContactSchema.AssistantPhone = new IndexedPropertyDefinition(FieldUris.PhoneNumber, "AssistantPhone");
    /**
     * Defines the **BusinessFax** property.
     */
    ContactSchema.BusinessFax = new IndexedPropertyDefinition(FieldUris.PhoneNumber, "BusinessFax");
    /**
     * Defines the **BusinessPhone** property.
     */
    ContactSchema.BusinessPhone = new IndexedPropertyDefinition(FieldUris.PhoneNumber, "BusinessPhone");
    /**
     * Defines the **BusinessPhone2** property.
     */
    ContactSchema.BusinessPhone2 = new IndexedPropertyDefinition(FieldUris.PhoneNumber, "BusinessPhone2");
    /**
     * Defines the **Callback** property.
     */
    ContactSchema.Callback = new IndexedPropertyDefinition(FieldUris.PhoneNumber, "Callback");
    /**
     * Defines the **CarPhone** property.
     */
    ContactSchema.CarPhone = new IndexedPropertyDefinition(FieldUris.PhoneNumber, "CarPhone");
    /**
     * Defines the **CompanyMainPhone** property.
     */
    ContactSchema.CompanyMainPhone = new IndexedPropertyDefinition(FieldUris.PhoneNumber, "CompanyMainPhone");
    /**
     * Defines the **HomeFax** property.
     */
    ContactSchema.HomeFax = new IndexedPropertyDefinition(FieldUris.PhoneNumber, "HomeFax");
    /**
     * Defines the **HomePhone** property.
     */
    ContactSchema.HomePhone = new IndexedPropertyDefinition(FieldUris.PhoneNumber, "HomePhone");
    /**
     * Defines the **HomePhone2** property.
     */
    ContactSchema.HomePhone2 = new IndexedPropertyDefinition(FieldUris.PhoneNumber, "HomePhone2");
    /**
     * Defines the **Isdn** property.
     */
    ContactSchema.Isdn = new IndexedPropertyDefinition(FieldUris.PhoneNumber, "Isdn");
    /**
     * Defines the **MobilePhone** property.
     */
    ContactSchema.MobilePhone = new IndexedPropertyDefinition(FieldUris.PhoneNumber, "MobilePhone");
    /**
     * Defines the **OtherFax** property.
     */
    ContactSchema.OtherFax = new IndexedPropertyDefinition(FieldUris.PhoneNumber, "OtherFax");
    /**
     * Defines the **OtherTelephone** property.
     */
    ContactSchema.OtherTelephone = new IndexedPropertyDefinition(FieldUris.PhoneNumber, "OtherTelephone");
    /**
     * Defines the **Pager** property.
     */
    ContactSchema.Pager = new IndexedPropertyDefinition(FieldUris.PhoneNumber, "Pager");
    /**
     * Defines the **PrimaryPhone** property.
     */
    ContactSchema.PrimaryPhone = new IndexedPropertyDefinition(FieldUris.PhoneNumber, "PrimaryPhone");
    /**
     * Defines the **RadioPhone** property.
     */
    ContactSchema.RadioPhone = new IndexedPropertyDefinition(FieldUris.PhoneNumber, "RadioPhone");
    /**
     * Defines the **Telex** property.
     */
    ContactSchema.Telex = new IndexedPropertyDefinition(FieldUris.PhoneNumber, "Telex");
    /**
     * Defines the **TtyTddPhone** property.
     */
    ContactSchema.TtyTddPhone = new IndexedPropertyDefinition(FieldUris.PhoneNumber, "TtyTddPhone");
    /**
     * Defines the **BusinessAddressStreet** property.
     */
    ContactSchema.BusinessAddressStreet = new IndexedPropertyDefinition(FieldUris.PhysicalAddressStreet, "Business");
    /**
     * Defines the **BusinessAddressCity** property.
     */
    ContactSchema.BusinessAddressCity = new IndexedPropertyDefinition(FieldUris.PhysicalAddressCity, "Business");
    /**
     * Defines the **BusinessAddressState** property.
     */
    ContactSchema.BusinessAddressState = new IndexedPropertyDefinition(FieldUris.PhysicalAddressState, "Business");
    /**
     * Defines the **BusinessAddressCountryOrRegion** property.
     */
    ContactSchema.BusinessAddressCountryOrRegion = new IndexedPropertyDefinition(FieldUris.PhysicalAddressCountryOrRegion, "Business");
    /**
     * Defines the **BusinessAddressPostalCode** property.
     */
    ContactSchema.BusinessAddressPostalCode = new IndexedPropertyDefinition(FieldUris.PhysicalAddressPostalCode, "Business");
    /**
     * Defines the **HomeAddressStreet** property.
     */
    ContactSchema.HomeAddressStreet = new IndexedPropertyDefinition(FieldUris.PhysicalAddressStreet, "Home");
    /**
     * Defines the **HomeAddressCity** property.
     */
    ContactSchema.HomeAddressCity = new IndexedPropertyDefinition(FieldUris.PhysicalAddressCity, "Home");
    /**
     * Defines the **HomeAddressState** property.
     */
    ContactSchema.HomeAddressState = new IndexedPropertyDefinition(FieldUris.PhysicalAddressState, "Home");
    /**
     * Defines the **HomeAddressCountryOrRegion** property.
     */
    ContactSchema.HomeAddressCountryOrRegion = new IndexedPropertyDefinition(FieldUris.PhysicalAddressCountryOrRegion, "Home");
    /**
     * Defines the **HomeAddressPostalCode** property.
     */
    ContactSchema.HomeAddressPostalCode = new IndexedPropertyDefinition(FieldUris.PhysicalAddressPostalCode, "Home");
    /**
     * Defines the **OtherAddressStreet** property.
     */
    ContactSchema.OtherAddressStreet = new IndexedPropertyDefinition(FieldUris.PhysicalAddressStreet, "Other");
    /**
     * Defines the **OtherAddressCity** property.
     */
    ContactSchema.OtherAddressCity = new IndexedPropertyDefinition(FieldUris.PhysicalAddressCity, "Other");
    /**
     * Defines the **OtherAddressState** property.
     */
    ContactSchema.OtherAddressState = new IndexedPropertyDefinition(FieldUris.PhysicalAddressState, "Other");
    /**
     * Defines the **OtherAddressCountryOrRegion** property.
     */
    ContactSchema.OtherAddressCountryOrRegion = new IndexedPropertyDefinition(FieldUris.PhysicalAddressCountryOrRegion, "Other");
    /**
     * Defines the **OtherAddressPostalCode** property.
     */
    ContactSchema.OtherAddressPostalCode = new IndexedPropertyDefinition(FieldUris.PhysicalAddressPostalCode, "Other");
    /**
     * @internal Instance of **ContactSchema**
     */
    ContactSchema.Instance = new ContactSchema();
    return ContactSchema;
}(ItemSchema));
exports.ContactSchema = ContactSchema;
Schemas.ContactSchema = ContactSchema;
/**
 * Field URIs for Members.
 */
(function (FieldUris) {
    /**
     * FieldUri for members.
     */
    FieldUris.Members = "distributionlist:Members";
})(FieldUris || (FieldUris = {}));
/**
 * Represents the schema for contact groups.
 */
var ContactGroupSchema = (function (_super) {
    __extends(ContactGroupSchema, _super);
    function ContactGroupSchema() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Registers properties.
     *
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    ContactGroupSchema.prototype.RegisterProperties = function () {
        _super.prototype.RegisterProperties.call(this);
        this.RegisterProperty(ContactGroupSchema, ContactGroupSchema.DisplayName);
        this.RegisterProperty(ContactGroupSchema, ContactGroupSchema.FileAs);
        this.RegisterProperty(ContactGroupSchema, ContactGroupSchema.Members);
    };
    /**
     * Defines the **DisplayName** property.
     */
    ContactGroupSchema.DisplayName = Schemas.ContactSchema.DisplayName;
    /**
     * Defines the **FileAs** property.
     */
    ContactGroupSchema.FileAs = Schemas.ContactSchema.FileAs;
    /**
     * Defines the **Members** property.
     */
    ContactGroupSchema.Members = new ComplexPropertyDefinition("Members", XmlElementNames.Members, FieldUris.Members, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate, ExchangeVersion.Exchange2010, function () { return new GroupMemberCollection(); });
    /**
     * @internal Instance of **ContactGroupSchema**
     */
    ContactGroupSchema.Instance = new ContactGroupSchema();
    return ContactGroupSchema;
}(ItemSchema));
exports.ContactGroupSchema = ContactGroupSchema;
Schemas.ContactGroupSchema = ContactGroupSchema;
/**
 * Field URIs for EmailMessage.
 */
(function (FieldUris) {
    FieldUris.ConversationIndex = "message:ConversationIndex";
    FieldUris.ConversationTopic = "message:ConversationTopic";
    FieldUris.InternetMessageId = "message:InternetMessageId";
    FieldUris.IsRead = "message:IsRead";
    FieldUris.IsResponseRequested = "message:IsResponseRequested";
    FieldUris.IsReadReceiptRequested = "message:IsReadReceiptRequested";
    FieldUris.IsDeliveryReceiptRequested = "message:IsDeliveryReceiptRequested";
    FieldUris.References = "message:References";
    FieldUris.ReplyTo = "message:ReplyTo";
    FieldUris.From = "message:From";
    FieldUris.Sender = "message:Sender";
    FieldUris.ToRecipients = "message:ToRecipients";
    FieldUris.CcRecipients = "message:CcRecipients";
    FieldUris.BccRecipients = "message:BccRecipients";
    FieldUris.ReceivedBy = "message:ReceivedBy";
    FieldUris.ReceivedRepresenting = "message:ReceivedRepresenting";
    FieldUris.ApprovalRequestData = "message:ApprovalRequestData";
    FieldUris.VotingInformation = "message:VotingInformation";
})(FieldUris || (FieldUris = {}));
/**
 * Represents the schema for e-mail messages.
 */
var EmailMessageSchema = (function (_super) {
    __extends(EmailMessageSchema, _super);
    function EmailMessageSchema() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Registers properties.
     *
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    EmailMessageSchema.prototype.RegisterProperties = function () {
        _super.prototype.RegisterProperties.call(this);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.Sender);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.ToRecipients);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.CcRecipients);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.BccRecipients);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.IsReadReceiptRequested);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.IsDeliveryReceiptRequested);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.ConversationIndex);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.ConversationTopic);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.From);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.InternetMessageId);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.IsRead);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.IsResponseRequested);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.References);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.ReplyTo);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.ReceivedBy);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.ReceivedRepresenting);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.ApprovalRequestData);
        this.RegisterProperty(EmailMessageSchema, EmailMessageSchema.VotingInformation);
    };
    /**
     * Defines the **ToRecipients** property.
     */
    EmailMessageSchema.ToRecipients = new ComplexPropertyDefinition("ToRecipients", XmlElementNames.ToRecipients, FieldUris.ToRecipients, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete, ExchangeVersion.Exchange2007_SP1, function () { return new EmailAddressCollection(); });
    /**
     * Defines the **BccRecipients** property.
     */
    EmailMessageSchema.BccRecipients = new ComplexPropertyDefinition("BccRecipients", XmlElementNames.BccRecipients, FieldUris.BccRecipients, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete, ExchangeVersion.Exchange2007_SP1, function () { return new EmailAddressCollection(); });
    /**
     * Defines the **CcRecipients** property.
     */
    EmailMessageSchema.CcRecipients = new ComplexPropertyDefinition("CcRecipients", XmlElementNames.CcRecipients, FieldUris.CcRecipients, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete, ExchangeVersion.Exchange2007_SP1, function () { return new EmailAddressCollection(); });
    /**
     * Defines the **ConversationIndex** property.
     */
    EmailMessageSchema.ConversationIndex = new ByteArrayPropertyDefinition("ConversationIndex", XmlElementNames.ConversationIndex, FieldUris.ConversationIndex, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **ConversationTopic** property.
     */
    EmailMessageSchema.ConversationTopic = new StringPropertyDefinition("ConversationTopic", XmlElementNames.ConversationTopic, FieldUris.ConversationTopic, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **From** property.
     */
    EmailMessageSchema.From = new ContainedPropertyDefinition("From", XmlElementNames.From, FieldUris.From, XmlElementNames.Mailbox, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, function () { return new EmailAddress(); });
    /**
     * Defines the **IsDeliveryReceiptRequested** property.
     */
    EmailMessageSchema.IsDeliveryReceiptRequested = new BoolPropertyDefinition("IsDeliveryReceiptRequested", XmlElementNames.IsDeliveryReceiptRequested, FieldUris.IsDeliveryReceiptRequested, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **IsRead** property.
     */
    EmailMessageSchema.IsRead = new BoolPropertyDefinition("IsRead", XmlElementNames.IsRead, FieldUris.IsRead, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **IsReadReceiptRequested** property.
     */
    EmailMessageSchema.IsReadReceiptRequested = new BoolPropertyDefinition("IsReadReceiptRequested", XmlElementNames.IsReadReceiptRequested, FieldUris.IsReadReceiptRequested, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **IsResponseRequested** property.
     */
    EmailMessageSchema.IsResponseRequested = new BoolPropertyDefinition("IsResponseRequested", XmlElementNames.IsResponseRequested, FieldUris.IsResponseRequested, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, true);
    /**
     * Defines the **InternetMessageId** property.
     */
    EmailMessageSchema.InternetMessageId = new StringPropertyDefinition("InternetMessageId", XmlElementNames.InternetMessageId, FieldUris.InternetMessageId, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **References** property.
     */
    EmailMessageSchema.References = new StringPropertyDefinition("References", XmlElementNames.References, FieldUris.References, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **ReplyTo** property.
     */
    EmailMessageSchema.ReplyTo = new ComplexPropertyDefinition("ReplyTo", XmlElementNames.ReplyTo, FieldUris.ReplyTo, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete, ExchangeVersion.Exchange2007_SP1, function () { return new EmailAddressCollection(); });
    /**
     * Defines the **Sender** property.
     */
    EmailMessageSchema.Sender = new ContainedPropertyDefinition("Sender", XmlElementNames.Sender, FieldUris.Sender, XmlElementNames.Mailbox, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, function () { return new EmailAddress(); });
    /**
     * Defines the **ReceivedBy** property.
     */
    EmailMessageSchema.ReceivedBy = new ContainedPropertyDefinition("ReceivedBy", XmlElementNames.ReceivedBy, FieldUris.ReceivedBy, XmlElementNames.Mailbox, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, function () { return new EmailAddress(); });
    /**
     * Defines the **ReceivedRepresenting** property.
     */
    EmailMessageSchema.ReceivedRepresenting = new ContainedPropertyDefinition("ReceivedRepresenting", XmlElementNames.ReceivedRepresenting, FieldUris.ReceivedRepresenting, XmlElementNames.Mailbox, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, function () { return new EmailAddress(); });
    /**
     * Defines the **ApprovalRequestData** property.
     */
    EmailMessageSchema.ApprovalRequestData = new ComplexPropertyDefinition("ApprovalRequestData", XmlElementNames.ApprovalRequestData, FieldUris.ApprovalRequestData, PropertyDefinitionFlags.None, ExchangeVersion.Exchange2013, function () { return new ApprovalRequestData(); });
    /**
     * Defines the **VotingInformation** property.
     */
    EmailMessageSchema.VotingInformation = new ComplexPropertyDefinition("VotingInformation", XmlElementNames.VotingInformation, FieldUris.VotingInformation, PropertyDefinitionFlags.None, ExchangeVersion.Exchange2013, function () { return new VotingInformation(); });
    /**
     * @internal Instance of **EmailMessageSchema**
     */
    EmailMessageSchema.Instance = new EmailMessageSchema();
    return EmailMessageSchema;
}(ItemSchema));
exports.EmailMessageSchema = EmailMessageSchema;
Schemas.EmailMessageSchema = EmailMessageSchema;
/**
 * Field URIs for MeetingMessage.
 */
(function (FieldUris) {
    FieldUris.AssociatedCalendarItemId = "meeting:AssociatedCalendarItemId";
    FieldUris.IsDelegated = "meeting:IsDelegated";
    FieldUris.IsOutOfDate = "meeting:IsOutOfDate";
    FieldUris.HasBeenProcessed = "meeting:HasBeenProcessed";
    FieldUris.ResponseType = "meeting:ResponseType";
    FieldUris.IsOrganizer = "cal:IsOrganizer";
})(FieldUris || (FieldUris = {}));
/**
 * Represents the schema for meeting messages.
 */
var MeetingMessageSchema = (function (_super) {
    __extends(MeetingMessageSchema, _super);
    function MeetingMessageSchema() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Registers properties.
     *
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    MeetingMessageSchema.prototype.RegisterProperties = function () {
        _super.prototype.RegisterProperties.call(this);
        this.RegisterProperty(MeetingMessageSchema, MeetingMessageSchema.AssociatedAppointmentId);
        this.RegisterProperty(MeetingMessageSchema, MeetingMessageSchema.IsDelegated);
        this.RegisterProperty(MeetingMessageSchema, MeetingMessageSchema.IsOutOfDate);
        this.RegisterProperty(MeetingMessageSchema, MeetingMessageSchema.HasBeenProcessed);
        this.RegisterProperty(MeetingMessageSchema, MeetingMessageSchema.ResponseType);
        this.RegisterProperty(MeetingMessageSchema, MeetingMessageSchema.ICalUid);
        this.RegisterProperty(MeetingMessageSchema, MeetingMessageSchema.ICalRecurrenceId);
        this.RegisterProperty(MeetingMessageSchema, MeetingMessageSchema.ICalDateTimeStamp);
        this.RegisterProperty(MeetingMessageSchema, MeetingMessageSchema.IsOrganizer);
    };
    /**
     * Defines the **AssociatedAppointmentId** property.
     */
    MeetingMessageSchema.AssociatedAppointmentId = new ComplexPropertyDefinition("AssociatedCalendarItemId", XmlElementNames.AssociatedCalendarItemId, FieldUris.AssociatedCalendarItemId, PropertyDefinitionFlags.None, ExchangeVersion.Exchange2007_SP1, function () { return new ItemId(); });
    /**
     * Defines the **IsDelegated** property.
     */
    MeetingMessageSchema.IsDelegated = new BoolPropertyDefinition("IsDelegated", XmlElementNames.IsDelegated, FieldUris.IsDelegated, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **IsOutOfDate** property.
     */
    MeetingMessageSchema.IsOutOfDate = new BoolPropertyDefinition("IsOutOfDate", XmlElementNames.IsOutOfDate, FieldUris.IsOutOfDate, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **HasBeenProcessed** property.
     */
    MeetingMessageSchema.HasBeenProcessed = new BoolPropertyDefinition("HasBeenProcessed", XmlElementNames.HasBeenProcessed, FieldUris.HasBeenProcessed, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **ResponseType** property.
     */
    MeetingMessageSchema.ResponseType = new GenericPropertyDefinition("ResponseType", XmlElementNames.ResponseType, FieldUris.ResponseType, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, MeetingResponseType);
    /**
     * Defines the **ICalUid** property.
     */
    MeetingMessageSchema.ICalUid = Schemas.AppointmentSchema.ICalUid;
    /**
     * Defines the **ICalRecurrenceId** property.
     */
    MeetingMessageSchema.ICalRecurrenceId = Schemas.AppointmentSchema.ICalRecurrenceId;
    /**
     * Defines the **ICalDateTimeStamp** property.
     */
    MeetingMessageSchema.ICalDateTimeStamp = Schemas.AppointmentSchema.ICalDateTimeStamp;
    /**
     * Defines the **IsOrganizer** property.
     */
    MeetingMessageSchema.IsOrganizer = new GenericPropertyDefinition("IsOrganizer", XmlElementNames.IsOrganizer, "cal:IsOrganizer", PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013, false //isNullable
    );
    /**
     * @internal Instance of **MeetingMessageSchema**
     */
    MeetingMessageSchema.Instance = new MeetingMessageSchema();
    return MeetingMessageSchema;
}(EmailMessageSchema));
exports.MeetingMessageSchema = MeetingMessageSchema;
Schemas.MeetingMessageSchema = MeetingMessageSchema;
/**
 * Represents the schema for meeting cancellation.
 */
var MeetingCancellationSchema = (function (_super) {
    __extends(MeetingCancellationSchema, _super);
    function MeetingCancellationSchema() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Registers properties.
     *
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    MeetingCancellationSchema.prototype.RegisterProperties = function () {
        _super.prototype.RegisterProperties.call(this);
        this.RegisterProperty(MeetingCancellationSchema, MeetingCancellationSchema.Start);
        this.RegisterProperty(MeetingCancellationSchema, MeetingCancellationSchema.End);
        this.RegisterProperty(MeetingCancellationSchema, MeetingCancellationSchema.Location);
        this.RegisterProperty(MeetingCancellationSchema, MeetingCancellationSchema.Recurrence);
        this.RegisterProperty(MeetingCancellationSchema, MeetingCancellationSchema.AppointmentType);
        this.RegisterProperty(MeetingCancellationSchema, MeetingCancellationSchema.EnhancedLocation);
    };
    /**
     * Defines the **Start** property.
     */
    MeetingCancellationSchema.Start = Schemas.AppointmentSchema.Start;
    /**
     * Defines the **End** property.
     */
    MeetingCancellationSchema.End = Schemas.AppointmentSchema.End;
    /**
     * Defines the **Location** property.
     */
    MeetingCancellationSchema.Location = Schemas.AppointmentSchema.Location;
    /**
     * Defines the **AppointmentType** property.
     */
    MeetingCancellationSchema.AppointmentType = Schemas.AppointmentSchema.AppointmentType;
    /**
     * Defines the **Recurrence** property.
     */
    MeetingCancellationSchema.Recurrence = Schemas.AppointmentSchema.Recurrence;
    /**
     * Defines the **EnhancedLocation** property.
     */
    MeetingCancellationSchema.EnhancedLocation = Schemas.AppointmentSchema.EnhancedLocation;
    /**
     * @internal Instance of **MeetingCancellationSchema**
     */
    MeetingCancellationSchema.Instance = new MeetingCancellationSchema();
    return MeetingCancellationSchema;
}(MeetingMessageSchema));
exports.MeetingCancellationSchema = MeetingCancellationSchema;
Schemas.MeetingCancellationSchema = MeetingCancellationSchema;
/**
 * Field URIs for meeting response.
 */
(function (FieldUris) {
    FieldUris.ProposedStart = "meeting:ProposedStart";
    FieldUris.ProposedEnd = "meeting:ProposedEnd";
})(FieldUris || (FieldUris = {}));
/**
 * Represents the schema for meeting response
 */
var MeetingResponseSchema = (function (_super) {
    __extends(MeetingResponseSchema, _super);
    function MeetingResponseSchema() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Registers properties.
     *
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    MeetingResponseSchema.prototype.RegisterProperties = function () {
        _super.prototype.RegisterProperties.call(this);
        this.RegisterProperty(MeetingResponseSchema, MeetingResponseSchema.Start);
        this.RegisterProperty(MeetingResponseSchema, MeetingResponseSchema.End);
        this.RegisterProperty(MeetingResponseSchema, MeetingResponseSchema.Location);
        this.RegisterProperty(MeetingResponseSchema, MeetingResponseSchema.Recurrence);
        this.RegisterProperty(MeetingResponseSchema, MeetingResponseSchema.AppointmentType);
        this.RegisterProperty(MeetingResponseSchema, MeetingResponseSchema.ProposedStart);
        this.RegisterProperty(MeetingResponseSchema, MeetingResponseSchema.ProposedEnd);
        this.RegisterProperty(MeetingResponseSchema, MeetingResponseSchema.EnhancedLocation);
    };
    /**
     * Defines the **Start** property.
     */
    MeetingResponseSchema.Start = Schemas.AppointmentSchema.Start;
    /**
     * Defines the **End** property.
     */
    MeetingResponseSchema.End = Schemas.AppointmentSchema.End;
    /**
     * Defines the **Location** property.
     */
    MeetingResponseSchema.Location = Schemas.AppointmentSchema.Location;
    /**
     * Defines the **AppointmentType** property.
     */
    MeetingResponseSchema.AppointmentType = Schemas.AppointmentSchema.AppointmentType;
    /**
     * Defines the **Recurrence** property.
     */
    MeetingResponseSchema.Recurrence = Schemas.AppointmentSchema.Recurrence;
    /**
     * Defines the **ProposedStart** property.
     */
    MeetingResponseSchema.ProposedStart = new ScopedDateTimePropertyDefinition("ProposedStart", XmlElementNames.ProposedStart, FieldUris.ProposedStart, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013, function (version) { return Schemas.AppointmentSchema.StartTimeZone; });
    /**
     * Defines the **ProposedEnd** property.
     */
    MeetingResponseSchema.ProposedEnd = new ScopedDateTimePropertyDefinition("ProposedEnd", XmlElementNames.ProposedEnd, FieldUris.ProposedEnd, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2013, function (version) { return Schemas.AppointmentSchema.EndTimeZone; });
    /**
     * Defines the **EnhancedLocation** property.
     */
    MeetingResponseSchema.EnhancedLocation = Schemas.AppointmentSchema.EnhancedLocation;
    /**
     * @internal Instance of **MeetingResponseSchema**
     */
    MeetingResponseSchema.Instance = new MeetingResponseSchema();
    return MeetingResponseSchema;
}(MeetingMessageSchema));
exports.MeetingResponseSchema = MeetingResponseSchema;
Schemas.MeetingResponseSchema = MeetingResponseSchema;
/**
 * Field URIs for meeting request.
 */
(function (FieldUris) {
    FieldUris.MeetingRequestType = "meetingRequest:MeetingRequestType";
    FieldUris.IntendedFreeBusyStatus = "meetingRequest:IntendedFreeBusyStatus";
    FieldUris.ChangeHighlights = "meetingRequest:ChangeHighlights";
})(FieldUris || (FieldUris = {}));
/**
 * Represents the schema for meeting requests.
 */
var MeetingRequestSchema = (function (_super) {
    __extends(MeetingRequestSchema, _super);
    function MeetingRequestSchema() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Registers properties.
     *
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    MeetingRequestSchema.prototype.RegisterProperties = function () {
        _super.prototype.RegisterProperties.call(this);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.MeetingRequestType);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.IntendedFreeBusyStatus);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.ChangeHighlights);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.Start);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.End);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.OriginalStart);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.IsAllDayEvent);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.LegacyFreeBusyStatus);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.Location);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.When);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.IsMeeting);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.IsCancelled);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.IsRecurring);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.MeetingRequestWasSent);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.AppointmentType);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.MyResponseType);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.Organizer);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.RequiredAttendees);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.OptionalAttendees);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.Resources);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.ConflictingMeetingCount);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.AdjacentMeetingCount);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.ConflictingMeetings);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.AdjacentMeetings);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.Duration);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.TimeZone);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.AppointmentReplyTime);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.AppointmentSequenceNumber);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.AppointmentState);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.Recurrence);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.FirstOccurrence);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.LastOccurrence);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.ModifiedOccurrences);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.DeletedOccurrences);
        this.RegisterInternalProperty(MeetingRequestSchema, MeetingRequestSchema.MeetingTimeZone);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.StartTimeZone);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.EndTimeZone);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.ConferenceType);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.AllowNewTimeProposal);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.IsOnlineMeeting);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.MeetingWorkspaceUrl);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.NetShowUrl);
        this.RegisterProperty(MeetingRequestSchema, MeetingRequestSchema.EnhancedLocation);
    };
    /**
     * Defines the **MeetingRequestType** property.
     */
    MeetingRequestSchema.MeetingRequestType = new GenericPropertyDefinition("MeetingRequestType", XmlElementNames.MeetingRequestType, FieldUris.MeetingRequestType, PropertyDefinitionFlags.None, ExchangeVersion.Exchange2007_SP1, MeetingRequestType);
    /**
     * Defines the **IntendedFreeBusyStatus** property.
     */
    MeetingRequestSchema.IntendedFreeBusyStatus = new GenericPropertyDefinition("IntendedFreeBusyStatus", XmlElementNames.IntendedFreeBusyStatus, FieldUris.IntendedFreeBusyStatus, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, LegacyFreeBusyStatus);
    /**
     * Defines the **ChangeHighlights** property.
     */
    MeetingRequestSchema.ChangeHighlights = new ComplexPropertyDefinition("ChangeHighlights", XmlElementNames.ChangeHighlights, FieldUris.ChangeHighlights, PropertyDefinitionFlags.None, ExchangeVersion.Exchange2013, function () { return new ChangeHighlights(); });
    /**
     * Defines the **EnhancedLocation** property.
     */
    MeetingRequestSchema.EnhancedLocation = Schemas.AppointmentSchema.EnhancedLocation;
    /**
     * Defines the **Start** property.
     */
    MeetingRequestSchema.Start = Schemas.AppointmentSchema.Start;
    /**
     * Defines the **End** property.
     */
    MeetingRequestSchema.End = Schemas.AppointmentSchema.End;
    /**
     * Defines the **OriginalStart** property.
     */
    MeetingRequestSchema.OriginalStart = Schemas.AppointmentSchema.OriginalStart;
    /**
     * Defines the **IsAllDayEvent** property.
     */
    MeetingRequestSchema.IsAllDayEvent = Schemas.AppointmentSchema.IsAllDayEvent;
    /**
     * Defines the **LegacyFreeBusyStatus** property.
     */
    MeetingRequestSchema.LegacyFreeBusyStatus = Schemas.AppointmentSchema.LegacyFreeBusyStatus;
    /**
     * Defines the **Location** property.
     */
    MeetingRequestSchema.Location = Schemas.AppointmentSchema.Location;
    /**
     * Defines the **When** property.
     */
    MeetingRequestSchema.When = Schemas.AppointmentSchema.When;
    /**
     * Defines the **IsMeeting** property.
     */
    MeetingRequestSchema.IsMeeting = Schemas.AppointmentSchema.IsMeeting;
    /**
     * Defines the **IsCancelled** property.
     */
    MeetingRequestSchema.IsCancelled = Schemas.AppointmentSchema.IsCancelled;
    /**
     * Defines the **IsRecurring** property.
     */
    MeetingRequestSchema.IsRecurring = Schemas.AppointmentSchema.IsRecurring;
    /**
     * Defines the **MeetingRequestWasSent** property.
     */
    MeetingRequestSchema.MeetingRequestWasSent = Schemas.AppointmentSchema.MeetingRequestWasSent;
    /**
     * Defines the **AppointmentType** property.
     */
    MeetingRequestSchema.AppointmentType = Schemas.AppointmentSchema.AppointmentType;
    /**
     * Defines the **MyResponseType** property.
     */
    MeetingRequestSchema.MyResponseType = Schemas.AppointmentSchema.MyResponseType;
    /**
     * Defines the **Organizer** property.
     */
    MeetingRequestSchema.Organizer = Schemas.AppointmentSchema.Organizer;
    /**
     * Defines the **RequiredAttendees** property.
     */
    MeetingRequestSchema.RequiredAttendees = Schemas.AppointmentSchema.RequiredAttendees;
    /**
     * Defines the **OptionalAttendees** property.
     */
    MeetingRequestSchema.OptionalAttendees = Schemas.AppointmentSchema.OptionalAttendees;
    /**
     * Defines the **Resources** property.
     */
    MeetingRequestSchema.Resources = Schemas.AppointmentSchema.Resources;
    /**
     * Defines the **ConflictingMeetingCount** property.
     */
    MeetingRequestSchema.ConflictingMeetingCount = Schemas.AppointmentSchema.ConflictingMeetingCount;
    /**
     * Defines the **AdjacentMeetingCount** property.
     */
    MeetingRequestSchema.AdjacentMeetingCount = Schemas.AppointmentSchema.AdjacentMeetingCount;
    /**
     * Defines the **ConflictingMeetings** property.
     */
    MeetingRequestSchema.ConflictingMeetings = Schemas.AppointmentSchema.ConflictingMeetings;
    /**
     * Defines the **AdjacentMeetings** property.
     */
    MeetingRequestSchema.AdjacentMeetings = Schemas.AppointmentSchema.AdjacentMeetings;
    /**
     * Defines the **Duration** property.
     */
    MeetingRequestSchema.Duration = Schemas.AppointmentSchema.Duration;
    /**
     * Defines the **TimeZone** property.
     */
    MeetingRequestSchema.TimeZone = Schemas.AppointmentSchema.TimeZone;
    /**
     * Defines the **AppointmentReplyTime** property.
     */
    MeetingRequestSchema.AppointmentReplyTime = Schemas.AppointmentSchema.AppointmentReplyTime;
    /**
     * Defines the **AppointmentSequenceNumber** property.
     */
    MeetingRequestSchema.AppointmentSequenceNumber = Schemas.AppointmentSchema.AppointmentSequenceNumber;
    /**
     * Defines the **AppointmentState** property.
     */
    MeetingRequestSchema.AppointmentState = Schemas.AppointmentSchema.AppointmentState;
    /**
     * Defines the **Recurrence** property.
     */
    MeetingRequestSchema.Recurrence = Schemas.AppointmentSchema.Recurrence;
    /**
     * Defines the **FirstOccurrence** property.
     */
    MeetingRequestSchema.FirstOccurrence = Schemas.AppointmentSchema.FirstOccurrence;
    /**
     * Defines the **LastOccurrence** property.
     */
    MeetingRequestSchema.LastOccurrence = Schemas.AppointmentSchema.LastOccurrence;
    /**
     * Defines the **ModifiedOccurrences** property.
     */
    MeetingRequestSchema.ModifiedOccurrences = Schemas.AppointmentSchema.ModifiedOccurrences;
    /**
     * Defines the **DeletedOccurrences** property.
     */
    MeetingRequestSchema.DeletedOccurrences = Schemas.AppointmentSchema.DeletedOccurrences;
    /**
     * Defines the **MeetingTimeZone** property.
     */
    MeetingRequestSchema.MeetingTimeZone = Schemas.AppointmentSchema.MeetingTimeZone;
    /**
     * Defines the **StartTimeZone** property.
     */
    MeetingRequestSchema.StartTimeZone = Schemas.AppointmentSchema.StartTimeZone;
    /**
     * Defines the **EndTimeZone** property.
     */
    MeetingRequestSchema.EndTimeZone = Schemas.AppointmentSchema.EndTimeZone;
    /**
     * Defines the **ConferenceType** property.
     */
    MeetingRequestSchema.ConferenceType = Schemas.AppointmentSchema.ConferenceType;
    /**
     * Defines the **AllowNewTimeProposal** property.
     */
    MeetingRequestSchema.AllowNewTimeProposal = Schemas.AppointmentSchema.AllowNewTimeProposal;
    /**
     * Defines the **IsOnlineMeeting** property.
     */
    MeetingRequestSchema.IsOnlineMeeting = Schemas.AppointmentSchema.IsOnlineMeeting;
    /**
     * Defines the **MeetingWorkspaceUrl** property.
     */
    MeetingRequestSchema.MeetingWorkspaceUrl = Schemas.AppointmentSchema.MeetingWorkspaceUrl;
    /**
     * Defines the **NetShowUrl** property.
     */
    MeetingRequestSchema.NetShowUrl = Schemas.AppointmentSchema.NetShowUrl;
    /**
     * @internal Instance of **MeetingRequestSchema**
     */
    MeetingRequestSchema.Instance = new MeetingRequestSchema();
    return MeetingRequestSchema;
}(MeetingMessageSchema));
exports.MeetingRequestSchema = MeetingRequestSchema;
Schemas.MeetingRequestSchema = MeetingRequestSchema;
/**
 * Field URIs for PostItem.
 */
(function (FieldUris) {
    FieldUris.PostedTime = "postitem:PostedTime";
})(FieldUris || (FieldUris = {}));
/**
 * Represents the schema for post items.
 */
var PostItemSchema = (function (_super) {
    __extends(PostItemSchema, _super);
    function PostItemSchema() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Registers properties.
     *
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    PostItemSchema.prototype.RegisterProperties = function () {
        _super.prototype.RegisterProperties.call(this);
        this.RegisterProperty(PostItemSchema, PostItemSchema.ConversationIndex);
        this.RegisterProperty(PostItemSchema, PostItemSchema.ConversationTopic);
        this.RegisterProperty(PostItemSchema, PostItemSchema.From);
        this.RegisterProperty(PostItemSchema, PostItemSchema.InternetMessageId);
        this.RegisterProperty(PostItemSchema, PostItemSchema.IsRead);
        this.RegisterProperty(PostItemSchema, PostItemSchema.PostedTime);
        this.RegisterProperty(PostItemSchema, PostItemSchema.References);
        this.RegisterProperty(PostItemSchema, PostItemSchema.Sender);
    };
    /**
     * Defines the **ConversationIndex** property.
     */
    PostItemSchema.ConversationIndex = Schemas.EmailMessageSchema.ConversationIndex;
    /**
     * Defines the **ConversationTopic** property.
     */
    PostItemSchema.ConversationTopic = Schemas.EmailMessageSchema.ConversationTopic;
    /**
     * Defines the **From** property.
     */
    PostItemSchema.From = Schemas.EmailMessageSchema.From;
    /**
     * Defines the **InternetMessageId** property.
     */
    PostItemSchema.InternetMessageId = Schemas.EmailMessageSchema.InternetMessageId;
    /**
     * Defines the **IsRead** property.
     */
    PostItemSchema.IsRead = Schemas.EmailMessageSchema.IsRead;
    /**
     * Defines the **PostedTime** property.
     */
    PostItemSchema.PostedTime = new DateTimePropertyDefinition("PostedTime", XmlElementNames.PostedTime, FieldUris.PostedTime, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **References** property.
     */
    PostItemSchema.References = Schemas.EmailMessageSchema.References;
    /**
     * Defines the **Sender** property.
     */
    PostItemSchema.Sender = Schemas.EmailMessageSchema.Sender;
    /**
     * @internal Instance of **PostItemSchema**
     */
    PostItemSchema.Instance = new PostItemSchema();
    return PostItemSchema;
}(ItemSchema));
exports.PostItemSchema = PostItemSchema;
Schemas.PostItemSchema = PostItemSchema;
/**
 * Field URIs for tasks.
 */
(function (FieldUris) {
    FieldUris.ActualWork = "task:ActualWork";
    FieldUris.AssignedTime = "task:AssignedTime";
    FieldUris.BillingInformation = "task:BillingInformation";
    FieldUris.ChangeCount = "task:ChangeCount";
    FieldUris.Companies = "task:Companies";
    FieldUris.CompleteDate = "task:CompleteDate";
    FieldUris.Contacts = "task:Contacts";
    FieldUris.DelegationState = "task:DelegationState";
    FieldUris.Delegator = "task:Delegator";
    FieldUris.DueDate = "task:DueDate";
    FieldUris.IsAssignmentEditable = "task:IsAssignmentEditable";
    FieldUris.IsComplete = "task:IsComplete";
    FieldUris.IsRecurring = "task:IsRecurring";
    FieldUris.IsTeamTask = "task:IsTeamTask";
    FieldUris.Mileage = "task:Mileage";
    FieldUris.Owner = "task:Owner";
    FieldUris.PercentComplete = "task:PercentComplete";
    FieldUris.Recurrence = "task:Recurrence";
    FieldUris.StartDate = "task:StartDate";
    FieldUris.Status = "task:Status";
    FieldUris.StatusDescription = "task:StatusDescription";
    FieldUris.TotalWork = "task:TotalWork";
})(FieldUris || (FieldUris = {}));
/**
 * Represents the schema for task items.
 */
var TaskSchema = (function (_super) {
    __extends(TaskSchema, _super);
    function TaskSchema() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Registers properties.
     *
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    TaskSchema.prototype.RegisterProperties = function () {
        _super.prototype.RegisterProperties.call(this);
        this.RegisterProperty(TaskSchema, TaskSchema.ActualWork);
        this.RegisterProperty(TaskSchema, TaskSchema.AssignedTime);
        this.RegisterProperty(TaskSchema, TaskSchema.BillingInformation);
        this.RegisterProperty(TaskSchema, TaskSchema.ChangeCount);
        this.RegisterProperty(TaskSchema, TaskSchema.Companies);
        this.RegisterProperty(TaskSchema, TaskSchema.CompleteDate);
        this.RegisterProperty(TaskSchema, TaskSchema.Contacts);
        this.RegisterProperty(TaskSchema, TaskSchema.DelegationState);
        this.RegisterProperty(TaskSchema, TaskSchema.Delegator);
        this.RegisterProperty(TaskSchema, TaskSchema.DueDate);
        this.RegisterProperty(TaskSchema, TaskSchema.Mode);
        this.RegisterProperty(TaskSchema, TaskSchema.IsComplete);
        this.RegisterProperty(TaskSchema, TaskSchema.IsRecurring);
        this.RegisterProperty(TaskSchema, TaskSchema.IsTeamTask);
        this.RegisterProperty(TaskSchema, TaskSchema.Mileage);
        this.RegisterProperty(TaskSchema, TaskSchema.Owner);
        this.RegisterProperty(TaskSchema, TaskSchema.PercentComplete);
        this.RegisterProperty(TaskSchema, TaskSchema.Recurrence);
        this.RegisterProperty(TaskSchema, TaskSchema.StartDate);
        this.RegisterProperty(TaskSchema, TaskSchema.Status);
        this.RegisterProperty(TaskSchema, TaskSchema.StatusDescription);
        this.RegisterProperty(TaskSchema, TaskSchema.TotalWork);
    };
    /**
     * Defines the **ActualWork** property.
     */
    TaskSchema.ActualWork = new IntPropertyDefinition("ActualWork", XmlElementNames.ActualWork, FieldUris.ActualWork, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, true);
    /**
     * Defines the **AssignedTime** property.
     */
    TaskSchema.AssignedTime = new DateTimePropertyDefinition("AssignedTime", XmlElementNames.AssignedTime, FieldUris.AssignedTime, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, true);
    /**
     * Defines the **BillingInformation** property.
     */
    TaskSchema.BillingInformation = new StringPropertyDefinition("BillingInformation", XmlElementNames.BillingInformation, FieldUris.BillingInformation, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **ChangeCount** property.
     */
    TaskSchema.ChangeCount = new IntPropertyDefinition("ChangeCount", XmlElementNames.ChangeCount, FieldUris.ChangeCount, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **Companies** property.
     */
    TaskSchema.Companies = new ComplexPropertyDefinition("Companies", XmlElementNames.Companies, FieldUris.Companies, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, function () { return new StringList(); });
    /**
     * Defines the **CompleteDate** property.
     */
    TaskSchema.CompleteDate = new DateTimePropertyDefinition("CompleteDate", XmlElementNames.CompleteDate, FieldUris.CompleteDate, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, true);
    /**
     * Defines the **Contacts** property.
     */
    TaskSchema.Contacts = new ComplexPropertyDefinition("Contacts", XmlElementNames.Contacts, FieldUris.Contacts, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, function () { return new StringList(); });
    /**
     * Defines the **DelegationState** property.
     */
    TaskSchema.DelegationState = new TaskDelegationStatePropertyDefinition("DelegationState", XmlElementNames.DelegationState, FieldUris.DelegationState, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **Delegator** property.
     */
    TaskSchema.Delegator = new StringPropertyDefinition("Delegator", XmlElementNames.Delegator, FieldUris.Delegator, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **DueDate** property.
     */
    TaskSchema.DueDate = new DateTimePropertyDefinition("DueDate", XmlElementNames.DueDate, FieldUris.DueDate, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, true);
    /**
     * Defines the **Mode** property.
     */
    TaskSchema.Mode = new GenericPropertyDefinition("IsAssignmentEditable", XmlElementNames.IsAssignmentEditable, FieldUris.IsAssignmentEditable, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, TaskMode);
    /**
     * Defines the **IsComplete** property.
     */
    TaskSchema.IsComplete = new BoolPropertyDefinition("IsComplete", XmlElementNames.IsComplete, FieldUris.IsComplete, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **IsRecurring** property.
     */
    TaskSchema.IsRecurring = new BoolPropertyDefinition("IsRecurring", XmlElementNames.IsRecurring, FieldUris.IsRecurring, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **IsTeamTask** property.
     */
    TaskSchema.IsTeamTask = new BoolPropertyDefinition("IsTeamTask", XmlElementNames.IsTeamTask, FieldUris.IsTeamTask, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **Mileage** property.
     */
    TaskSchema.Mileage = new StringPropertyDefinition("Mileage", XmlElementNames.Mileage, FieldUris.Mileage, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **Owner** property.
     */
    TaskSchema.Owner = new StringPropertyDefinition("Owner", XmlElementNames.Owner, FieldUris.Owner, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **PercentComplete** property.
     */
    TaskSchema.PercentComplete = new DoublePropertyDefinition("PercentComplete", XmlElementNames.PercentComplete, FieldUris.PercentComplete, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **Recurrence** property.
     */
    TaskSchema.Recurrence = new RecurrencePropertyDefinition("Recurrence", XmlElementNames.Recurrence, FieldUris.Recurrence, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **StartDate** property.
     */
    TaskSchema.StartDate = new DateTimePropertyDefinition("StartDate", XmlElementNames.StartDate, FieldUris.StartDate, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, true);
    /**
     * Defines the **Status** property.
     */
    TaskSchema.Status = new GenericPropertyDefinition("Status", XmlElementNames.Status, FieldUris.Status, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, TaskStatus);
    /**
     * Defines the **StatusDescription** property.
     */
    TaskSchema.StatusDescription = new StringPropertyDefinition("StatusDescription", XmlElementNames.StatusDescription, FieldUris.StatusDescription, PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1);
    /**
     * Defines the **TotalWork** property.
     */
    TaskSchema.TotalWork = new IntPropertyDefinition("TotalWork", XmlElementNames.TotalWork, FieldUris.TotalWork, PropertyDefinitionFlags.CanSet | PropertyDefinitionFlags.CanUpdate | PropertyDefinitionFlags.CanDelete | PropertyDefinitionFlags.CanFind, ExchangeVersion.Exchange2007_SP1, true);
    /**
     * @internal Instance of **TaskSchema**
     */
    TaskSchema.Instance = new TaskSchema();
    return TaskSchema;
}(ItemSchema));
exports.TaskSchema = TaskSchema;
Schemas.TaskSchema = TaskSchema;
/**
 * Represents ResponseObject schema definition.
 */
var ResponseObjectSchema = (function (_super) {
    __extends(ResponseObjectSchema, _super);
    function ResponseObjectSchema() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Registers properties.
     *
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    ResponseObjectSchema.prototype.RegisterProperties = function () {
        _super.prototype.RegisterProperties.call(this);
        this.RegisterProperty(ResponseObjectSchema, ResponseObjectSchema.ReferenceItemId);
    };
    /**
     * Defines the **ReferenceItemId** property.
     */
    ResponseObjectSchema.ReferenceItemId = new ComplexPropertyDefinition("ReferenceItemId", XmlElementNames.ReferenceItemId, PropertyDefinitionFlags.AutoInstantiateOnRead | PropertyDefinitionFlags.CanSet, ExchangeVersion.Exchange2007_SP1, function () { return new ItemId(); });
    /**
     * Defines the **BodyPrefix** property.
     */
    ResponseObjectSchema.BodyPrefix = new ComplexPropertyDefinition("NewBodyContent", XmlElementNames.NewBodyContent, PropertyDefinitionFlags.CanSet, ExchangeVersion.Exchange2007_SP1, function () { return new MessageBody(); });
    /**
     * @internal Instance of **ResponseObjectSchema**
     */
    ResponseObjectSchema.Instance = new ResponseObjectSchema();
    return ResponseObjectSchema;
}(ServiceObjectSchema));
exports.ResponseObjectSchema = ResponseObjectSchema;
Schemas.ResponseObjectSchema = ResponseObjectSchema;
/**
 * Represents PostReply schema definition.
 */
var PostReplySchema = (function (_super) {
    __extends(PostReplySchema, _super);
    function PostReplySchema() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Registers properties.
     *
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    PostReplySchema.prototype.RegisterProperties = function () {
        _super.prototype.RegisterProperties.call(this);
        this.RegisterProperty(PostReplySchema, Schemas.ItemSchema.Subject);
        this.RegisterProperty(PostReplySchema, Schemas.ItemSchema.Body);
        this.RegisterProperty(PostReplySchema, Schemas.ResponseObjectSchema.ReferenceItemId);
        this.RegisterProperty(PostReplySchema, Schemas.ResponseObjectSchema.BodyPrefix);
    };
    /**
     * @internal Instance of **PostReplySchema**
     */
    PostReplySchema.Instance = new PostReplySchema();
    return PostReplySchema;
}(ServiceObjectSchema));
exports.PostReplySchema = PostReplySchema;
Schemas.PostReplySchema = PostReplySchema;
/**
 * Represents ResponseMessage schema definition.
 */
var ResponseMessageSchema = (function (_super) {
    __extends(ResponseMessageSchema, _super);
    function ResponseMessageSchema() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Registers properties.
     *
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    ResponseMessageSchema.prototype.RegisterProperties = function () {
        _super.prototype.RegisterProperties.call(this);
        this.RegisterProperty(ResponseMessageSchema, Schemas.ItemSchema.Subject);
        this.RegisterProperty(ResponseMessageSchema, Schemas.ItemSchema.Body);
        this.RegisterProperty(ResponseMessageSchema, Schemas.EmailMessageSchema.ToRecipients);
        this.RegisterProperty(ResponseMessageSchema, Schemas.EmailMessageSchema.CcRecipients);
        this.RegisterProperty(ResponseMessageSchema, Schemas.EmailMessageSchema.BccRecipients);
        this.RegisterProperty(ResponseMessageSchema, Schemas.EmailMessageSchema.IsReadReceiptRequested);
        this.RegisterProperty(ResponseMessageSchema, Schemas.EmailMessageSchema.IsDeliveryReceiptRequested);
        this.RegisterProperty(ResponseMessageSchema, Schemas.ResponseObjectSchema.ReferenceItemId);
        this.RegisterProperty(ResponseMessageSchema, Schemas.ResponseObjectSchema.BodyPrefix);
    };
    /**
     * @internal Instance of **ResponseMessageSchema**
     */
    ResponseMessageSchema.Instance = new ResponseMessageSchema();
    return ResponseMessageSchema;
}(ServiceObjectSchema));
exports.ResponseMessageSchema = ResponseMessageSchema;
Schemas.ResponseMessageSchema = ResponseMessageSchema;
/**
 * Represents CancelMeetingMessage schema definition.
 */
var CancelMeetingMessageSchema = (function (_super) {
    __extends(CancelMeetingMessageSchema, _super);
    function CancelMeetingMessageSchema() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Registers properties.
     *
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    CancelMeetingMessageSchema.prototype.RegisterProperties = function () {
        _super.prototype.RegisterProperties.call(this);
        this.RegisterProperty(CancelMeetingMessageSchema, Schemas.EmailMessageSchema.IsReadReceiptRequested);
        this.RegisterProperty(CancelMeetingMessageSchema, Schemas.EmailMessageSchema.IsDeliveryReceiptRequested);
        this.RegisterProperty(CancelMeetingMessageSchema, Schemas.ResponseObjectSchema.ReferenceItemId);
        this.RegisterProperty(CancelMeetingMessageSchema, CancelMeetingMessageSchema.Body);
    };
    /**
     * Defines the **Body** property.
     */
    CancelMeetingMessageSchema.Body = new ComplexPropertyDefinition("Body", XmlElementNames.NewBodyContent, PropertyDefinitionFlags.CanSet, ExchangeVersion.Exchange2007_SP1, function () { return new MessageBody(); });
    /**
     * @internal Instance of **CancelMeetingMessageSchema**
     */
    CancelMeetingMessageSchema.Instance = new CancelMeetingMessageSchema();
    return CancelMeetingMessageSchema;
}(ServiceObjectSchema));
exports.CancelMeetingMessageSchema = CancelMeetingMessageSchema;
Schemas.CancelMeetingMessageSchema = CancelMeetingMessageSchema;
/**
 * Represents CalendarResponseObject schema definition.
 */
var CalendarResponseObjectSchema = (function (_super) {
    __extends(CalendarResponseObjectSchema, _super);
    function CalendarResponseObjectSchema() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Registers properties.
     *
     * /remarks/    IMPORTANT NOTE: PROPERTIES MUST BE REGISTERED IN SCHEMA ORDER (i.e. the same order as they are defined in types.xsd)
     */
    CalendarResponseObjectSchema.prototype.RegisterProperties = function () {
        _super.prototype.RegisterProperties.call(this);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.ItemSchema.ItemClass);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.ItemSchema.Sensitivity);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.ItemSchema.Body);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.ItemSchema.Attachments);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.ItemSchema.InternetMessageHeaders);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.EmailMessageSchema.Sender);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.EmailMessageSchema.ToRecipients);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.EmailMessageSchema.CcRecipients);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.EmailMessageSchema.BccRecipients);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.EmailMessageSchema.IsReadReceiptRequested);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.EmailMessageSchema.IsDeliveryReceiptRequested);
        this.RegisterProperty(CalendarResponseObjectSchema, Schemas.ResponseObjectSchema.ReferenceItemId);
    };
    /**
     * @internal Instance of **CalendarResponseObjectSchema**
     */
    CalendarResponseObjectSchema.Instance = new CalendarResponseObjectSchema();
    return CalendarResponseObjectSchema;
}(ServiceObjectSchema));
exports.CalendarResponseObjectSchema = CalendarResponseObjectSchema;
Schemas.CalendarResponseObjectSchema = CalendarResponseObjectSchema;
/** @internal */
var ConfigurationSettingsBase = (function () {
    function ConfigurationSettingsBase() {
    }
    ConfigurationSettingsBase.prototype.ConvertSettings = function (smtpAddress, requestedSettings) { throw new Error("ConfigurationSettingsBase.ts - ConvertSettings : Not implemented."); };
    ConfigurationSettingsBase.prototype.GetNamespace = function () { throw new Error("ConfigurationSettingsBase.ts - GetNamespace : Not implemented."); };
    //LoadFromXml(reader: EwsXmlReader): any { throw new Error("ConfigurationSettingsBase.ts - LoadFromXml : Not implemented."); }
    ConfigurationSettingsBase.prototype.MakeRedirectionResponse = function (redirectUrl) { throw new Error("ConfigurationSettingsBase.ts - MakeRedirectionResponse : Not implemented."); };
    return ConfigurationSettingsBase;
}());
exports.ConfigurationSettingsBase = ConfigurationSettingsBase;
/** @internal */
var OutlookAccount = (function () {
    function OutlookAccount() {
    }
    OutlookAccount.prototype.ConvertToUserSettings = function (requestedSettings, // System.Collections.Generic.List<Microsoft.Exchange.WebServices.Autodiscover.UserSettingName>,
        response) { throw new Error("OutlookAccount.ts - response: GetUserSettingsResponse): any { throw new Error : Not implemented."); };
    OutlookAccount.Settings = "settings";
    OutlookAccount.RedirectAddr = "redirectAddr";
    OutlookAccount.RedirectUrl = "redirectUrl";
    return OutlookAccount;
}());
exports.OutlookAccount = OutlookAccount;
/** @internal  */
var OutlookConfigurationSettings = (function (_super) {
    __extends(OutlookConfigurationSettings, _super);
    function OutlookConfigurationSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OutlookConfigurationSettings.prototype.ConvertSettings = function (smtpAddress, requestedSettings) { throw new Error("OutlookConfigurationSettings.ts - ConvertSettings : Not implemented."); };
    OutlookConfigurationSettings.prototype.GetNamespace = function () { throw new Error("OutlookConfigurationSettings.ts - GetNamespace : Not implemented."); };
    OutlookConfigurationSettings.prototype.IsAvailableUserSetting = function (setting) { throw new Error("OutlookConfigurationSettings.ts - IsAvailableUserSetting : Not implemented."); };
    OutlookConfigurationSettings.prototype.MakeRedirectionResponse = function (redirectUrl) { throw new Error("OutlookConfigurationSettings.ts - MakeRedirectionResponse : Not implemented."); };
    OutlookConfigurationSettings.prototype.ReportUnsupportedSettings = function (requestedSettings, response) { throw new Error("OutlookConfigurationSettings.ts - ReportUnsupportedSettings : Not implemented."); };
    OutlookConfigurationSettings.allOutlookProviderSettings = new LazyMember(function () {
        var results = []; //new List<UserSettingName>();
        ArrayHelper.AddRange(results, OutlookUser.AvailableUserSettings);
        ArrayHelper.AddRange(results, OutlookProtocol.AvailableUserSettings);
        results.push(UserSettingName.AlternateMailboxes);
        return results;
    });
    return OutlookConfigurationSettings;
}(ConfigurationSettingsBase));
exports.OutlookConfigurationSettings = OutlookConfigurationSettings;
/** @internal */
var OutlookProtocol = (function () {
    function OutlookProtocol() {
    }
    OutlookProtocol.prototype.ConvertEcpFragmentToUrl = function (fragment) { throw new Error("OutlookProtocol.ts - ConvertEcpFragmentToUrl : Not implemented."); };
    OutlookProtocol.prototype.ConvertToUserSettings = function (requestedSettings, response) { throw new Error("OutlookProtocol.ts - ConvertToUserSettings : Not implemented."); };
    //LoadFromXml(reader: EwsXmlReader): any { throw new Error("OutlookProtocol.ts - LoadFromXml : Not implemented."); }
    //LoadWebClientUrlsFromXml(reader: EwsXmlReader, webClientUrls: WebClientUrlCollection, elementName: string): any { throw new Error("OutlookProtocol.ts - LoadWebClientUrlsFromXml : Not implemented."); }
    OutlookProtocol.prototype.ProtocolNameToType = function (protocolName) { throw new Error("OutlookProtocol.ts - ProtocolNameToType : Not implemented."); };
    OutlookProtocol.EXPR = "EXPR";
    OutlookProtocol.EXCH = "EXCH";
    OutlookProtocol.WEB = "WEB";
    return OutlookProtocol;
}());
exports.OutlookProtocol = OutlookProtocol;
var OutlookUser = (function () {
    function OutlookUser() {
    }
    OutlookUser.prototype.ConvertToUserSettings = function (requestedSettings, response) { throw new Error("OutlookUser.ts - ConvertToUserSettings : Not implemented."); };
    return OutlookUser;
}());
exports.OutlookUser = OutlookUser;
var AutodiscoverRequest = (function () {
    function AutodiscoverRequest(service, url) {
        this.url = null;
        this.service = service;
        this.url = url;
    }
    Object.defineProperty(AutodiscoverRequest.prototype, "Service", {
        get: function () {
            return this.service;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutodiscoverRequest.prototype, "Url", {
        get: function () {
            return this.url;
        },
        enumerable: true,
        configurable: true
    });
    AutodiscoverRequest.prototype.CreateRedirectionResponse = function (httpWebResponse /*IEwsHttpWebResponse*/) {
        //string location = httpWebResponse.Headers[System.Net.HttpResponseHeader.Location];
        //    if (!string.IsNullOrEmpty(location)) {
        //        try {
        //            Uri redirectionUri = new Uri(this.Url, location);
        //            if ((redirectionUri.Scheme == Uri.UriSchemeHttp) || (redirectionUri.Scheme == Uri.UriSchemeHttps)) {
        //                AutodiscoverResponse response = this.CreateServiceResponse();
        //                response.ErrorCode = AutodiscoverErrorCode.RedirectUrl;
        //                response.RedirectionUrl = redirectionUri;
        //                return response;
        //            }
        //            this.Service.TraceMessage(
        //                TraceFlags.AutodiscoverConfiguration,
        //                string.Format("Invalid redirection URL '{0}' returned by Autodiscover service.", redirectionUri));
        //        }
        //        catch (UriFormatException) {
        //            this.Service.TraceMessage(
        //                TraceFlags.AutodiscoverConfiguration,
        //                string.Format("Invalid redirection location '{0}' returned by Autodiscover service.", location));
        //        }
        //    }
        //    else {
        //        this.Service.TraceMessage(
        //            TraceFlags.AutodiscoverConfiguration,
        //            "Redirection response returned by Autodiscover service without redirection location.");
        //    }
        return null;
    };
    AutodiscoverRequest.prototype.CreateServiceResponse = function () { throw new Error("AutodiscoverRequest.ts - CreateServiceResponse : Not implemented."); };
    AutodiscoverRequest.prototype.GetRequestXmlElementName = function () { throw new Error("AutodiscoverRequest.ts - GetRequestXmlElementName : Not implemented."); };
    AutodiscoverRequest.prototype.GetResponseStream = function (response /*IEwsHttpWebResponse*/) {
        //string contentEncoding = response.ContentEncoding;
        //Stream responseStream = response.GetResponseStream();
        //if (contentEncoding.ToLowerInvariant().Contains("gzip")) {
        //    return new GZipStream(responseStream, CompressionMode.Decompress);
        //}
        //else if (contentEncoding.ToLowerInvariant().Contains("deflate")) {
        //    return new DeflateStream(responseStream, CompressionMode.Decompress);
        //}
        //else {
        //    return responseStream;
        //}
    };
    AutodiscoverRequest.prototype.GetResponseXmlElementName = function () { throw new Error("AutodiscoverRequest.ts - GetResponseXmlElementName : Not implemented."); };
    AutodiscoverRequest.prototype.GetWsAddressingActionName = function () { throw new Error("AutodiscoverRequest.ts - GetWsAddressingActionName : Not implemented."); };
    AutodiscoverRequest.prototype.InternalExecute = function () {
        var _this = this;
        var writer = new EwsServiceXmlWriter(this.service);
        this.WriteSoapRequest(this.url, writer);
        if (!this.service || !this.Service.Credentials && (!this.Service.Credentials.UserName || this.service.Credentials.Password))
            throw new Error("missing credential");
        //var cred = "Basic " + btoa(this.Service.Credentials.UserName + ":" + this.Service.Credentials.Password);
        var cc = writer.GetXML();
        var xhrOptions = {
            type: "POST",
            data: cc,
            //url: "https://pod51045.outlook.com/autodiscover/autodiscover.svc",
            url: this.url.ToString(),
            //headers: { "Content-Type": "text/xml", "Authorization": cred },
            headers: { "Content-Type": "text/xml" },
        };
        this.service.Credentials.PrepareWebRequest(xhrOptions);
        return new exports.Promise(function (successDelegate, errorDelegate) {
            EwsLogging.DebugLog("sending ews request");
            EwsLogging.DebugLog(xhrOptions, true);
            _this.service.XHRApi.xhr(xhrOptions)
                .then(function (xhrResponse) {
                var ewsXmlReader = new EwsXmlReader(xhrResponse.responseText || xhrResponse.response);
                //EwsLogging.log(util.inspect(xhrResponse.response, { showHidden: false, depth: null, colors: true }));
                EwsLogging.DebugLog(ewsXmlReader.JsObject, true);
                if (xhrResponse.status == 200) {
                    //ewsXmlReader.Read();
                    //if (ewsXmlReader.NodeType == Node.DOCUMENT_NODE /*System.Xml.XmlNodeType.Document*/) {
                    //    ewsXmlReader.ReadStartElement(XmlNamespace.Soap, XmlElementNames.SOAPEnvelopeElementName);
                    //}
                    //else if ((ewsXmlReader.NodeType != Node.ELEMENT_NODE /*System.Xml.XmlNodeType.Element*/) || (ewsXmlReader.LocalName != XmlElementNames.SOAPEnvelopeElementName) || (ewsXmlReader.NamespaceUri != EwsUtilities.GetNamespaceUri(XmlNamespace.Soap))) {
                    //    throw new Error(Strings.InvalidAutodiscoverServiceResponse);
                    //}
                    _this.ReadSoapHeaders(ewsXmlReader);
                    var response = _this.ReadSoapBody(ewsXmlReader);
                    //ewsXmlReader.ReadEndElement(XmlNamespace.Soap, XmlElementNames.SOAPEnvelopeElementName);
                    if (response.ErrorCode == AutodiscoverErrorCode.NoError) {
                        //todo: passon to successDelegate
                        //return response;
                    }
                    else {
                        throw new Error("response error " + response.ErrorCode + response.ErrorMessage); // new AutodiscoverResponseException(response.ErrorCode, response.ErrorMessage);
                    }
                }
                else {
                    EwsLogging.Log("status !== 200", true, true);
                    EwsLogging.Log(xhrResponse.response, true, true);
                    EwsLogging.Log(ewsXmlReader, true, true);
                }
                if (successDelegate)
                    successDelegate(response || xhrResponse.responseText || xhrResponse.response);
            }, function (resperr) {
                var exception;
                try {
                    _this.ProcessWebException(resperr);
                }
                catch (exc) {
                    exception = exc;
                }
                if (errorDelegate)
                    errorDelegate(exception || resperr.responseText || resperr.response);
            });
        });
    };
    AutodiscoverRequest.IsRedirectionResponse = function (httpWebResponse) {
        return (httpWebResponse.status == 302 /*System.Net.HttpStatusCode.Redirect*/) ||
            (httpWebResponse.status == 301 /*System.Net.HttpStatusCode.Moved*/) ||
            (httpWebResponse.status == 307 /*System.Net.HttpStatusCode.RedirectKeepVerb*/) ||
            (httpWebResponse.status == 303 /*System.Net.HttpStatusCode.RedirectMethod*/);
    };
    /**@internal */
    AutodiscoverRequest.prototype.LoadFromXml = function (reader) {
        var elementName = this.GetResponseXmlElementName();
        reader.ReadStartElement(XmlNamespace.Autodiscover, elementName);
        var response = this.CreateServiceResponse();
        response.LoadFromXml(reader, elementName);
        return response;
    };
    AutodiscoverRequest.prototype.LoadFromObject = function (obj) {
        var elementName = this.GetResponseXmlElementName();
        obj = obj.Body[elementName];
        var response = this.CreateServiceResponse();
        response.LoadFromJson(obj[XmlElementNames.Response]);
        return response;
    };
    AutodiscoverRequest.prototype.ProcessWebException = function (webException) {
        if (webException.response) {
            //IEwsHttpWebResponse httpWebResponse = this.Service.HttpWebRequestFactory.CreateExceptionResponse(webException);
            var soapFaultDetails = null;
            if (webException.status == 500 /*System.Net.HttpStatusCode.InternalServerError*/) {
                // If tracing is enabled, we read the entire response into a MemoryStream so that we
                // can pass it along to the ITraceListener. Then we parse the response from the
                // MemoryStream.
                //if (this.Service.IsTraceEnabledFor(TraceFlags.AutodiscoverRequest)) {
                //using(MemoryStream memoryStream = new MemoryStream())
                //{
                //    using(Stream serviceResponseStream = AutodiscoverRequest.GetResponseStream(httpWebResponse))
                //    {
                //        // Copy response to in-memory stream and reset position to start.
                //        EwsUtilities.CopyStream(serviceResponseStream, memoryStream);
                //        memoryStream.Position = 0;
                //    }
                //todo implement tracing to base class.
                //this.Service.TraceResponse(httpWebResponse, memoryStream);
                //var reader = new EwsXmlReader(webException.responseText);
                //soapFaultDetails = this.ReadSoapFault(reader);
                //}
                //}
                //else {
                //    using(Stream stream = AutodiscoverRequest.GetResponseStream(httpWebResponse))
                //    {
                //        EwsXmlReader reader = new EwsXmlReader(stream);
                //        soapFaultDetails = this.ReadSoapFault(reader);
                //    }
                //}
                var reader = new EwsXmlReader(webException.responseText || webException.response);
                soapFaultDetails = this.ReadSoapFault(reader);
                if (soapFaultDetails) {
                    //todo: implement soap fault error throw
                    throw new ServiceResponseException(new ServiceResponse(soapFaultDetails));
                }
            }
            else {
                //todo: fix this
                this.Service.ProcessHttpErrorResponse(webException, webException);
            }
        }
    };
    /**@internal */
    AutodiscoverRequest.prototype.ReadServerVersionInfo = function (reader) {
        var serverInfo = new ExchangeServerInfo();
        do {
            reader.Read();
            switch (reader.LocalName) {
                case XmlElementNames.MajorVersion:
                    serverInfo.MajorVersion = +(reader.ReadElementValue());
                    break;
                case XmlElementNames.MinorVersion:
                    serverInfo.MinorVersion = +(reader.ReadElementValue());
                    break;
                case XmlElementNames.MajorBuildNumber:
                    serverInfo.MajorBuildNumber = +(reader.ReadElementValue());
                    break;
                case XmlElementNames.MinorBuildNumber:
                    serverInfo.MinorBuildNumber = +(reader.ReadElementValue());
                    break;
                case XmlElementNames.Version:
                    serverInfo.VersionString = reader.ReadElementValue();
                    break;
                default:
                    break;
            }
        } while (reader.ParentNode.localName === XmlElementNames.ServerVersionInfo);
        //while (!reader.IsEndElement(XmlNamespace.Autodiscover, XmlElementNames.ServerVersionInfo));
        return serverInfo;
    };
    /**@internal */
    AutodiscoverRequest.prototype.ReadSoapBody = function (reader) {
        var responses = this.LoadFromObject(reader.JsObject);
        return responses;
        reader.ReadStartElement(XmlNamespace.Soap, XmlElementNames.SOAPBodyElementName);
        var responses = this.LoadFromXml(reader);
        //reader.ReadEndElement(XmlNamespace.Soap, XmlElementNames.SOAPBodyElementName);
        return responses;
    };
    /**@internal */
    AutodiscoverRequest.prototype.ReadSoapFault = function (reader) {
        var soapFaultDetails = undefined;
        if (reader.JsObject && reader.JsObject[XmlElementNames.SOAPBodyElementName]) {
            var obj = reader.JsObject[XmlElementNames.SOAPBodyElementName];
            if (obj[XmlElementNames.SOAPFaultElementName])
                soapFaultDetails = SoapFaultDetails.Parse(obj[XmlElementNames.SOAPFaultElementName]);
        }
        return soapFaultDetails;
        //skipped xml section, using Json only.
        //////try {
        //////    // WCF may not generate an XML declaration.
        //////    reader.Read();
        //////    //if (reader.NodeType == Node.  System.Xml.XmlNodeType.XmlDeclaration) {
        //////    //    reader.Read();
        //////    //}
        //////    if (reader.LocalName != XmlElementNames.SOAPEnvelopeElementName) {
        //////        return soapFaultDetails;
        //////    }
        //////    // Get the namespace URI from the envelope element and use it for the rest of the parsing.
        //////    // If it's not 1.1 or 1.2, we can't continue.
        //////    var soapNamespace: XmlNamespace = EwsUtilities.GetNamespaceFromUri(reader.NamespaceUri);
        //////    if (soapNamespace == XmlNamespace.NotSpecified) {
        //////        return soapFaultDetails;
        //////    }
        //////    reader.Read();
        //////    // Skip SOAP header.
        //////    if (reader.IsElement(soapNamespace, XmlElementNames.SOAPHeaderElementName)) {
        //////        do {
        //////            reader.Read();
        //////        }
        //////        while (reader.HasRecursiveParent(XmlElementNames.SOAPHeaderElementName));
        //////        // Queue up the next read
        //////        //reader.Read(); - no need with nodeiterator/treewalker as the node is already a body Node
        //////    }
        //////    // Parse the fault element contained within the SOAP body.
        //////    if (reader.IsElement(soapNamespace, XmlElementNames.SOAPBodyElementName)) {
        //////        do {
        //////            reader.Read();
        //////            // Parse Fault element
        //////            if (reader.IsElement(soapNamespace, XmlElementNames.SOAPFaultElementName)) {
        //////                soapFaultDetails = SoapFaultDetails.Parse(reader, soapNamespace);
        //////            }
        //////        }
        //////        while (reader.HasRecursiveParent(XmlElementNames.SOAPBodyElementName));
        //////    }
        //////}
        //////catch (XmlException) {
        //////    // If response doesn't contain a valid SOAP fault, just ignore exception and
        //////    // return null for SOAP fault details.
        //////}
        //////return soapFaultDetails;
    };
    /**@internal */
    AutodiscoverRequest.prototype.ReadSoapHeader = function (reader) {
        // Is this the ServerVersionInfo?
        if (reader.IsElement(XmlNamespace.Autodiscover, XmlElementNames.ServerVersionInfo)) {
            this.service.ServerInfo = this.ReadServerVersionInfo(reader);
        }
    };
    /**@internal */
    AutodiscoverRequest.prototype.ReadSoapHeaders = function (reader) {
        this.service.ServerInfo = reader.JsObject.Header.ServerVersionInfo;
        //return;
        //reader.ReadStartElement(XmlNamespace.Soap, XmlElementNames.SOAPHeaderElementName);
        //do {
        //    reader.Read();
        //    this.ReadSoapHeader(reader);
        //}
        //while (reader.HasRecursiveParent(XmlElementNames.SOAPHeaderElementName));
    };
    AutodiscoverRequest.prototype.Validate = function () {
        //this.Service.Validate();
    };
    /**@internal */
    AutodiscoverRequest.prototype.WriteAttributesToXml = function (writer) { throw new Error("Not implemented. overridden"); };
    /**@internal */
    AutodiscoverRequest.prototype.WriteBodyToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Autodiscover, this.GetRequestXmlElementName());
        this.WriteAttributesToXml(writer);
        this.WriteElementsToXml(writer);
        writer.WriteEndElement(); // m:this.GetXmlElementName()
    };
    /**@internal */
    AutodiscoverRequest.prototype.WriteElementsToXml = function (writer) { throw new Error("Not implemented. overridden"); };
    /**@internal */
    AutodiscoverRequest.prototype.WriteExtraCustomSoapHeadersToXml = function (writer) { };
    /**@internal */
    AutodiscoverRequest.prototype.WriteSoapRequest = function (requestUrl, writer) {
        writer.WriteStartElement(XmlNamespace.Soap, XmlElementNames.SOAPEnvelopeElementName);
        writer.WriteAttributeValue("xmlns", EwsUtilities.AutodiscoverSoapNamespacePrefix, EwsUtilities.AutodiscoverSoapNamespace);
        writer.WriteAttributeValue("xmlns", EwsUtilities.WSAddressingNamespacePrefix, EwsUtilities.WSAddressingNamespace);
        writer.WriteAttributeValue("xmlns", EwsUtilities.EwsXmlSchemaInstanceNamespacePrefix, EwsUtilities.EwsXmlSchemaInstanceNamespace);
        if (writer.RequireWSSecurityUtilityNamespace) {
            writer.WriteAttributeValue("xmlns", EwsUtilities.WSSecurityUtilityNamespacePrefix, EwsUtilities.WSSecurityUtilityNamespace);
        }
        writer.WriteStartElement(XmlNamespace.Soap, XmlElementNames.SOAPHeaderElementName);
        //if (this.Service.Credentials != null) {
        //    this.Service.Credentials.EmitExtraSoapHeaderNamespaceAliases(writer.InternalWriter);
        //}
        writer.WriteElementValue(XmlNamespace.Autodiscover, XmlElementNames.RequestedServerVersion, ExchangeVersion[this.Service.RequestedServerVersion]);
        writer.WriteElementValue(XmlNamespace.WSAddressing, XmlElementNames.Action, this.GetWsAddressingActionName());
        writer.WriteElementValue(XmlNamespace.WSAddressing, XmlElementNames.To, requestUrl.ToString()); //.AbsoluteUri);
        this.WriteExtraCustomSoapHeadersToXml(writer);
        //if (this.Service.Credentials != null) {
        //    this.Service.Credentials.SerializeWSSecurityHeaders(writer.InternalWriter);
        //}
        //this.Service.DoOnSerializeCustomSoapHeaders(writer.InternalWriter);
        writer.WriteEndElement(); // soap:Header
        writer.WriteStartElement(XmlNamespace.Soap, XmlElementNames.SOAPBodyElementName);
        this.WriteBodyToXml(writer);
        writer.WriteEndElement(); // soap:Body
        writer.WriteEndElement(); // soap:Envelope
        writer.Flush();
    };
    return AutodiscoverRequest;
}());
exports.AutodiscoverRequest = AutodiscoverRequest;
var GetDomainSettingsRequest = (function (_super) {
    __extends(GetDomainSettingsRequest, _super);
    function GetDomainSettingsRequest(service, url) {
        return _super.call(this, service, url) || this;
    }
    GetDomainSettingsRequest.prototype.CreateServiceResponse = function () { return new GetDomainSettingsResponseCollection(); };
    GetDomainSettingsRequest.prototype.Execute = function () {
        var responses = this.InternalExecute();
        //GetDomainSettingsResponseCollection responses = (GetDomainSettingsResponseCollection) this.InternalExecute();
        //if (responses.ErrorCode == AutodiscoverErrorCode.NoError) {
        //    this.PostProcessResponses(responses);
        //}
        return responses;
    };
    GetDomainSettingsRequest.prototype.GetRequestXmlElementName = function () { return XmlElementNames.GetDomainSettingsRequestMessage; };
    GetDomainSettingsRequest.prototype.GetResponseXmlElementName = function () { return XmlElementNames.GetDomainSettingsResponseMessage; };
    GetDomainSettingsRequest.prototype.GetWsAddressingActionName = function () { return GetDomainSettingsRequest.GetDomainSettingsActionUri; };
    GetDomainSettingsRequest.prototype.PostProcessResponses = function (responses) {
        // Note:The response collection may not include all of the requested domains if the request has been throttled.
        for (var index = 0; index < responses.Count; index++) {
            responses.__thisIndexer(index).Domain = this.Domains[index];
        }
    };
    GetDomainSettingsRequest.prototype.Validate = function () { _super.prototype.Validate.call(this); };
    /**@internal */
    GetDomainSettingsRequest.prototype.WriteAttributesToXml = function (writer) {
        writer.WriteAttributeValue("xmlns", EwsUtilities.AutodiscoverSoapNamespacePrefix, EwsUtilities.AutodiscoverSoapNamespace);
    };
    /**@internal */
    GetDomainSettingsRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Autodiscover, XmlElementNames.Request);
        writer.WriteStartElement(XmlNamespace.Autodiscover, XmlElementNames.Domains);
        for (var _a = 0, _b = this.Domains; _a < _b.length; _a++) {
            var domain = _b[_a];
            //if (!string.IsNullOrEmpty(domain)) {
            if (domain != undefined && domain !== "") {
                writer.WriteElementValue(XmlNamespace.Autodiscover, XmlElementNames.Domain, domain);
            }
        }
        writer.WriteEndElement(); //Domains
        writer.WriteStartElement(XmlNamespace.Autodiscover, XmlElementNames.RequestedSettings);
        for (var _c = 0, _d = this.Settings; _c < _d.length; _c++) {
            var setting = _d[_c];
            writer.WriteElementValue(XmlNamespace.Autodiscover, XmlElementNames.Setting, DomainSettingName[setting]);
        }
        writer.WriteEndElement(); //RequestedSettings
        if (this.requestedVersion) {
            writer.WriteElementValue(XmlNamespace.Autodiscover, XmlElementNames.RequestedVersion, this.requestedVersion);
        }
        writer.WriteEndElement(); //Request
    };
    GetDomainSettingsRequest.GetDomainSettingsActionUri = EwsUtilities.AutodiscoverSoapNamespace + "/Autodiscover/GetDomainSettings";
    return GetDomainSettingsRequest;
}(AutodiscoverRequest));
exports.GetDomainSettingsRequest = GetDomainSettingsRequest;
var GetUserSettingsRequest = (function (_super) {
    __extends(GetUserSettingsRequest, _super);
    function GetUserSettingsRequest(service, url) {
        var _this = _super.call(this, service, url) || this;
        _this.expectPartnerToken = false;
        return _this;
    }
    GetUserSettingsRequest.prototype.CreateServiceResponse = function () {
        return new GetUserSettingsResponseCollection();
    };
    GetUserSettingsRequest.prototype.Execute = function () {
        var _this = this;
        return this.InternalExecute().then(function (adr) {
            _this.PostProcessResponses(adr);
            return adr;
        });
        //<Promise<>> v
        //if (!responses) return;
        //if (responses.ErrorCode == AutodiscoverErrorCode.NoError) {
        //    this.PostProcessResponses(responses);
        //}
        //return responses;
    };
    GetUserSettingsRequest.prototype.GetRequestXmlElementName = function () {
        return XmlElementNames.GetUserSettingsRequestMessage;
    };
    GetUserSettingsRequest.prototype.GetResponseXmlElementName = function () {
        return XmlElementNames.GetUserSettingsResponseMessage;
    };
    GetUserSettingsRequest.prototype.GetWsAddressingActionName = function () {
        return GetUserSettingsRequest.GetUserSettingsActionUri; // GetUserSettingsActionUri;
    };
    GetUserSettingsRequest.prototype.PostProcessResponses = function (responses) {
        // Note:The response collection may not include all of the requested users if the request has been throttled.
        for (var index = 0; index < responses.Count; index++) {
            responses.__thisIndexer(index).SmtpAddress = this.SmtpAddresses[index];
        }
    };
    /**@internal */
    GetUserSettingsRequest.prototype.ReadSoapHeader = function (reader) {
        _super.prototype.ReadSoapHeader.call(this, reader);
        return;
        if (this.expectPartnerToken) {
            if (reader.IsElement(XmlNamespace.Autodiscover, XmlElementNames.PartnerToken)) {
                this.PartnerToken = reader.ReadInnerXml();
            }
            if (reader.IsElement(XmlNamespace.Autodiscover, XmlElementNames.PartnerTokenReference)) {
                this.PartnerTokenReference = reader.ReadInnerXml();
            }
        }
    };
    GetUserSettingsRequest.prototype.Validate = function () {
        _super.prototype.Validate.call(this);
        EwsUtilities.ValidateParam(this.SmtpAddresses, "smtpAddresses");
        EwsUtilities.ValidateParam(this.Settings, "settings");
        if (this.Settings.length == 0) {
            throw new ServiceValidationException(Strings.InvalidAutodiscoverSettingsCount);
        }
        if (this.SmtpAddresses.length == 0) {
            throw new ServiceValidationException(Strings.InvalidAutodiscoverSmtpAddressesCount);
        }
        for (var s in this.SmtpAddresses) {
            var smtpAddress = this.SmtpAddresses[s];
            //if (string.IsNullOrEmpty(smtpAddress)) {
            if (smtpAddress != undefined && smtpAddress !== "") {
                throw new ServiceValidationException(Strings.InvalidAutodiscoverSmtpAddress);
            }
        }
    };
    /**@internal */
    GetUserSettingsRequest.prototype.WriteAttributesToXml = function (writer) {
        writer.WriteAttributeValue("xmlns", EwsUtilities.AutodiscoverSoapNamespacePrefix, EwsUtilities.AutodiscoverSoapNamespace);
    };
    /**@internal */
    GetUserSettingsRequest.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Autodiscover, XmlElementNames.Request);
        writer.WriteStartElement(XmlNamespace.Autodiscover, XmlElementNames.Users);
        for (var s in this.SmtpAddresses) {
            var smtpAddress = this.SmtpAddresses[s];
            writer.WriteStartElement(XmlNamespace.Autodiscover, XmlElementNames.User);
            //if (!string.IsNullOrEmpty(smtpAddress)) {
            if (smtpAddress != undefined && smtpAddress !== "") {
                writer.WriteElementValue(XmlNamespace.Autodiscover, XmlElementNames.Mailbox, smtpAddress);
            }
            writer.WriteEndElement(); // User
        }
        writer.WriteEndElement(); // Users
        writer.WriteStartElement(XmlNamespace.Autodiscover, XmlElementNames.RequestedSettings);
        for (var s in this.Settings) {
            var setting = this.Settings[s];
            writer.WriteElementValue(XmlNamespace.Autodiscover, XmlElementNames.Setting, UserSettingName[setting]);
        }
        writer.WriteEndElement(); // RequestedSettings
        writer.WriteEndElement(); // Request
    };
    /**@internal */
    GetUserSettingsRequest.prototype.WriteExtraCustomSoapHeadersToXml = function (writer) {
        if (this.expectPartnerToken) {
            debugger;
            // writer.WriteElementValue(
            //    XmlNamespace.Autodiscover,
            //    XmlElementNames.BinarySecret,
            //    btoa(ExchangeServiceBase.SessionKey));
            //    //System.Convert.ToBase64String(ExchangeServiceBase.SessionKey));
        }
    };
    GetUserSettingsRequest.GetUserSettingsActionUri = EwsUtilities.AutodiscoverSoapNamespace + "/Autodiscover/GetUserSettings";
    return GetUserSettingsRequest;
}(AutodiscoverRequest));
exports.GetUserSettingsRequest = GetUserSettingsRequest;
var AutodiscoverResponse = (function () {
    function AutodiscoverResponse() {
    }
    //private errorCode: AutodiscoverErrorCode;
    //private errorMessage: string;
    //private redirectionUrl: Uri;
    /**@internal */
    AutodiscoverResponse.prototype.LoadFromXml = function (reader, endElementName) {
        switch (reader.LocalName) {
            case XmlElementNames.ErrorCode:
                var errorstring = reader.ReadElementValue();
                this.ErrorCode = AutodiscoverErrorCode[errorstring];
                break;
            case XmlElementNames.ErrorMessage:
                this.ErrorMessage = reader.ReadElementValue();
                break;
            default:
                break;
        }
    };
    AutodiscoverResponse.prototype.LoadFromJson = function (obj /*, endElementName: string*/) {
        var errorstring = obj[XmlElementNames.ErrorCode];
        this.ErrorCode = AutodiscoverErrorCode[errorstring];
        var errmsg = obj[XmlElementNames.ErrorMessage];
        this.ErrorMessage = errmsg;
    };
    return AutodiscoverResponse;
}());
exports.AutodiscoverResponse = AutodiscoverResponse;
var AutodiscoverResponseCollection = (function (_super) {
    __extends(AutodiscoverResponseCollection, _super);
    //private responses: TResponse[];//System.Collections.Generic.List<TResponse>;
    function AutodiscoverResponseCollection() {
        var _this = _super.call(this) || this;
        _this.Responses = []; //System.Collections.Generic.List<TResponse>;
        return _this;
    }
    Object.defineProperty(AutodiscoverResponseCollection.prototype, "Count", {
        get: function () { return this.Responses.length; },
        enumerable: true,
        configurable: true
    });
    ;
    AutodiscoverResponseCollection.prototype.__thisIndexer = function (index) {
        return this.Responses[index];
    };
    AutodiscoverResponseCollection.prototype.CreateResponseInstance = function () { throw new Error("AutodiscoverResponseCollection.ts - CreateResponseInstance : Not implemented."); };
    AutodiscoverResponseCollection.prototype.GetEnumerator = function () { throw new Error("AutodiscoverResponseCollection.ts - GetEnumerator : Not implemented."); };
    AutodiscoverResponseCollection.prototype.GetResponseCollectionXmlElementName = function () { throw new Error("AutodiscoverResponseCollection.ts - GetResponseCollectionXmlElementName : Not implemented."); };
    AutodiscoverResponseCollection.prototype.GetResponseInstanceXmlElementName = function () { throw new Error("AutodiscoverResponseCollection.ts - GetResponseInstanceXmlElementName : Not implemented."); };
    /**@internal */
    AutodiscoverResponseCollection.prototype.LoadFromXml = function (reader, endElementName) {
        do {
            reader.Read();
            if (reader.NodeType == 1 /*Node.ELEMENT_NODE*/) {
                if (reader.LocalName == this.GetResponseCollectionXmlElementName()) {
                    this.LoadResponseCollectionFromXml(reader);
                }
                else {
                    _super.prototype.LoadFromXml.call(this, reader, endElementName);
                }
            }
        } while (reader.HasRecursiveParent(endElementName));
        //while (!reader.IsEndElement(XmlNamespace.Autodiscover, endElementName));
    };
    AutodiscoverResponseCollection.prototype.LoadFromJson = function (obj) {
        var element = this.GetResponseCollectionXmlElementName();
        _super.prototype.LoadFromJson.call(this, obj);
        this.LoadResponseCollectionFromJson(obj[element]);
    };
    AutodiscoverResponseCollection.prototype.LoadResponseCollectionFromJson = function (obj) {
        var element = this.GetResponseInstanceXmlElementName();
        var responses = undefined;
        if (Object.prototype.toString.call(obj[element]) === "[object Array]")
            responses = obj[element];
        else
            responses = [obj[element]];
        for (var i = 0; i < responses.length; i++) {
            var response = this.CreateResponseInstance();
            response.LoadFromJson(responses[i]);
            this.Responses.push(response);
        }
    };
    /**@internal */
    AutodiscoverResponseCollection.prototype.LoadResponseCollectionFromXml = function (reader) {
        if (!reader.IsEmptyElement) {
            do {
                reader.Read();
                if ((reader.NodeType == 1 /*Node.ELEMENT_NODE*/ /*System.Xml.XmlNodeType.Element*/) && (reader.LocalName == this.GetResponseInstanceXmlElementName())) {
                    var response = this.CreateResponseInstance();
                    response.LoadFromXml(reader, this.GetResponseInstanceXmlElementName());
                    this.Responses.push(response);
                }
            } while (reader.HasRecursiveParent(this.GetResponseCollectionXmlElementName()));
            //while (!reader.IsEndElement(XmlNamespace.Autodiscover, this.GetResponseCollectionXmlElementName()));
        }
    };
    return AutodiscoverResponseCollection;
}(AutodiscoverResponse));
exports.AutodiscoverResponseCollection = AutodiscoverResponseCollection;
var GetDomainSettingsResponse = (function (_super) {
    __extends(GetDomainSettingsResponse, _super);
    function GetDomainSettingsResponse() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**@internal */
    GetDomainSettingsResponse.prototype.LoadDomainSettingErrorsFromXml = function (reader) {
        if (!reader.IsEmptyElement) {
            do {
                reader.Read();
                if ((reader.NodeType == Node.ELEMENT_NODE) && (reader.LocalName == XmlElementNames.DomainSettingError)) {
                    var error = new DomainSettingError();
                    error.LoadFromXml(reader);
                    this.DomainSettingErrors.push(error);
                }
            } while (reader.HasRecursiveParent(XmlElementNames.UserSettingErrors));
            reader.SeekLast(); // fix xml treewalker to go back last node, next do..while loop will come back to current node.
        }
    };
    /**@internal */
    GetDomainSettingsResponse.prototype.LoadDomainSettingsFromXml = function (reader) {
        var parent = reader.CurrentNode;
        if (!reader.IsEmptyElement) {
            do {
                reader.Read();
                if (reader.Eof || !reader.HasRecursiveParentNode(parent, XmlElementNames.DomainSettings))
                    break;
                if ((reader.NodeType == Node.ELEMENT_NODE /*System.Xml.XmlNodeType.Element*/) && (reader.LocalName == XmlElementNames.DomainSetting)) {
                    var settingClass = reader.ReadAttributeValue(XmlNamespace.XmlSchemaInstance, XmlAttributeNames.Type);
                    switch (settingClass) {
                        case XmlElementNames.DomainStringSetting:
                            this.ReadSettingFromXml(reader);
                            break;
                        default:
                            EwsLogging.Assert(false, "GetUserSettingsResponse.LoadUserSettingsFromXml", StringHelper.Format("Invalid setting class '{0}' returned", settingClass));
                            break;
                    }
                }
            } while (true); // (reader.HasRecursiveParent(XmlElementNames.UserSettings));
            //while (!reader.IsEndElement(XmlNamespace.Autodiscover, XmlElementNames.UserSettings));
        }
    };
    /**@internal */
    GetDomainSettingsResponse.prototype.LoadFromXml = function (reader, parentElementName) {
        do {
            reader.Read();
            if (reader.NodeType == Node.ELEMENT_NODE) {
                switch (reader.LocalName) {
                    case XmlElementNames.RedirectTarget:
                        this.RedirectTarget = reader.ReadElementValue();
                        break;
                    case XmlElementNames.DomainSettingErrors:
                        this.LoadDomainSettingErrorsFromXml(reader);
                        break;
                    case XmlElementNames.DomainSettings:
                        this.LoadDomainSettingsFromXml(reader);
                        break;
                    default:
                        _super.prototype.LoadFromXml.call(this, reader, parentElementName);
                        break;
                }
            }
        } while (reader.HasRecursiveParent(parentElementName));
        //while (!reader.IsEndElement(XmlNamespace.Autodiscover, endElementName));
    };
    /**@internal */
    GetDomainSettingsResponse.prototype.ReadSettingFromXml = function (reader) {
        var name = null;
        var value = null;
        var parent = reader.CurrentNode;
        do {
            reader.Read();
            if (reader.Eof || !reader.HasRecursiveParentNode(parent, XmlElementNames.UserSetting))
                break;
            if (reader.NodeType == Node.ELEMENT_NODE) {
                switch (reader.LocalName) {
                    case XmlElementNames.Name:
                        name = reader.ReadElementValue();
                        break;
                    case XmlElementNames.Value:
                        value = reader.ReadElementValue();
                        break;
                }
            }
        } while (true);
        reader.SeekLast(); // fix xml treewalker to go back last node, next do..while loop will come back to current node.
        // EWS Managed API is broken with AutoDSvc endpoint in RedirectUrl scenario
        var domainSettingName = DomainSettingName[name]; // EwsUtilities.Parse<UserSettingName>(name);
        if (domainSettingName !== undefined)
            this.Settings[domainSettingName] = value;
        else
            EwsLogging.Assert(false, "GetUserSettingsResponse.ReadSettingFromXml", "Unexpected or empty name element in user setting");
    };
    GetDomainSettingsResponse.prototype.LoadDomainSettingErrorsFromJson = function (obj) {
        var errors = undefined;
        if (typeof (obj[XmlElementNames.DomainSettingError]) === 'undefined')
            return;
        if (Object.prototype.toString.call(obj[XmlElementNames.DomainSettingError]) === "[object Array]")
            errors = obj[XmlElementNames.DomainSettingError];
        else
            errors = [obj[XmlElementNames.DomainSettingError]];
        for (var i = 0; i < errors.length; i++) {
            var error = new DomainSettingError();
            error.LoadFromObject(errors[0]);
            this.DomainSettingErrors.push(error);
        }
    };
    GetDomainSettingsResponse.prototype.LoadDomainSettingsFromJson = function (obj) {
        var settings = undefined;
        if (typeof (obj[XmlElementNames.DomainSetting]) === 'undefined')
            return;
        if (Object.prototype.toString.call(obj[XmlElementNames.DomainSetting]) === "[object Array]")
            settings = obj[XmlElementNames.DomainSetting];
        else
            settings = [obj[XmlElementNames.DomainSetting]];
        for (var i = 0; i < settings.length; i++) {
            var setting = settings[i];
            var settingClass = setting["type"];
            switch (settingClass) {
                case XmlElementNames.DomainStringSetting:
                    this.ReadSettingFromJson(setting);
                    break;
                default:
                    EwsLogging.Assert(false, "GetUserSettingsResponse.LoadUserSettingsFromXml", StringHelper.Format("Invalid setting class '{0}' returned", settingClass));
                    break;
            }
        }
    };
    GetDomainSettingsResponse.prototype.LoadFromJson = function (obj) {
        _super.prototype.LoadFromJson.call(this, obj);
        var settingscol = obj[XmlElementNames.DomainSettings];
        this.LoadDomainSettingsFromJson(settingscol);
        this.RedirectTarget = obj[XmlElementNames.RedirectTarget];
        this.LoadDomainSettingErrorsFromJson(obj[XmlElementNames.DomainSettingErrors]);
    };
    GetDomainSettingsResponse.prototype.ReadSettingFromJson = function (obj) {
        var name = obj[XmlElementNames.Name];
        var value = obj[XmlElementNames.Value];
        // EWS Managed API is broken with AutoDSvc endpoint in RedirectUrl scenario
        var domainSettingName = DomainSettingName[name]; // EwsUtilities.Parse<UserSettingName>(name);
        if (domainSettingName !== undefined)
            this.Settings[domainSettingName] = value;
        else
            EwsLogging.Assert(false, "GetUserSettingsResponse.ReadSettingFromObject", "Unexpected or empty name element in user setting");
    };
    return GetDomainSettingsResponse;
}(AutodiscoverResponse));
exports.GetDomainSettingsResponse = GetDomainSettingsResponse;
var GetDomainSettingsResponseCollection = (function (_super) {
    __extends(GetDomainSettingsResponseCollection, _super);
    function GetDomainSettingsResponseCollection() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GetDomainSettingsResponseCollection.prototype.CreateResponseInstance = function () { return new GetDomainSettingsResponse(); };
    GetDomainSettingsResponseCollection.prototype.GetResponseCollectionXmlElementName = function () { return XmlElementNames.DomainResponses; };
    GetDomainSettingsResponseCollection.prototype.GetResponseInstanceXmlElementName = function () { return XmlElementNames.DomainResponse; };
    return GetDomainSettingsResponseCollection;
}(AutodiscoverResponseCollection));
exports.GetDomainSettingsResponseCollection = GetDomainSettingsResponseCollection;
var GetUserSettingsResponse = (function (_super) {
    __extends(GetUserSettingsResponse, _super);
    function GetUserSettingsResponse() {
        var _this = _super.call(this) || this;
        _this.SmtpAddress = "";
        _this.Settings = {};
        _this.UserSettingErrors = new Array();
        return _this;
    }
    /**@internal */
    GetUserSettingsResponse.prototype.LoadFromXml = function (reader, parentElementName) {
        do {
            reader.Read();
            if (reader.NodeType == Node.ELEMENT_NODE) {
                switch (reader.LocalName) {
                    case XmlElementNames.RedirectTarget:
                        this.RedirectTarget = reader.ReadElementValue();
                        break;
                    case XmlElementNames.UserSettingErrors:
                        this.LoadUserSettingErrorsFromXml(reader);
                        break;
                    case XmlElementNames.UserSettings:
                        this.LoadUserSettingsFromXml(reader);
                        break;
                    default:
                        _super.prototype.LoadFromXml.call(this, reader, parentElementName);
                        break;
                }
            }
        } while (reader.HasRecursiveParent(parentElementName));
        //while (!reader.IsEndElement(XmlNamespace.Autodiscover, endElementName));
    };
    /**@internal */
    GetUserSettingsResponse.prototype.LoadUserSettingErrorsFromXml = function (reader) {
        if (!reader.IsEmptyElement) {
            do {
                reader.Read();
                if ((reader.NodeType == Node.ELEMENT_NODE) && (reader.LocalName == XmlElementNames.UserSettingError)) {
                    var error = new UserSettingError();
                    error.LoadFromXml(reader);
                    this.UserSettingErrors.push(error);
                }
            } while (reader.HasRecursiveParent(XmlElementNames.UserSettingErrors));
            reader.SeekLast(); // fix xml treewalker to go back last node, next do..while loop will come back to current node.
        }
    };
    /**@internal */
    GetUserSettingsResponse.prototype.LoadUserSettingsFromXml = function (reader) {
        var parent = reader.CurrentNode;
        if (!reader.IsEmptyElement) {
            do {
                reader.Read();
                if (reader.Eof || !reader.HasRecursiveParentNode(parent, XmlElementNames.UserSettings))
                    break;
                if ((reader.NodeType == Node.ELEMENT_NODE /*System.Xml.XmlNodeType.Element*/) && (reader.LocalName == XmlElementNames.UserSetting)) {
                    var settingClass = reader.ReadAttributeValue(XmlNamespace.XmlSchemaInstance, XmlAttributeNames.Type);
                    switch (settingClass) {
                        case XmlElementNames.StringSetting:
                        case XmlElementNames.WebClientUrlCollectionSetting:
                        case XmlElementNames.AlternateMailboxCollectionSetting:
                        case XmlElementNames.ProtocolConnectionCollectionSetting:
                        case XmlElementNames.DocumentSharingLocationCollectionSetting:
                            this.ReadSettingFromXml(reader);
                            break;
                        default:
                            EwsLogging.Assert(false, "GetUserSettingsResponse.LoadUserSettingsFromXml", StringHelper.Format("Invalid setting class '{0}' returned", settingClass));
                            break;
                    }
                }
            } while (true); // (reader.HasRecursiveParent(XmlElementNames.UserSettings));
            //while (!reader.IsEndElement(XmlNamespace.Autodiscover, XmlElementNames.UserSettings));
        }
    };
    /**@internal */
    GetUserSettingsResponse.prototype.ReadSettingFromXml = function (reader) {
        var name = null;
        var value = null;
        var parent = reader.CurrentNode;
        do {
            reader.Read();
            if (reader.Eof || !reader.HasRecursiveParentNode(parent, XmlElementNames.UserSetting))
                break;
            if (reader.NodeType == Node.ELEMENT_NODE) {
                switch (reader.LocalName) {
                    case XmlElementNames.Name:
                        name = reader.ReadElementValue();
                        break;
                    case XmlElementNames.Value:
                        value = reader.ReadElementValue();
                        break;
                    case XmlElementNames.WebClientUrls:
                        value = WebClientUrlCollection.LoadFromXml(reader);
                        break;
                    case XmlElementNames.ProtocolConnections:
                        value = ProtocolConnectionCollection.LoadFromXml(reader);
                        break;
                    case XmlElementNames.AlternateMailboxes:
                        value = AlternateMailboxCollection.LoadFromXml(reader);
                        break;
                    case XmlElementNames.DocumentSharingLocations:
                        value = DocumentSharingLocationCollection.LoadFromXml(reader);
                        break;
                }
            }
        } while (true);
        //while (reader.HasRecursiveParentNode(parent, XmlElementNames.UserSetting));
        //while (!reader.IsEndElement(XmlNamespace.Autodiscover, XmlElementNames.UserSetting));
        reader.SeekLast(); // fix xml treewalker to go back last node, next do..while loop will come back to current node.
        // EWS Managed API is broken with AutoDSvc endpoint in RedirectUrl scenario
        var userSettingName = UserSettingName[name]; // EwsUtilities.Parse<UserSettingName>(name);
        if (userSettingName !== undefined)
            this.Settings[userSettingName] = value;
        else
            EwsLogging.Assert(false, "GetUserSettingsResponse.ReadSettingFromXml", "Unexpected or empty name element in user setting");
        //try {
        //}
        //catch (ArgumentException) {
        //    // ignore unexpected UserSettingName in the response (due to the server-side bugs).
        //    // it'd be better if this is hooked into ITraceListener, but that is unavailable here.
        //    //
        //    // in case "name" is null, EwsUtilities.Parse throws ArgumentNullException
        //    // (which derives from ArgumentException).
        //    //
        //    //EwsUtilities.Assert(
        //    //    false,
        //    //    "GetUserSettingsResponse.ReadSettingFromXml",
        //    //    "Unexpected or empty name element in user setting");
        //}
    };
    GetUserSettingsResponse.prototype.LoadFromJson = function (obj /*, parentElementName: string*/) {
        //debugger;
        _super.prototype.LoadFromJson.call(this, obj /*, parentElementName*/);
        var settingscol = obj[XmlElementNames.UserSettings];
        this.LoadUserSettingsFromJson(settingscol);
        this.RedirectTarget = obj[XmlElementNames.RedirectTarget];
        //var redirecttarget = obj[XmlElementNames.RedirectTarget];
        ////if (redirecttarget["nil"]) redirecttarget = null;
        //this.RedirectTarget = redirecttarget;
        this.LoadUserSettingErrorsFromJson(obj[XmlElementNames.UserSettingErrors]);
    };
    GetUserSettingsResponse.prototype.LoadUserSettingErrorsFromJson = function (obj) {
        var errors = undefined;
        if (!obj || typeof (obj[XmlElementNames.UserSettingError]) === 'undefined')
            return;
        if (Object.prototype.toString.call(obj[XmlElementNames.UserSettingError]) === "[object Array]")
            errors = obj[XmlElementNames.UserSettingError];
        else
            errors = [obj[XmlElementNames.UserSettingError]];
        for (var i = 0; i < errors.length; i++) {
            var error = new UserSettingError();
            error.LoadFromJson(errors[0]);
            this.UserSettingErrors.push(error);
        }
    };
    GetUserSettingsResponse.prototype.LoadUserSettingsFromJson = function (obj) {
        var settings = undefined;
        if (!obj || typeof (obj[XmlElementNames.UserSetting]) === 'undefined')
            return;
        if (Object.prototype.toString.call(obj[XmlElementNames.UserSetting]) === "[object Array]")
            settings = obj[XmlElementNames.UserSetting];
        else
            settings = [obj[XmlElementNames.UserSetting]];
        for (var i = 0; i < settings.length; i++) {
            var setting = settings[i];
            var settingClass = setting["type"];
            switch (settingClass) {
                case XmlElementNames.StringSetting:
                case XmlElementNames.WebClientUrlCollectionSetting:
                case XmlElementNames.AlternateMailboxCollectionSetting:
                case XmlElementNames.ProtocolConnectionCollectionSetting:
                case XmlElementNames.DocumentSharingLocationCollectionSetting:
                    this.ReadSettingFromJson(setting);
                    break;
                default:
                    EwsLogging.Assert(false, "GetUserSettingsResponse.LoadUserSettingsFromXml", StringHelper.Format("Invalid setting class '{0}' returned", settingClass));
                    break;
            }
        }
    };
    GetUserSettingsResponse.prototype.ReadSettingFromJson = function (obj) {
        var name = obj[XmlElementNames.Name];
        var value = obj[XmlElementNames.Value];
        switch (obj["type"]) {
            case XmlElementNames.WebClientUrlCollectionSetting://.WebClientUrls:
                value = WebClientUrlCollection.LoadFromJson(obj[XmlElementNames.WebClientUrls]);
                break;
            case XmlElementNames.ProtocolConnectionCollectionSetting://ProtocolConnections:
                value = ProtocolConnectionCollection.LoadFromJson(obj[XmlElementNames.ProtocolConnections]);
                break;
            case XmlElementNames.AlternateMailboxCollectionSetting://AlternateMailboxes:
                value = AlternateMailboxCollection.LoadFromJson(obj[XmlElementNames.AlternateMailboxes]);
                break;
            case XmlElementNames.DocumentSharingLocationCollectionSetting://DocumentSharingLocations:
                debugger;
                EwsLogging.Log("------------DocumentSharingLocationCollection needs test and fix ----------------", true);
                EwsLogging.Log(obj, true, true);
                value = DocumentSharingLocationCollection.LoadFromJson(obj);
                break;
        }
        // EWS Managed API is broken with AutoDSvc endpoint in RedirectUrl scenario
        var userSettingName = UserSettingName[name]; // EwsUtilities.Parse<UserSettingName>(name);
        if (userSettingName !== undefined)
            this.Settings[userSettingName] = value;
        else
            EwsLogging.Assert(false, "GetUserSettingsResponse.ReadSettingFromXml", "Unexpected or empty name element in user setting");
        //try {
        //}
        //catch (ArgumentException) {
        //    // ignore unexpected UserSettingName in the response (due to the server-side bugs).
        //    // it'd be better if this is hooked into ITraceListener, but that is unavailable here.
        //    //
        //    // in case "name" is null, EwsUtilities.Parse throws ArgumentNullException
        //    // (which derives from ArgumentException).
        //    //
        //    //EwsUtilities.Assert(
        //    //    false,
        //    //    "GetUserSettingsResponse.ReadSettingFromXml",
        //    //    "Unexpected or empty name element in user setting");
        //}
    };
    GetUserSettingsResponse.prototype.GetSettingValue = function (setting) {
        //public bool TryGetSettingValue<T>(UserSettingName setting, out T value)
        return this.Settings[setting];
    };
    return GetUserSettingsResponse;
}(AutodiscoverResponse));
exports.GetUserSettingsResponse = GetUserSettingsResponse;
var GetUserSettingsResponseCollection = (function (_super) {
    __extends(GetUserSettingsResponseCollection, _super);
    function GetUserSettingsResponseCollection() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GetUserSettingsResponseCollection.prototype.CreateResponseInstance = function () { return new GetUserSettingsResponse(); };
    GetUserSettingsResponseCollection.prototype.GetResponseCollectionXmlElementName = function () { return XmlElementNames.UserResponses; };
    GetUserSettingsResponseCollection.prototype.GetResponseInstanceXmlElementName = function () { return XmlElementNames.UserResponse; };
    return GetUserSettingsResponseCollection;
}(AutodiscoverResponseCollection));
exports.GetUserSettingsResponseCollection = GetUserSettingsResponseCollection;
//todo: fix this - import Xml = require("System.Xml");
var AlternateMailbox = (function () {
    function AlternateMailbox() {
    }
    //private type: string;
    //private displayName: string;
    //private legacyDN: string;
    //private server: string;
    //private smtpAddress: string;
    //private ownerSmtpAddress: string;
    /**@internal */
    AlternateMailbox.prototype.LoadFromXml = function (reader) {
        var altMailbox = new AlternateMailbox();
        do {
            reader.Read();
            if (reader.NodeType == 1) {
                switch (reader.LocalName) {
                    case XmlElementNames.Type:
                        altMailbox.Type = reader.ReadElementValue(); //  reader.ReadElementValue<string>();
                        break;
                    case XmlElementNames.DisplayName:
                        altMailbox.DisplayName = reader.ReadElementValue(); //reader.ReadElementValue<string>();
                        break;
                    case XmlElementNames.LegacyDN:
                        altMailbox.LegacyDN = reader.ReadElementValue(); //reader.ReadElementValue<string>();
                        break;
                    case XmlElementNames.Server:
                        altMailbox.Server = reader.ReadElementValue(); //reader.ReadElementValue<string>();
                        break;
                    case XmlElementNames.SmtpAddress:
                        altMailbox.SmtpAddress = reader.ReadElementValue(); //reader.ReadElementValue<string>();
                        break;
                    case XmlElementNames.OwnerSmtpAddress:
                        altMailbox.OwnerSmtpAddress = reader.ReadElementValue(); //reader.ReadElementValue<string>();
                        break;
                    default:
                        break;
                }
            }
        } while (!reader.IsElement(XmlNamespace.Autodiscover, XmlElementNames.AlternateMailbox));
        reader.SeekLast(); // to go back to last one, fix for xmlnode based reader.
        return altMailbox;
    };
    AlternateMailbox.LoadFromJson = function (obj) { throw new Error("this was skipped as not needed at dev time, fix this"); };
    return AlternateMailbox;
}());
exports.AlternateMailbox = AlternateMailbox;
var AlternateMailboxCollection = (function () {
    function AlternateMailboxCollection() {
        this.Entries = []; //System.Collections.Generic.List<AlternateMailbox>;
    }
    /**@internal */
    AlternateMailboxCollection.LoadFromXml = function (reader) { throw new Error("Not implemented. depricated use LoadFromJson"); };
    AlternateMailboxCollection.LoadFromJson = function (obj) {
        var instance = new AlternateMailboxCollection();
        var element = XmlElementNames.AlternateMailbox;
        var responses = undefined;
        if (Object.prototype.toString.call(obj[element]) === "[object Array]")
            responses = obj[element];
        else
            responses = [obj[element]];
        for (var i = 0; i < responses.length; i++) {
            instance.Entries.push(responses[i]);
            //AlternateMailbox.LoadFromJson(responses[i]);
            //instance.Entries.push(responses);
        }
        return instance;
    };
    return AlternateMailboxCollection;
}());
exports.AlternateMailboxCollection = AlternateMailboxCollection;
/**@internal */
var AutodiscoverDnsClient = (function () {
    function AutodiscoverDnsClient() {
    }
    AutodiscoverDnsClient.prototype.FindAutodiscoverHostFromSrv = function (domain) { throw new Error("AutodiscoverDnsClient.ts - FindAutodiscoverHostFromSrv : Not implemented."); };
    AutodiscoverDnsClient.prototype.FindBestMatchingSrvRecord = function (domain) { throw new Error("AutodiscoverDnsClient.ts - FindBestMatchingSrvRecord : Not implemented."); };
    AutodiscoverDnsClient.AutoDiscoverSrvPrefix = "_autodiscover._tcp.";
    AutodiscoverDnsClient.SslPort = 443;
    return AutodiscoverDnsClient;
}());
exports.AutodiscoverDnsClient = AutodiscoverDnsClient;
var AutodiscoverError = (function () {
    function AutodiscoverError() {
    }
    return AutodiscoverError;
}());
exports.AutodiscoverError = AutodiscoverError;
var AutodiscoverService = (function (_super) {
    __extends(AutodiscoverService, _super);
    function AutodiscoverService(domainUrlServiceOrVersion, domainOrVersion, version) {
        if (version === void 0) { version = ExchangeVersion.Exchange2010; }
        var _this = this;
        var argsLength = arguments.length;
        if (argsLength > 3) {
            throw new Error("AutodiscoverService.ts - ctor with " + argsLength + " parameters, invalid number of arguments, check documentation and try again.");
        }
        //EwsUtilities.ValidateDomainNameAllowNull(domainOrVersion, "domain"); 
        var domain = null;
        var url = null;
        var service = null;
        var requestedServerVersion = ExchangeVersion.Exchange2010;
        var hasService = false;
        var hasVersion = false;
        if (argsLength >= 1) {
            if (domainUrlServiceOrVersion instanceof Uri) {
                url = domainUrlServiceOrVersion;
            }
            else if (domainUrlServiceOrVersion instanceof ExchangeServiceBase) {
                service = domainUrlServiceOrVersion;
                hasService = true;
            }
            else if (typeof domainUrlServiceOrVersion === 'string') {
                domain = domainUrlServiceOrVersion;
            }
            else if (typeof domainUrlServiceOrVersion === 'number') {
                requestedServerVersion = domainUrlServiceOrVersion;
                hasVersion = true;
            }
        }
        if (argsLength >= 2) {
            if (typeof domainOrVersion === 'string') {
                if (!(domainUrlServiceOrVersion instanceof Uri)) {
                    throw new Error("AutodiscoverService.ts - ctor with " + argsLength + " parameters - incorrect uses of parameter at 1st position, it must be Uri when using string at 2nd place");
                }
                domain = domainOrVersion;
            }
            else if (typeof domainOrVersion === 'number') {
                requestedServerVersion = domainOrVersion;
            }
        }
        if (argsLength === 3) {
            requestedServerVersion = version;
        }
        if (service !== null && typeof service !== 'undefined') {
            _this = _super.call(this, service, requestedServerVersion) || this;
        }
        else {
            _this = _super.call(this, requestedServerVersion) || this;
            _this.url = url;
            _this.domain = domain;
        }
        return _this;
    }
    Object.defineProperty(AutodiscoverService.prototype, "Domain", {
        //private isExternal: boolean;
        //private redirectionUrlValidationCallback: AutodiscoverRedirectionUrlValidationCallback;
        //private dnsClient: AutodiscoverDnsClient;
        //private dnsServerAddress: any;// System.Net.IPAddress;
        //private enableScpLookup: boolean;
        get: function () {
            return this.domain;
        },
        set: function (value) {
            this.domain = value;
            if (value)
                this.url = undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutodiscoverService.prototype, "Url", {
        get: function () {
            return this.url;
        },
        set: function (value) {
            if (value)
                this.domain = value.Host;
            this.url = value;
        },
        enumerable: true,
        configurable: true
    });
    AutodiscoverService.prototype.CallRedirectionUrlValidationCallback = function (redirectionUrl) {
        var callback = (this.RedirectionUrlValidationCallback == null)
            ? this.DefaultAutodiscoverRedirectionUrlValidationCallback
            : this.RedirectionUrlValidationCallback;
        return callback(redirectionUrl);
    };
    AutodiscoverService.prototype.DefaultAutodiscoverRedirectionUrlValidationCallback = function (redirectionUrl) {
        throw new AutodiscoverLocalException(StringHelper.Format("Autodiscover redirection is blocked for url: {0}" /*Strings.AutodiscoverRedirectBlocked*/, redirectionUrl));
    };
    //DefaultGetScpUrlsForDomain(domainName: string): string[] { return null; }// System.Collections.Generic.ICollection<string>{ throw new Error("AutodiscoverService.ts - DefaultGetScpUrlsForDomain : Not implemented.");}
    //DisableScpLookupIfDuplicateRedirection(emailAddress: string, redirectionEmailAddresses: string[]): any{ throw new Error("AutodiscoverService.ts - DisableScpLookupIfDuplicateRedirection : Not implemented.");}
    AutodiscoverService.prototype.GetAutodiscoverEndpointUrl = function (host) {
        var autodiscoverUrlOut = { outValue: null };
        return this.TryGetAutodiscoverEndpointUrl(host, autodiscoverUrlOut)
            .then(function (value) {
            if (value) {
                return autodiscoverUrlOut.outValue;
            }
            else {
                throw new AutodiscoverLocalException("no soap or WsSecurity endpoint available" /*Strings.NoSoapOrWsSecurityEndpointAvailable*/);
            }
        }, function (err) {
            throw new AutodiscoverLocalException("no soap or WsSecurity endpoint available" /*Strings.NoSoapOrWsSecurityEndpointAvailable*/);
        });
    };
    //--done
    AutodiscoverService.prototype.GetAutodiscoverServiceHosts = function (domainName) {
        var serviceHosts = [];
        var urls = this.GetAutodiscoverServiceUrls(domainName);
        for (var _a = 0, urls_1 = urls; _a < urls_1.length; _a++) {
            var url = urls_1[_a];
            serviceHosts.push(UriHelper.getHost(url));
        }
        return serviceHosts;
    };
    //--done
    AutodiscoverService.prototype.GetAutodiscoverServiceUrls = function (domainName) {
        var urls = [];
        if (this.EnableScpLookup) {
            // Get SCP URLs
            //Func < string, ICollection <string>> callback = this.GetScpUrlsForDomainCallback ?? this.DefaultGetScpUrlsForDomain;
            //ICollection < string> scpUrls = callback(domainName);
            //foreach(string str in scpUrls)
            //{
            //    urls.Add(new Uri(str));
            //}
        }
        //scpHostCount = urls.length;
        // As a fallback, add autodiscover URLs base on the domain name.
        urls.push(StringHelper.Format(AutodiscoverService.AutodiscoverLegacyHttpsUrl, "autodiscover." + domainName));
        urls.push(StringHelper.Format(AutodiscoverService.AutodiscoverLegacyHttpsUrl, domainName));
        return urls;
    };
    AutodiscoverService.prototype.GetDomainSettings = function (domainOrDomainNames, settingsOrVersion, versionOrSettingNames //...params DomainSettingName[]
    ) {
        // EwsUtilities.ValidateParam(domains, "domains");
        // EwsUtilities.ValidateParam(settings, "settings");
        var requestedVersion = null;
        var settings = [];
        if (arguments.length <= 3) {
            if (Array.isArray(settingsOrVersion)) {
                settings = settingsOrVersion;
                requestedVersion = versionOrSettingNames;
            }
            else {
                settings.push(arguments[2]);
            }
        }
        else {
            if (settingsOrVersion !== null && typeof settingsOrVersion !== 'number') {
                throw new Error("AutodiscoverService.ts - GetDomainSettings with " + arguments.length + " incorrect uses of parameter at 2nd position, it must be ExchangeVersion or null when using DomainSettingName[] ...params at 3rd place");
            }
            for (var _i = 2; _i < arguments.length; _i++) {
                settings[_i - 2] = arguments[_i];
            }
            requestedVersion = settingsOrVersion;
        }
        var isCollection = true;
        var domains = domainOrDomainNames;
        if (!Array.isArray(domainOrDomainNames)) {
            domains = [domainOrDomainNames];
            isCollection = false;
        }
        return this.GetSettings(domains, settings, requestedVersion, this.InternalGetDomainSettings, function () { return domains[0]; }).then(function (value) {
            if (isCollection) {
                return value;
            }
            else {
                return value.__thisIndexer(0);
            }
        }, function (error) {
            throw error;
        });
        // var request = new GetDomainSettingsRequest(this, this.url);
        // request.Settings = domainSettingNames;
        // request.Domains = [domain];
        // var response = request.Execute();
        // return <any>response;
    };
    //previous name - GetEndpointsFromHttpWebResponse
    AutodiscoverService.prototype.GetEndpointsFromHttpResponse = function (response) {
        var endpoints = AutodiscoverEndpoints.Legacy;
        if (!StringHelper.IsNullOrEmpty(response.getResponseHeader(AutodiscoverService.AutodiscoverSoapEnabledHeaderName))) {
            endpoints |= AutodiscoverEndpoints.Soap;
        }
        if (!StringHelper.IsNullOrEmpty(response.getResponseHeader(AutodiscoverService.AutodiscoverWsSecurityEnabledHeaderName))) {
            endpoints |= AutodiscoverEndpoints.WsSecurity;
        }
        if (!StringHelper.IsNullOrEmpty(response.getResponseHeader(AutodiscoverService.AutodiscoverWsSecuritySymmetricKeyEnabledHeaderName))) {
            endpoints |= AutodiscoverEndpoints.WSSecuritySymmetricKey;
        }
        if (!StringHelper.IsNullOrEmpty(response.getResponseHeader(AutodiscoverService.AutodiscoverWsSecurityX509CertEnabledHeaderName))) {
            endpoints |= AutodiscoverEndpoints.WSSecurityX509Cert;
        }
        if (!StringHelper.IsNullOrEmpty(response.getResponseHeader(AutodiscoverService.AutodiscoverOAuthEnabledHeaderName))) {
            endpoints |= AutodiscoverEndpoints.OAuth;
        }
        return endpoints;
    };
    //GetLegacyUserSettings(emailAddress: string): any{ throw new Error("AutodiscoverService.ts - GetLegacyUserSettings : Not implemented.");}
    //GetLegacyUserSettingsAtUrl(emailAddress: string, url: Uri): any{ throw new Error("AutodiscoverService.ts - GetLegacyUserSettingsAtUrl : Not implemented.");}
    //GetRedirectionUrlFromDnsSrvRecord(domainName: string): Uri{ throw new Error("AutodiscoverService.ts - GetRedirectionUrlFromDnsSrvRecord : Not implemented.");}
    AutodiscoverService.prototype.GetRedirectUrl = function (domainName) {
        var _this = this;
        var url = StringHelper.Format(AutodiscoverService.AutodiscoverLegacyHttpUrl, "autodiscover." + domainName);
        this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("Trying to get Autodiscover redirection URL from {0}.", url));
        var xhrOptions = {
            type: "GET",
            url: url,
        };
        return this.XHRApi.xhr(xhrOptions)
            .then(function (response) {
            if (response != null) {
                _this.TraceMessage(TraceFlags.All, "***hard checking for office 365 with node.js http request and presence of header x-federationtrusttokenissueruri= urn:federation:MicrosoftOnline");
                var redirectUrl = null;
                if (!StringHelper.IsNullOrEmpty(response.getResponseHeader("x-federationtrusttokenissueruri"))) {
                    if (response.getResponseHeader("x-federationtrusttokenissueruri") === "urn:federation:MicrosoftOnline")
                        redirectUrl = "https://autodiscover-s.outlook.com/autodiscover/autodiscover.svc";
                    return new Uri(redirectUrl);
                }
                //if (this.TryGetRedirectionResponse(response, redirectUrl)) {
                //    return redirectUrl;
                //}
            }
            _this.TraceMessage(TraceFlags.AutodiscoverConfiguration, "No Autodiscover redirection URL was returned.");
            return null;
        }, function (resperr) {
            if (resperr.status === 0) {
                //catch (IOException ex)
                _this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("I/O error: {0}", "unable to connect"));
            }
            else {
                //catch (WebException ex)
                _this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("--Request error: {0}, {1}", resperr.status, resperr.statusText));
                //todo: possible?
                // The exception response factory requires a valid HttpWebResponse,
                // but there will be no web response if the web request couldn't be
                // actually be issued (e.g. due to DNS error).
                //if (ex.Response != null) {
                //    response = this.HttpWebRequestFactory.CreateExceptionResponse(ex);
                //}
            }
            if (resperr.status === 401) {
                _this.TraceMessage(TraceFlags.All, "***hard checking for office 365 with node.js http request and presence of header x-federationtrusttokenissueruri= urn:federation:MicrosoftOnline");
                var redirectUrl = null;
                if (!StringHelper.IsNullOrEmpty(resperr.getResponseHeader("x-federationtrusttokenissueruri"))) {
                    if (resperr.getResponseHeader("x-federationtrusttokenissueruri") === "urn:federation:MicrosoftOnline") {
                        redirectUrl = "https://autodiscover-s.outlook.com/autodiscover/autodiscover.svc";
                        _this.TraceMessage(TraceFlags.All, "possible hard match for O365 based on federation header (could be any legitimate 302 redirect - less likely)\r\n trying to connect to O365 multitenent autodiscover url: " + redirectUrl);
                    }
                    return new Uri(redirectUrl);
                }
            }
            return null;
        });
    };
    AutodiscoverService.prototype.GetSettings = function (identities, settings, requestedVersion, getSettingsMethod, getDomainMethod) {
        var _this = this;
        // Autodiscover service only exists in E14 or later.
        if (this.RequestedServerVersion < AutodiscoverService.MinimumRequestVersionForAutoDiscoverSoapService) {
            throw new ServiceVersionException(StringHelper.Format(Strings.AutodiscoverServiceIncompatibleWithRequestVersion, AutodiscoverService.MinimumRequestVersionForAutoDiscoverSoapService));
        }
        var response = null;
        var autodiscoverUrlRef = { getValue: function () { return _this.Url; }, setValue: function (url) { return _this.url = url; } };
        // If Url is specified, call service directly.
        if (this.Url != null) {
            return getSettingsMethod(identities, settings, requestedVersion, autodiscoverUrlRef, this)
                .then(function (response) {
                _this.Url = autodiscoverUrlRef.getValue();
                return response;
            });
        }
        else if (!StringHelper.IsNullOrEmpty(this.Domain)) {
            return this.GetAutodiscoverEndpointUrl(this.Domain)
                .then(function (adsvcurl) {
                autodiscoverUrlRef = { getValue: function () { return adsvcurl; } };
                return getSettingsMethod(identities, settings, requestedVersion, autodiscoverUrlRef, _this)
                    .then(function (response) {
                    // If we got this far, response was successful, set Url.
                    _this.Url = autodiscoverUrlRef.getValue();
                    return response;
                });
            });
        }
        else {
            // Assume caller is not inside the Intranet, regardless of whether SCP Urls
            // were returned or not. SCP Urls are only relevent if one of them returns
            // valid Autodiscover settings.
            this.IsExternal = true;
            var autodiscoverOutUrl = { outValue: undefined };
            var domainName = getDomainMethod();
            var scpHostCount;
            var hosts = this.GetAutodiscoverServiceHosts(domainName); //, scpHostCount);
            if (hosts.length == 0) {
                throw new ServiceValidationException("autodiscover service request requires domain or url"
                /*Strings.AutodiscoverServiceRequestRequiresDomainOrUrl*/ );
            }
            return this.GetSettingsRecursiveLookup(identities, settings, requestedVersion, getSettingsMethod, autodiscoverUrlRef, hosts).then(function (response) {
                return response;
            }, function (err) {
                _this.TraceMessage(TraceFlags.DebugMessage, "--hard checking for office 365 with node.js http request and presence of header x-federationtrusttokenissueruri: urn:federation:MicrosoftOnline. All other redirection wil fail");
                // Next-to-last chance: try unauthenticated GET over HTTP to be redirected to appropriate service endpoint.
                return _this.GetRedirectUrl(domainName).then(function (autodiscoverUrl) {
                    if ((autodiscoverUrl != null) &&
                        _this.CallRedirectionUrlValidationCallback(autodiscoverUrl.ToString())) {
                        return _this.TryGetAutodiscoverEndpointUrl(autodiscoverUrl.Host, { outValue: autodiscoverUrl }).then(function (value) {
                            if (value) {
                                return getSettingsMethod(identities, settings, requestedVersion, { getValue: function () { return autodiscoverUrl; } }, _this).then(function (response) {
                                    // If we got this far, response was successful, set Url.
                                    _this.Url = autodiscoverUrl;
                                    return response;
                                });
                            }
                        });
                    }
                }, function (err) {
                    throw new AutodiscoverLocalException("Autodiscover could not be located, skipped srv record lookup, not implement in this js version" /*Strings.AutodiscoverCouldNotBeLocated*/);
                });
            });
            /// ------- SRV record resolution not implemented ------- /// Last Chance: try to read autodiscover SRV Record from DNS. If we find one, use
            ////// the hostname returned to construct an Autodiscover endpoint URL.
            ////autodiscoverUrl = this.GetRedirectionUrlFromDnsSrvRecord(domainName);
            ////if ((autodiscoverUrl != null) &&
            ////    this.CallRedirectionUrlValidationCallback(autodiscoverUrl.ToString()) &&
            ////    this.TryGetAutodiscoverEndpointUrl(autodiscoverUrl.Host, out autodiscoverUrl)) {
            ////    response = getSettingsMethod(
            ////        identities,
            ////        settings,
            ////        requestedVersion,
            ////        ref autodiscoverUrl);
            ////    // If we got this far, the response was successful, set Url.
            ////    this.Url = autodiscoverUrl;
            ////    return response;
            ////}
            ////else {
            ////    throw new AutodiscoverLocalException(Strings.AutodiscoverCouldNotBeLocated);
            ////}
        }
    };
    AutodiscoverService.prototype.GetSettingsRecursiveLookup = function (identities, settings, requestedVersion, getSettingsMethod, autodiscoverUrlRef, hosts, currentHostIndex) {
        //        for (var currentHostIndex = 0; currentHostIndex < hosts.length; currentHostIndex++) {
        var _this = this;
        if (currentHostIndex === void 0) { currentHostIndex = 0; }
        if (currentHostIndex >= hosts.length)
            throw new AutodiscoverLocalException("***cannot determine based on autodiscover host names");
        var host = hosts[currentHostIndex];
        // var isScpHost:bool = currentHostIndex < scpHostCount;
        var autodiscoverUrlOut = { outValue: null };
        return this.TryGetAutodiscoverEndpointUrl(host, autodiscoverUrlOut)
            .then(function (value) {
            if (value) {
                return getSettingsMethod(identities, settings, requestedVersion, autodiscoverUrlRef, _this).then(function (response) {
                    // If we got this far, the response was successful, set Url.
                    _this.Url = autodiscoverUrlRef.getValue();
                    // Not external if Autodiscover endpoint found via SCP returned the settings.
                    //if (isScpHost) {
                    //    this.IsExternal = false;
                    //}
                    return response;
                });
            }
            else {
                currentHostIndex++;
                return _this.GetSettingsRecursiveLookup(identities, settings, requestedVersion, getSettingsMethod, autodiscoverUrlRef, hosts, currentHostIndex);
            }
        }, function (err) {
            currentHostIndex++;
            return _this.GetSettingsRecursiveLookup(identities, settings, requestedVersion, getSettingsMethod, autodiscoverUrlRef, hosts, currentHostIndex);
        });
    };
    AutodiscoverService.prototype.GetUserSettings = function (smtpAddresses, userSettings) {
        var userSettingNames = [];
        if (arguments.length === 2) {
            if (Array.isArray(userSettings)) {
                userSettingNames = userSettings;
            }
            else {
                userSettingNames.push(arguments[1]);
            }
        }
        else {
            for (var _i = 1; _i < arguments.length; _i++) {
                userSettingNames[_i - 1] = arguments[_i];
            }
        }
        if (Array.isArray(smtpAddresses)) {
            //EwsUtilities.ValidateParam(smtpAddresses, "smtpAddresses");
            //EwsUtilities.ValidateParam(settings, "settings");
            return this.GetSettings(smtpAddresses, userSettingNames, null, this.InternalGetUserSettings, function () { return EwsUtilities.DomainFromEmailAddress(smtpAddresses[0]); });
        }
        var userSmtpAddress = smtpAddresses;
        //List < UserSettingName > requestedSettings = new List<UserSettingName>(userSettingNames);
        if (StringHelper.IsNullOrEmpty(userSmtpAddress)) {
            throw new ServiceValidationException("invalid autodiscover smtp address" /*Strings.InvalidAutodiscoverSmtpAddress*/);
        }
        var requestedSettings = userSettingNames || [];
        if (requestedSettings.length == 0) {
            throw new ServiceValidationException("invalid autodiscover setting count" /*Strings.InvalidAutodiscoverSettingsCount*/);
        }
        if (this.RequestedServerVersion < AutodiscoverService.MinimumRequestVersionForAutoDiscoverSoapService) {
            return this.InternalGetLegacyUserSettings(userSmtpAddress, requestedSettings);
        }
        else {
            return this.InternalGetSoapUserSettings(userSmtpAddress, requestedSettings);
        }
    };
    AutodiscoverService.prototype.GetUsersSettings = function (userSmtpAddresses) {
        var userSettingNames = [];
        for (var _a = 1; _a < arguments.length; _a++) {
            userSettingNames[_a - 1] = arguments[_a];
        }
        if (this.RequestedServerVersion < AutodiscoverService.MinimumRequestVersionForAutoDiscoverSoapService) {
            throw new ServiceVersionException(StringHelper.Format(/*Strings.AutodiscoverServiceIncompatibleWithRequestVersion*/ "autodiscover service is incompatible with requested versio, minimum versi supported is {0}", AutodiscoverService.MinimumRequestVersionForAutoDiscoverSoapService));
        }
        ////var smtpAddresses: string[] = []// new List<string>(userSmtpAddresses);
        ////if (userSmtpAddresses)
        ////    userSmtpAddresses.forEach((s) => smtpAddresses.push(s));
        ////else throw new Error("invalid input");
        ////var settingNames: UserSettingName[] = [];// List<UserSettingName>(userSettingNames);
        ////if(userSettingNames)
        ////userSettingNames.forEach((s)=> settingNames.push());
        return this.GetUserSettings(userSmtpAddresses, userSettingNames); //calls getsettings
    };
    AutodiscoverService.prototype.InternalGetDomainSettings = function (domains, settings, requestedVersion, autodiscoverUrlRef, thisref, currentHop) {
        var _this = this;
        if (currentHop === void 0) { currentHop = 0; }
        // The response to GetDomainSettings can be a redirection. Execute GetDomainSettings until we get back 
        // a valid response or we've followed too many redirections.
        currentHop++;
        if (currentHop > AutodiscoverService.AutodiscoverMaxRedirections) {
            this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("Maximum number of redirection hops {0} exceeded", AutodiscoverService.AutodiscoverMaxRedirections));
            throw new AutodiscoverLocalException(Strings.AutodiscoverCouldNotBeLocated);
        }
        //BUG  - Typescript bug, reference for "this" inside multiple layers of IPromise points to global this object;
        //(may be not) - this functional is called as delegate under Promise chaining, loss poiters to this.
        //var request: GetUserSettingsRequest = new GetUserSettingsRequest(this, autodiscoverUrlRef.refvalue);
        var request = new GetDomainSettingsRequest(thisref, autodiscoverUrlRef.getValue());
        request.Settings = settings;
        request.Domains = domains;
        return request.Execute().then(function (response) {
            // Did we get redirected?
            if (response.ErrorCode == AutodiscoverErrorCode.RedirectUrl && response.RedirectionUrl != null) {
                _this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("Request to {0} returned redirection to {1}", autodiscoverUrlRef.getValue().ToString(), response.RedirectionUrl.ToString()));
                // this url need be brought back to the caller.
                //
                autodiscoverUrlRef.setValue(response.RedirectionUrl);
                return _this.InternalGetDomainSettings(domains, settings, requestedVersion, autodiscoverUrlRef, thisref, currentHop);
            }
            else {
                return response;
            }
        }, function (err) {
        });
    };
    AutodiscoverService.prototype.InternalGetLegacyUserSettings = function (emailAddress, requestedSettings) {
        throw new Error("Not implemented.");
    };
    AutodiscoverService.prototype.InternalGetLegacyUserSettingsPrivate = function (emailAddress, redirectionEmailAddresses, currentHop) {
        throw new Error("Not implemented.");
    };
    AutodiscoverService.prototype.InternalGetSoapUserSettings = function (smtpAddress, requestedSettings) {
        var smtpAddresses = [];
        smtpAddresses.push(smtpAddress);
        var redirectionEmailAddresses = [];
        redirectionEmailAddresses.push(smtpAddress.toLowerCase());
        return this.InternalGetSoapUserSettingsRecursive(smtpAddresses, requestedSettings, redirectionEmailAddresses);
    };
    AutodiscoverService.prototype.InternalGetSoapUserSettingsRecursive = function (smtpAddresses, requestedSettings, redirectionEmailAddresses, currentHop) {
        var _this = this;
        if (redirectionEmailAddresses === void 0) { redirectionEmailAddresses = []; }
        if (currentHop === void 0) { currentHop = 0; }
        currentHop++;
        //if (currentHop > AutodiscoverService.AutodiscoverMaxRedirections)
        //    throw new AutodiscoverLocalException(Strings.AutodiscoverCouldNotBeLocated);
        return this.GetUserSettings(smtpAddresses, requestedSettings)
            .then(function (resp) {
            var response = resp.Responses[0];
            switch (response.ErrorCode) {
                case AutodiscoverErrorCode.RedirectAddress:
                    _this.TraceMessage(TraceFlags.AutodiscoverResponse, StringHelper.Format("Autodiscover service returned redirection email address '{0}'.", response.RedirectTarget));
                    smtpAddresses.splice(0);
                    smtpAddresses.push(response.RedirectTarget.toLowerCase());
                    _this.Url = null;
                    _this.Domain = null;
                    // If this email address was already tried, we may have a loop
                    // in SCP lookups. Disable consideration of SCP records.
                    _this.ThrowIfDuplicateRedirection(response.RedirectTarget, { getValue: function () { return redirectionEmailAddresses; } });
                    return _this.InternalGetSoapUserSettingsRecursive(smtpAddresses, requestedSettings, redirectionEmailAddresses, currentHop);
                    break;
                case AutodiscoverErrorCode.RedirectUrl:
                    _this.TraceMessage(TraceFlags.AutodiscoverResponse, StringHelper.Format("Autodiscover service returned redirection URL '{0}'.", response.RedirectTarget));
                    _this.Url = _this.Credentials.AdjustUrl(new Uri(response.RedirectTarget));
                    return _this.InternalGetSoapUserSettingsRecursive(smtpAddresses, requestedSettings, redirectionEmailAddresses, currentHop);
                    break;
                case AutodiscoverErrorCode.NoError:
                default:
                    return response;
            }
        }, function (err) {
            throw err;
        });
    };
    AutodiscoverService.prototype.InternalGetUserSettings = function (smtpAddresses, settings, requestedVersion, autodiscoverUrlRef, thisref, currentHop) {
        var _this = this;
        if (currentHop === void 0) { currentHop = 0; }
        // The response to GetUserSettings can be a redirection. Execute GetUserSettings until we get back
        // a valid response or we've followed too many redirections.
        //this function is called recursively for that
        currentHop++;
        if (currentHop > AutodiscoverService.AutodiscoverMaxRedirections) {
            this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("Maximum number of redirection hops {0} exceeded", AutodiscoverService.AutodiscoverMaxRedirections));
            throw new AutodiscoverLocalException("Autodiscover settings could not be located, max redirection reached" /*Strings.AutodiscoverCouldNotBeLocated*/);
        }
        //BUG  - Typescript bug, reference for "this" inside multiple layers of IPromise points to global this object;
        //(may be not) - this functional is called as delegate under Promise chaining, loss poiters to this.
        //var request: GetUserSettingsRequest = new GetUserSettingsRequest(this, autodiscoverUrlRef.refvalue);
        var request = new GetUserSettingsRequest(thisref, autodiscoverUrlRef.getValue());
        request.SmtpAddresses = smtpAddresses;
        request.Settings = settings;
        return request.Execute().then(function (response) {
            // Did we get redirected?
            if (response.ErrorCode == AutodiscoverErrorCode.RedirectUrl && response.RedirectionUrl != null) {
                _this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("Request to {0} returned redirection to {1}", autodiscoverUrlRef.getValue().ToString(), response.RedirectionUrl.ToString()));
                // this url need be brought back to the caller.
                //
                autodiscoverUrlRef.setValue(response.RedirectionUrl);
                return _this.InternalGetUserSettings(smtpAddresses, settings, requestedVersion, autodiscoverUrlRef, thisref, currentHop);
            }
            else {
                return response;
            }
        }, function (err) {
        });
    };
    //PrepareHttpWebRequestForUrl(url: Uri): Data.IEwsHttpWebRequest{ throw new Error("AutodiscoverService.ts - PrepareHttpWebRequestForUrl : Not implemented.");}
    //ProcessHttpErrorResponse(httpWebResponse: Data.IEwsHttpWebResponse, webException: any): any{ throw new Error("AutodiscoverService.ts - ProcessHttpErrorResponse : Not implemented.");}
    AutodiscoverService.prototype.ProcessHttpErrorResponse = function (httpWebResponse, webException) { /*throw new Error("Not implemented.")*/ ; };
    AutodiscoverService.prototype.TraceResponse = function (response, memoryStream) {
        //todo: implement tracing
        //this.ProcessHttpResponseHeaders(TraceFlags.AutodiscoverResponseHttpHeaders, response);
        //if (this.TraceEnabled) {
        //    if (!StringHelper.IsNullOrEmpty(response.ContentType) &&
        //        (response.ContentType.StartsWith("text/", StringComparison.OrdinalIgnoreCase) ||
        //        response.ContentType.StartsWith("application/soap", StringComparison.OrdinalIgnoreCase))) {
        //        this.TraceXml(TraceFlags.AutodiscoverResponse, memoryStream);
        //    }
        //    else {
        //        this.TraceMessage(TraceFlags.AutodiscoverResponse, "Non-textual response");
        //    }
        //}
    };
    AutodiscoverService.prototype.TryGetAutodiscoverEndpointUrl = function (host, url) {
        var _this = this;
        url.outValue = null;
        var endpointsOut = { outValue: AutodiscoverEndpoints.None };
        return this.TryGetEnabledEndpointsForHost({ getValue: function () { return host; }, setValue: function (value) { return host = value; } }, endpointsOut).then(function (value) {
            if (value) {
                url.outValue = new Uri(StringHelper.Format(AutodiscoverService.AutodiscoverSoapHttpsUrl, host));
                var endpoints = endpointsOut.outValue;
                // Make sure that at least one of the non-legacy endpoints is available.
                if (((endpoints & AutodiscoverEndpoints.Soap) != AutodiscoverEndpoints.Soap) &&
                    ((endpoints & AutodiscoverEndpoints.WsSecurity) != AutodiscoverEndpoints.WsSecurity) &&
                    ((endpoints & AutodiscoverEndpoints.WSSecuritySymmetricKey) != AutodiscoverEndpoints.WSSecuritySymmetricKey) &&
                    ((endpoints & AutodiscoverEndpoints.WSSecurityX509Cert) != AutodiscoverEndpoints.WSSecurityX509Cert) &&
                    ((endpoints & AutodiscoverEndpoints.OAuth) != AutodiscoverEndpoints.OAuth)) {
                    _this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("No Autodiscover endpoints are available  for host {0}", host));
                    return false;
                }
                // If we have WLID credentials, make sure that we have a WS-Security endpoint
                return true;
                if (_this.Credentials instanceof WindowsLiveCredentials) {
                    if ((endpoints & AutodiscoverEndpoints.WsSecurity) != AutodiscoverEndpoints.WsSecurity) {
                        _this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("No Autodiscover WS-Security endpoint is available for host {0}", host));
                        return false;
                    }
                    else {
                        url.outValue = new Uri(StringHelper.Format(AutodiscoverService.AutodiscoverSoapWsSecurityHttpsUrl, host));
                    }
                }
                else if (_this.Credentials instanceof PartnerTokenCredentials) {
                    if ((endpoints & AutodiscoverEndpoints.WSSecuritySymmetricKey) != AutodiscoverEndpoints.WSSecuritySymmetricKey) {
                        _this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("No Autodiscover WS-Security/SymmetricKey endpoint is available for host {0}", host));
                        return false;
                    }
                    else {
                        url.outValue = new Uri(StringHelper.Format(AutodiscoverService.AutodiscoverSoapWsSecuritySymmetricKeyHttpsUrl, host));
                    }
                }
                else if (_this.Credentials instanceof X509CertificateCredentials) {
                    if ((endpoints & AutodiscoverEndpoints.WSSecurityX509Cert) != AutodiscoverEndpoints.WSSecurityX509Cert) {
                        _this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("No Autodiscover WS-Security/X509Cert endpoint is available for host {0}", host));
                        return false;
                    }
                    else {
                        url.outValue = new Uri(StringHelper.Format(AutodiscoverService.AutodiscoverSoapWsSecurityX509CertHttpsUrl, host));
                    }
                }
                else if (_this.Credentials instanceof OAuthCredentials) {
                    // If the credential is OAuthCredentials, no matter whether we have
                    // the corresponding x-header, we will go with OAuth.
                    url.outValue = new Uri(StringHelper.Format(AutodiscoverService.AutodiscoverSoapHttpsUrl, host));
                }
                return true;
            }
            else {
                _this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("No Autodiscover endpoints are available for host {0}", host));
                return false;
            }
        }, function (err) { throw err; });
    };
    AutodiscoverService.prototype.TryGetEnabledEndpointsForHost = function (host, endpoints, currentHop) {
        var _this = this;
        if (currentHop === void 0) { currentHop = 0; }
        this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("Determining which endpoints are enabled for host {0}", host.getValue()));
        currentHop++;
        // We may get redirected to another host. And therefore need to limit the number
        // of redirections we'll tolerate.
        if (currentHop > AutodiscoverService.AutodiscoverMaxRedirections) {
            this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("Maximum number of redirection hops {0} exceeded", AutodiscoverService.AutodiscoverMaxRedirections));
            throw new AutodiscoverLocalException("Maximum redirection hop reached" /*Strings.MaximumRedirectionHopsExceeded*/);
        }
        var autoDiscoverUrl = StringHelper.Format(AutodiscoverService.AutodiscoverLegacyHttpsUrl, host.getValue());
        endpoints.outValue = AutodiscoverEndpoints.None;
        var xhrOptions = {
            type: "GET",
            url: autoDiscoverUrl,
        };
        //todo - optimize code, need to apply logic in failed errors as 401 go to onerror of xhr;
        return this.XHRApi.xhr(xhrOptions)
            .then(function (response) {
            if (response != null) {
                var redirectUrl = null;
                ;
                if (_this.TryGetRedirectionResponse(response, { outValue: redirectUrl })) {
                    _this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("Host returned redirection to host '{0}'", redirectUrl.Host));
                    host.setValue(UriHelper.getHost(redirectUrl));
                }
                else {
                    endpoints.outValue = _this.GetEndpointsFromHttpResponse(response);
                    _this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("Host returned enabled endpoint flags: {0}", EnumHelper.ToString(AutodiscoverEndpoints, endpoints.outValue)));
                    return true;
                }
            }
            else {
                return false;
            }
        }, function (resperr) {
            if (resperr.status === 0) {
                //catch (IOException ex)
                _this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("I/O error: {0}", "unable to connect"));
            }
            else if (resperr.status === 401) {
                endpoints.outValue = _this.GetEndpointsFromHttpResponse(resperr);
                _this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("Host returned enabled endpoint flags: {0}", EnumHelper.ToString(AutodiscoverEndpoints, endpoints.outValue)));
                return true;
            }
            else {
                //catch (WebException ex)
                _this.TraceMessage(TraceFlags.AutodiscoverConfiguration, StringHelper.Format("Request error: {0}, {1}", resperr.status, resperr.statusText));
                //todo: possible?
                // The exception response factory requires a valid HttpWebResponse,
                // but there will be no web response if the web request couldn't be
                // actually be issued (e.g. due to DNS error).
                //if (ex.Response != null) {
                //    response = this.HttpWebRequestFactory.CreateExceptionResponse(ex);
                //}
            }
            return false;
        });
    };
    AutodiscoverService.prototype.ThrowIfDuplicateRedirection = function (emailAddress, redirectionEmailAddresses) {
        // SMTP addresses are case-insensitive so entries are converted to lower-case.
        emailAddress = emailAddress.toLowerCase();
        if (redirectionEmailAddresses.getValue().indexOf(emailAddress) >= 0) {
            //this.EnableScpLookup = false;
            throw new AutodiscoverLocalException("Detected redirection loop, Redirection address already tried");
        }
        else {
            var oldcount = redirectionEmailAddresses.getValue().length;
            redirectionEmailAddresses.getValue().push(emailAddress);
            if (oldcount === redirectionEmailAddresses.getValue().length) {
                throw new Error("AutodiscoverService.ts - error in ref param logic, need to fix array type getter");
            }
            EwsLogging.Assert(false, "AutodiscoverService.ts - ThrowIfDuplicateRedirection", "AutodiscoverService.ts - array getter worked:), remove this message and throw statement");
        }
    };
    //TryGetPartnerAccess(targetTenantDomain: string, partnerAccessCredentials: any, targetTenantAutodiscoverUrl: any): boolean{ throw new Error("AutodiscoverService.ts - TryGetPartnerAccess : Not implemented.");}
    AutodiscoverService.prototype.TryGetRedirectionResponse = function (response, redirectUrl) {
        this.TraceMessage(TraceFlags.DebugMessage, "cant determine redirectionResponse, 302 redirect code does not work in browser xhr and in Node.js http response");
        //redirectUrl.outValue = null;
        //if (AutodiscoverRequest.IsRedirectionResponse(response)) {
        //    // Get the redirect location and verify that it's valid.
        //    var location = response.getResponseHeader("Location");//. [HttpResponseHeader.Location];
        //    if (!StringHelper.IsNullOrEmpty(location)) {
        //        try
        //        {
        //            redirectUrl.outValue = location;
        //            // Check if URL is SSL and that the path matches.
        //            var match =  LegacyPathRegex.Match(redirectUrl.AbsolutePath);
        //            if ((redirectUrl.Scheme == UriHelper.UriSchemeHttps) &&
        //                match.Success) {
        //                this.TraceMessage(
        //                    TraceFlags.AutodiscoverConfiguration,
        //                    StringHelper.Format("Redirection URL found: '{0}'", redirectUrl));
        //                return true;
        //            }
        //        }
        //        catch (UriFormatException) {
        //            this.TraceMessage(
        //                TraceFlags.AutodiscoverConfiguration,
        //                StringHelper.Format("Invalid redirection URL was returned: '{0}'", location));
        //            return false;
        //        }
        //    }
        //}
        return false;
    };
    AutodiscoverService.AutodiscoverLegacyPath = "/autodiscover/autodiscover.xml";
    AutodiscoverService.AutodiscoverLegacyUrl = "{0}://{1}" + AutodiscoverService.AutodiscoverLegacyPath;
    AutodiscoverService.AutodiscoverLegacyHttpsUrl = "https://{0}" + AutodiscoverService.AutodiscoverLegacyPath;
    AutodiscoverService.AutodiscoverLegacyHttpUrl = "http://{0}" + AutodiscoverService.AutodiscoverLegacyPath;
    AutodiscoverService.AutodiscoverSoapHttpsUrl = "https://{0}/autodiscover/autodiscover.svc";
    AutodiscoverService.AutodiscoverSoapWsSecurityHttpsUrl = AutodiscoverService.AutodiscoverSoapHttpsUrl + "/wssecurity";
    AutodiscoverService.AutodiscoverSoapWsSecuritySymmetricKeyHttpsUrl = AutodiscoverService.AutodiscoverSoapHttpsUrl + "/wssecurity/symmetrickey";
    AutodiscoverService.AutodiscoverSoapWsSecurityX509CertHttpsUrl = AutodiscoverService.AutodiscoverSoapHttpsUrl + "/wssecurity/x509cert";
    AutodiscoverService.AutodiscoverRequestNamespace = "http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006";
    AutodiscoverService.AutodiscoverMaxRedirections = 10;
    AutodiscoverService.AutodiscoverSoapEnabledHeaderName = "X-SOAP-Enabled";
    AutodiscoverService.AutodiscoverWsSecurityEnabledHeaderName = "X-WSSecurity-Enabled";
    AutodiscoverService.AutodiscoverWsSecuritySymmetricKeyEnabledHeaderName = "X-WSSecurity-SymmetricKey-Enabled";
    AutodiscoverService.AutodiscoverWsSecurityX509CertEnabledHeaderName = "X-WSSecurity-X509Cert-Enabled";
    AutodiscoverService.AutodiscoverOAuthEnabledHeaderName = "X-OAuth-Enabled";
    AutodiscoverService.LegacyPathRegex = new RegExp("\/autodiscover/([^/]+/)*autodiscover.xml");
    AutodiscoverService.MinimumRequestVersionForAutoDiscoverSoapService = ExchangeVersion.Exchange2010;
    return AutodiscoverService;
}(ExchangeServiceBase));
exports.AutodiscoverService = AutodiscoverService;
//class AutodiscoverRedirectionUrlValidationCallback extends System.MulticastDelegate {
//    BeginInvoke(redirectionUrl: string, callback: System.AsyncCallback, object: any): System.IAsyncResult { throw new Error("AutodiscoverServiceDelegates.ts - BeginInvoke : Not implemented."); }
//    EndInvoke(result: System.IAsyncResult): boolean { throw new Error("AutodiscoverServiceDelegates.ts - EndInvoke : Not implemented."); }
//    Invoke(redirectionUrl: string): boolean { throw new Error("AutodiscoverServiceDelegates.ts - Invoke : Not implemented."); }
//}
var ComparisonHelpers = (function () {
    function ComparisonHelpers() {
    }
    ComparisonHelpers.prototype.CaseInsensitiveContains = function (collection /*System.Collections.ICollection*/, match) { throw new Error("ComparisonHelpers.ts - CaseInsensitiveContains : Not implemented."); };
    return ComparisonHelpers;
}());
exports.ComparisonHelpers = ComparisonHelpers;
var DirectoryHelper = (function () {
    function DirectoryHelper() {
    }
    DirectoryHelper.prototype.GetAutodiscoverScpUrlsForDomain = function (domainName) { throw new Error("DirectoryHelper.ts - GetAutodiscoverScpUrlsForDomain : Not implemented."); };
    DirectoryHelper.prototype.GetScpUrlList = function (domainName, ldapPath, maxHops) { throw new Error("DirectoryHelper.ts - GetScpUrlList : Not implemented."); };
    DirectoryHelper.prototype.GetSiteName = function () { throw new Error("DirectoryHelper.ts - GetSiteName : Not implemented."); };
    DirectoryHelper.prototype.TraceMessage = function (message) { throw new Error("DirectoryHelper.ts - TraceMessage : Not implemented."); };
    //private service: ExchangeServiceBase;
    DirectoryHelper.AutodiscoverMaxScpHops = 10;
    DirectoryHelper.ScpUrlGuidString = "77378F46-2C66-4aa9-A6A6-3E7A48B19596";
    DirectoryHelper.ScpPtrGuidString = "67661d7F-8FC4-4fa7-BFAC-E1D7794C1F68";
    DirectoryHelper.ScpFilterString = "(&(objectClass=serviceConnectionPoint)(|(keywords=67661d7F-8FC4-4fa7-BFAC-E1D7794C1F68)(keywords=77378F46-2C66-4aa9-A6A6-3E7A48B19596)))";
    return DirectoryHelper;
}());
exports.DirectoryHelper = DirectoryHelper;
var DocumentSharingLocation = (function () {
    function DocumentSharingLocation() {
    }
    //LoadFromXml(reader: EwsXmlReader): DocumentSharingLocation { throw new Error("DocumentSharingLocation.ts - LoadFromXml : Not implemented."); }
    DocumentSharingLocation.LoadFromJson = function (obj) { throw new Error("this was skipped at dev time, fix this"); };
    return DocumentSharingLocation;
}());
exports.DocumentSharingLocation = DocumentSharingLocation;
var DocumentSharingLocationCollection = (function () {
    function DocumentSharingLocationCollection() {
        this.Entries = []; //System.Collections.Generic.List<DocumentSharingLocation>;
    }
    /**@internal */
    DocumentSharingLocationCollection.LoadFromXml = function (reader) { throw new Error("Not implemented. Depricated, use LoadFromJson"); };
    DocumentSharingLocationCollection.LoadFromJson = function (obj) {
        var instance = new DocumentSharingLocationCollection();
        var element = XmlElementNames.AlternateMailbox;
        var responses = undefined;
        if (Object.prototype.toString.call(obj[element]) === "[object Array]")
            responses = obj[element];
        else
            responses = [obj[element]];
        for (var i = 0; i < responses.length; i++) {
            instance.Entries.push(responses[i]); //skipped processing individual objects in collection against DocumentSharingLocation, fix if there is parsing error later
            //DocumentSharingLocation.LoadFromJson(responses[i]);
            //instance.Entries.push(responses);
        }
        return instance;
    };
    return DocumentSharingLocationCollection;
}());
exports.DocumentSharingLocationCollection = DocumentSharingLocationCollection;
var DomainSettingError = (function () {
    function DomainSettingError() {
    }
    //private errorCode: AutodiscoverErrorCode;
    //private errorMessage: string;
    //private settingName: string;
    DomainSettingError.prototype.LoadFromObject = function (obj) {
        var errorstring = obj[XmlElementNames.ErrorCode];
        this.ErrorCode = AutodiscoverErrorCode[errorstring];
        this.ErrorMessage = obj[XmlElementNames.ErrorMessage];
        this.SettingName = obj[XmlElementNames.SettingName];
    };
    /**@internal */
    DomainSettingError.prototype.LoadFromXml = function (reader) {
        var parent = reader.CurrentNode;
        do {
            reader.Read();
            if (reader.NodeType == Node.ELEMENT_NODE) {
                switch (reader.LocalName) {
                    case XmlElementNames.ErrorCode:
                        var errorstring = reader.ReadElementValue();
                        this.ErrorCode = AutodiscoverErrorCode[errorstring];
                        break;
                    case XmlElementNames.ErrorMessage:
                        this.ErrorMessage = reader.ReadElementValue();
                        break;
                    case XmlElementNames.SettingName:
                        this.SettingName = reader.ReadElementValue();
                        break;
                }
            }
        } while (reader.HasRecursiveParentNode(parent, parent.localName));
        reader.SeekLast(); // fix xml treewalker to go back last node, next do..while loop will come back to current node.
    };
    return DomainSettingError;
}());
exports.DomainSettingError = DomainSettingError;
var ProtocolConnection = (function () {
    function ProtocolConnection() {
    }
    return ProtocolConnection;
}());
exports.ProtocolConnection = ProtocolConnection;
var ProtocolConnectionCollection = (function () {
    //private connections: ProtocolConnection[];//System.Collections.Generic.List<ProtocolConnection>;
    function ProtocolConnectionCollection() {
        this.Connections = []; //System.Collections.Generic.List<ProtocolConnection>;
    }
    /**@internal */
    ProtocolConnectionCollection.LoadFromXml = function (reader) { throw new Error("Not implemented. - depricated for JS api, use LoadFromJson"); };
    ProtocolConnectionCollection.LoadFromJson = function (obj) {
        var instance = new ProtocolConnectionCollection();
        var element = XmlElementNames.ProtocolConnection;
        var responses = undefined;
        if (Object.prototype.toString.call(obj[element]) === "[object Array]")
            responses = obj[element];
        else
            responses = [obj[element]];
        for (var i = 0; i < responses.length; i++) {
            instance.Connections.push(responses[i]);
            //var response: = this.CreateResponseInstance();
            //response.LoadFromObject(responses[i], this.GetResponseInstanceXmlElementName());
            //instance.Urls.push(responses);
        }
        return instance;
    };
    return ProtocolConnectionCollection;
}());
exports.ProtocolConnectionCollection = ProtocolConnectionCollection;
var UserSettingError = (function () {
    function UserSettingError() {
    }
    /**@internal */
    UserSettingError.prototype.LoadFromXml = function (reader) {
        var parent = reader.CurrentNode;
        do {
            reader.Read();
            if (reader.NodeType == Node.ELEMENT_NODE) {
                switch (reader.LocalName) {
                    case XmlElementNames.ErrorCode:
                        var errorstring = reader.ReadElementValue();
                        this.ErrorCode = AutodiscoverErrorCode[errorstring];
                        break;
                    case XmlElementNames.ErrorMessage:
                        this.ErrorMessage = reader.ReadElementValue();
                        break;
                    case XmlElementNames.SettingName:
                        this.SettingName = reader.ReadElementValue();
                        break;
                }
            }
        } while (reader.HasRecursiveParentNode(parent, parent.localName));
        reader.SeekLast(); // fix xml treewalker to go back last node, next do..while loop will come back to current node.
    };
    UserSettingError.prototype.LoadFromJson = function (obj) {
        var errorstring = obj[XmlElementNames.ErrorCode];
        this.ErrorCode = AutodiscoverErrorCode[errorstring];
        this.ErrorMessage = obj[XmlElementNames.ErrorMessage];
        this.SettingName = obj[XmlElementNames.SettingName];
    };
    return UserSettingError;
}());
exports.UserSettingError = UserSettingError;
var WebClientUrl = (function () {
    function WebClientUrl() {
    }
    //private authenticationMethods: string;
    //private url: string;
    WebClientUrl.LoadFromJson = function (obj) {
        var webClientUrl = new WebClientUrl();
        webClientUrl.AuthenticationMethods = obj[XmlElementNames.AuthenticationMethods];
        webClientUrl.Url = obj[XmlElementNames.Url];
        return webClientUrl;
    };
    /**@internal */
    WebClientUrl.LoadFromXml = function (reader) {
        var webClientUrl = new WebClientUrl();
        var parent = reader.CurrentNode;
        do {
            reader.Read();
            if (reader.NodeType == Node.ELEMENT_NODE) {
                switch (reader.LocalName) {
                    case XmlElementNames.AuthenticationMethods:
                        webClientUrl.AuthenticationMethods = reader.ReadElementValue();
                        break;
                    case XmlElementNames.Url:
                        webClientUrl.Url = reader.ReadElementValue();
                        break;
                }
            }
        } while (reader.HasRecursiveParentNode(parent, parent.localName));
        //reader.SeekLast();// fix xml treewalker to go back last node, next do..while loop will come back to current node.
        return webClientUrl;
    };
    return WebClientUrl;
}());
exports.WebClientUrl = WebClientUrl;
var WebClientUrlCollection = (function () {
    function WebClientUrlCollection() {
        this.Urls = []; // new Array<WebClientUrl>();// System.Collections.Generic.List<WebClientUrl>;
    }
    //private urls: WebClientUrl[];// System.Collections.Generic.List<WebClientUrl>;
    WebClientUrlCollection.LoadFromJson = function (obj) {
        var instance = new WebClientUrlCollection();
        var element = XmlElementNames.WebClientUrl;
        var responses = undefined;
        if (Object.prototype.toString.call(obj[element]) === "[object Array]")
            responses = obj[element];
        else
            responses = [obj[element]];
        for (var i = 0; i < responses.length; i++) {
            instance.Urls.push(responses[i]);
            //var response: = this.CreateResponseInstance();
            //response.LoadFromObject(responses[i], this.GetResponseInstanceXmlElementName());
            //instance.Urls.push(responses);
        }
        return instance;
    };
    /**@internal */
    WebClientUrlCollection.LoadFromXml = function (reader) {
        var instance = new WebClientUrlCollection();
        var parent = reader.CurrentNode;
        do {
            reader.Read();
            if ((reader.NodeType == 1 /*Node.ELEMENT_NODE*/) && (reader.LocalName == XmlElementNames.WebClientUrl)) {
                instance.Urls.push(WebClientUrl.LoadFromXml(reader));
            }
        } while (reader.HasRecursiveParentNode(parent, parent.localName));
        reader.SeekLast(); // fix xml treewalker to go back last node, next do..while loop will come back to current node.
        return instance;
    };
    return WebClientUrlCollection;
}());
exports.WebClientUrlCollection = WebClientUrlCollection;
//todo: not converted initially - pending
//export = BasicAuthModuleForUTF8;
var ExchangeCredentials = (function () {
    function ExchangeCredentials(userName, password) {
        if (userName === void 0) { userName = null; }
        if (password === void 0) { password = null; }
        this.UserName = null;
        if (arguments.length > 0 && (StringHelper.IsNullOrEmpty(userName) || StringHelper.IsNullOrEmpty(password))) {
            throw new Error("ExchangeCredentials.ctor, must provide username and password value.");
        }
        this.UserName = userName;
        var pwd = password;
        this.setPassword = function (value) { pwd = value; };
        this.getPassword = function () { return pwd; };
        //this.Password = password;
    }
    Object.defineProperty(ExchangeCredentials.prototype, "Password", {
        get: function () { return this.getPassword(); },
        set: function (value) { this.setPassword(value); },
        enumerable: true,
        configurable: true
    });
    ExchangeCredentials.prototype.AdjustUrl = function (url) { return new Uri(ExchangeCredentials.GetUriWithoutSuffix(url)); };
    ExchangeCredentials.prototype.EmitExtraSoapHeaderNamespaceAliases = function (writer /*System.Xml.XmlWriter*/) { };
    ExchangeCredentials.GetUriWithoutSuffix = function (url) {
        var absoluteUri = url.AbsoluteUri;
        //ref: can not use WSSecurityBasedCredentials.WsSecurityPathSuffix, creates circular reference.
        var index = absoluteUri.toUpperCase().indexOf(/*WSSecurityBasedCredentials*/ ExchangeCredentials.WsSecurityPathSuffix.toUpperCase()); //, StringComparison.OrdinalIgnoreCase);
        if (index != -1) {
            return absoluteUri.substring(0, index);
        }
        return absoluteUri;
    };
    //PreAuthenticate(): any{ throw new Error("ExchangeCredentials.ts - PreAuthenticate : Not implemented.");}
    ExchangeCredentials.prototype.PrepareWebRequest = function (request /*IEwsHttpWebRequest*/) {
        request.headers["Authorization"] = "Basic " + base64Helper.btoa(this.UserName + ":" + this.Password);
    };
    ExchangeCredentials.prototype.SerializeExtraSoapHeaders = function (writer /*System.Xml.XmlWriter*/, webMethodName) { };
    //NeedSignature: boolean;
    ExchangeCredentials.WsSecurityPathSuffix = "/wssecurity";
    return ExchangeCredentials;
}());
exports.ExchangeCredentials = ExchangeCredentials;
var ClientCertificateCredentials = (function (_super) {
    __extends(ClientCertificateCredentials, _super);
    function ClientCertificateCredentials() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ClientCertificateCredentials.prototype.PrepareWebRequest = function (request) { throw new Error("ClientCertificateCredentials.ts - PrepareWebRequest : Not implemented."); };
    return ClientCertificateCredentials;
}(ExchangeCredentials));
exports.ClientCertificateCredentials = ClientCertificateCredentials;
var OAuthCredentials = (function (_super) {
    __extends(OAuthCredentials, _super);
    function OAuthCredentials(token, verbatim) {
        if (verbatim === void 0) { verbatim = false; }
        var _this = _super.call(this) || this;
        _this.token = null;
        _this.credentials = null; /*System.Net.ICredentials*/
        EwsUtilities.ValidateParam(token, "token");
        var rawToken;
        if (verbatim) {
            rawToken = token;
        }
        else {
            var whiteSpacePosition = token.indexOf(' ');
            if (whiteSpacePosition == -1) {
                rawToken = token;
            }
            else {
                var authType = token.substring(0, whiteSpacePosition);
                if (StringHelper.Compare(authType, OAuthCredentials.BearerAuthenticationType, true) != 0) {
                    throw new Error(Strings.InvalidAuthScheme); //ArgumentException
                }
                rawToken = token.substring(whiteSpacePosition + 1);
            }
            if (!OAuthCredentials.validTokenPattern.test(rawToken)) {
                throw new Error(Strings.InvalidOAuthToken); //ArgumentException
            }
        }
        _this.token = OAuthCredentials.BearerAuthenticationType + " " + rawToken;
        return _this;
    }
    OAuthCredentials.prototype.PrepareWebRequest = function (request /*IEwsHttpWebRequest*/) {
        request.headers["Authorization"] = this.token;
    };
    OAuthCredentials.BearerAuthenticationType = "Bearer";
    OAuthCredentials.validTokenPattern = new RegExp("^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$");
    return OAuthCredentials;
}(ExchangeCredentials));
exports.OAuthCredentials = OAuthCredentials;
var WebCredentials = (function (_super) {
    __extends(WebCredentials, _super);
    function WebCredentials() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WebCredentials;
}(ExchangeCredentials));
exports.WebCredentials = WebCredentials;
var WSSecurityBasedCredentials = (function (_super) {
    __extends(WSSecurityBasedCredentials, _super);
    function WSSecurityBasedCredentials() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WSSecurityBasedCredentials.prototype.AdjustUrl = function (url) { throw new Error("WSSecurityBasedCredentials.ts - AdjustUrl : Not implemented."); };
    WSSecurityBasedCredentials.prototype.EmitExtraSoapHeaderNamespaceAliases = function (writer /*System.Xml.XmlWriter*/) { throw new Error("WSSecurityBasedCredentials.ts - EmitExtraSoapHeaderNamespaceAliases : Not implemented."); };
    WSSecurityBasedCredentials.prototype.PreAuthenticate = function () { throw new Error("WSSecurityBasedCredentials.ts - PreAuthenticate : Not implemented."); };
    WSSecurityBasedCredentials.prototype.SerializeExtraSoapHeaders = function (writer /*System.Xml.XmlWriter*/, webMethodName) { throw new Error("WSSecurityBasedCredentials.ts - SerializeExtraSoapHeaders : Not implemented."); };
    WSSecurityBasedCredentials.prototype.SerializeWSAddressingHeaders = function (xmlWriter /*System.Xml.XmlWriter*/, webMethodName) { throw new Error("WSSecurityBasedCredentials.ts - SerializeWSAddressingHeaders : Not implemented."); };
    WSSecurityBasedCredentials.prototype.SerializeWSSecurityHeaders = function (xmlWriter /*System.Xml.XmlWriter*/) { throw new Error("WSSecurityBasedCredentials.ts - SerializeWSSecurityHeaders : Not implemented."); };
    WSSecurityBasedCredentials.WsAddressingHeadersFormat = "<wsa:Action soap:mustUnderstand='1'>http://schemas.microsoft.com/exchange/services/2006/messages/{0}</wsa:Action><wsa:ReplyTo><wsa:Address>http://www.w3.org/2005/08/addressing/anonymous</wsa:Address></wsa:ReplyTo><wsa:To soap:mustUnderstand='1'>{1}</wsa:To>";
    WSSecurityBasedCredentials.WsSecurityHeaderFormat = "<wsse:Security soap:mustUnderstand='1'>  {0}</wsse:Security>";
    WSSecurityBasedCredentials.WsuTimeStampFormat = "<wsu:Timestamp><wsu:Created>{0:yyyy'-'MM'-'dd'T'HH':'mm':'ss'Z'}</wsu:Created><wsu:Expires>{1:yyyy'-'MM'-'dd'T'HH':'mm':'ss'Z'}</wsu:Expires></wsu:Timestamp>";
    return WSSecurityBasedCredentials;
}(ExchangeCredentials));
exports.WSSecurityBasedCredentials = WSSecurityBasedCredentials;
var PartnerTokenCredentials = (function (_super) {
    __extends(PartnerTokenCredentials, _super);
    function PartnerTokenCredentials() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PartnerTokenCredentials.prototype.AdjustUrl = function (url) { throw new Error("PartnerTokenCredentials.ts - AdjustUrl : Not implemented."); };
    //PrepareWebRequest(request: IEwsHttpWebRequest): any { throw new Error("PartnerTokenCredentials.ts - PrepareWebRequest : Not implemented.");}
    PartnerTokenCredentials.prototype.Sign = function (memoryStream) { throw new Error("PartnerTokenCredentials.ts - Sign : Not implemented."); };
    PartnerTokenCredentials.WsSecuritySymmetricKeyPathSuffix = "/wssecurity/symmetrickey";
    return PartnerTokenCredentials;
}(WSSecurityBasedCredentials));
exports.PartnerTokenCredentials = PartnerTokenCredentials;
var TokenCredentials = (function (_super) {
    __extends(TokenCredentials, _super);
    function TokenCredentials() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TokenCredentials;
}(WSSecurityBasedCredentials));
exports.TokenCredentials = TokenCredentials;
var WindowsLiveCredentials = (function (_super) {
    __extends(WindowsLiveCredentials, _super);
    function WindowsLiveCredentials() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WindowsLiveCredentials.prototype.EmitTokenRequest = function (uriForTokenEndpointReference) { throw new Error("WindowsLiveCredentials.ts - EmitTokenRequest : Not implemented."); };
    WindowsLiveCredentials.prototype.MakeTokenRequestToWindowsLive = function (uriForTokenEndpointReference) { throw new Error("WindowsLiveCredentials.ts - MakeTokenRequestToWindowsLive : Not implemented."); };
    //ParseWindowsLiveRSTResponseBody(rstResponse: EwsXmlReader): any { throw new Error("WindowsLiveCredentials.ts - ParseWindowsLiveRSTResponseBody : Not implemented."); }
    //PrepareWebRequest(request: IEwsHttpWebRequest): any { throw new Error("WindowsLiveCredentials.ts - PrepareWebRequest : Not implemented.");}
    WindowsLiveCredentials.prototype.ProcessTokenResponse = function (response) { throw new Error("WindowsLiveCredentials.ts - ProcessTokenResponse : Not implemented."); };
    //ReadWindowsLiveRSTResponseHeaders(rstResponse: EwsXmlReader): any { throw new Error("WindowsLiveCredentials.ts - ReadWindowsLiveRSTResponseHeaders : Not implemented."); }
    WindowsLiveCredentials.prototype.TraceResponse = function (response, memoryStream) { throw new Error("WindowsLiveCredentials.ts - TraceResponse : Not implemented."); };
    WindowsLiveCredentials.prototype.TraceWebException = function (e) { throw new Error("WindowsLiveCredentials.ts - TraceWebException : Not implemented."); };
    WindowsLiveCredentials.XmlEncNamespace = "http://www.w3.org/2001/04/xmlenc#";
    WindowsLiveCredentials.WindowsLiveSoapNamespacePrefix = "S";
    WindowsLiveCredentials.RequestSecurityTokenResponseCollectionElementName = "RequestSecurityTokenResponseCollection";
    WindowsLiveCredentials.RequestSecurityTokenResponseElementName = "RequestSecurityTokenResponse";
    WindowsLiveCredentials.EncryptedDataElementName = "EncryptedData";
    WindowsLiveCredentials.PpElementName = "pp";
    WindowsLiveCredentials.ReqstatusElementName = "reqstatus";
    WindowsLiveCredentials.SuccessfulReqstatus = "0x0";
    WindowsLiveCredentials.XmlSignatureReference = "_EWSTKREF";
    return WindowsLiveCredentials;
}(WSSecurityBasedCredentials));
exports.WindowsLiveCredentials = WindowsLiveCredentials;
var X509CertificateCredentials = (function (_super) {
    __extends(X509CertificateCredentials, _super);
    function X509CertificateCredentials() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    X509CertificateCredentials.prototype.AdjustUrl = function (url) { throw new Error("X509CertificateCredentials.ts - AdjustUrl : Not implemented."); };
    //PrepareWebRequest(request: IEwsHttpWebRequest): any { throw new Error("X509CertificateCredentials.ts - PrepareWebRequest : Not implemented.");}
    X509CertificateCredentials.prototype.Sign = function (memoryStream) { throw new Error("X509CertificateCredentials.ts - Sign : Not implemented."); };
    X509CertificateCredentials.prototype.ToString = function () { throw new Error("X509CertificateCredentials.ts - ToString : Not implemented."); };
    X509CertificateCredentials.BinarySecurityTokenFormat = "<wsse:BinarySecurityToken EncodingType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary' ValueType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3' wsu:Id='{0}'>{1}</wsse:BinarySecurityToken>";
    X509CertificateCredentials.KeyInfoClauseFormat = "<wsse:SecurityTokenReference xmlns:wsse='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd' ><wsse:Reference URI='#{0}' ValueType='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3' /></wsse:SecurityTokenReference>";
    X509CertificateCredentials.WsSecurityX509CertPathSuffix = "/wssecurity/x509cert";
    return X509CertificateCredentials;
}(WSSecurityBasedCredentials));
exports.X509CertificateCredentials = X509CertificateCredentials;
var WSSecurityUtilityIdSignedXml /*extends System.Security.Cryptography.Xml.SignedXml*/ = (function () {
    function WSSecurityUtilityIdSignedXml() {
    }
    WSSecurityUtilityIdSignedXml.prototype.AddReference = function (xpath) { throw new Error("WSSecurityUtilityIdSignedXml.ts - AddReference : Not implemented."); };
    WSSecurityUtilityIdSignedXml.prototype.GetIdElement = function (document, idValue) { throw new Error("WSSecurityUtilityIdSignedXml.ts - GetIdElement : Not implemented."); };
    WSSecurityUtilityIdSignedXml.prototype.GetUniqueId = function () { throw new Error("WSSecurityUtilityIdSignedXml.ts - GetUniqueId : Not implemented."); };
    return WSSecurityUtilityIdSignedXml;
}());
exports.WSSecurityUtilityIdSignedXml = WSSecurityUtilityIdSignedXml;
var DnsClient = (function () {
    function DnsClient() {
    }
    DnsClient.prototype.DnsQuer = function (domain, dnsServerAddress /*System.Net.IPAddress*/) { throw new Error("DnsClient.ts - DnsQuer<T> : Not implemented."); };
    DnsClient.Win32Success = 0;
    return DnsClient;
}());
exports.DnsClient = DnsClient;
//------------modulename->Microsoft.Exchange.WebServices.Dns------------
// export class DnsNativeMethods {
// 	 private static DNSAPI: string = "dnsapi.dll";
// 	AllocDnsServerList(dnsServerAddress: any /*System.Net.IPAddress*/): number{ throw new Error("DnsNativeMethods.ts - AllocDnsServerList : Not implemented.");}
// 	DnsQuery(pszName: string, wType: DnsRecordType, options: DnsQueryOptions, aipServers: number, ppQueryResults: number /*System.IntPtr&*/, pReserved: number): number{ throw new Error("DnsNativeMethods.ts - DnsQuery : Not implemented.");}
// 	//DnsQuery(domain: string, dnsServerAddress: any /*System.Net.IPAddress*/, recordType: DnsRecordType, ppQueryResults: number /*System.IntPtr&*/): number{ throw new Error("DnsNativeMethods.ts - DnsQuery : Not implemented.");}
// 	DnsRecordListFree(ptrRecords: number, freeType: FreeType): void{ throw new Error("DnsNativeMethods.ts - DnsRecordListFree : Not implemented.");}
// 	FreeDnsQueryResults(ptrRecords: number): void{ throw new Error("DnsNativeMethods.ts - FreeDnsQueryResults : Not implemented.");}
// }
// //------------modulename->Microsoft.Exchange.WebServices.Dns------------
/** @internal */
var DnsRecordHeader = (function () {
    function DnsRecordHeader() {
    }
    return DnsRecordHeader;
}());
exports.DnsRecordHeader = DnsRecordHeader;
//------------modulename->Microsoft.Exchange.WebServices.Dns------------
/**@internal */
var DnsRecord = (function () {
    function DnsRecord() {
    }
    DnsRecord.prototype.Load = function (header, dataPointer) { throw new Error("DnsRecord.ts - Load : Not implemented."); };
    return DnsRecord;
}());
exports.DnsRecord = DnsRecord;
//------------modulename->Microsoft.Exchange.WebServices.Dns------------
/** @internal */
var DnsSrvRecord = (function (_super) {
    __extends(DnsSrvRecord, _super);
    function DnsSrvRecord() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DnsSrvRecord.prototype.Load = function (header, dataPointer) { throw new Error("DnsSrvRecord.ts - Load : Not implemented."); };
    return DnsSrvRecord;
}(DnsRecord));
exports.DnsSrvRecord = DnsSrvRecord;
//------------modulename->Microsoft.Exchange.WebServices.Dns------------
/**
 * Represents retention policy tag object.
 *
 * @sealed
 */
var RetentionPolicyTag = (function () {
    function RetentionPolicyTag(displayName, retentionId, retentionPeriod, type, retentionAction, isVisible, optedInto, isArchive) {
        /**
         * Retention policy tag display name.
         */
        this.DisplayName = null;
        /**
         * Retention Id.
         */
        this.RetentionId = null;
        /**
         * Retention period in time span.
         */
        this.RetentionPeriod = 0;
        /**
         * Retention type.
         */
        this.Type = ElcFolderType.Calendar;
        /**
         * Retention action.
         */
        this.RetentionAction = RetentionActionType.None;
        /**
         * Retention policy tag description.
         */
        this.Description = null;
        /**
         * Is this a visible tag?
         */
        this.IsVisible = false;
        /**
         * Is this a opted into tag?
         */
        this.OptedInto = false;
        /**
         * Is this an archive tag?
         */
        this.IsArchive = false;
        if (arguments.length > 0) {
            this.DisplayName = displayName;
            this.RetentionId = retentionId;
            this.RetentionPeriod = retentionPeriod;
            this.Type = type;
            this.RetentionAction = retentionAction;
            this.IsVisible = isVisible;
            this.OptedInto = optedInto;
            this.IsArchive = isArchive;
        }
    }
    /**
     * @internal Loads object from XML.
     *
     * @param   {any}	jsObject		Json Object converted from XML.
     */
    RetentionPolicyTag.LoadFromXmlJsObject = function (jsObject) {
        var retentionPolicyTag = new RetentionPolicyTag();
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.DisplayName:
                    retentionPolicyTag.DisplayName = jsObject[XmlElementNames.DisplayName];
                    break;
                case XmlElementNames.RetentionId:
                    retentionPolicyTag.RetentionId = new Guid(jsObject[XmlElementNames.RetentionId]);
                    break;
                case XmlElementNames.RetentionPeriod:
                    retentionPolicyTag.RetentionPeriod = Convert.toNumber(jsObject[XmlElementNames.RetentionPeriod]);
                    break;
                case XmlElementNames.Type:
                    retentionPolicyTag.Type = ElcFolderType[jsObject[XmlElementNames.Type]];
                    break;
                case XmlElementNames.RetentionAction:
                    retentionPolicyTag.RetentionAction = RetentionActionType[jsObject[XmlElementNames.RetentionAction]];
                    break;
                case XmlElementNames.Description:
                    retentionPolicyTag.Description = jsObject[XmlElementNames.Description];
                    break;
                case XmlElementNames.IsVisible:
                    retentionPolicyTag.IsVisible = Convert.toBool(jsObject[XmlElementNames.IsVisible]);
                    break;
                case XmlElementNames.OptedInto:
                    retentionPolicyTag.OptedInto = Convert.toBool(jsObject[XmlElementNames.OptedInto]);
                    break;
                case XmlElementNames.IsArchive:
                    retentionPolicyTag.IsArchive = Convert.toBool(jsObject[XmlElementNames.IsArchive]);
                    break;
                default:
                    break;
            }
        }
        return retentionPolicyTag;
    };
    return RetentionPolicyTag;
}());
exports.RetentionPolicyTag = RetentionPolicyTag;
//make necessary changes if needed
//ref: 0.9 - extending Error as BlueBird throws error if promise is rejected without an Error object
var Exception = (function () {
    function Exception(message, innerException) {
        if (message === void 0) { message = ""; }
        if (innerException === void 0) { innerException = null; }
        /** @internal  */
        this.message = '';
        //todo: implement stacktrace and source if needed - stack trace implemented by calling Error.captureStack
        this.stack = null;
        this.InnerException = null;
        this.InnerException = innerException;
        this.message = message || "";
        if (typeof Error['captureStackTrace'] === 'function') {
            Error.captureStackTrace(this, this.constructor);
        }
        else {
            this.stack = (new Error(message)).stack;
        }
        //this.name = this.constructor.name; - no need to capture Name, can be infered by checking instance of Exception (or inheriting class)
    }
    Object.defineProperty(Exception.prototype, "Message", {
        get: function () {
            return this.message;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Exception.prototype, "name", {
        /** @internal  needed for bluebird to work when rejected without inheriting from Error object. BlueBird checks for Error like object not Error subclass itself. */
        get: function () {
            return 'Exception';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @override user JSON.stringify for now, todo: impelemtn real Exception tostring
     */
    Exception.prototype.toString = function () {
        var result = this.stack;
        try {
            result = result || JSON.stringify(this);
        }
        catch (e) { }
        return result;
    };
    Exception.prototype.ToString = function () {
        return this.toString();
    };
    return Exception;
}());
exports.Exception = Exception;
var ArgumentException = (function (_super) {
    __extends(ArgumentException, _super);
    function ArgumentException(message, paramNameOrInnerException, innerException) {
        if (message === void 0) { message = null; }
        if (paramNameOrInnerException === void 0) { paramNameOrInnerException = null; }
        if (innerException === void 0) { innerException = null; }
        var _this = _super.call(this, message, innerException || (paramNameOrInnerException instanceof Exception ? paramNameOrInnerException : null)) || this;
        _this.ParamName = null;
        if (typeof paramNameOrInnerException === 'string') {
            _this.ParamName = message;
        }
        return _this;
    }
    return ArgumentException;
}(Exception));
exports.ArgumentException = ArgumentException;
var ArgumentNullException = (function (_super) {
    __extends(ArgumentNullException, _super);
    function ArgumentNullException(paramNameOrMessage, paramNameOrInnerException, innerException) {
        if (paramNameOrMessage === void 0) { paramNameOrMessage = null; }
        if (paramNameOrInnerException === void 0) { paramNameOrInnerException = null; }
        if (innerException === void 0) { innerException = null; }
        var _this = this;
        var argsLength = arguments.length;
        switch (argsLength) {
            case 1:
                _this = _super.call(this, "Argument is Null", paramNameOrMessage) || this;
                break;
            case 2:
                if (typeof paramNameOrInnerException === 'string') {
                    _this = _super.call(this, paramNameOrInnerException, paramNameOrMessage) || this;
                }
                else {
                    _this = _super.call(this, paramNameOrMessage, paramNameOrInnerException) || this;
                }
                break;
            default:
                _this = _super.call(this, "Argument is Null") || this;
                break;
        }
        return _this;
    }
    return ArgumentNullException;
}(ArgumentException));
exports.ArgumentNullException = ArgumentNullException;
var ArgumentOutOfRangeException = (function (_super) {
    __extends(ArgumentOutOfRangeException, _super);
    function ArgumentOutOfRangeException(paramNameOrMessage, messageOrActualValueOrException, message) {
        if (message === void 0) { message = null; }
        var _this = this;
        //super((message || messageOrObjValueOrException instanceof Exception ? paramNameOrMessage : null);
        var argsLength = arguments.length;
        switch (argsLength) {
            case 0:
                _this = _super.call(this, "ArgumentOutOfRangeException") || this;
                break;
            case 1:
                _this = _super.call(this, "ArgumentOutOfRangeException", paramNameOrMessage) || this;
                break;
            case 2:
                if (typeof messageOrActualValueOrException === 'string') {
                    _this = _super.call(this, messageOrActualValueOrException, paramNameOrMessage) || this;
                }
                else {
                    _this = _super.call(this, paramNameOrMessage, messageOrActualValueOrException) || this;
                }
                break;
            case 3:
                _this = _super.call(this, message, paramNameOrMessage) || this;
                _this.actualValue = messageOrActualValueOrException;
                break;
            default:
                _this = _super.call(this, "ArgumentOutOfRangeException") || this;
                break;
        }
        return _this;
    }
    Object.defineProperty(ArgumentOutOfRangeException.prototype, "ActualValue", {
        /**
         * Gets the value of the argument that caused the exception.
         */
        get: function () { return this.actualValue; },
        enumerable: true,
        configurable: true
    });
    return ArgumentOutOfRangeException;
}(ArgumentException));
exports.ArgumentOutOfRangeException = ArgumentOutOfRangeException;
var InvalidOperationException = (function (_super) {
    __extends(InvalidOperationException, _super);
    function InvalidOperationException(message, innerException) {
        if (message === void 0) { message = null; }
        if (innerException === void 0) { innerException = null; }
        var _this = _super.call(this, message, innerException) || this;
        _this.ParamName = null;
        return _this;
    }
    return InvalidOperationException;
}(Exception));
exports.InvalidOperationException = InvalidOperationException;
var JsonSerializationNotImplementedException = (function (_super) {
    __extends(JsonSerializationNotImplementedException, _super);
    function JsonSerializationNotImplementedException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return JsonSerializationNotImplementedException;
}(Exception));
exports.JsonSerializationNotImplementedException = JsonSerializationNotImplementedException;
var NotSupportedException = (function (_super) {
    __extends(NotSupportedException, _super);
    function NotSupportedException(message, innerException) {
        if (message === void 0) { message = null; }
        if (innerException === void 0) { innerException = null; }
        var _this = _super.call(this, message, innerException) || this;
        _this.ParamName = null;
        return _this;
    }
    return NotSupportedException;
}(Exception));
exports.NotSupportedException = NotSupportedException;
//class DnsException extends System.ComponentModel.Win32Exception {
//}
/**
 * Represents an error that occurs when a service operation fails locally (e.g. validation error).
 */
var ServiceLocalException = (function (_super) {
    __extends(ServiceLocalException, _super);
    function ServiceLocalException(message, innerException) {
        if (message === void 0) { message = null; }
        if (innerException === void 0) { innerException = null; }
        return _super.call(this, message, innerException) || this;
    }
    return ServiceLocalException;
}(Exception));
exports.ServiceLocalException = ServiceLocalException;
var AutodiscoverLocalException = (function (_super) {
    __extends(AutodiscoverLocalException, _super);
    function AutodiscoverLocalException(message, innerException) {
        if (message === void 0) { message = null; }
        if (innerException === void 0) { innerException = null; }
        return _super.call(this, message, innerException) || this;
    }
    return AutodiscoverLocalException;
}(ServiceLocalException));
exports.AutodiscoverLocalException = AutodiscoverLocalException;
var JsonDeserializationNotImplementedException = (function (_super) {
    __extends(JsonDeserializationNotImplementedException, _super);
    function JsonDeserializationNotImplementedException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return JsonDeserializationNotImplementedException;
}(ServiceLocalException));
exports.JsonDeserializationNotImplementedException = JsonDeserializationNotImplementedException;
var ServiceJsonDeserializationException = (function (_super) {
    __extends(ServiceJsonDeserializationException, _super);
    function ServiceJsonDeserializationException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ServiceJsonDeserializationException;
}(ServiceLocalException));
exports.ServiceJsonDeserializationException = ServiceJsonDeserializationException;
/**
 * Represents an error that occurs when a validation check fails.
 *
 * @sealed
 */
var ServiceValidationException = (function (_super) {
    __extends(ServiceValidationException, _super);
    function ServiceValidationException(message, innerException) {
        if (message === void 0) { message = null; }
        if (innerException === void 0) { innerException = null; }
        return _super.call(this, message, innerException) || this;
    }
    return ServiceValidationException;
}(ServiceLocalException));
exports.ServiceValidationException = ServiceValidationException;
/**
 * Represents an error that occurs when a request cannot be handled due to a service version mismatch.
 *
 * @sealed
 */
var ServiceVersionException = (function (_super) {
    __extends(ServiceVersionException, _super);
    function ServiceVersionException(message, innerException) {
        if (message === void 0) { message = null; }
        if (innerException === void 0) { innerException = null; }
        return _super.call(this, message, innerException) || this;
    }
    return ServiceVersionException;
}(ServiceLocalException));
exports.ServiceVersionException = ServiceVersionException;
var ServiceXmlDeserializationException = (function (_super) {
    __extends(ServiceXmlDeserializationException, _super);
    function ServiceXmlDeserializationException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ServiceXmlDeserializationException;
}(ServiceLocalException));
exports.ServiceXmlDeserializationException = ServiceXmlDeserializationException;
var ServiceXmlSerializationException = (function (_super) {
    __extends(ServiceXmlSerializationException, _super);
    function ServiceXmlSerializationException(message, innerException) {
        if (message === void 0) { message = null; }
        if (innerException === void 0) { innerException = null; }
        return _super.call(this, message, innerException) || this;
    }
    return ServiceXmlSerializationException;
}(ServiceLocalException));
exports.ServiceXmlSerializationException = ServiceXmlSerializationException;
var TimeZoneConversionException = (function (_super) {
    __extends(TimeZoneConversionException, _super);
    function TimeZoneConversionException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TimeZoneConversionException;
}(ServiceLocalException));
exports.TimeZoneConversionException = TimeZoneConversionException;
var PropertyException = (function (_super) {
    __extends(PropertyException, _super);
    //private name: string;
    function PropertyException(message, name, innerException) {
        if (name === void 0) { name = null; }
        if (innerException === void 0) { innerException = null; }
        var _this = _super.call(this, message, innerException) || this;
        _this.Name = name;
        return _this;
    }
    return PropertyException;
}(ServiceLocalException));
exports.PropertyException = PropertyException;
var ServiceObjectPropertyException = (function (_super) {
    __extends(ServiceObjectPropertyException, _super);
    //private propertyDefinition: PropertyDefinitionBase;
    function ServiceObjectPropertyException(message, propertyDefinition, innerException) {
        var _this = _super.call(this, message, propertyDefinition.GetPrintableName(), innerException) || this;
        _this.PropertyDefinition = propertyDefinition;
        return _this;
    }
    return ServiceObjectPropertyException;
}(PropertyException));
exports.ServiceObjectPropertyException = ServiceObjectPropertyException;
/**
 * Represents an error that occurs when a service operation fails remotely.
 */
var ServiceRemoteException = (function (_super) {
    __extends(ServiceRemoteException, _super);
    function ServiceRemoteException(message, innerException) {
        if (message === void 0) { message = null; }
        if (innerException === void 0) { innerException = null; }
        return _super.call(this, message, innerException) || this;
    }
    return ServiceRemoteException;
}(Exception));
exports.ServiceRemoteException = ServiceRemoteException;
/**
 * Represents an error that occurs when the account that is being accessed is locked and requires user interaction to be unlocked.
 */
var AccountIsLockedException = (function (_super) {
    __extends(AccountIsLockedException, _super);
    /**
     * Initializes a new instance of the **AccountIsLockedException** class.
     *
     * @param   {string}        message            Error message text.
     * @param   {Uri}           accountUnlockUrl   URL for client to visit to unlock account.
     * @param   {Exception}     innerException     Inner exception.
     */
    function AccountIsLockedException(message, accountUnlockUrl, innerException) {
        var _this = _super.call(this, message, innerException) || this;
        /**
         * Gets the URL of a web page where the user can navigate to unlock his or her account.
         *
         * internal set
         */
        _this.AccountUnlockUrl = null;
        _this.AccountUnlockUrl = accountUnlockUrl;
        return _this;
    }
    return AccountIsLockedException;
}(ServiceRemoteException));
exports.AccountIsLockedException = AccountIsLockedException;
var AutodiscoverRemoteException = (function (_super) {
    __extends(AutodiscoverRemoteException, _super);
    function AutodiscoverRemoteException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AutodiscoverRemoteException;
}(ServiceRemoteException));
exports.AutodiscoverRemoteException = AutodiscoverRemoteException;
var AutodiscoverResponseException = (function (_super) {
    __extends(AutodiscoverResponseException, _super);
    function AutodiscoverResponseException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AutodiscoverResponseException;
}(ServiceRemoteException));
exports.AutodiscoverResponseException = AutodiscoverResponseException;
/**
 * Represents an exception thrown when an error occurs as a result of calling the UpdateInboxRules operation.
 *
 * @sealed
 */
var UpdateInboxRulesException = (function (_super) {
    __extends(UpdateInboxRulesException, _super);
    /**
     * @internal Initializes a new instance of the **UpdateInboxRulesException** class.
     *
     * @param   {UpdateInboxRulesResponse}  serviceResponse   The rule operation service response.
     * @param   {RuleOperation[]}           ruleOperations    The original operations.
     */
    function UpdateInboxRulesException(serviceResponse, ruleOperations) {
        var _this = _super.call(this, serviceResponse && serviceResponse.ErrorMessage ? serviceResponse.ErrorMessage : "" || "") || this;
        /**
         * ServiceResponse when service operation failed remotely.
         */
        _this.serviceResponse = null;
        /**
         * Rule operation error collection.
         */
        _this.errors = null;
        _this.serviceResponse = serviceResponse;
        _this.errors = serviceResponse.Errors;
        for (var _a = 0, _b = _this.errors.Items; _a < _b.length; _a++) {
            var error = _b[_a];
            error.SetOperationByIndex(ruleOperations);
        }
        return _this;
    }
    Object.defineProperty(UpdateInboxRulesException.prototype, "ServiceResponse", {
        /**
         * Gets the ServiceResponse for the exception.
         */
        get: function () {
            return this.serviceResponse;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UpdateInboxRulesException.prototype, "Errors", {
        /**
         * Gets the rule operation error collection.
         */
        get: function () {
            return this.errors;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UpdateInboxRulesException.prototype, "ErrorCode", {
        /**
         * Gets the rule operation error code.
         */
        get: function () {
            return this.serviceResponse.ErrorCode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UpdateInboxRulesException.prototype, "ErrorMessage", {
        /**
         * Gets the rule operation error message.
         */
        get: function () {
            return this.serviceResponse.ErrorMessage;
        },
        enumerable: true,
        configurable: true
    });
    return UpdateInboxRulesException;
}(ServiceRemoteException));
exports.UpdateInboxRulesException = UpdateInboxRulesException;
/**
 * Represents a remote service exception that can have multiple service responses.
 *
 * @type {TResponse}       The type of the response.
 */
var BatchServiceResponseException = (function (_super) {
    __extends(BatchServiceResponseException, _super);
    function BatchServiceResponseException(serviceResponses, message, innerException) {
        var _this = this;
        if (arguments.length == 2) {
            _this = _super.call(this, message) || this;
        }
        else {
            _this = _super.call(this, message, innerException) || this;
        }
        EwsLogging.Assert(serviceResponses != null, "BatchServiceResponseException.ctor", "serviceResponses is null");
        _this.responses = serviceResponses;
        return _this;
    }
    Object.defineProperty(BatchServiceResponseException.prototype, "ServiceResponses", {
        /**
         * Gets a list of responses returned by the web method.
         */
        get: function () { return this.ServiceResponses; },
        enumerable: true,
        configurable: true
    });
    return BatchServiceResponseException;
}(ServiceRemoteException));
exports.BatchServiceResponseException = BatchServiceResponseException;
var CreateAttachmentException = (function (_super) {
    __extends(CreateAttachmentException, _super);
    function CreateAttachmentException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CreateAttachmentException;
}(BatchServiceResponseException));
exports.CreateAttachmentException = CreateAttachmentException;
/**
 * Represents an error that occurs when a call to the DeleteAttachment web method fails.
 */
var DeleteAttachmentException = (function (_super) {
    __extends(DeleteAttachmentException, _super);
    function DeleteAttachmentException(serviceResponses, message, innerException) {
        var _this = this;
        if (arguments.length == 2)
            _this = _super.call(this, serviceResponses, message) || this;
        else
            _this = _super.call(this, serviceResponses, message, innerException) || this;
        return _this;
    }
    return DeleteAttachmentException;
}(BatchServiceResponseException));
exports.DeleteAttachmentException = DeleteAttachmentException;
var ServiceRequestException = (function (_super) {
    __extends(ServiceRequestException, _super);
    function ServiceRequestException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ServiceRequestException;
}(ServiceRemoteException));
exports.ServiceRequestException = ServiceRequestException;
var ServiceRequestUnauthorizedException = (function (_super) {
    __extends(ServiceRequestUnauthorizedException, _super);
    function ServiceRequestUnauthorizedException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ServiceRequestUnauthorizedException;
}(ServiceRequestException));
exports.ServiceRequestUnauthorizedException = ServiceRequestUnauthorizedException;
/**
 * Represents a remote service exception that has a single response.
 */
var ServiceResponseException = (function (_super) {
    __extends(ServiceResponseException, _super);
    /**
     * @internal Initializes a new instance of the **ServiceResponseException** class.
     *
     * @param   {ServiceResponse}   response   The ServiceResponse when service operation failed remotely.
     */
    function ServiceResponseException(response) {
        var _this = _super.call(this, response && response.ErrorMessage ? response.ErrorMessage : "") || this;
        _this.response = response;
        return _this;
    }
    Object.defineProperty(ServiceResponseException.prototype, "Response", {
        /**
         * Gets the ServiceResponse for the exception.
         */
        get: function () {
            return this.response;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServiceResponseException.prototype, "ErrorCode", {
        /**
         * Gets the service error code.
         */
        get: function () {
            return this.response ? this.response.ErrorCode : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ServiceResponseException.prototype, "Message", {
        /**
         * Gets a message that describes the current exception.
         *
         * @returns The error message that explains the reason for the exception.
         */
        get: function () {
            // Special case for Internal Server Error. If the server returned
            // stack trace information, include it in the exception message.
            if (this.Response.ErrorCode == ServiceError.ErrorInternalServerError) {
                var exceptionClass = this.Response.ErrorDetails.get(ServiceResponseException.ExceptionClassKey);
                var exceptionMessage = this.Response.ErrorDetails.get(ServiceResponseException.ExceptionMessageKey);
                var stackTrace = this.Response.ErrorDetails.get(ServiceResponseException.StackTraceKey);
                if (!StringHelper.IsNullOrEmpty(exceptionClass) && !StringHelper.IsNullOrEmpty(exceptionMessage) && !StringHelper.IsNullOrEmpty(stackTrace)) {
                    return StringHelper.Format(Strings.ServerErrorAndStackTraceDetails, this.Response.ErrorMessage, exceptionClass, exceptionMessage, stackTrace);
                }
            }
            return this.Response.ErrorMessage;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Error details Value keys
     */
    ServiceResponseException.ExceptionClassKey = "ExceptionClass";
    ServiceResponseException.ExceptionMessageKey = "ExceptionMessage";
    ServiceResponseException.StackTraceKey = "StackTrace";
    return ServiceResponseException;
}(ServiceRemoteException));
exports.ServiceResponseException = ServiceResponseException;
var ServerBusyException = (function (_super) {
    __extends(ServerBusyException, _super);
    function ServerBusyException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ServerBusyException.BackOffMillisecondsKey = "BackOffMilliseconds";
    return ServerBusyException;
}(ServiceResponseException));
exports.ServerBusyException = ServerBusyException;
/**
 * Represents mailbox query object.
 *
 * @sealed
 */
var DiscoverySearchConfiguration = (function () {
    function DiscoverySearchConfiguration() {
        /**
         * Search Id
         */
        this.SearchId = null;
        /**
         * Search query
         */
        this.SearchQuery = null;
        /**
         * Set of mailbox and scope pair
         */
        this.SearchableMailboxes = null;
        /**
         * In-Place hold identity
         */
        this.InPlaceHoldIdentity = null;
        /**
         * Managed by organization
         */
        this.ManagedByOrganization = null;
        /**
         * Language
         */
        this.Language = null;
    }
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     * @return  {DiscoverySearchConfiguration}              Discovery search configuration object.
     */
    DiscoverySearchConfiguration.LoadFromXmlJsObject = function (jsObject, service) {
        var mailboxes = [];
        var configuration = new DiscoverySearchConfiguration();
        if (jsObject[XmlElementNames.SearchId]) {
            configuration.SearchId = jsObject[XmlElementNames.SearchId];
        }
        if (jsObject[XmlElementNames.InPlaceHoldIdentity]) {
            configuration.InPlaceHoldIdentity = jsObject[XmlElementNames.InPlaceHoldIdentity];
        }
        if (jsObject[XmlElementNames.ManagedByOrganization]) {
            configuration.ManagedByOrganization = jsObject[XmlElementNames.ManagedByOrganization];
        }
        if (jsObject[XmlElementNames.SearchQuery]) {
            configuration.SearchQuery = jsObject[XmlElementNames.SearchQuery];
        }
        if (jsObject[XmlElementNames.SearchableMailboxes]) {
            for (var _a = 0, _b = EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.SearchableMailboxes], XmlElementNames.SearchableMailbox); _a < _b.length; _a++) {
                var searchableMailboxObject = _b[_a];
                mailboxes.push(SearchableMailbox.LoadFromXmlJsObject(searchableMailboxObject, service));
            }
        }
        if (jsObject[XmlElementNames.Language]) {
            configuration.Language = jsObject[XmlElementNames.Language];
        }
        configuration.SearchableMailboxes = mailboxes.length == 0 ? null : mailboxes;
        return configuration;
    };
    return DiscoverySearchConfiguration;
}());
exports.DiscoverySearchConfiguration = DiscoverySearchConfiguration;
/**
 * Class ExtendedAttribute
 *
 * @sealed
 */
var ExtendedAttribute = (function () {
    function ExtendedAttribute(name, value) {
        if (name === void 0) { name = null; }
        if (value === void 0) { value = null; }
        /**
         * Gets or sets the name.
         *
         * @value The name.
         */
        this.Name = null;
        /**
         * Gets or sets the value.
         *
         * @value The value.
         */
        this.Value = null;
        this.Name = name;
        this.Value = value;
    }
    return ExtendedAttribute;
}());
exports.ExtendedAttribute = ExtendedAttribute;
// export class ExtendedAttributes extends Array<ExtendedAttribute> {
// }
/**
 * Represents failed mailbox to be searched
 *
 * @sealed
 */
var FailedSearchMailbox = (function () {
    function FailedSearchMailbox(mailbox, errorCode, errorMessage, isArchive) {
        if (isArchive === void 0) { isArchive = false; }
        this.Mailbox = null;
        this.ErrorCode = 0;
        this.ErrorMessage = null;
        this.IsArchive = false;
        this.Mailbox = mailbox;
        this.ErrorCode = errorCode;
        this.ErrorMessage = errorMessage;
        this.IsArchive = isArchive;
    }
    /**
     * @internal Load failed mailboxes xml
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     * @return  {FailedSearchMailbox[]}       Failed search mailboxes.
     */
    FailedSearchMailbox.LoadFromXmlJsObject = function (jsObject, service) {
        var failedMailboxes = [];
        for (var _a = 0, _b = EwsServiceJsonReader.ReadAsArray(jsObject, XmlElementNames.FailedMailbox); _a < _b.length; _a++) {
            var failedMailboxObject = _b[_a];
            var mailbox = null, errorCode = 0, errorMessage = null, isArchive = false;
            if (failedMailboxObject[XmlElementNames.Mailbox]) {
                mailbox = failedMailboxObject[XmlElementNames.Mailbox];
            }
            if (failedMailboxObject[XmlElementNames.ErrorCode]) {
                errorCode = Convert.toNumber(failedMailboxObject[XmlElementNames.ErrorCode]);
            }
            if (failedMailboxObject[XmlElementNames.ErrorMessage]) {
                errorMessage = failedMailboxObject[XmlElementNames.ErrorMessage];
            }
            if (failedMailboxObject[XmlElementNames.IsArchive]) {
                isArchive = Convert.toBool(failedMailboxObject[XmlElementNames.IsArchive]);
            }
            failedMailboxes.push(new FailedSearchMailbox(mailbox, errorCode, errorMessage, isArchive));
        }
        return failedMailboxes.length === 0 ? null : failedMailboxes;
    };
    return FailedSearchMailbox;
}());
exports.FailedSearchMailbox = FailedSearchMailbox;
/**
 * Represents the keyword statistics result.
 *
 * @sealed
 */
var KeywordStatisticsSearchResult = (function () {
    function KeywordStatisticsSearchResult() {
    }
    return KeywordStatisticsSearchResult;
}());
exports.KeywordStatisticsSearchResult = KeywordStatisticsSearchResult;
/**
 * Represents mailbox hold result
 *
 * @sealed
 */
var MailboxHoldResult = (function () {
    function MailboxHoldResult() {
        /**
         * Hold id
         */
        this.HoldId = null;
        /**
         * Query
         */
        this.Query = null;
        /**
         * Collection of mailbox status
         */
        this.Statuses = null;
    }
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     * @return  {MailboxHoldResult}              Mailbox hold object
     */
    MailboxHoldResult.LoadFromXmlJsObject = function (jsObject, service) {
        var statuses = [];
        var holdResult = new MailboxHoldResult();
        if (jsObject[XmlElementNames.HoldId]) {
            holdResult.HoldId = jsObject[XmlElementNames.HoldId];
        }
        if (jsObject[XmlElementNames.Query]) {
            holdResult.Query = jsObject[XmlElementNames.Query];
        }
        if (jsObject[XmlElementNames.MailboxHoldStatuses]) {
            for (var _a = 0, _b = EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.MailboxHoldStatuses], XmlElementNames.MailboxHoldStatus); _a < _b.length; _a++) {
                var statusObject = _b[_a];
                var status_1 = new MailboxHoldStatus();
                if (statusObject[XmlElementNames.Mailbox]) {
                    status_1.Mailbox = statusObject[XmlElementNames.Mailbox];
                }
                if (statusObject[XmlElementNames.Status]) {
                    status_1.Status = HoldStatus[statusObject[XmlElementNames.Status]];
                }
                if (statusObject[XmlElementNames.AdditionalInfo]) {
                    status_1.AdditionalInfo = statusObject[XmlElementNames.AdditionalInfo];
                }
                statuses.push(status_1);
            }
        }
        holdResult.Statuses = statuses.length == 0 ? null : statuses;
        return holdResult;
    };
    return MailboxHoldResult;
}());
exports.MailboxHoldResult = MailboxHoldResult;
/**
 * Represents mailbox hold status
 *
 * @sealed
 */
var MailboxHoldStatus = (function () {
    function MailboxHoldStatus(mailbox, status, additionalInfo) {
        if (mailbox === void 0) { mailbox = null; }
        if (status === void 0) { status = HoldStatus.NotOnHold; }
        if (additionalInfo === void 0) { additionalInfo = null; }
        this.Mailbox = mailbox;
        this.Status = status;
        this.AdditionalInfo = additionalInfo;
    }
    return MailboxHoldStatus;
}());
exports.MailboxHoldStatus = MailboxHoldStatus;
/**
 * Represents mailbox query object.
 *
 * @sealed
 */
var MailboxQuery = (function () {
    /**
     * Constructor
     *
     * @param   {string}                query          Search query
     * @param   {MailboxSearchScope[]}  searchScopes   Set of mailbox and scope pair
     */
    function MailboxQuery(query, searchScopes) {
        /**
         * Search query
         */
        this.Query = null;
        /**
         * Set of mailbox and scope pair
         */
        this.MailboxSearchScopes = null;
        this.Query = query;
        this.MailboxSearchScopes = searchScopes;
    }
    return MailboxQuery;
}());
exports.MailboxQuery = MailboxQuery;
/**
 * Represents mailbox search scope object.
 */
var MailboxSearchScope = (function () {
    /**
     * Constructor
     *
     * @param   {string}   mailbox       Mailbox
     * @param   {MailboxSearchLocation}   searchScope   Search scope
     */
    function MailboxSearchScope(mailbox, searchScope) {
        this.searchScope = MailboxSearchLocation.All;
        this.scopeType = MailboxSearchScopeType.LegacyExchangeDN;
        /**
         * Mailbox
         */
        this.Mailbox = null;
        /**
         * Gets the extended data.
         *
         * @value The extended data.
         */
        this.ExtendedAttributes = null;
        this.Mailbox = mailbox;
        this.searchScope = searchScope;
        this.ExtendedAttributes = [];
    }
    Object.defineProperty(MailboxSearchScope.prototype, "SearchScope", {
        /**
         * Search scope
         */
        get: function () {
            return this.searchScope;
        },
        set: function (value) {
            this.searchScope = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MailboxSearchScope.prototype, "SearchScopeType", {
        /**
         * @internal Search scope type
         */
        get: function () {
            return this.scopeType;
        },
        set: function (value) {
            this.scopeType = value;
        },
        enumerable: true,
        configurable: true
    });
    return MailboxSearchScope;
}());
exports.MailboxSearchScope = MailboxSearchScope;
/**
 * Mailbox statistics item
 *
 * @sealed
 */
var MailboxStatisticsItem = (function () {
    function MailboxStatisticsItem() {
        /**
         * Mailbox id
         */
        this.MailboxId = null;
        /**
         * Display name
         */
        this.DisplayName = null;
        /**
         * Item count
         */
        this.ItemCount = 0;
        /**
         * Total size
         * [CLSCompliant(false)]
         */
        this.Size = 0;
    }
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     * @return  {SearchRefinerItem}
     */
    MailboxStatisticsItem.LoadFromXmlJsObject = function (jsObject, service) {
        var msi = new MailboxStatisticsItem();
        msi.MailboxId = jsObject[XmlElementNames.MailboxId];
        msi.DisplayName = jsObject[XmlElementNames.DisplayName];
        msi.ItemCount = Convert.toNumber(jsObject[XmlElementNames.ItemCount]);
        msi.Size = Convert.toNumber(jsObject[XmlElementNames.Size]);
        return msi;
    };
    return MailboxStatisticsItem;
}());
exports.MailboxStatisticsItem = MailboxStatisticsItem;
/**
 * Represents non indexable item.
 *
 * @sealed
 */
var NonIndexableItem = (function () {
    function NonIndexableItem() {
        /**
         * Item Identity
         */
        this.ItemId = null;
        /**
         * Error code
         */
        this.ErrorCode = ItemIndexError.None;
        /**
         * Error description
         */
        this.ErrorDescription = null;
        /**
         * Is partially indexed
         */
        this.IsPartiallyIndexed = false;
        /**
         * Is permanent failure
         */
        this.IsPermanentFailure = false;
        /**
         * Attempt count
         */
        this.AttemptCount = 0;
        /**
         * Last attempt time
         */
        this.LastAttemptTime = null;
        /**
         * Additional info
         */
        this.AdditionalInfo = null;
        /**
         * Sort value
         */
        this.SortValue = null;
    }
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     * @return  {NonIndexableItemDetailsResult}       Non indexable item details result object
     */
    NonIndexableItem.LoadFromXmlJsObject = function (jsObject, service) {
        var result = new NonIndexableItem();
        if (jsObject[XmlElementNames.ItemId]) {
            result.ItemId = new ItemId();
            result.ItemId.LoadFromXmlJsObject(jsObject[XmlElementNames.ItemId], service);
        }
        if (jsObject[XmlElementNames.ErrorDescription]) {
            result.ErrorDescription = jsObject[XmlElementNames.ErrorDescription];
        }
        if (jsObject[XmlElementNames.IsPartiallyIndexed]) {
            result.IsPartiallyIndexed = Convert.toBool(jsObject[XmlElementNames.IsPartiallyIndexed]);
        }
        if (jsObject[XmlElementNames.IsPermanentFailure]) {
            result.IsPermanentFailure = Convert.toBool(jsObject[XmlElementNames.IsPermanentFailure]);
        }
        if (jsObject[XmlElementNames.AttemptCount]) {
            result.AttemptCount = Convert.toNumber(jsObject[XmlElementNames.AttemptCount]);
        }
        if (jsObject[XmlElementNames.LastAttemptTime]) {
            result.LastAttemptTime = DateTime.Parse(jsObject[XmlElementNames.LastAttemptTime]);
        }
        if (jsObject[XmlElementNames.AdditionalInfo]) {
            result.AdditionalInfo = jsObject[XmlElementNames.AdditionalInfo];
        }
        if (jsObject[XmlElementNames.SortValue]) {
            result.SortValue = jsObject[XmlElementNames.SortValue];
        }
        return result;
    };
    return NonIndexableItem;
}());
exports.NonIndexableItem = NonIndexableItem;
/**
 * Represents non indexable item details result.
 *
 * @sealed
 */
var NonIndexableItemDetailsResult = (function () {
    function NonIndexableItemDetailsResult() {
        /**
         * Collection of items
         */
        this.Items = null;
        /**
         * Failed mailboxes
         */
        this.FailedMailboxes = null;
    }
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     * @return  {NonIndexableItemDetailsResult}       Non indexable item details result object
     */
    NonIndexableItemDetailsResult.LoadFromXmlJsObject = function (jsObject, service) {
        var nonIndexableItemDetailsResult = new NonIndexableItemDetailsResult();
        if (jsObject[XmlElementNames.Items]) {
            nonIndexableItemDetailsResult.Items = [];
            for (var _a = 0, _b = EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.Items], XmlElementNames.NonIndexableItemDetail); _a < _b.length; _a++) {
                var nonIndexableItem = _b[_a];
                nonIndexableItemDetailsResult.Items.push(NonIndexableItem.LoadFromXmlJsObject(nonIndexableItem, service));
            }
            if (nonIndexableItemDetailsResult.Items.length === 0) {
                nonIndexableItemDetailsResult.Items = null;
            }
        }
        if (jsObject[XmlElementNames.FailedMailboxes]) {
            nonIndexableItemDetailsResult.FailedMailboxes = FailedSearchMailbox.LoadFromXmlJsObject(jsObject[XmlElementNames.FailedMailboxes], service);
        }
        return nonIndexableItemDetailsResult;
    };
    return NonIndexableItemDetailsResult;
}());
exports.NonIndexableItemDetailsResult = NonIndexableItemDetailsResult;
/**
 * Represents non indexable item parameters base class
 */
var NonIndexableItemParameters = (function () {
    function NonIndexableItemParameters() {
        /**
         * List of mailboxes (in legacy DN format)
         */
        this.Mailboxes = null;
        /**
         * Search archive only
         */
        this.SearchArchiveOnly = false;
    }
    return NonIndexableItemParameters;
}());
exports.NonIndexableItemParameters = NonIndexableItemParameters;
/**
 * Represents get non indexable item statistics parameters.
 *
 * @sealed
 */
var GetNonIndexableItemStatisticsParameters = (function (_super) {
    __extends(GetNonIndexableItemStatisticsParameters, _super);
    function GetNonIndexableItemStatisticsParameters() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return GetNonIndexableItemStatisticsParameters;
}(NonIndexableItemParameters));
exports.GetNonIndexableItemStatisticsParameters = GetNonIndexableItemStatisticsParameters;
/**
 * Represents get non indexable item details parameters.
 *
 * @sealed
 */
var GetNonIndexableItemDetailsParameters = (function (_super) {
    __extends(GetNonIndexableItemDetailsParameters, _super);
    function GetNonIndexableItemDetailsParameters() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * @Nullable Page size
         */
        _this.PageSize = null; //Nullable
        /**
         * Page item reference
         */
        _this.PageItemReference = null;
        /**
         * @Nullable Search page direction
         */
        _this.PageDirection = null; //Nullable
        return _this;
    }
    return GetNonIndexableItemDetailsParameters;
}(NonIndexableItemParameters));
exports.GetNonIndexableItemDetailsParameters = GetNonIndexableItemDetailsParameters;
/**
 * Represents non indexable item statistic.
 *
 * @sealed
 */
var NonIndexableItemStatistic = (function () {
    function NonIndexableItemStatistic() {
        /**
         * Mailbox legacy DN
         */
        this.Mailbox = null;
        /**
         * Item count
         */
        this.ItemCount = 0;
        /**
         * Error message
         */
        this.ErrorMessage = null;
    }
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     * @return  {NonIndexableItemStatistic}       non indexable item statistic object
     */
    NonIndexableItemStatistic.LoadFromXmlJsObject = function (jsObject, service) {
        var result = new NonIndexableItemStatistic();
        if (jsObject[XmlElementNames.Mailbox]) {
            result.Mailbox = jsObject[XmlElementNames.Mailbox];
        }
        if (jsObject[XmlElementNames.ItemCount]) {
            result.ItemCount = Convert.toNumber(jsObject[XmlElementNames.ItemCount]);
        }
        if (jsObject[XmlElementNames.ErrorMessage]) {
            result.ErrorMessage = jsObject[XmlElementNames.ErrorMessage];
        }
        return result;
    };
    return NonIndexableItemStatistic;
}());
exports.NonIndexableItemStatistic = NonIndexableItemStatistic;
/**
 * Represents mailbox object for preview item.
 *
 * @sealed
 */
var PreviewItemMailbox = (function () {
    function PreviewItemMailbox(mailboxId, primarySmtpAddress) {
        if (mailboxId === void 0) { mailboxId = null; }
        if (primarySmtpAddress === void 0) { primarySmtpAddress = null; }
        /**
         * Mailbox id
         */
        this.MailboxId = null;
        /**
         * Primary smtp address
         */
        this.PrimarySmtpAddress = null;
        this.MailboxId = mailboxId;
        this.PrimarySmtpAddress = primarySmtpAddress;
    }
    return PreviewItemMailbox;
}());
exports.PreviewItemMailbox = PreviewItemMailbox;
/**
 * Represents preview item response shape
 *
 * @sealed
 */
var PreviewItemResponseShape = (function () {
    function PreviewItemResponseShape(baseShape, additionalProperties) {
        if (baseShape === void 0) { baseShape = PreviewItemBaseShape.Default; }
        if (additionalProperties === void 0) { additionalProperties = null; }
        /**
         * Mailbox identifier
         */
        this.BaseShape = PreviewItemBaseShape.Default;
        /**
         * Additional properties (must be in form of extended properties)
         */
        this.AdditionalProperties = null;
        this.BaseShape = baseShape;
        this.AdditionalProperties = additionalProperties;
    }
    return PreviewItemResponseShape;
}());
exports.PreviewItemResponseShape = PreviewItemResponseShape;
/**
 * Represents searchable mailbox object
 *
 * @sealed
 */
var SearchableMailbox = (function () {
    function SearchableMailbox(guid, smtpAddress, isExternalMailbox, externalEmailAddress, displayName, isMembershipGroup, referenceId) {
        if (guid === void 0) { guid = null; }
        if (smtpAddress === void 0) { smtpAddress = null; }
        if (isExternalMailbox === void 0) { isExternalMailbox = false; }
        if (externalEmailAddress === void 0) { externalEmailAddress = null; }
        if (displayName === void 0) { displayName = null; }
        if (isMembershipGroup === void 0) { isMembershipGroup = false; }
        if (referenceId === void 0) { referenceId = null; }
        /**
         * Guid
         */
        this.Guid = null;
        /**
         * Smtp address
         */
        this.SmtpAddress = null;
        /**
         * If true, this is an external mailbox
         */
        this.IsExternalMailbox = false;
        /**
         * External email address for the mailbox
         */
        this.ExternalEmailAddress = null;
        /**
         * Display name
         */
        this.DisplayName = null;
        /**
         * Is a membership group
         */
        this.IsMembershipGroup = false;
        /**
         * Reference id
         */
        this.ReferenceId = null;
        this.Guid = guid;
        this.SmtpAddress = smtpAddress;
        this.IsExternalMailbox = isExternalMailbox;
        this.ExternalEmailAddress = externalEmailAddress;
        this.DisplayName = displayName;
        this.IsMembershipGroup = isMembershipGroup;
        this.ReferenceId = referenceId;
    }
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     * @return  {SearchableMailbox}              Searchable mailbox object
     */
    SearchableMailbox.LoadFromXmlJsObject = function (jsObject, service) {
        var searchableMailbox = new SearchableMailbox();
        if (jsObject[XmlElementNames.Guid]) {
            searchableMailbox.Guid = new Guid(jsObject[XmlElementNames.Guid]);
        }
        if (jsObject[XmlElementNames.DisplayName]) {
            searchableMailbox.DisplayName = jsObject[XmlElementNames.DisplayName];
        }
        if (jsObject[XmlElementNames.PrimarySmtpAddress]) {
            searchableMailbox.SmtpAddress = jsObject[XmlElementNames.PrimarySmtpAddress];
        }
        if (jsObject[XmlElementNames.IsExternalMailbox]) {
            searchableMailbox.IsExternalMailbox = Convert.toBool(jsObject[XmlElementNames.IsExternalMailbox]);
        }
        if (jsObject[XmlElementNames.ExternalEmailAddress]) {
            searchableMailbox.ExternalEmailAddress = jsObject[XmlElementNames.ExternalEmailAddress];
        }
        if (jsObject[XmlElementNames.IsMembershipGroup]) {
            searchableMailbox.IsMembershipGroup = Convert.toBool(jsObject[XmlElementNames.IsMembershipGroup]);
        }
        if (jsObject[XmlElementNames.ReferenceId]) {
            searchableMailbox.ReferenceId = jsObject[XmlElementNames.ReferenceId];
        }
        return searchableMailbox;
    };
    return SearchableMailbox;
}());
exports.SearchableMailbox = SearchableMailbox;
/**
 * Represents search mailbox parameters.
 *
 * @sealed
 */
var SearchMailboxesParameters = (function () {
    function SearchMailboxesParameters() {
        /**
         * Search queries
         */
        this.SearchQueries = null;
        /**
         * Result type
         */
        this.ResultType = SearchResultType.PreviewOnly;
        /**
         * Sort by property
         */
        this.SortBy = null;
        /**
         * Sort direction
         */
        this.SortOrder = SortDirection.Ascending;
        /**
         * Perform deduplication
         */
        this.PerformDeduplication = false;
        /**
         * Page size
         */
        this.PageSize = 0;
        /**
         * Search page direction
         */
        this.PageDirection = SearchPageDirection.Next;
        /**
         * Page item reference
         */
        this.PageItemReference = null;
        /**
         * Preview item response shape
         */
        this.PreviewItemResponseShape = null;
        /**
         * Query language
         */
        this.Language = null;
    }
    return SearchMailboxesParameters;
}());
exports.SearchMailboxesParameters = SearchMailboxesParameters;
/**
 * Represents search mailbox result.
 *
 * @sealed
 */
var SearchMailboxesResult = (function () {
    function SearchMailboxesResult() {
        /**
         * Search queries
         */
        this.SearchQueries = null;
        /**
         * Result type
         */
        this.ResultType = SearchResultType.StatisticsOnly;
        /**
         * Item count
         */
        this.ItemCount = 0;
        /**
         * Total size
         * [CLSCompliant(false)]
         */
        this.Size = 0;
        /**
         * Page item count
         */
        this.PageItemCount = 0;
        /**
         * Total page item size
         * [CLSCompliant(false)]
         */
        this.PageItemSize = 0;
        /**
         * Keyword statistics search result
         */
        this.KeywordStats = null;
        /**
         * Search preview items
         */
        this.PreviewItems = null;
        /**
         * Failed mailboxes
         */
        this.FailedMailboxes = null;
        /**
         * Refiners
         */
        this.Refiners = null;
        /**
         * Mailbox statistics
         */
        this.MailboxStats = null;
    }
    /**
     * Get collection of recipients
     *
     * @param   {any}   jsObject	Json Object converted from XML.
     * @return  {string[]}          Array of recipients
     */
    SearchMailboxesResult.GetRecipients = function (jsObject) {
        var recipients = EwsServiceJsonReader.ReadAsArray(jsObject, XmlElementNames.SmtpAddress);
        return recipients.length === 0 ? null : recipients;
    };
    /**
     * Load extended properties from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     * @return  {ExtendedPropertyCollection}     Extended properties collection
     */
    SearchMailboxesResult.LoadExtendedPropertiesXmlJsObject = function (jsObject, service) {
        var extendedProperties = new ExtendedPropertyCollection();
        for (var _a = 0, _b = EwsServiceJsonReader.ReadAsArray(jsObject, XmlElementNames.ExtendedProperty); _a < _b.length; _a++) {
            var extendedProperty = _b[_a];
            extendedProperties.LoadFromXmlJsObject(extendedProperty, service);
        }
        return extendedProperties.Count === 0 ? null : extendedProperties;
    };
    /**
     * Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     * @return  {SearchMailboxesResult}     Search result object
     */
    SearchMailboxesResult.LoadFromXmlJsObject = function (jsObject, service) {
        var searchResult = new SearchMailboxesResult();
        if (jsObject[XmlElementNames.SearchQueries]) {
            searchResult.SearchQueries = [];
            for (var _a = 0, _b = EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.SearchQueries], XmlElementNames.SearchQuery); _a < _b.length; _a++) {
                var searchQuery = _b[_a];
                var query = searchQuery[XmlElementNames.Query];
                var mailboxSearchScopes = [];
                if (searchQuery[XmlElementNames.MailboxSearchScopes]) {
                    for (var _c = 0, _d = EwsServiceJsonReader.ReadAsArray(searchQuery[XmlElementNames.MailboxSearchScopes], XmlElementNames.MailboxSearchScope); _c < _d.length; _c++) {
                        var mailboxSearchScope = _d[_c];
                        var mailbox = mailboxSearchScope[XmlElementNames.Mailbox];
                        var searchScope = MailboxSearchLocation[mailboxSearchScope[XmlElementNames.SearchScope]];
                        mailboxSearchScopes.push(new MailboxSearchScope(mailbox, searchScope));
                    }
                }
                searchResult.SearchQueries.push(new MailboxQuery(query, mailboxSearchScopes));
            }
        }
        if (jsObject[XmlElementNames.ResultType]) {
            searchResult.ResultType = SearchResultType[jsObject[XmlElementNames.ResultType]];
        }
        if (jsObject[XmlElementNames.ItemCount]) {
            searchResult.ItemCount = Convert.toNumber(jsObject[XmlElementNames.ItemCount]);
        }
        if (jsObject[XmlElementNames.Size]) {
            searchResult.Size = Convert.toNumber(jsObject[XmlElementNames.Size]);
        }
        if (jsObject[XmlElementNames.PageItemCount]) {
            searchResult.PageItemCount = Convert.toNumber(jsObject[XmlElementNames.PageItemCount]);
        }
        if (jsObject[XmlElementNames.PageItemSize]) {
            searchResult.PageItemSize = Convert.toNumber(jsObject[XmlElementNames.PageItemSize]);
        }
        if (jsObject[XmlElementNames.KeywordStats]) {
            searchResult.KeywordStats = this.LoadKeywordStatsXmlJsObject(jsObject[XmlElementNames.KeywordStats]);
        }
        if (jsObject[XmlElementNames.Items]) {
            searchResult.PreviewItems = this.LoadPreviewItemsXmlJsObject(jsObject[XmlElementNames.Items], service);
        }
        if (jsObject[XmlElementNames.FailedMailboxes]) {
            searchResult.FailedMailboxes = FailedSearchMailbox.LoadFromXmlJsObject(jsObject[XmlElementNames.FailedMailboxes], service);
        }
        if (jsObject[XmlElementNames.Refiners]) {
            var refiners = [];
            for (var _e = 0, _f = EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.Refiners], XmlElementNames.Refiner); _e < _f.length; _e++) {
                var refiner = _f[_e];
                refiners.push(SearchRefinerItem.LoadFromXmlJsObject(refiner, service));
            }
            if (refiners.length > 0) {
                searchResult.Refiners = refiners;
            }
        }
        if (jsObject[XmlElementNames.MailboxStats]) {
            var mailboxStats = [];
            for (var _g = 0, _h = EwsServiceJsonReader.ReadAsArray(jsObject[XmlElementNames.MailboxStats], XmlElementNames.MailboxStat); _g < _h.length; _g++) {
                var mailboxStat = _h[_g];
                mailboxStats.push(MailboxStatisticsItem.LoadFromXmlJsObject(mailboxStat, service));
            }
            if (mailboxStats.length > 0) {
                searchResult.MailboxStats = mailboxStats;
            }
        }
        return searchResult;
    };
    /**
     * Load keyword stats from XML.
     *
     * @param   {any}   jsObject	Json Object converted from XML.
     * @return  {KeywordStatisticsSearchResult[]}       Array of keyword statistics
     */
    SearchMailboxesResult.LoadKeywordStatsXmlJsObject = function (jsObject) {
        var keywordStats = [];
        for (var _a = 0, _b = EwsServiceJsonReader.ReadAsArray(jsObject, XmlElementNames.KeywordStat); _a < _b.length; _a++) {
            var keywordStatObj = _b[_a];
            var keywordStat = new KeywordStatisticsSearchResult();
            keywordStat.Keyword = jsObject[XmlElementNames.Keyword];
            keywordStat.ItemHits = Convert.toNumber(jsObject[XmlElementNames.ItemHits]);
            keywordStat.Size = Convert.toNumber(jsObject[XmlElementNames.Size]);
            keywordStats.push(keywordStat);
        }
        return keywordStats.length === 0 ? null : keywordStats;
    };
    /**
     * Load preview items from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     * @return  {SearchPreviewItem[]}     Array of preview items
     */
    SearchMailboxesResult.LoadPreviewItemsXmlJsObject = function (jsObject, service) {
        var previewItems = [];
        for (var _a = 0, _b = EwsServiceJsonReader.ReadAsArray(jsObject, XmlElementNames.SearchPreviewItem); _a < _b.length; _a++) {
            var searchPreviewItem = _b[_a];
            var previewItem = new SearchPreviewItem();
            if (searchPreviewItem[XmlElementNames.Id]) {
                previewItem.Id = new ItemId();
                previewItem.Id.LoadFromXmlJsObject(searchPreviewItem[XmlElementNames.Id], service);
            }
            if (searchPreviewItem[XmlElementNames.ParentId]) {
                previewItem.ParentId = new ItemId();
                previewItem.ParentId.LoadFromXmlJsObject(searchPreviewItem[XmlElementNames.ParentId], service);
            }
            if (searchPreviewItem[XmlElementNames.Mailbox]) {
                previewItem.Mailbox = new PreviewItemMailbox();
                previewItem.Mailbox.MailboxId = searchPreviewItem[XmlElementNames.Mailbox][XmlElementNames.MailboxId];
                previewItem.Mailbox.PrimarySmtpAddress = searchPreviewItem[XmlElementNames.Mailbox][XmlElementNames.PrimarySmtpAddress];
            }
            //missing in official repo
            if (searchPreviewItem[XmlElementNames.ItemClass]) {
                previewItem.ItemClass = searchPreviewItem[XmlElementNames.ItemClass];
            }
            if (searchPreviewItem[XmlElementNames.UniqueHash]) {
                previewItem.UniqueHash = searchPreviewItem[XmlElementNames.UniqueHash];
            }
            if (searchPreviewItem[XmlElementNames.SortValue]) {
                previewItem.SortValue = searchPreviewItem[XmlElementNames.SortValue];
            }
            if (searchPreviewItem[XmlElementNames.OwaLink]) {
                previewItem.OwaLink = searchPreviewItem[XmlElementNames.OwaLink];
            }
            if (searchPreviewItem[XmlElementNames.Sender]) {
                previewItem.Sender = searchPreviewItem[XmlElementNames.Sender];
            }
            if (searchPreviewItem[XmlElementNames.ToRecipients]) {
                previewItem.ToRecipients = this.GetRecipients(searchPreviewItem[XmlElementNames.ToRecipients]);
            }
            if (searchPreviewItem[XmlElementNames.CcRecipients]) {
                previewItem.CcRecipients = this.GetRecipients(searchPreviewItem[XmlElementNames.CcRecipients]);
            }
            if (searchPreviewItem[XmlElementNames.BccRecipients]) {
                previewItem.BccRecipients = this.GetRecipients(searchPreviewItem[XmlElementNames.BccRecipients]);
            }
            if (searchPreviewItem[XmlElementNames.CreatedTime]) {
                previewItem.CreatedTime = DateTime.Parse(searchPreviewItem[XmlElementNames.CreatedTime]);
            }
            if (searchPreviewItem[XmlElementNames.ReceivedTime]) {
                previewItem.ReceivedTime = DateTime.Parse(searchPreviewItem[XmlElementNames.ReceivedTime]);
            }
            if (searchPreviewItem[XmlElementNames.SentTime]) {
                previewItem.SentTime = DateTime.Parse(searchPreviewItem[XmlElementNames.SentTime]);
            }
            if (searchPreviewItem[XmlElementNames.Subject]) {
                previewItem.Subject = searchPreviewItem[XmlElementNames.Subject];
            }
            if (searchPreviewItem[XmlElementNames.Preview]) {
                previewItem.Preview = searchPreviewItem[XmlElementNames.Preview];
            }
            if (searchPreviewItem[XmlElementNames.Size]) {
                previewItem.Size = Convert.toNumber(searchPreviewItem[XmlElementNames.Size]);
            }
            if (searchPreviewItem[XmlElementNames.Importance]) {
                previewItem.Importance = Importance[searchPreviewItem[XmlElementNames.Importance]];
            }
            if (searchPreviewItem[XmlElementNames.Read]) {
                previewItem.Read = Convert.toBool(searchPreviewItem[XmlElementNames.Read]);
            }
            if (searchPreviewItem[XmlElementNames.HasAttachment]) {
                previewItem.HasAttachment = Convert.toBool(searchPreviewItem[XmlElementNames.HasAttachment]);
            }
            if (searchPreviewItem[XmlElementNames.ExtendedProperties]) {
                previewItem.ExtendedProperties = this.LoadExtendedPropertiesXmlJsObject(searchPreviewItem[XmlElementNames.ExtendedProperties], service);
            }
            previewItems.push(previewItem);
        }
        return previewItems.length === 0 ? null : previewItems;
    };
    return SearchMailboxesResult;
}());
exports.SearchMailboxesResult = SearchMailboxesResult;
/**
 * Represents search preview item.
 *
 * @sealed
 */
var SearchPreviewItem = (function () {
    function SearchPreviewItem() {
        /**
         * Item id
         */
        this.Id = null;
        /**
         * Mailbox
         */
        this.Mailbox = null;
        /**
         * Parent item id
         */
        this.ParentId = null;
        /**
         * Item Class
         */
        this.ItemClass = null;
        /**
         * Unique hash
         */
        this.UniqueHash = null;
        /**
         * Sort Value
         */
        this.SortValue = null;
        /**
         * OWA Link
         */
        this.OwaLink = null;
        /**
         * Sender
         */
        this.Sender = null;
        /**
         * To recipients
         */
        this.ToRecipients = null;
        /**
         * Cc recipients
         */
        this.CcRecipients = null;
        /**
         * Bcc recipients
         */
        this.BccRecipients = null;
        /**
         * Created Time
         */
        this.CreatedTime = null;
        /**
         * Received Time
         */
        this.ReceivedTime = null;
        /**
         * Sent Time
         */
        this.SentTime = null;
        /**
         * Subject
         */
        this.Subject = null;
        /**
         * Item size
         */
        this.Size = 0;
        /**
         * Preview
         */
        this.Preview = null;
        /**
         * Importance
         */
        this.Importance = Importance.Low;
        /**
         * Read
         */
        this.Read = false;
        /**
         * Has attachment
         */
        this.HasAttachment = false;
        /**
         * Extended properties
         */
        this.ExtendedProperties = null;
    }
    return SearchPreviewItem;
}());
exports.SearchPreviewItem = SearchPreviewItem;
/**
 * Search refiner item
 */
var SearchRefinerItem = (function () {
    function SearchRefinerItem() {
        /**
         * Refiner name
         */
        this.Name = null;
        /**
         * Refiner value
         */
        this.Value = null;
        /**
         * Refiner count
         */
        this.Count = 0;
        /**
         * Refiner token, essentially comprises of an operator (i.e. ':' or '>') plus the refiner value The caller such as Sharepoint can simply append this to refiner name for query refinement
         */
        this.Token = null;
    }
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     * @return  {SearchRefinerItem}
     */
    SearchRefinerItem.LoadFromXmlJsObject = function (jsObject, service) {
        var sri = new SearchRefinerItem();
        sri.Name = jsObject[XmlElementNames.Name];
        sri.Value = jsObject[XmlElementNames.Value];
        sri.Count = Convert.toNumber(jsObject[XmlElementNames.Count]);
        sri.Token = jsObject[XmlElementNames.Token];
        return sri;
    };
    return SearchRefinerItem;
}());
exports.SearchRefinerItem = SearchRefinerItem;
/**
 * Represents set hold on mailboxes parameters.
 *
 * @sealed
 */
var SetHoldOnMailboxesParameters = (function () {
    function SetHoldOnMailboxesParameters() {
        /**
         * Action type
         */
        this.ActionType = HoldAction.Create;
        /**
         * Hold id
         */
        this.HoldId = null;
        /**
         * Query
         */
        this.Query = null;
        /**
         * Collection of mailboxes
         */
        this.Mailboxes = null;
        /**
         * Query language
         */
        this.Language = null;
        /**
         * In-place hold identity
         */
        this.InPlaceHoldIdentity = null;
        /**
         * Item hold period
         * *The text value can be "Unlimited" or the string value of any Timespan value.*
         *
         * per github issue #120
         */
        this.ItemHoldPeriod = null;
        /**
         * Include Non Indexable Items
         *
         * per github issue #120
         */
        this.IncludeNonIndexableItems = null;
        /**
         * Perform deduplication
         *
         * per github issue #120
         */
        this.PerformDeduplication = null;
    }
    return SetHoldOnMailboxesParameters;
}());
exports.SetHoldOnMailboxesParameters = SetHoldOnMailboxesParameters;
/**
 * Class Feature
 */
var SchemaChange = (function () {
    function SchemaChange(serverVersionOrserverBuild) {
        /**
         * Gets the minimum server version.
         *
         * @value The minimum server version.
         */
        this.MinimumServerVersion = 0; //private set;l long
        if (typeof serverVersionOrserverBuild === 'number')
            this.MinimumServerVersion = serverVersionOrserverBuild;
        if (typeof serverVersionOrserverBuild === 'string') {
            var version = serverVersionOrserverBuild.split(".");
            var major = Convert.toNumber(version[0]) || 0;
            var minor = Convert.toNumber(version[1]) || 0;
            var build = Convert.toNumber(version[2]) || 0;
            var revision = Convert.toNumber(version[3]) || 0;
            this.MinimumServerVersion = (build & 0x7FFF) |
                ((minor & 0x3F) << 16) |
                ((major & 0x3F) << 22) |
                0x70008000;
            //                        System. Version Version = new Version(serverBuild);
            //
            //                        this.MinimumServerVersion = (version.Build & 0x7FFF) |
            //                                            ((version.Minor & 0x3F) << 16) |
            //                                            ((version.Major & 0x3F) << 22) |
            //                                            0x70008000;
        }
    }
    /**
     * Determines whether the specified versionable is compatible.
     *
     * @param   {IDiscoveryVersionable}   versionable   The versionable.
     * @return  {boolean}                 *true* if the specified versionable is compatible; otherwise, *false*.
     */
    SchemaChange.prototype.IsCompatible = function (versionable) {
        // note: when ServerVersion is not set(i.e., => 0), we ignore compatible check on the client side. It will eventually fail server side schema check if incompatible
        return versionable.ServerVersion == 0 || versionable.ServerVersion >= this.MinimumServerVersion;
    };
    return SchemaChange;
}());
exports.SchemaChange = SchemaChange;
/**
 * Class DiscoverySchemaChanges
 * This class is a catalog of schema changes in discovery with the minimum server version in which they were introduced When making a schema change
 * - First make the server side changes and check them in
 * - Create SchemaChange() entry here for the change and the version at which it was checked int
 * - In the request
 *  - Implement IDiscoveryVersionable
 *  - In the Validate method verify if any new schema parameters are compatible if not error out
 *  - In the WriteXml method downgrade the schema based on compatability checks
 * Eg, SearchMailboxesRequest.cs
 *
 * @static
 */
var DiscoverySchemaChanges = (function () {
    function DiscoverySchemaChanges() {
    }
    ;
    ;
    /**
     * Gets the search mailboxes extended data.
     *
     * @value The search mailboxes extended data.
     */
    DiscoverySchemaChanges.SearchMailboxesExtendedData = new SchemaChange("15.0.730.0");
    /**
     * Gets the search mailboxes additional search scopes.
     *
     * The search mailboxes additional search scopes.
     */
    DiscoverySchemaChanges.SearchMailboxesAdditionalSearchScopes = new SchemaChange("15.0.730.0");
    return DiscoverySchemaChanges;
}());
exports.DiscoverySchemaChanges = DiscoverySchemaChanges;
/**
 * Represents information about an attendee for which to request availability information.
 *
 * @sealed
 */
var AttendeeInfo = (function () {
    function AttendeeInfo(smtpAddress, attendeeType, excludeConflicts) {
        if (smtpAddress === void 0) { smtpAddress = null; }
        if (attendeeType === void 0) { attendeeType = MeetingAttendeeType.Required; }
        if (excludeConflicts === void 0) { excludeConflicts = false; }
        /**
         * Gets or sets the SMTP address of this attendee.
         */
        this.SmtpAddress = null;
        /**
         * Gets or sets the type of this attendee.
         */
        this.AttendeeType = MeetingAttendeeType.Required;
        /**
         * Gets or sets a value indicating whether times when this attendee is not available should be returned.
         */
        this.ExcludeConflicts = false;
        this.SmtpAddress = smtpAddress;
        this.AttendeeType = attendeeType;
        this.ExcludeConflicts = excludeConflicts;
    }
    /**
     * Validates this instance.
     *
     * ISelfValidate.Validate
     */
    AttendeeInfo.prototype.Validate = function () {
        EwsUtilities.ValidateParam(this.SmtpAddress, "SmtpAddress");
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    AttendeeInfo.prototype.WriteToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.MailboxData);
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Email);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Address, this.SmtpAddress);
        writer.WriteEndElement(); // Email
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.AttendeeType, MeetingAttendeeType[this.AttendeeType]);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ExcludeConflicts, this.ExcludeConflicts);
        writer.WriteEndElement(); // MailboxData
    };
    return AttendeeInfo;
}());
exports.AttendeeInfo = AttendeeInfo;
var AvailabilityOptions = (function () {
    function AvailabilityOptions() {
        this.mergedFreeBusyInterval = 30;
        this.requestedFreeBusyView = FreeBusyViewType.Detailed;
        this.goodSuggestionThreshold = 25;
        this.maximumSuggestionsPerDay = 10;
        this.maximumNonWorkHoursSuggestionsPerDay = 0;
        this.meetingDuration = 60;
        this.minimumSuggestionQuality = SuggestionQuality.Fair;
        this.detailedSuggestionsWindow = null;
        this.currentMeetingTime = null;
        this.globalObjectId = null;
    }
    Object.defineProperty(AvailabilityOptions.prototype, "MergedFreeBusyInterval", {
        get: function () {
            return this.mergedFreeBusyInterval;
        },
        set: function (value) {
            if (value < 5 || value > 1440) {
                throw new Error(StringHelper.Format(Strings.InvalidPropertyValueNotInRange, "MergedFreeBusyInterval", 5, 1440)); //ArgumentException
            }
            this.mergedFreeBusyInterval = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvailabilityOptions.prototype, "RequestedFreeBusyView", {
        get: function () {
            return this.requestedFreeBusyView;
        },
        set: function (value) {
            this.requestedFreeBusyView = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvailabilityOptions.prototype, "GoodSuggestionThreshold", {
        get: function () {
            return this.goodSuggestionThreshold;
        },
        set: function (value) {
            if (value < 1 || value > 49) {
                throw new Error(StringHelper.Format(Strings.InvalidPropertyValueNotInRange, "GoodSuggestionThreshold", 1, 49)); //ArgumentException
            }
            this.goodSuggestionThreshold = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvailabilityOptions.prototype, "MaximumSuggestionsPerDay", {
        get: function () {
            return this.maximumSuggestionsPerDay;
        },
        set: function (value) {
            if (value < 0 || value > 48) {
                throw new Error(StringHelper.Format(Strings.InvalidPropertyValueNotInRange, "MaximumSuggestionsPerDay", 0, 48)); //ArgumentException
            }
            this.maximumSuggestionsPerDay = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvailabilityOptions.prototype, "MaximumNonWorkHoursSuggestionsPerDay", {
        get: function () {
            return this.maximumNonWorkHoursSuggestionsPerDay;
        },
        set: function (value) {
            if (value < 0 || value > 48) {
                throw new Error(StringHelper.Format(Strings.InvalidPropertyValueNotInRange, "MaximumNonWorkHoursSuggestionsPerDay", 0, 48)); //ArgumentException
            }
            this.maximumNonWorkHoursSuggestionsPerDay = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvailabilityOptions.prototype, "MeetingDuration", {
        get: function () {
            return this.meetingDuration;
        },
        set: function (value) {
            if (value < 30 || value > 1440) {
                throw new Error(StringHelper.Format(Strings.InvalidPropertyValueNotInRange, "MeetingDuration", 30, 1440)); //ArgumentException
            }
            this.meetingDuration = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvailabilityOptions.prototype, "MinimumSuggestionQuality", {
        get: function () {
            return this.minimumSuggestionQuality;
        },
        set: function (value) {
            this.minimumSuggestionQuality = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvailabilityOptions.prototype, "DetailedSuggestionsWindow", {
        get: function () {
            return this.detailedSuggestionsWindow;
        },
        set: function (value) {
            this.detailedSuggestionsWindow = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvailabilityOptions.prototype, "CurrentMeetingTime", {
        get: function () {
            return this.currentMeetingTime;
        },
        set: function (value) {
            this.currentMeetingTime = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvailabilityOptions.prototype, "GlobalObjectId", {
        get: function () {
            return this.globalObjectId;
        },
        set: function (value) {
            this.globalObjectId = value;
        },
        enumerable: true,
        configurable: true
    });
    AvailabilityOptions.prototype.Validate = function (timeWindow) {
        if (TimeSpan.FromMinutes(this.MergedFreeBusyInterval) > timeWindow) {
            throw new Error(Strings.MergedFreeBusyIntervalMustBeSmallerThanTimeWindow); //, "MergedFreeBusyInterval");//ArgumentException
        }
        EwsUtilities.ValidateParamAllowNull(this.DetailedSuggestionsWindow, "DetailedSuggestionsWindow");
    };
    /** @internal */
    AvailabilityOptions.prototype.WriteToXml = function (writer, request) {
        if (request.IsFreeBusyViewRequested) {
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.FreeBusyViewOptions);
            request.TimeWindow.WriteToXmlUnscopedDatesOnly(writer, XmlElementNames.TimeWindow);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.MergedFreeBusyIntervalInMinutes, this.MergedFreeBusyInterval);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.RequestedView, FreeBusyViewType[this.RequestedFreeBusyView]);
            writer.WriteEndElement(); // FreeBusyViewOptions
        }
        if (request.IsSuggestionsViewRequested) {
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.SuggestionsViewOptions);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.GoodThreshold, this.GoodSuggestionThreshold);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.MaximumResultsByDay, this.MaximumSuggestionsPerDay);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.MaximumNonWorkHourResultsByDay, this.MaximumNonWorkHoursSuggestionsPerDay);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.MeetingDurationInMinutes, this.MeetingDuration);
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.MinimumSuggestionQuality, SuggestionQuality[this.MinimumSuggestionQuality]);
            var timeWindowToSerialize = this.DetailedSuggestionsWindow === null ?
                request.TimeWindow :
                this.DetailedSuggestionsWindow;
            timeWindowToSerialize.WriteToXmlUnscopedDatesOnly(writer, XmlElementNames.DetailedSuggestionsWindow);
            if (this.CurrentMeetingTime !== null) {
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.CurrentMeetingTime, this.CurrentMeetingTime);
            }
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.GlobalObjectId, this.GlobalObjectId);
            writer.WriteEndElement(); // SuggestionsViewOptions
        }
    };
    return AvailabilityOptions;
}());
exports.AvailabilityOptions = AvailabilityOptions;
var GetUserAvailabilityResults = (function () {
    function GetUserAvailabilityResults() {
        this.attendeesAvailability = null;
        this.suggestionsResponse = null;
    }
    Object.defineProperty(GetUserAvailabilityResults.prototype, "SuggestionsResponse", {
        get: function () {
            return this.suggestionsResponse;
        },
        set: function (value) {
            this.suggestionsResponse = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetUserAvailabilityResults.prototype, "AttendeesAvailability", {
        get: function () {
            return this.attendeesAvailability;
        },
        set: function (value) {
            this.attendeesAvailability = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetUserAvailabilityResults.prototype, "Suggestions", {
        get: function () {
            if (this.suggestionsResponse === null) {
                return null;
            }
            this.suggestionsResponse.ThrowIfNecessary();
            return this.suggestionsResponse.Suggestions;
        },
        enumerable: true,
        configurable: true
    });
    return GetUserAvailabilityResults;
}());
exports.GetUserAvailabilityResults = GetUserAvailabilityResults;
var LegacyAvailabilityTimeZone = (function (_super) {
    __extends(LegacyAvailabilityTimeZone, _super);
    function LegacyAvailabilityTimeZone(timeZoneInfo) {
        if (timeZoneInfo === void 0) { timeZoneInfo = null; }
        var _this = _super.call(this) || this;
        _this.bias = TimeSpan.Zero;
        return _this;
        //ref: skipping due to only called when server is 2007 sp1, 10 years later, may be not many cases to handle. 
        // if (timeZoneInfo && arguments.length === 1) {
        //     // Availability uses the opposite sign for the bias, e.g. if TimeZoneInfo.BaseUtcOffset = 480 than
        //     // SerializedTimeZone.Bias must be -480.
        //     this.bias = TimeSpan.FromMilliseconds(-timeZoneInfo.BaseUtcOffset.TotalMilliseconds);
        //     // To convert TimeZoneInfo into SerializableTimeZone, we need two time changes: one to Standard
        //     // time, the other to Daylight time. TimeZoneInfo holds a list of adjustment rules that represent
        //     // the different rules that govern time changes over the years. We need to grab one of those rules
        //     // to initialize this instance.
        //     let adjustmentRules: TimeZoneInfo.AdjustmentRule[] = timeZoneInfo.GetAdjustmentRules();
        //     if (adjustmentRules.length == 0) {
        //         // If there are no adjustment rules (which is the case for UTC), we have to come up with two
        //         // dummy time changes which both have a delta of zero and happen at two hard coded dates. This
        //         // simulates a time zone in which there are no time changes.
        //         this.daylightTime = new LegacyAvailabilityTimeZoneTime();
        //         this.daylightTime.Delta = TimeSpan.Zero;
        //         this.daylightTime.DayOrder = 1;
        //         this.daylightTime.DayOfTheWeek = DayOfTheWeek.Sunday;
        //         this.daylightTime.Month = 10;
        //         this.daylightTime.TimeOfDay = TimeSpan.FromHours(2);
        //         this.daylightTime.Year = 0;
        //         this.standardTime = new LegacyAvailabilityTimeZoneTime();
        //         this.standardTime.Delta = TimeSpan.Zero;
        //         this.standardTime.DayOrder = 1;
        //         this.standardTime.DayOfTheWeek = DayOfTheWeek.Sunday;
        //         this.standardTime.Month = 3;
        //         this.standardTime.TimeOfDay = TimeSpan.FromHours(2);
        //         this.daylightTime.Year = 0;
        //     }
        //     else {
        //         // When there is at least one adjustment rule, we need to grab the last one which is the
        //         // one that currently applies (TimeZoneInfo stores adjustment rules sorted from oldest to
        //         // most recent).
        //         let currentRule: TimeZoneInfo.AdjustmentRule = adjustmentRules[adjustmentRules.length - 1];
        //         this.standardTime = new LegacyAvailabilityTimeZoneTime(currentRule.DaylightTransitionEnd, TimeSpan.Zero);
        //         // Again, TimeZoneInfo and SerializableTime use opposite signs for bias.
        //         this.daylightTime = new LegacyAvailabilityTimeZoneTime(currentRule.DaylightTransitionStart, TimeSpan.FromMilliseconds(-currentRule.DaylightDelta.TotalMilliseconds));
        //     }
        // }
    }
    LegacyAvailabilityTimeZone.prototype.ToTimeZoneInfo = function () {
        if (this.daylightTime.HasTransitionTime &&
            this.standardTime.HasTransitionTime) {
            var adjustmentRule = TimeZoneInfo.AdjustmentRule.CreateAdjustmentRule(DateTime.MinValue.Date, DateTime.MaxValue.Date, TimeSpan.FromMilliseconds(-this.daylightTime.Delta.TotalMilliseconds), this.daylightTime.ToTransitionTime(), this.standardTime.ToTransitionTime());
            return TimeZoneInfo.CreateCustomTimeZone(Guid.NewGuid().ToString(), TimeSpan.FromMilliseconds(-this.bias.TotalMilliseconds), "Custom time zone", "Standard time", "Daylight time", [adjustmentRule]);
        }
        else {
            // Create no DST time zone
            return TimeZoneInfo.CreateCustomTimeZone(Guid.NewGuid().ToString(), TimeSpan.FromMilliseconds(-this.bias.TotalMilliseconds), "Custom time zone", "Standard time");
        }
    };
    LegacyAvailabilityTimeZone.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.Bias:
                    this.bias = TimeSpan.FromMinutes(Number(jsonProperty[key]));
                    break;
                case XmlElementNames.StandardTime:
                    this.standardTime = new LegacyAvailabilityTimeZoneTime();
                    this.standardTime.LoadFromXmlJsObject(jsonProperty[key], service);
                    break;
                case XmlElementNames.DaylightTime:
                    this.daylightTime = new LegacyAvailabilityTimeZoneTime();
                    this.daylightTime.LoadFromXmlJsObject(jsonProperty[key], service);
                    break;
                default:
                    break;
            }
        }
    };
    /**@internal */
    LegacyAvailabilityTimeZone.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Bias, this.bias.TotalMinutes);
        this.standardTime.WriteToXml(writer, XmlElementNames.StandardTime);
        this.daylightTime.WriteToXml(writer, XmlElementNames.DaylightTime);
    };
    return LegacyAvailabilityTimeZone;
}(ComplexProperty));
exports.LegacyAvailabilityTimeZone = LegacyAvailabilityTimeZone;
var LegacyAvailabilityTimeZoneTime = (function (_super) {
    __extends(LegacyAvailabilityTimeZoneTime, _super);
    // private delta: TimeSpan /*System.TimeSpan*/; //backing property not needed
    // private year: number;
    // private month: number;
    // private dayOrder: number;
    // private dayOfTheWeek: DayOfTheWeek;
    // private timeOfDay: TimeSpan /*System.TimeSpan*/;
    function LegacyAvailabilityTimeZoneTime() {
        var _this = _super.call(this) || this;
        _this.Delta = TimeSpan.Zero /*System.TimeSpan*/;
        _this.TimeOfDay = TimeSpan.Zero /*System.TimeSpan*/;
        _this.DayOrder = 0;
        _this.Month = 0;
        _this.DayOfTheWeek = DayOfTheWeek.Sunday;
        _this.Year = 0;
        return _this;
    }
    Object.defineProperty(LegacyAvailabilityTimeZoneTime.prototype, "HasTransitionTime", {
        get: function () { return this.Month >= 1 && this.Month <= 12; },
        enumerable: true,
        configurable: true
    });
    LegacyAvailabilityTimeZoneTime.prototype.ToTransitionTime = function () {
        if (this.Year == 0) {
            return TimeZoneInfo.TransitionTime.CreateFloatingDateRule(new DateTime(DateTime.MinValue.Year, DateTime.MinValue.Month, DateTime.MinValue.Day, this.TimeOfDay.Hours, this.TimeOfDay.Minutes, this.TimeOfDay.Seconds), this.Month, this.DayOrder, EwsUtilities.EwsToSystemDayOfWeek(this.DayOfTheWeek));
        }
        else {
            return TimeZoneInfo.TransitionTime.CreateFixedDateRule(new DateTime(this.TimeOfDay.TotalMilliseconds), this.Month, this.DayOrder);
        }
    };
    LegacyAvailabilityTimeZoneTime.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.Bias:
                    this.Delta = TimeSpan.FromMinutes(Number(jsonProperty[key]));
                    break;
                case XmlElementNames.Time:
                    this.TimeOfDay = new TimeSpan(jsonProperty[key]); // momentjs taks care of parsing TimeSpan.Parse(jsonProperty[key]);
                    break;
                case XmlElementNames.DayOrder:
                    this.DayOrder = Number(jsonProperty[key]);
                    break;
                case XmlElementNames.DayOfWeek:
                    this.DayOfTheWeek = DayOfTheWeek[jsonProperty[key]];
                    break;
                case XmlElementNames.Month:
                    this.Month = Number(jsonProperty[key]);
                    break;
                case XmlElementNames.Year:
                    this.Year = Number(jsonProperty[key]);
                    break;
                default:
                    break;
            }
        }
    };
    /**@internal */
    LegacyAvailabilityTimeZoneTime.prototype.WriteElementsToXml = function (writer) {
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Bias, this.Delta.TotalMinutes);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Time, EwsUtilities.TimeSpanToXSTime(this.TimeOfDay));
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DayOrder, this.DayOrder);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Month, this.Month);
        // Only write DayOfWeek if this is a recurring time change
        if (this.Year == 0) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DayOfWeek, DayOfTheWeek[this.DayOfTheWeek]); // needs to be string
        }
        // Only emit year if it's non zero, otherwise AS returns "Request is invalid"
        if (this.Year != 0) {
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Year, this.Year);
        }
    };
    return LegacyAvailabilityTimeZoneTime;
}(ComplexProperty));
exports.LegacyAvailabilityTimeZoneTime = LegacyAvailabilityTimeZoneTime;
/**
 * Represents an Out of Office response.
 */
var OofReply = (function () {
    function OofReply(message) {
        if (message === void 0) { message = null; }
        this.culture = ''; //todo: implement CultureInfo //  CultureInfo.CurrentCulture.Name;
        this.message = null;
        this.message = message;
    }
    Object.defineProperty(OofReply.prototype, "Culture", {
        /**
         * Gets or sets the culture of the reply.
         */
        get: function () {
            return this.culture;
        },
        set: function (value) {
            this.culture = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OofReply.prototype, "Message", {
        /**
         * Gets or sets the culture of the reply.
         */
        get: function () {
            return this.message;
        },
        set: function (value) {
            this.message = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads from xmlJsObject.
     *
     * @param   {any}   jsObject   The xmlJsObject object.
     * @param   {ExchangeService}   service      The service.
     */
    OofReply.prototype.LoadFromXmlJsObject = function (jsonObject, service) {
        if (jsonObject["xml:lang"]) {
            this.culture = jsonObject["xml:lang"];
        }
        this.message = jsonObject[XmlElementNames.Message];
    };
    /**
     * Obtains a string representation of the reply.
     *
     * @return  {string}      A string containing the reply message.
     */
    OofReply.prototype.ToString = function () { return this.Message; };
    OofReply.prototype.toString = function () { return this.Message; };
    /**
     * @internal Writes an empty OofReply to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    OofReply.WriteEmptyReplyToXml = function (writer, xmlElementName) {
        writer.WriteStartElement(XmlNamespace.Types, xmlElementName);
        writer.WriteEndElement(); // xmlElementName
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    OofReply.prototype.WriteToXml = function (writer, xmlElementName) {
        writer.WriteStartElement(XmlNamespace.Types, xmlElementName);
        if (this.Culture != null) {
            writer.WriteAttributeValue("xml", "lang", this.Culture);
        }
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Message, this.Message);
        writer.WriteEndElement(); // xmlElementName
    };
    return OofReply;
}());
exports.OofReply = OofReply;
/**
 * Represents a time period.
 *
 * @sealed
 */
var TimeWindow = (function () {
    function TimeWindow(startTime, endTime) {
        if (startTime === void 0) { startTime = null; }
        if (endTime === void 0) { endTime = null; }
        this.StartTime = startTime;
        this.EndTime = endTime;
    }
    Object.defineProperty(TimeWindow.prototype, "Duration", {
        /**
         * @internal Gets the duration.
         */
        get: function () {
            return this.StartTime.Difference(this.EndTime);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    TimeWindow.prototype.LoadFromXmlJsObject = function (jsonObject, service) {
        this.StartTime = service.ConvertUniversalDateTimeStringToLocalDateTime(jsonObject[XmlElementNames.StartTime]);
        this.EndTime = service.ConvertUniversalDateTimeStringToLocalDateTime(jsonObject[XmlElementNames.EndTime]);
    };
    /**
     * Validates this instance.
     *
     * ISelfValidate.Validate
     */
    TimeWindow.prototype.Validate = function () {
        if (this.StartTime.CompareTo(this.EndTime) >= 0) {
            throw new ArgumentException(Strings.TimeWindowStartTimeMustBeGreaterThanEndTime);
        }
    };
    /**
     * Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {string}                xmlElementName   Name of the XML element.
     * @param   {any}                   startTime        The start time.
     * @param   {any}                   endTime          The end time.
     */
    TimeWindow.WriteToXml = function (writer, xmlElementName, startTime, endTime) {
        writer.WriteStartElement(XmlNamespace.Types, xmlElementName);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.StartTime, startTime);
        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.EndTime, endTime);
        writer.WriteEndElement(); // xmlElementName
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    TimeWindow.prototype.WriteToXml = function (writer, xmlElementName) {
        TimeWindow.WriteToXml(writer, xmlElementName, this.StartTime, this.EndTime);
    };
    /**
     * @internal Writes to XML without scoping the dates and without emitting times.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    TimeWindow.prototype.WriteToXmlUnscopedDatesOnly = function (writer, xmlElementName) {
        var DateOnlyFormat = "YYYY-MM-DDT00:00:00";
        TimeWindow.WriteToXml(writer, xmlElementName, this.StartTime.Format(DateOnlyFormat), // CultureInfo.InvariantCulture),
        this.EndTime.Format(DateOnlyFormat) // CultureInfo.InvariantCulture));
        );
    };
    return TimeWindow;
}());
exports.TimeWindow = TimeWindow;
/**
 * Represents the base class for Id expressed in a specific format.
 */
var AlternateIdBase = (function () {
    function AlternateIdBase(format) {
        if (format === void 0) { format = IdFormat.EwsLegacyId; }
        this.Format = format;
    }
    /**
     * @internal Validate this instance.
     */
    AlternateIdBase.prototype.InternalValidate = function () { };
    /**
     * @internal Loads the attributes from Xml JsObject.
     *
     * @param   {any}   responseObject   The response object.
     */
    AlternateIdBase.prototype.LoadAttributesFromXmlJsObject = function (responseObject) {
        this.Format = IdFormat[responseObject[XmlAttributeNames.Format]];
    };
    /**
     * Validate this instance.
     * ISelfValidate.Validate
     *
     */
    AlternateIdBase.prototype.Validate = function () {
        this.InternalValidate();
    };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    AlternateIdBase.prototype.WriteAttributesToXml = function (writer) {
        writer.WriteAttributeValue(XmlAttributeNames.Format, IdFormat[this.Format]);
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    AlternateIdBase.prototype.WriteToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Types, this.GetXmlElementName());
        this.WriteAttributesToXml(writer);
        writer.WriteEndElement(); // this.GetXmlElementName()
    };
    return AlternateIdBase;
}());
exports.AlternateIdBase = AlternateIdBase;
/**
 * Represents an Id expressed in a specific format.
 */
var AlternateId = (function (_super) {
    __extends(AlternateId, _super);
    function AlternateId(format, id, mailbox, isArchive) {
        if (format === void 0) { format = IdFormat.EwsLegacyId; }
        if (id === void 0) { id = null; }
        if (mailbox === void 0) { mailbox = null; }
        if (isArchive === void 0) { isArchive = false; }
        var _this = _super.call(this, format) || this;
        /**
         * Gets or sets the Id.
         */
        _this.UniqueId = null;
        /**
         * Gets or sets the mailbox to which the Id belongs.
         */
        _this.Mailbox = null;
        /**
         * Gets or sets the type (primary or archive) mailbox to which the Id belongs.
         */
        _this.IsArchive = false;
        _this.UniqueId = id;
        _this.Mailbox = mailbox;
        _this.IsArchive = isArchive;
        return _this;
    }
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    AlternateId.prototype.GetXmlElementName = function () {
        return XmlElementNames.AlternateId;
    };
    /**
     * @internal Validate this instance.
     */
    AlternateId.prototype.InternalValidate = function () {
        EwsUtilities.ValidateParam(this.Mailbox, "mailbox");
    };
    /**
     * @internal Loads the attributes from Xml JsObject.
     *
     * @param   {any}   responseObject   The response object.
     */
    AlternateId.prototype.LoadAttributesFromXmlJsObject = function (responseObject) {
        _super.prototype.LoadAttributesFromXmlJsObject.call(this, responseObject);
        this.UniqueId = responseObject[XmlAttributeNames.Id];
        this.Mailbox = responseObject[XmlAttributeNames.Mailbox];
        if (responseObject[XmlAttributeNames.IsArchive]) {
            this.IsArchive = Convert.toBool(responseObject[XmlAttributeNames.IsArchive]);
        }
    };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    AlternateId.prototype.WriteAttributesToXml = function (writer) {
        _super.prototype.WriteAttributesToXml.call(this, writer);
        writer.WriteAttributeValue(XmlAttributeNames.Id, this.UniqueId);
        writer.WriteAttributeValue(XmlAttributeNames.Mailbox, this.Mailbox);
        // this is optional attribute will default false so we will write
        // it only if it is true
        if (this.IsArchive) {
            writer.WriteAttributeValue(XmlAttributeNames.IsArchive, true);
        }
    };
    /**
     * @internal Name of schema type used for AlternateId.
     */
    AlternateId.SchemaTypeName = "AlternateIdType";
    return AlternateId;
}(AlternateIdBase));
exports.AlternateId = AlternateId;
/**
 * Represents the Id of a public folder expressed in a specific format.
 */
var AlternatePublicFolderId = (function (_super) {
    __extends(AlternatePublicFolderId, _super);
    function AlternatePublicFolderId(format, folderId) {
        if (format === void 0) { format = IdFormat.EwsLegacyId; }
        if (folderId === void 0) { folderId = null; }
        var _this = _super.call(this, format) || this;
        /**
         * The Id of the public folder.
         */
        _this.FolderId = null;
        _this.FolderId = folderId;
        return _this;
    }
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    AlternatePublicFolderId.prototype.GetXmlElementName = function () {
        return XmlElementNames.AlternatePublicFolderId;
    };
    /**
     * @internal Loads the attributes from Xml JsObject.
     *
     * @param   {any}   responseObject   The response object.
     */
    AlternatePublicFolderId.prototype.LoadAttributesFromXmlJsObject = function (responseObject) {
        _super.prototype.LoadAttributesFromXmlJsObject.call(this, responseObject);
        this.FolderId = responseObject[XmlAttributeNames.FolderId];
    };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    AlternatePublicFolderId.prototype.WriteAttributesToXml = function (writer) {
        _super.prototype.WriteAttributesToXml.call(this, writer);
        writer.WriteAttributeValue(XmlAttributeNames.FolderId, this.FolderId);
    };
    /**
     * @internal Name of schema type used for AlternatePublicFolderId element.
     */
    AlternatePublicFolderId.SchemaTypeName = "AlternatePublicFolderIdType";
    return AlternatePublicFolderId;
}(AlternateIdBase));
exports.AlternatePublicFolderId = AlternatePublicFolderId;
/**
 * Represents the Id of a public folder item expressed in a specific format.
 */
var AlternatePublicFolderItemId = (function (_super) {
    __extends(AlternatePublicFolderItemId, _super);
    function AlternatePublicFolderItemId(format, folderId, itemId) {
        if (format === void 0) { format = IdFormat.EwsLegacyId; }
        if (folderId === void 0) { folderId = null; }
        if (itemId === void 0) { itemId = null; }
        var _this = _super.call(this, format, folderId) || this;
        _this.itemId = itemId;
        return _this;
    }
    Object.defineProperty(AlternatePublicFolderItemId.prototype, "ItemId", {
        /**
         * The Id of the public folder item.
         */
        get: function () {
            return this.itemId;
        },
        set: function (v) {
            this.itemId = v;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    AlternatePublicFolderItemId.prototype.GetXmlElementName = function () {
        return XmlElementNames.AlternatePublicFolderItemId;
    };
    /**
     * @internal Loads the attributes from Xml JsObject.
     *
     * @param   {any}   responseObject   The response object.
     */
    AlternatePublicFolderItemId.prototype.LoadAttributesFromXmlJsObject = function (responseObject) {
        _super.prototype.LoadAttributesFromXmlJsObject.call(this, responseObject);
        this.itemId = responseObject[XmlAttributeNames.ItemId];
    };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    AlternatePublicFolderItemId.prototype.WriteAttributesToXml = function (writer) {
        _super.prototype.WriteAttributesToXml.call(this, writer);
        writer.WriteAttributeValue(XmlAttributeNames.ItemId, this.ItemId);
    };
    /**
     * @internal Schema type associated with AlternatePublicFolderItemId.
     */
    AlternatePublicFolderItemId.SchemaTypeName = "AlternatePublicFolderItemIdType";
    return AlternatePublicFolderItemId;
}(AlternatePublicFolderId));
exports.AlternatePublicFolderItemId = AlternatePublicFolderItemId;
/**
 * Represents the results of an action performed on a calendar item or meeting message, such as accepting, tentatively accepting or declining a meeting request.
 *
 * @sealed
 */
var CalendarActionResults = (function () {
    /**
     * @internal Initializes a new instance of the **CalendarActionResults** class.
     *
     * @param   {Item[]}   items   Collection of items that were created or modified as a result of a calendar action.
     */
    function CalendarActionResults(items) {
        this.appointment = EwsUtilities.FindFirstItemOfType(items, TypeContainer.Appointment);
        this.meetingRequest = EwsUtilities.FindFirstItemOfType(items, TypeContainer.MeetingRequest);
        this.meetingResponse = EwsUtilities.FindFirstItemOfType(items, TypeContainer.MeetingResponse);
        this.meetingCancellation = EwsUtilities.FindFirstItemOfType(items, TypeContainer.MeetingCancellation);
    }
    Object.defineProperty(CalendarActionResults.prototype, "Appointment", {
        /**
         * Gets the meeting that was accepted, tentatively accepted or declined.
         *
         * Remark - When a meeting is accepted or tentatively accepted via an Appointment object,
         * EWS recreates the meeting, and Appointment represents that new version.
         * When a meeting is accepted or tentatively accepted via a MeetingRequest object,
         * EWS creates an associated meeting in the attendee's calendar and Appointment
         * represents that meeting.
         * When declining a meeting via an Appointment object, EWS moves the appointment to
         * the attendee's Deleted Items folder and Appointment represents that moved copy.
         * When declining a meeting via a MeetingRequest object, EWS creates an associated
         * meeting in the attendee's Deleted Items folder, and Appointment represents that
         * meeting.
         * When a meeting is declined via either an Appointment or a MeetingRequest object
         * from the Deleted Items folder, Appointment is null.
         */
        get: function () { return this.appointment; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarActionResults.prototype, "MeetingRequest", {
        /**
         * Gets the meeting request that was moved to the Deleted Items folder as a result of an attendee accepting, tentatively accepting or declining a meeting request. If the meeting request is accepted, tentatively accepted or declined from the Deleted Items folder, it is permanently deleted and MeetingRequest is null.
         *
         */
        get: function () { return this.meetingRequest; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarActionResults.prototype, "MeetingResponse", {
        /**
         * Gets the copy of the response that is sent to the organizer of a meeting when the meeting is accepted, tentatively accepted or declined by an attendee. MeetingResponse is null if the attendee chose not to send a response.
         *
         */
        get: function () { return this.meetingResponse; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarActionResults.prototype, "MeetingCancellation", {
        /**
         * Gets the copy of the meeting cancellation message sent by the organizer to the attendees of a meeting when the meeting is cancelled.
         *
         */
        get: function () { return this.meetingCancellation; },
        enumerable: true,
        configurable: true
    });
    return CalendarActionResults;
}());
exports.CalendarActionResults = CalendarActionResults;
/**
 * @internal ConversationAction class that represents ConversationActionType in the request XML.
 * This class really is meant for representing single ConversationAction that needs to be taken on a conversation.
 */
var ConversationAction = (function () {
    function ConversationAction() {
        /**
         * @internal Gets or sets conversation action
         */
        this.Action = ConversationActionType.AlwaysCategorize;
        /**
         * @internal Gets or sets conversation id
         */
        this.ConversationId = null;
        /**
         * @internal Gets or sets ProcessRightAway
         */
        this.ProcessRightAway = false;
        /**
         * @internal Gets or set conversation categories for Always Categorize action
         */
        this.Categories = null;
        /**
         * @internal Gets or sets Enable Always Delete value for Always Delete action
         */
        this.EnableAlwaysDelete = false;
        /**
         * @internal Gets or sets the IsRead state. :Nullable
         */
        this.IsRead = null; //Nullable
        /**
         * @internal Gets or sets the SuppressReadReceipts flag.
         */
        this.SuppressReadReceipts = null; //Nullable
        /**
         * @internal Gets or sets the Deletion mode.
         */
        this.DeleteType = null; //Nullable
        /**
         * @internal Gets or sets the flag.
         */
        this.Flag = null;
        /**
         * @internal ConversationLastSyncTime is used in one time action to determine the items on which to take the action.
         */
        this.ConversationLastSyncTime = null; //Nullable
        /**
         * @internal Gets or sets folder id ContextFolder
         */
        this.ContextFolderId = null;
        /**
         * @internal Gets or sets folder id for Move action
         */
        this.DestinationFolderId = null;
        /**
         * @internal Gets or sets the retention policy type.
         */
        this.RetentionPolicyType = null; //Nullable
        /**
         * @internal Gets or sets the retention policy tag id.
         */
        this.RetentionPolicyTagId = null; //Nullable
    }
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    ConversationAction.prototype.GetXmlElementName = function () {
        return XmlElementNames.ApplyConversationAction;
    };
    /**
     * @internal Validate request.
     */
    ConversationAction.prototype.Validate = function () {
        EwsUtilities.ValidateParam(this.ConversationId, "conversationId");
    };
    /**
     * @internal Writes XML elements.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ConversationAction.prototype.WriteElementsToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.ConversationAction);
        try {
            var actionValue = StringHelper.Empty;
            switch (this.Action) {
                case ConversationActionType.AlwaysCategorize:
                    actionValue = XmlElementNames.AlwaysCategorize;
                    break;
                case ConversationActionType.AlwaysDelete:
                    actionValue = XmlElementNames.AlwaysDelete;
                    break;
                case ConversationActionType.AlwaysMove:
                    actionValue = XmlElementNames.AlwaysMove;
                    break;
                case ConversationActionType.Delete:
                    actionValue = XmlElementNames.Delete;
                    break;
                case ConversationActionType.Copy:
                    actionValue = XmlElementNames.Copy;
                    break;
                case ConversationActionType.Move:
                    actionValue = XmlElementNames.Move;
                    break;
                case ConversationActionType.SetReadState:
                    actionValue = XmlElementNames.SetReadState;
                    break;
                case ConversationActionType.SetRetentionPolicy:
                    actionValue = XmlElementNames.SetRetentionPolicy;
                    break;
                case ConversationActionType.Flag:
                    actionValue = XmlElementNames.Flag;
                    break;
                default:
                    throw new ArgumentException("ConversationAction");
            }
            // Emit the action element
            writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Action, actionValue);
            // Emit the conversation id element
            this.ConversationId.WriteToXml(writer, XmlElementNames.ConversationId, XmlNamespace.Types);
            if (this.Action == ConversationActionType.AlwaysCategorize ||
                this.Action == ConversationActionType.AlwaysDelete ||
                this.Action == ConversationActionType.AlwaysMove) {
                // Emit the ProcessRightAway element
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ProcessRightAway, EwsUtilities.BoolToXSBool(this.ProcessRightAway));
            }
            if (this.Action == ConversationActionType.AlwaysCategorize) {
                // Emit the categories element
                if (this.Categories != null && this.Categories.Count > 0) {
                    this.Categories.WriteToXml(writer, XmlElementNames.Categories, XmlNamespace.Types);
                }
            }
            else if (this.Action == ConversationActionType.AlwaysDelete) {
                // Emit the EnableAlwaysDelete element
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.EnableAlwaysDelete, EwsUtilities.BoolToXSBool(this.EnableAlwaysDelete));
            }
            else if (this.Action == ConversationActionType.AlwaysMove) {
                // Emit the Move Folder Id
                if (this.DestinationFolderId != null) {
                    writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.DestinationFolderId);
                    this.DestinationFolderId.WriteToXml(writer);
                    writer.WriteEndElement();
                }
            }
            else {
                if (this.ContextFolderId != null) {
                    writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.ContextFolderId);
                    this.ContextFolderId.WriteToXml(writer);
                    writer.WriteEndElement();
                }
                if (this.ConversationLastSyncTime) {
                    writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.ConversationLastSyncTime, this.ConversationLastSyncTime);
                }
                if (this.Action == ConversationActionType.Copy) {
                    EwsLogging.Assert(this.DestinationFolderId != null, "ApplyconversationActionRequest", "DestinationFolderId should be set when performing copy action");
                    writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.DestinationFolderId);
                    this.DestinationFolderId.WriteToXml(writer);
                    writer.WriteEndElement();
                }
                else if (this.Action == ConversationActionType.Move) {
                    EwsLogging.Assert(this.DestinationFolderId != null, "ApplyconversationActionRequest", "DestinationFolderId should be set when performing move action");
                    writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.DestinationFolderId);
                    this.DestinationFolderId.WriteToXml(writer);
                    writer.WriteEndElement();
                }
                else if (this.Action == ConversationActionType.Delete) {
                    EwsLogging.Assert(this.DeleteType != null, "ApplyconversationActionRequest", "DeleteType should be specified when deleting a conversation.");
                    writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.DeleteType, DeleteMode[this.DeleteType]);
                }
                else if (this.Action == ConversationActionType.SetReadState) {
                    EwsLogging.Assert(this.IsRead != null, "ApplyconversationActionRequest", "IsRead should be specified when marking/unmarking a conversation as read.");
                    writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.IsRead, this.IsRead);
                    if (this.SuppressReadReceipts) {
                        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.SuppressReadReceipts, this.SuppressReadReceipts);
                    }
                }
                else if (this.Action == ConversationActionType.SetRetentionPolicy) {
                    EwsLogging.Assert(this.RetentionPolicyType != null, "ApplyconversationActionRequest", "RetentionPolicyType should be specified when setting a retention policy on a conversation.");
                    writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.RetentionPolicyType, RetentionType[this.RetentionPolicyType]);
                    if (this.RetentionPolicyTagId) {
                        writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.RetentionPolicyTagId, this.RetentionPolicyTagId.ToString());
                    }
                }
                else if (this.Action == ConversationActionType.Flag) {
                    EwsLogging.Assert(this.Flag != null, "ApplyconversationActionRequest", "Flag should be specified when flagging conversation items.");
                    writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Flag);
                    this.Flag.WriteElementsToXml(writer);
                    writer.WriteEndElement();
                }
            }
        }
        finally {
            writer.WriteEndElement();
        }
    };
    return ConversationAction;
}());
exports.ConversationAction = ConversationAction;
/**
 * Represents the results of a GetDelegates operation.
 *
 * @sealed
 */
var DelegateInformation = (function () {
    /**
     * @internal Initializes a **DelegateInformation** object
     *
     * @param   {DelegateUserResponse[]}   		delegateUserResponses         List of DelegateUserResponses from a GetDelegates request
     * @param   {MeetingRequestsDeliveryScope}	meetingReqestsDeliveryScope   MeetingRequestsDeliveryScope from a GetDelegates request.
     */
    function DelegateInformation(delegateUserResponses, meetingReqestsDeliveryScope) {
        this.meetingReqestsDeliveryScope = MeetingRequestsDeliveryScope.DelegatesOnly;
        this.delegateUserResponses = delegateUserResponses || [];
        this.meetingReqestsDeliveryScope = meetingReqestsDeliveryScope;
    }
    Object.defineProperty(DelegateInformation.prototype, "DelegateUserResponses", {
        /**
         * Gets a list of responses for each of the delegate users concerned by the operation.
         */
        get: function () {
            return this.delegateUserResponses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DelegateInformation.prototype, "MeetingRequestsDeliveryScope", {
        /**
         * Gets a value indicating if and how meeting requests are delivered to delegates.
         */
        get: function () {
            return this.meetingReqestsDeliveryScope;
        },
        enumerable: true,
        configurable: true
    });
    return DelegateInformation;
}());
exports.DelegateInformation = DelegateInformation;
//class CreateServiceObjectWithAttachmentParam extends System.MulticastDelegate {
//    BeginInvoke(itemAttachment: ItemAttachment, isNew: boolean, callback: System.AsyncCallback, object: any): System.IAsyncResult{ throw new Error("DelegateTypes.ts - BeginInvoke : Not implemented.");}
//    EndInvoke(result: System.IAsyncResult): any{ throw new Error("DelegateTypes.ts - EndInvoke : Not implemented.");}
//    Invoke(itemAttachment: ItemAttachment, isNew: boolean): any{ throw new Error("DelegateTypes.ts - Invoke : Not implemented.");}
//}
//class CreateServiceObjectWithServiceParam extends System.MulticastDelegate {
//    BeginInvoke(srv: ExchangeService, callback: System.AsyncCallback, object: any): System.IAsyncResult{ throw new Error("DelegateTypes.ts - BeginInvoke : Not implemented.");}
//    EndInvoke(result: System.IAsyncResult): any{ throw new Error("DelegateTypes.ts - EndInvoke : Not implemented.");}
//    Invoke(srv: ExchangeService): any{ throw new Error("DelegateTypes.ts - Invoke : Not implemented.");}
//}
var EwsTraceListener = (function () {
    function EwsTraceListener() {
    }
    EwsTraceListener.prototype.Trace = function (traceType, traceMessage) { throw new Error("EwsTraceListener.ts - Trace : Not implemented."); };
    return EwsTraceListener;
}());
exports.EwsTraceListener = EwsTraceListener;
/**
 * Represents the results of an ExpandGroup operation.
 *
 * @sealed
 */
var ExpandGroupResults = (function () {
    /**
     * @internal Initializes a new instance of the **ExpandGroupResults** class.
     */
    function ExpandGroupResults() {
        /**
         * True, if all members are returned.
         * EWS always returns true on ExpandDL, i.e. all members are returned.
         */
        this.includesAllMembers = false;
        /**
         * DL members.
         */
        this.members = [];
    }
    Object.defineProperty(ExpandGroupResults.prototype, "Count", {
        /**
         * Gets the number of members that were returned by the ExpandGroup operation.
         * Count might be less than the total number of members in the group, in which case the value of the IncludesAllMembers is false.
         */
        get: function () {
            return this.members.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExpandGroupResults.prototype, "IncludesAllMembers", {
        /**
         * Gets a value indicating whether all the members of the group have been returned by ExpandGroup.
         */
        get: function () {
            return this.includesAllMembers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExpandGroupResults.prototype, "Members", {
        /**
         * Gets the members of the expanded group.
         */
        get: function () {
            return this.members;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *  Returns an enumerator that iterates through the collection. this case this.members
     */
    ExpandGroupResults.prototype.GetEnumerator = function () {
        return this.members;
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    ExpandGroupResults.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        var dlResponse = jsObject[XmlElementNames.DLExpansion];
        var mailboxes = EwsServiceJsonReader.ReadAsArray(dlResponse, XmlElementNames.Mailbox);
        this.includesAllMembers = Convert.toBool(dlResponse[XmlAttributeNames.IncludesLastItemInRange]);
        var mailboxCount = Convert.toNumber(dlResponse[XmlAttributeNames.TotalItemsInView]);
        for (var _a = 0, mailboxes_1 = mailboxes; _a < mailboxes_1.length; _a++) {
            var mailbox = mailboxes_1[_a];
            var emailAddress = new EmailAddress();
            emailAddress.LoadFromXmlJsObject(mailbox, service);
            this.members.push(emailAddress);
        }
    };
    return ExpandGroupResults;
}());
exports.ExpandGroupResults = ExpandGroupResults;
/**
 * @internal Represents a list a abstracted folder Ids.
 */
var FolderIdWrapperList = (function () {
    function FolderIdWrapperList() {
        /**
         * List of AbstractFolderIdWrapper.
         */
        this.ids = [];
    }
    Object.defineProperty(FolderIdWrapperList.prototype, "Count", {
        /**
         * Gets the id count.
         *
         * @value   The count.
         */
        get: function () {
            return this.ids.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets the **AbstractFolderIdWrapper** at the specified index.
     *
     * @param   {}   index   the index
     */
    FolderIdWrapperList.prototype._getItem = function (index) {
        return this.ids[index];
    };
    FolderIdWrapperList.prototype.Add = function (folderOrId) {
        if (folderOrId instanceof Folder)
            this.ids.push(new FolderWrapper(folderOrId));
        else if (folderOrId instanceof FolderId)
            this.ids.push(new FolderIdWrapper(folderOrId));
        else
            throw new Error("FolderIdWrapperList.ts - Add - should not be seeing this.");
    };
    FolderIdWrapperList.prototype.AddRange = function (foldersOrIds) {
        if (foldersOrIds != null) {
            for (var _a = 0, foldersOrIds_1 = foldersOrIds; _a < foldersOrIds_1.length; _a++) {
                var folderOrId = foldersOrIds_1[_a];
                this.Add(folderOrId);
            }
        }
    };
    /**
     *  Returns an enumerator that iterates through the collection. this case this.ids
     */
    FolderIdWrapperList.prototype.GetEnumerator = function () {
        return this.ids;
    };
    /**
     * @internal Validates list of folderIds against a specified request version.
     *
     * @param   {ExchangeVersion}   version   The version.
     */
    FolderIdWrapperList.prototype.Validate = function (version) {
        for (var _a = 0, _b = this.ids; _a < _b.length; _a++) {
            var folderIdWrapper = _b[_a];
            //var folderIdWrapper: AbstractFolderIdWrapper = item;
            folderIdWrapper.Validate(version);
        }
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {XmlNamespace}          ewsNamesapce     The ews namesapce.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    FolderIdWrapperList.prototype.WriteToXml = function (writer, ewsNamesapce, xmlElementName) {
        if (this.Count > 0) {
            writer.WriteStartElement(ewsNamesapce, xmlElementName);
            for (var _a = 0, _b = this.ids; _a < _b.length; _a++) {
                var folderIdWrapper = _b[_a];
                //var folderIdWrapper: AbstractFolderIdWrapper = item;
                folderIdWrapper.WriteToXml(writer);
            }
            writer.WriteEndElement();
        }
    };
    return FolderIdWrapperList;
}());
exports.FolderIdWrapperList = FolderIdWrapperList;
//import ExchangeService = require("../Core/ExchangeService");
//			
// class HangingTraceStream extends System.IO.Stream {
//	CanRead: boolean;
//	CanSeek: boolean;
//	CanWrite: boolean;
//	Length: number;
//	Position: number;
//	private underlyingStream: any /*System.IO.Stream*/;
//	private service: ExchangeService;
//	private responseCopy: any /*System.IO.MemoryStream*/;
//	Flush(): void{ throw new Error("HangingTraceStream.ts - Flush : Not implemented.");}
//	Read(buffer: any /*System.Byte[]*/, offset: number, count: number): number{ throw new Error("HangingTraceStream.ts - Read : Not implemented.");}
//	Seek(offset: number, origin: any /*System.IO.SeekOrigin*/): number{ throw new Error("HangingTraceStream.ts - Seek : Not implemented.");}
//	SetLength(value: number): void{ throw new Error("HangingTraceStream.ts - SetLength : Not implemented.");}
//	SetResponseCopy(responseCopy: any /*System.IO.MemoryStream*/): void{ throw new Error("HangingTraceStream.ts - SetResponseCopy : Not implemented.");}
//	Write(buffer: any /*System.Byte[]*/, offset: number, count: number): void{ throw new Error("HangingTraceStream.ts - Write : Not implemented.");}
//}
//export = HangingTraceStream;
//todo: should be done
var ImpersonatedUserId = (function () {
    //private idType: ConnectingIdType;
    //private id: string;
    function ImpersonatedUserId(idType, id) {
        this.IdType = idType;
        this.Id = id;
    }
    /**@internal */
    ImpersonatedUserId.prototype.WriteToXml = function (writer) {
        if (!this.Id || this.Id === "") {
            throw new Error("Id property must be set before serialization"); // ArgumentException(Strings.IdPropertyMustBeSet);
        }
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.ExchangeImpersonation);
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.ConnectingSID);
        // For 2007 SP1, use PrimarySmtpAddress for type SmtpAddress
        var connectingIdTypeLocalName = (this.IdType == ConnectingIdType.SmtpAddress) && (writer.Service.RequestedServerVersion == ExchangeVersion.Exchange2007_SP1)
            ? XmlElementNames.PrimarySmtpAddress
            : ConnectingIdType[this.IdType];
        writer.WriteElementValue(XmlNamespace.Types, connectingIdTypeLocalName, this.Id);
        writer.WriteEndElement(); // ConnectingSID
        writer.WriteEndElement(); // ExchangeImpersonation
    };
    return ImpersonatedUserId;
}());
exports.ImpersonatedUserId = ImpersonatedUserId;
/**
 * @internal Represents a list a abstracted item Ids.
 */
var ItemIdWrapperList = (function () {
    /**
     * @internal Initializes a new instance of the **ItemIdWrapperList** class.
     */
    function ItemIdWrapperList() {
        /**
         * List of ItemIdWrapper
         */
        this.itemIds = [];
    }
    Object.defineProperty(ItemIdWrapperList.prototype, "Count", {
        /**
         * @internal Gets the count.
         *
         * @value   The count.
         */
        get: function () {
            return this.itemIds.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the *Item* at the specified index.
     *
     * @param   {number}   index   the index
     */
    ItemIdWrapperList.prototype._getItem = function (index) {
        return this.itemIds[index].GetItem();
    };
    ItemIdWrapperList.prototype.Add = function (itemOrId) {
        if (itemOrId instanceof Item)
            this.itemIds.push(new ItemWrapper(itemOrId));
        else if (itemOrId instanceof ItemId)
            this.itemIds.push(new ItemIdWrapper(itemOrId));
        else
            throw new Error("FolderIdWrapperList.ts - Add - should not be seeing this.");
    };
    ItemIdWrapperList.prototype.AddRange = function (itemsOrIds) {
        if (itemsOrIds != null) {
            for (var _a = 0, itemsOrIds_1 = itemsOrIds; _a < itemsOrIds_1.length; _a++) {
                var itemOrId = itemsOrIds_1[_a];
                this.Add(itemOrId);
            }
        }
    };
    /**
     *  Returns an enumerator that iterates through the collection. this case this.itemIds
     */
    ItemIdWrapperList.prototype.GetEnumerator = function () {
        return this.itemIds;
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {XmlNamespace}          ewsNamesapce     The ews namesapce.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    ItemIdWrapperList.prototype.WriteToXml = function (writer, ewsNamesapce, xmlElementName) {
        if (this.Count > 0) {
            writer.WriteStartElement(ewsNamesapce, xmlElementName);
            for (var _a = 0, _b = this.itemIds; _a < _b.length; _a++) {
                var itemIdWrapper = _b[_a];
                itemIdWrapper.WriteToXml(writer);
            }
            writer.WriteEndElement();
        }
    };
    return ItemIdWrapperList;
}());
exports.ItemIdWrapperList = ItemIdWrapperList;
//todo: json not implemented, should be done otherwise
var ManagementRoles = (function () {
    function ManagementRoles(userRoles, applicationRoles) {
        if (userRoles) {
            this.userRoles = userRoles;
        }
        if (applicationRoles) {
            this.applicationRoles = applicationRoles;
        }
    }
    //ToJsonObject(): Microsoft.Exchange.WebServices.Data.JsonObject { throw new Error("ManagementRoles.ts - ToJsonObject : Not implemented."); }
    /**@internal */
    ManagementRoles.prototype.WriteRolesToXml = function (writer, roles, elementName) {
        if (roles && roles.length > 0) {
            writer.WriteStartElement(XmlNamespace.Types, elementName);
            for (var _a = 0, roles_1 = roles; _a < roles_1.length; _a++) {
                var role = roles_1[_a];
                writer.WriteElementValue(XmlNamespace.Types, XmlElementNames.Role, role);
            }
            writer.WriteEndElement();
        }
    };
    /**@internal */
    ManagementRoles.prototype.WriteToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.ManagementRole);
        this.WriteRolesToXml(writer, this.userRoles, XmlElementNames.UserRoles);
        this.WriteRolesToXml(writer, this.applicationRoles, XmlElementNames.ApplicationRoles);
        writer.WriteEndElement();
    };
    return ManagementRoles;
}());
exports.ManagementRoles = ManagementRoles;
var MapiTypeConverter = (function () {
    function MapiTypeConverter() {
    }
    Object.defineProperty(MapiTypeConverter, "MapiTypeConverterMap", {
        get: function () { return MapiTypeConverter.mapiTypeConverterMap.Member; },
        enumerable: true,
        configurable: true
    });
    MapiTypeConverter.ChangeType = function (mapiType, value) {
        EwsUtilities.ValidateParam(value, "value");
        return MapiTypeConverter.MapiTypeConverterMap.get(mapiType).ChangeType(value);
    };
    MapiTypeConverter.ConvertToString = function (mapiPropType, value) {
        return (value === null || value === undefined)
            ? StringHelper.Empty
            : MapiTypeConverter.MapiTypeConverterMap.get(mapiPropType).ConvertToString(value);
    };
    MapiTypeConverter.ConvertToValue = function (mapiPropType, strings) {
        if (typeof strings === 'string') {
            return MapiTypeConverter.MapiTypeConverterMap.get(mapiPropType).ConvertToValue(strings);
        }
        else if (Array.isArray(strings)) {
            EwsUtilities.ValidateParam(strings, "strings");
            var typeConverter = MapiTypeConverter.MapiTypeConverterMap.get(mapiPropType);
            var array = []; // = Array.CreateInstance(typeConverter.Type, strings.length);
            var index = 0;
            for (var _a = 0, strings_2 = strings; _a < strings_2.length; _a++) {
                var stringValue = strings_2[_a];
                var value = typeConverter.ConvertToValueOrDefault(stringValue);
                array.push(value);
            }
            return array;
        }
        throw new ArgumentException("parameter not in correct type");
    };
    MapiTypeConverter.IsArrayType = function (mapiType) { return MapiTypeConverter.MapiTypeConverterMap.get(mapiType).IsArray; };
    MapiTypeConverter.ParseMapiIntegerValue = function (s) {
        var num = Convert.toNumber(s);
        if (num === NaN) {
            return s;
        }
        return num;
    };
    MapiTypeConverter.UtcDataTimeStyles = DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal;
    MapiTypeConverter.mapiTypeConverterMap = new LazyMember(function () {
        var map = new Dictionary(function (k) { return k.toString(); });
        map.Add(MapiPropertyType.ApplicationTime, new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.number, //double
        function (s) { return Convert.toNumber(s); }, //Parse
        function (o) { return o.toString(); } //ConvertToString 
        ));
        map.Add(MapiPropertyType.ApplicationTimeArray, new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.number, //double
        function (s) { return Convert.toNumber(s); }, //Parse
        function (o) { return o.toString(); }, //ConvertToString
        true //IsArray
        ));
        var byteConverter = new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.byteArray, //byte[]
        function (s) { return StringHelper.IsNullOrEmpty(s) ? null : Convert.FromBase64String(s); }, //Parse
        function (o) { return Convert.ToBase64String(o); } //ConvertToString
        );
        map.Add(MapiPropertyType.Binary, byteConverter);
        var byteArrayConverter = new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.byteArray, //byte[]
        function (s) { return StringHelper.IsNullOrEmpty(s) ? null : Convert.FromBase64String(s); }, //Parse
        function (o) { return Convert.ToBase64String(o); }, //ConvertToString
        true //IsArray
        );
        map.Add(MapiPropertyType.BinaryArray, byteArrayConverter);
        var boolConverter = new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.boolean, function (s) { return Convert.toBool(s); }, //Parse
        function (o) { return o.toString().toLowerCase(); } //ConvertToString
        );
        map.Add(MapiPropertyType.Boolean, boolConverter);
        var clsidConverter = new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.guid, function (s) { return new Guid(s); }, //Parse
        function (o) { return o.ToString(); } //ConvertToString
        );
        map.Add(MapiPropertyType.CLSID, clsidConverter);
        var clsidArrayConverter = new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.guid, function (s) { return new Guid(s); }, //Parse
        function (o) { return o.ToString(); }, //ConvertToString
        true //IsArray
        );
        map.Add(MapiPropertyType.CLSIDArray, clsidArrayConverter);
        map.Add(MapiPropertyType.Currency, new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.number, //Int64
        function (s) { return Convert.toNumber(s); }, //Parse
        function (o) { return o.toString(); } //ConvertToString 
        ));
        map.Add(MapiPropertyType.CurrencyArray, new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.number, //Int64
        function (s) { return Convert.toNumber(s); }, //Parse
        function (o) { return o.toString(); }, //ConvertToString
        true //IsArray
        ));
        map.Add(MapiPropertyType.Double, new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.number, //double
        function (s) { return Convert.toNumber(s); }, //Parse
        function (o) { return o.toString(); } //ConvertToString 
        ));
        map.Add(MapiPropertyType.DoubleArray, new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.number, //double
        function (s) { return Convert.toNumber(s); }, //Parse
        function (o) { return o.toString(); }, //ConvertToString
        true //IsArray
        ));
        map.Add(MapiPropertyType.Error, new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.number, //Int32
        function (s) { return Convert.toNumber(s); }, //Parse
        function (o) { return o.toString(); } //ConvertToString 
        ));
        map.Add(MapiPropertyType.Float, new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.number, //float
        function (s) { return Convert.toNumber(s); }, //Parse
        function (o) { return o.toString(); } //ConvertToString 
        ));
        map.Add(MapiPropertyType.FloatArray, new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.number, //float
        function (s) { return Convert.toNumber(s); }, //Parse
        function (o) { return o.toString(); }, //ConvertToString
        true //IsArray
        ));
        map.Add(MapiPropertyType.Integer, new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.number, //Int32
        function (s) { return MapiTypeConverter.ParseMapiIntegerValue(s); }, //Parse
        function (o) { return o.toString(); } //ConvertToString 
        ));
        map.Add(MapiPropertyType.IntegerArray, new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.number, //Int32
        function (s) { return Convert.toNumber(s); }, //Parse //ref: check if latest ews managed api code changes this to same as Integer property type above
        function (o) { return o.toString(); }, //ConvertToString
        true //IsArray
        ));
        map.Add(MapiPropertyType.Long, new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.number, //Int64
        function (s) { return Convert.toNumber(s); }, //Parse
        function (o) { return o.toString(); } //ConvertToString 
        ));
        map.Add(MapiPropertyType.LongArray, new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.number, //Int64
        function (s) { return Convert.toNumber(s); }, //Parse
        function (o) { return o.toString(); }, //ConvertToString
        true //IsArray
        ));
        var objectConverter = new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.string, function (s) { return s; }, //Parse
        function (o) { return o.toString(); } //ConvertToString
        );
        map.Add(MapiPropertyType.Object, objectConverter);
        var objectArrayConverter = new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.string, function (s) { return s; }, //Parse
        function (o) { return o.toString(); }, //ConvertToString
        true //IsArray
        );
        map.Add(MapiPropertyType.ObjectArray, objectArrayConverter);
        map.Add(MapiPropertyType.Short, new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.number, //short
        function (s) { return Convert.toNumber(s); }, //Parse
        function (o) { return o.toString(); } //ConvertToString 
        ));
        map.Add(MapiPropertyType.ShortArray, new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.number, //short
        function (s) { return Convert.toNumber(s); }, //Parse
        function (o) { return o.toString(); }, //ConvertToString
        true //IsArray
        ));
        var stringConverter = new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.string, function (s) { return s; }, //Parse
        function (o) { return o.toString(); } //ConvertToString
        );
        map.Add(MapiPropertyType.String, stringConverter);
        var stringArrayConverter = new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.string, function (s) { return s; }, //Parse
        function (o) { return o.toString(); }, //ConvertToString
        true //IsArray
        );
        map.Add(MapiPropertyType.StringArray, stringArrayConverter);
        var sysTimeConverter = new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.DateTime, function (s) { return DateTime.Parse(s); }, //Parse //ref: UtcDataTimeStyles not used, always utc, timezone not implemented
        function (o) { return EwsUtilities.DateTimeToXSDateTime(o); } //ConvertToString
        );
        map.Add(MapiPropertyType.SystemTime, sysTimeConverter);
        var sysTimeArrayConverter = new MapiTypeConverterMapEntry(MapiTypeConverterTypeSystem.DateTime, function (s) { return DateTime.Parse(s); }, //Parse //ref: UtcDataTimeStyles not used, always utc, timezone not implemented
        function (o) { return EwsUtilities.DateTimeToXSDateTime(o); }, //ConvertToString
        true //IsArray
        );
        map.Add(MapiPropertyType.SystemTimeArray, sysTimeArrayConverter);
        return map;
    });
    return MapiTypeConverter;
}());
exports.MapiTypeConverter = MapiTypeConverter;
var MapiTypeConverterMapEntry = (function () {
    function MapiTypeConverterMapEntry(type, parseMethod, convertToStringMethod, isArray) {
        if (isArray === void 0) { isArray = false; }
        this.Parse = null;
        this.ConvertToString = null;
        this.Type = MapiTypeConverterTypeSystem.boolean;
        this.IsArray = false;
        EwsLogging.Assert(MapiTypeConverterMapEntry.defaultValueMap.Member.containsKey(type), "MapiTypeConverterMapEntry ctor", StringHelper.Format("No default value entry for type {0}", MapiTypeConverterTypeSystem[type]));
        this.Type = type;
        this.ConvertToString = convertToStringMethod;
        this.Parse = parseMethod;
        this.IsArray = isArray;
    }
    Object.defineProperty(MapiTypeConverterMapEntry.prototype, "DefaultValue", {
        get: function () { return MapiTypeConverterMapEntry.defaultValueMap.Member.get(this.Type); },
        enumerable: true,
        configurable: true
    });
    MapiTypeConverterMapEntry.prototype.ChangeType = function (value) {
        var sourcetype = typeof value;
        if (sourcetype === typeof null) {
            try {
                sourcetype = value.constructor.name;
            }
            catch (ex) { }
        }
        EwsLogging.Assert(false, "MapiTypeConverterMapEntry.ChangeType", StringHelper.Format("Not Implemented to convert type from one to another. instance Type: {0}, source Type: {1}", MapiTypeConverterTypeSystem[this.Type], sourcetype));
        return value;
    };
    MapiTypeConverterMapEntry.prototype.ConvertToValue = function (stringValue) {
        try {
            return this.Parse(stringValue);
        }
        catch (ex) {
            throw new ServiceXmlDeserializationException(StringHelper.Format(Strings.ValueCannotBeConverted, stringValue, this.Type), ex);
        }
    };
    MapiTypeConverterMapEntry.prototype.ConvertToValueOrDefault = function (stringValue) { return StringHelper.IsNullOrEmpty(stringValue) ? this.DefaultValue : this.ConvertToValue(stringValue); };
    MapiTypeConverterMapEntry.prototype.ValidateValueAsArray = function (value) {
        var array = value;
        if (array == null) {
            throw new ArgumentException(StringHelper.Format(Strings.IncompatibleTypeForArray, value.GetType(), this.Type));
        }
        else if (ArrayHelper.Rank(array) != 1) {
            throw new ArgumentException(Strings.ArrayMustHaveSingleDimension);
        }
        else if (array.length == 0) {
            throw new ArgumentException(Strings.ArrayMustHaveAtLeastOneElement);
        }
        // else if (array.GetType().GetElementType() != this.Type)
        // {
        //     throw new ArgumentException(
        //         StringHelper.Format(
        //             Strings.IncompatibleTypeForArray,
        //             value.GetType(),
        //             this.Type));
        // }
    };
    MapiTypeConverterMapEntry.defaultValueMap = new LazyMember(function () {
        var map = new DictionaryWithNumericKey();
        map.Add(MapiTypeConverterTypeSystem.boolean, false);
        map.Add(MapiTypeConverterTypeSystem.byteArray, null);
        map.Add(MapiTypeConverterTypeSystem.number, 0);
        map.Add(MapiTypeConverterTypeSystem.DateTime, DateTime.MinValue);
        map.Add(MapiTypeConverterTypeSystem.guid, Guid.Empty);
        map.Add(MapiTypeConverterTypeSystem.string, null);
        return map;
    });
    return MapiTypeConverterMapEntry;
}());
exports.MapiTypeConverterMapEntry = MapiTypeConverterMapEntry;
/**
 * Represents a mobile phone.
 *
 * @sealed
 */
var MobilePhone = (function () {
    function MobilePhone(name, phoneNumber) {
        if (name === void 0) { name = null; }
        if (phoneNumber === void 0) { phoneNumber = null; }
        this.name = name;
        this.phoneNumber = phoneNumber;
    }
    Object.defineProperty(MobilePhone.prototype, "Name", {
        /**
         * Gets or sets the name associated with this mobile phone.
         */
        get: function () {
            return this.name;
        },
        set: function (value) {
            this.name = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MobilePhone.prototype, "PhoneNumber", {
        /**
         * Gets or sets the number of this mobile phone.
         */
        get: function () {
            return this.phoneNumber;
        },
        set: function (value) {
            this.phoneNumber = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Validates this instance.
     * ISelfValidate.Validate
     */
    MobilePhone.prototype.Validate = function () {
        if (StringHelper.IsNullOrEmpty(this.PhoneNumber)) {
            throw new ServiceValidationException("PhoneNumber cannot be empty.");
        }
    };
    ;
    return MobilePhone;
}());
exports.MobilePhone = MobilePhone;
var NameResolution = (function () {
    function NameResolution(owner) {
        this.owner = null;
        this.mailbox = new EmailAddress();
        this.contact = null;
        EwsLogging.Assert(owner !== null, "NameResolution.ctor", "owner is null.");
        this.owner = owner;
    }
    Object.defineProperty(NameResolution.prototype, "Mailbox", {
        get: function () {
            return this.mailbox;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NameResolution.prototype, "Contact", {
        get: function () {
            return this.contact;
        },
        enumerable: true,
        configurable: true
    });
    NameResolution.prototype.LoadFromJson = function (jsonProperty, service) { throw new Error("NameResolution.ts - LoadFromJson : Not implemented."); };
    NameResolution.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        for (var key in jsonProperty) {
            switch (key) {
                case XmlElementNames.Mailbox:
                    this.mailbox.LoadFromXmlJsObject(jsonProperty[key], service);
                    break;
                case XmlElementNames.Contact:
                    this.contact = new Contact(this.owner.Session);
                    this.contact.LoadFromXmlJsObject(jsonProperty[key], service, true, PropertySet.FirstClassProperties, false);
                    break;
                default:
                    break;
            }
        }
    };
    return NameResolution;
}());
exports.NameResolution = NameResolution;
/**
 * Represents a list of suggested name resolutions.
 *
 * @sealed
 */
var NameResolutionCollection = (function () {
    /**
     * @internal Initializes a new instance of the **NameResolutionCollection** class.
     *
     * @param   {ExchangeService}   service   The service.
     */
    function NameResolutionCollection(service) {
        this.service = null;
        this.includesAllResolutions = false;
        this.items = [];
        EwsLogging.Assert(service !== null, "NameResolutionSet.ctor", "service is null.");
        this.service = service;
    }
    Object.defineProperty(NameResolutionCollection.prototype, "Session", {
        /**
         * @internal Gets the session.
         *
         * @value   The Session.
         */
        get: function () {
            return this.service;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NameResolutionCollection.prototype, "Count", {
        /**
         * Gets the total number of elements in the list.
         */
        get: function () {
            return this.items.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NameResolutionCollection.prototype, "IncludesAllResolutions", {
        /**
         * Gets a value indicating whether more suggested resolutions are available. ResolveName only returns a maximum of 100 name resolutions.
         * When IncludesAllResolutions is false, there were more than 100 matching names on the server. To narrow the search, provide a more precise name to ResolveName.
         */
        get: function () {
            return this.includesAllResolutions;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the name resolution at the specified index.
     *
     * @param   {number}   index    The index of the name resolution to get.
     * @return  {NameResolution}    The name resolution at the speicfied index.
     */
    NameResolutionCollection.prototype._getItem = function (index) {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }
        return this.items[index];
    };
    /**
     *  Returns an enumerator that iterates through the collection. this case this.items
     */
    NameResolutionCollection.prototype.GetEnumerator = function () {
        return this.items;
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    NameResolutionCollection.prototype.LoadFromXmlJsObject = function (jsonProperty, service) {
        var totalItemsInView;
        var resolutions;
        for (var key in jsonProperty) {
            switch (key) {
                case XmlAttributeNames.TotalItemsInView:
                    totalItemsInView = Convert.toNumber(jsonProperty[key]);
                    break;
                case XmlAttributeNames.IncludesLastItemInRange:
                    this.includesAllResolutions = Convert.toBool(jsonProperty[key]);
                    break;
                // This label only exists for Json objects.  The XML doesn't have a "Resolutions"
                // element.  
                // This was necessary becaue of the lack of attributes in JSON
                //
                case XmlElementNames.Resolution:
                    resolutions = EwsServiceJsonReader.ReadAsArray(jsonProperty, key);
                    for (var _a = 0, resolutions_1 = resolutions; _a < resolutions_1.length; _a++) {
                        var resolution = resolutions_1[_a];
                        var nameResolution = new NameResolution(this);
                        nameResolution.LoadFromXmlJsObject(resolution, service);
                        this.items.push(nameResolution);
                    }
                    break;
                default:
                    break;
            }
        }
    };
    return NameResolutionCollection;
}());
exports.NameResolutionCollection = NameResolutionCollection;
//todo: should be done
/** @internal */
var PrivilegedUserId = (function () {
    //private logonType: PrivilegedLogonType;
    //private idType: ConnectingIdType;
    //private id: string;
    //private budgetType: PrivilegedUserIdBudgetType;
    function PrivilegedUserId(openType, idType, id) {
        this.LogonType = openType;
        this.IdType = idType;
        this.Id = id;
    }
    PrivilegedUserId.prototype.WriteToXml = function (writer, requestedServerVersion) {
        if (this.Id == null || this.Id === undefined || this.Id === "") {
            throw new Error("id can not be null");
        }
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.OpenAsAdminOrSystemService);
        writer.WriteAttributeString(XmlElementNames.LogonType, PrivilegedLogonType[this.LogonType]);
        if (requestedServerVersion >= ExchangeVersion.Exchange2013 && this.BudgetType) {
            writer.WriteAttributeString(XmlElementNames.BudgetType, PrivilegedUserIdBudgetType[this.BudgetType]);
        }
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.ConnectingSID);
        writer.WriteElementValue(XmlNamespace.Types, ConnectingIdType[this.IdType], this.Id);
        writer.WriteEndElement(); // ConnectingSID
        writer.WriteEndElement(); // OpenAsAdminOrSystemService
    };
    return PrivilegedUserId;
}());
exports.PrivilegedUserId = PrivilegedUserId;
/**
 * Represents SoapFault details.
 *
 * /remarks/    ews-javascript-api -> removing internal modifier to, this class will be used to pass on to error delegate of promise instead of Exceptions.
 *
 * /remarks/    ews-javascript-api -> 0.9 - Extending from Error object to avoid BlueBird errors when promise is rejected without and Error object
 * /remarks/    ews-javascript-api -> 0.9 - extending from Exception which looks like Error to BlueBird. can not extend from Error. Typescript 1.8+ can not extend builtin objects property, it swallows inheriting properties see  https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
 */
var SoapFaultDetails = (function (_super) {
    __extends(SoapFaultDetails, _super);
    function SoapFaultDetails() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.faultCode = null;
        _this.faultString = null;
        _this.faultActor = null;
        /**
         * Response code returned by EWS requests.
         * Default to InternalServerError.
         */
        _this.responseCode = ServiceError.ErrorInternalServerError;
        /**
         * This is returned by Availability requests.
         */
        _this.errorCode = ServiceError.NoError;
        /**
         * This is returned by UM requests. It's the name of the exception that was raised.
         */
        _this.exceptionType = null;
        /**
         * When a schema validation error is returned, this is the line number in the request where the error occurred.
         */
        _this.lineNumber = 0;
        /**
         * When a schema validation error is returned, this is the offset into the line of the request where the error occurred.
         */
        _this.positionWithinLine = 0;
        /**
         * Dictionary of key/value pairs from the MessageXml node in the fault. Usually empty but there are a few cases where SOAP faults may include MessageXml details (e.g. CASOverBudgetException includes BackoffTime value).
         */
        _this.errorDetails = new DictionaryWithStringKey();
        /**
         * ews-javascript-api specific: HTTP status code
         */
        _this.HttpStatusCode = 200;
        return _this;
    }
    Object.defineProperty(SoapFaultDetails.prototype, "FaultCode", {
        /**
         * @internal Gets or sets the SOAP fault code.
         *
         * @value   The SOAP fault code.
         */
        get: function () {
            return this.faultCode;
        },
        set: function (value) {
            this.faultCode = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoapFaultDetails.prototype, "FaultString", {
        /**
         * @internal Gets or sets the SOAP fault string.
         *
         * @value   The fault string.
         */
        get: function () {
            return this.faultString;
        },
        set: function (value) {
            this.faultString = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoapFaultDetails.prototype, "FaultActor", {
        /**
         * @internal Gets or sets the SOAP fault actor.
         *
         * @value   The fault actor.
         */
        get: function () {
            return this.faultActor;
        },
        set: function (value) {
            this.faultActor = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoapFaultDetails.prototype, "ResponseCode", {
        /**
         * @internal Gets or sets the response code.
         *
         * @value   The response code.
         */
        get: function () {
            return this.responseCode;
        },
        set: function (value) {
            this.responseCode = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoapFaultDetails.prototype, "Message", {
        /**
         * @internal Gets or sets the message.
         *
         * @value   The message.
         */
        get: function () {
            return this.message;
        },
        set: function (value) {
            this.message = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoapFaultDetails.prototype, "ErrorCode", {
        /**
         * @internal Gets or sets the error code.
         *
         * @value   The error code.
         */
        get: function () {
            return this.errorCode;
        },
        set: function (value) {
            this.errorCode = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoapFaultDetails.prototype, "ExceptionType", {
        /**
         * @internal Gets or sets the type of the exception.
         *
         * @value   The type of the exception.
         */
        get: function () {
            return this.exceptionType;
        },
        set: function (value) {
            this.exceptionType = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoapFaultDetails.prototype, "LineNumber", {
        /**
         * @internal Gets or sets the line number.
         *
         * @value   The line number.
         */
        get: function () {
            return this.lineNumber;
        },
        set: function (value) {
            this.lineNumber = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoapFaultDetails.prototype, "PositionWithinLine", {
        /**
         * @internal Gets or sets the position within line.
         *
         * @value   The position within line.
         */
        get: function () {
            return this.positionWithinLine;
        },
        set: function (value) {
            this.positionWithinLine = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoapFaultDetails.prototype, "ErrorDetails", {
        /**
         * @internal Gets or sets the error details dictionary.
         *
         * @value   The error details dictionary.
         */
        get: function () {
            return this.errorDetails;
        },
        set: function (value) {
            this.errorDetails = value;
        },
        enumerable: true,
        configurable: true
    });
    // /**
    //  * @private Initializes a new instance of the **SoapFaultDetails** class.
    //  */
    // // constructor() {
    // //     super();
    // // }
    /**
     * @internal Parses the soap:Fault content.
     *
     * @param   {any}   jsObject        The converted Xml JsObject.
     * @return  {SoapFaultDetails}      SOAP fault details.
     */
    SoapFaultDetails.Parse = function (jsObject) {
        var soapFaultDetails = new SoapFaultDetails();
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.SOAPFaultCodeElementName:
                    soapFaultDetails.FaultCode = jsObject[key];
                    break;
                case XmlElementNames.SOAPFaultStringElementName:
                    soapFaultDetails.FaultString = jsObject[key];
                    break;
                case XmlElementNames.SOAPFaultActorElementName:
                    soapFaultDetails.FaultActor = jsObject[key];
                    break;
                case XmlElementNames.SOAPDetailElementName:
                    soapFaultDetails.ParseDetailNode(jsObject[key]);
                    break;
                default:
                    break;
            }
        }
        return soapFaultDetails;
    };
    /**
     * Parses the detail node.
     *
     * @param   {any}   jsObject   The detail node.
     */
    SoapFaultDetails.prototype.ParseDetailNode = function (jsObject) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.EwsResponseCodeElementName:
                    // ServiceError couldn't be mapped to enum value, treat as an ISE
                    this.ResponseCode = ServiceError[jsObject[key]] || ServiceError.ErrorInternalServerError;
                    ;
                    break;
                case XmlElementNames.EwsMessageElementName:
                    this.Message = jsObject[key];
                    break;
                case XmlElementNames.EwsLineElementName:
                    this.LineNumber = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.EwsPositionElementName:
                    this.PositionWithinLine = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.EwsErrorCodeElementName:
                    // ServiceError couldn't be mapped to enum value, treat as an ISE
                    this.ErrorCode = ServiceError[jsObject[key]] || ServiceError.ErrorInternalServerError;
                    break;
                case XmlElementNames.EwsExceptionTypeElementName:
                    this.ExceptionType = jsObject[key];
                    break;
                case XmlElementNames.MessageXml:
                    this.ParseMessageXml(jsObject[key]);
                    break;
                default:
                    // Ignore any other details
                    break;
            }
        }
    };
    /**
     * Parses the message XML.
     *
     * @param   {any}   jsObject   The message Xml object.
     */
    SoapFaultDetails.prototype.ParseMessageXml = function (jsObject) {
        var _this = this;
        for (var key in jsObject) {
            if (key.indexOf("__") === 0) {
                continue;
            }
            switch (key) {
                case XmlElementNames.Value:
                    var values = EwsServiceJsonReader.ReadAsArray(jsObject, key);
                    values.forEach(function (value, index) {
                        var name = value[XmlAttributeNames.Name];
                        if (name) {
                            if (_this.ErrorDetails.containsKey(name)) {
                                name = name + " - " + (index + 1);
                            }
                            _this.errorDetails.Add(name, value[key]);
                        }
                    });
                case XmlElementNames.EwsLineElementName:
                case "LineNumber":
                    this.LineNumber = Convert.toNumber(jsObject[key]);
                    break;
                case XmlElementNames.EwsPositionElementName:
                case "LinePosition":
                    this.PositionWithinLine = Convert.toNumber(jsObject[key]);
                    break;
                default:
                    if (typeof jsObject[key] === "string") {
                        this.errorDetails.addUpdate(key, jsObject[key]);
                    }
                    EwsLogging.Assert(false, "SoapFaultDetails.ParseMessageXml", "Element: " + key + " - Please report example of this operation to ews-javascript-api repo to improve SoapFault parsing");
                    break;
            }
        }
    };
    return SoapFaultDetails;
}(Exception));
exports.SoapFaultDetails = SoapFaultDetails;
/**
 * @internal Represents a time.
 * @sealed
 */
var Time = (function () {
    function Time(minutesOrDateTimeOrHours, minutes, seconds) {
        this.hours = 0;
        this.minutes = 0;
        this.seconds = 0;
        if (arguments.length === 1) {
            if (typeof minutesOrDateTimeOrHours === 'number') {
                if (minutes < 0 || minutes >= 1440) {
                    throw new ArgumentException(Strings.MinutesMustBeBetween0And1439, "minutes");
                }
                this.Hours = minutesOrDateTimeOrHours / 60;
                this.Minutes = minutesOrDateTimeOrHours % 60;
                this.Seconds = 0;
            }
            else {
                this.Hours = minutesOrDateTimeOrHours.Hour;
                this.Minutes = minutesOrDateTimeOrHours.Minute;
                this.Seconds = minutesOrDateTimeOrHours.Second;
            }
        }
        if (arguments.length === 3) {
            this.Hours = minutesOrDateTimeOrHours;
            this.Minutes = minutes;
            this.Seconds = seconds;
        }
    }
    Object.defineProperty(Time.prototype, "Hours", {
        /**
         * @internal Gets or sets the hours.
         */
        get: function () {
            return this.hours;
        },
        set: function (value) {
            if (value >= 0 && value < 24) {
                this.hours = value;
                return;
            }
            throw new ArgumentException(Strings.HourMustBeBetween0And23);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Time.prototype, "Minutes", {
        /**
         * @internal Gets or sets the minutes.
         */
        get: function () {
            return this.minutes;
        },
        set: function (value) {
            if (value >= 0 && value < 60) {
                this.minutes = value;
                return;
            }
            throw new ArgumentException(Strings.MinuteMustBeBetween0And59);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Time.prototype, "Seconds", {
        /**
         * @internal Gets or sets the seconds.
         */
        get: function () {
            return this.seconds;
        },
        set: function (value) {
            if (value >= 0 && value < 60) {
                this.seconds = value;
                return;
            }
            throw new ArgumentException(Strings.SecondMustBeBetween0And59);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Converts the time into a number of minutes since 12:00AM.
     *
     * @return  {number}      The number of minutes since 12:00AM the time represents.
     */
    Time.prototype.ConvertToMinutes = function () {
        return this.Minutes + (this.Hours * 60);
    };
    /**
     * @internal Convert Time to XML Schema time.
     *
     * @return  {string}      String in XML Schema time format.
     */
    Time.prototype.ToXSTime = function () {
        return StringHelper.Format("{0:00}:{1:00}:{2:00}", this.Hours, this.Minutes, this.Seconds);
    };
    return Time;
}());
exports.Time = Time;
/**
 * Represents an object that can be used to store user-defined configuration settings.
 */
var UserConfiguration = (function () {
    function UserConfiguration(service, requestedProperties) {
        if (requestedProperties === void 0) { requestedProperties = UserConfiguration.PropertiesAvailableForNewObject; }
        this.parentFolderId = null;
        this.itemId = null;
        this.dictionary = null;
        this.xmlData = null; //System.Byte[]; //info: base64 encoded value
        this.binaryData = null; //System.Byte[];
        this.propertiesAvailableForAccess = UserConfigurationProperties.Id;
        this.updatedProperties = UserConfigurationProperties.Id;
        /**
         * Indicates whether changes trigger an update or create operation.
         */
        this.isNew = false;
        EwsUtilities.ValidateParam(service, "service");
        if (service.RequestedServerVersion < UserConfiguration.ObjectVersion) {
            throw new ServiceVersionException(StringHelper.Format(Strings.ObjectTypeIncompatibleWithRequestVersion, "UserConfiguration", ExchangeVersion[UserConfiguration.ObjectVersion]));
        }
        this.service = service;
        this.isNew = true;
        this.InitializeProperties(requestedProperties);
    }
    Object.defineProperty(UserConfiguration.prototype, "Name", {
        /**
         * Gets the name of the user configuration.
         * internal set
         */
        get: function () {
            return this.name;
        },
        set: function (value) {
            this.name = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserConfiguration.prototype, "ParentFolderId", {
        /**
         * Gets the Id of the folder containing the user configuration.
         * internal set
         */
        get: function () {
            return this.parentFolderId;
        },
        set: function (value) {
            this.parentFolderId = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserConfiguration.prototype, "ItemId", {
        /**
         * Gets the Id of the user configuration.
         */
        get: function () {
            return this.itemId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserConfiguration.prototype, "Dictionary", {
        /**
         * Gets the dictionary of the user configuration.
         */
        get: function () {
            return this.dictionary;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserConfiguration.prototype, "XmlData", {
        /**
         * Gets or sets the xml data of the user configuration.
         * ### base64 encoded value, not the memory stream or byte[]
         */
        get: function () {
            this.ValidatePropertyAccess(UserConfigurationProperties.XmlData);
            return this.xmlData;
        },
        set: function (value) {
            this.xmlData = value;
            this.MarkPropertyForUpdate(UserConfigurationProperties.XmlData);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserConfiguration.prototype, "BinaryData", {
        /**
         *  Gets or sets the binary data of the user configuration.
         * ### base64 encoded value, not the memory stream or byte[]
         */
        get: function () {
            this.ValidatePropertyAccess(UserConfigurationProperties.BinaryData);
            return this.binaryData;
        },
        set: function (value) {
            this.binaryData = value;
            this.MarkPropertyForUpdate(UserConfigurationProperties.BinaryData);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserConfiguration.prototype, "IsDirty", {
        /**
         * Gets a value indicating whether this user configuration has been modified.
         */
        get: function () {
            return (this.updatedProperties != UserConfiguration.NoProperties) || this.dictionary.IsDirty;
        },
        enumerable: true,
        configurable: true
    });
    UserConfiguration.Bind = function (service, name, parentFolderIdOrName, properties) {
        var parentFolderId = parentFolderIdOrName;
        if (typeof parentFolderIdOrName === 'number') {
            parentFolderId = new FolderId(parentFolderIdOrName);
        }
        return service.GetUserConfiguration(name, parentFolderId, properties).then(function (result) {
            result.isNew = false;
            return result;
        });
    };
    /**
     * Deletes the user configuration.
     * Calling this method results in a call to EWS.
     * @return  {Promise<void>}    :Promise.
     */
    UserConfiguration.prototype.Delete = function () {
        if (this.isNew) {
            exports.Promise.reject(new InvalidOperationException(Strings.DeleteInvalidForUnsavedUserConfiguration));
        }
        else {
            return this.service.DeleteUserConfiguration(this.name, this.parentFolderId);
        }
    };
    /**
     * Gets the base64 property value.
     *
     * @param   {base64String}   bytes   The bytes.
     * @return  {string}         [description]
     */
    UserConfiguration.prototype.GetBase64PropertyValue = function (bytes /*System.Byte[]*/) { throw new Error("UserConfiguration.ts - GetBase64PropertyValue : Not implemented."); };
    /**
     * Initializes properties.
     *
     * /remarks/    InitializeProperties is called in 3 cases:
     * .  Create new object:  From the UserConfiguration constructor.
     * .  Bind to existing object:  Again from the constructor.  The constructor is called eventually by the GetUserConfiguration request.
     * .  Refresh properties:  From the Load method.
     *
     * @param   {UserConfigurationProperties}   requestedProperties   The properties requested for this UserConfiguration.
     */
    UserConfiguration.prototype.InitializeProperties = function (requestedProperties) {
        this.itemId = null;
        this.dictionary = new UserConfigurationDictionary();
        this.xmlData = null;
        this.binaryData = null;
        this.propertiesAvailableForAccess = requestedProperties;
        this.ResetIsDirty();
    };
    /**
     * Determines whether the specified property was updated.
     *
     * @param   {UserConfigurationProperties}   property   property to evaluate.
     * @return  {boolean}                       Boolean indicating whether to send the property Xml.
     */
    UserConfiguration.prototype.IsPropertyUpdated = function (property) {
        var isPropertyDirty = false;
        var isPropertyEmpty = false;
        switch (property) {
            case UserConfigurationProperties.Dictionary:
                isPropertyDirty = this.Dictionary.IsDirty;
                isPropertyEmpty = this.Dictionary.Count == 0;
                break;
            case UserConfigurationProperties.XmlData:
                isPropertyDirty = (property & this.updatedProperties) == property;
                isPropertyEmpty = (this.xmlData == null) || (this.xmlData.length == 0);
                break;
            case UserConfigurationProperties.BinaryData:
                isPropertyDirty = (property & this.updatedProperties) == property;
                isPropertyEmpty = (this.binaryData == null) || (this.binaryData.length == 0);
                break;
            default:
                EwsLogging.Assert(false, "UserConfiguration.IsPropertyUpdated", "property not supported: " + EnumHelper.ToString(UserConfigurationProperties, property));
                break;
        }
        // Consider the property updated, if it's been modified, and either 
        //    . there's a value or 
        //    . there's no value but the operation is update.
        return isPropertyDirty && ((!isPropertyEmpty) || (!this.isNew));
    };
    /**
     * Loads the specified properties on the user configuration.
     * Calling this method results in a call to EWS.
     * @return  {Promise<void>}    :Promise.
     */
    UserConfiguration.prototype.Load = function (properties) {
        this.InitializeProperties(properties);
        return this.service.LoadPropertiesForUserConfiguration(this, properties);
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    UserConfiguration.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            switch (key) {
                case XmlElementNames.UserConfigurationName:
                    var userConfigName = jsObject[key];
                    var responseName = userConfigName[XmlAttributeNames.Name];
                    EwsLogging.Assert(StringHelper.Compare(this.name, responseName, /** StringComparison.Ordinal*/ false) == 0, "UserConfiguration.LoadFromXmlJsObject", "UserConfigurationName does not match: Expected: " + this.name + " Name in response: " + responseName);
                    break;
                case XmlElementNames.ItemId:
                    this.itemId = new ItemId();
                    this.itemId.LoadFromXmlJsObject(jsObject[key], service);
                    break;
                case XmlElementNames.Dictionary:
                    (this.dictionary).CreateFromXMLJsObjectCollection(jsObject[key], service);
                    break;
                case XmlElementNames.XmlData:
                    this.xmlData = jsObject[key]; //Convert.FromBase64String(jsObject.ReadAsString(key)); //info: no need to convert, using base64 as is
                    break;
                case XmlElementNames.BinaryData:
                    this.binaryData = jsObject[key]; //Convert.FromBase64String(jsObject.ReadAsString(key)); //info: no need to convert, using base64 as is
                    break;
                default:
                    break;
            }
        }
    };
    /**
     * Adds the passed property to updatedProperties.
     *
     * @param   {UserConfigurationProperties}   property   Property to update.
     */
    UserConfiguration.prototype.MarkPropertyForUpdate = function (property) {
        this.updatedProperties |= property;
        this.propertiesAvailableForAccess |= property;
    };
    /**
     * Resets flags to indicate that properties haven't been modified.
     */
    UserConfiguration.prototype.ResetIsDirty = function () {
        this.updatedProperties = UserConfiguration.NoProperties;
        this.dictionary.IsDirty = false;
    };
    UserConfiguration.prototype.Save = function (name, parentFolderIdOrName) {
        var _this = this;
        var parentFolderId = parentFolderIdOrName;
        if (typeof parentFolderIdOrName === 'number') {
            parentFolderId = new FolderId(parentFolderIdOrName);
        }
        EwsUtilities.ValidateParam(name, "name");
        EwsUtilities.ValidateParam(parentFolderId, "parentFolderId");
        parentFolderId.Validate(this.service.RequestedServerVersion);
        if (!this.isNew) {
            throw new InvalidOperationException(Strings.CannotSaveNotNewUserConfiguration);
        }
        this.parentFolderId = parentFolderId;
        this.name = name;
        return this.service.CreateUserConfiguration(this).then(function () {
            _this.isNew = false;
            _this.ResetIsDirty();
        });
    };
    /**
     * Updates the user configuration by applying local changes to the Exchange server.
     * Calling this method results in a call to EWS.
     * @return  {Promise<void>}    :Promise.
     */
    UserConfiguration.prototype.Update = function () {
        var _this = this;
        if (this.isNew) {
            exports.Promise.reject(new InvalidOperationException(Strings.CannotUpdateNewUserConfiguration));
        }
        if (this.IsPropertyUpdated(UserConfigurationProperties.BinaryData) ||
            this.IsPropertyUpdated(UserConfigurationProperties.Dictionary) ||
            this.IsPropertyUpdated(UserConfigurationProperties.XmlData)) {
            return this.service.UpdateUserConfiguration(this).then(function () {
                _this.ResetIsDirty();
            });
        }
        else {
            this.ResetIsDirty();
            return exports.Promise.resolve();
        }
    };
    /**
     * Determines whether the specified property may be accessed.
     *
     * @param   {UserConfigurationProperties}   property   Property to access.
     */
    UserConfiguration.prototype.ValidatePropertyAccess = function (property) {
        if ((property & this.propertiesAvailableForAccess) != property) {
            throw new PropertyException(Strings.MustLoadOrAssignPropertyBeforeAccess, EnumHelper.ToString(UserConfigurationProperties, property));
        }
    };
    /**
     * Writes the BinaryData property to Xml.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    UserConfiguration.prototype.WriteBinaryDataToXml = function (writer) {
        EwsLogging.Assert(writer != null, "UserConfiguration.WriteBinaryDataToXml", "writer is null");
        UserConfiguration.WriteByteArrayToXml(writer, this.binaryData, XmlElementNames.BinaryData);
    };
    /**
     * Writes a byte array to Xml.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {base64String}          byteArray        Byte array to write #base64 string.
     * @param   {string}                xmlElementName   Name of the Xml element.
     */
    UserConfiguration.WriteByteArrayToXml = function (writer, byteArray /*System.Byte[]*/, xmlElementName) {
        EwsLogging.Assert(writer != null, "UserConfiguration.WriteByteArrayToXml", "writer is null");
        EwsLogging.Assert(xmlElementName != null, "UserConfiguration.WriteByteArrayToXml", "xmlElementName is null");
        writer.WriteStartElement(XmlNamespace.Types, xmlElementName);
        if (byteArray != null && byteArray.length > 0) {
            //writer.WriteValue(Convert.ToBase64String(byteArray), xmlElementName); //info: no need to convert to string, it is already base 64 encoded string
            writer.WriteValue(byteArray, xmlElementName);
        }
        writer.WriteEndElement();
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {XmlNamespace}          xmlNamespace     The XML namespace.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    UserConfiguration.prototype.WriteToXml = function (writer, xmlNamespace, xmlElementName) {
        EwsLogging.Assert(writer != null, "UserConfiguration.WriteToXml", "writer is null");
        EwsLogging.Assert(xmlElementName != null, "UserConfiguration.WriteToXml", "xmlElementName is null");
        writer.WriteStartElement(xmlNamespace, xmlElementName);
        // Write the UserConfigurationName element
        UserConfiguration.WriteUserConfigurationNameToXml(writer, XmlNamespace.Types, this.name, this.parentFolderId);
        // Write the Dictionary element
        if (this.IsPropertyUpdated(UserConfigurationProperties.Dictionary)) {
            this.dictionary.WriteToXml(writer, XmlElementNames.Dictionary);
        }
        // Write the XmlData element
        if (this.IsPropertyUpdated(UserConfigurationProperties.XmlData)) {
            this.WriteXmlDataToXml(writer);
        }
        // Write the BinaryData element
        if (this.IsPropertyUpdated(UserConfigurationProperties.BinaryData)) {
            this.WriteBinaryDataToXml(writer);
        }
        writer.WriteEndElement();
    };
    /**
     * @internal Writes to Xml.
     *
     * @param   {EwsServiceXmlWriter}   writer           The writer.
     * @param   {XmlNamespace}          xmlNamespace     The XML namespace.
     * @param   {string}                name             The user configuration name.
     * @param   {FolderId}              parentFolderId   The Id of the folder containing the user configuration.
     */
    UserConfiguration.WriteUserConfigurationNameToXml = function (writer, xmlNamespace, name, parentFolderId) {
        EwsLogging.Assert(writer != null, "UserConfiguration.WriteUserConfigurationNameToXml", "writer is null");
        EwsLogging.Assert(name != null, "UserConfiguration.WriteUserConfigurationNameToXml", "name is null");
        EwsLogging.Assert(parentFolderId != null, "UserConfiguration.WriteUserConfigurationNameToXml", "parentFolderId is null");
        writer.WriteStartElement(xmlNamespace, XmlElementNames.UserConfigurationName);
        writer.WriteAttributeValue(XmlAttributeNames.Name, name);
        parentFolderId.WriteToXml(writer);
        writer.WriteEndElement();
    };
    /**
     * Writes the XmlData property to Xml.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    UserConfiguration.prototype.WriteXmlDataToXml = function (writer) {
        EwsLogging.Assert(writer != null, "UserConfiguration.WriteXmlDataToXml", "writer is null");
        UserConfiguration.WriteByteArrayToXml(writer, this.xmlData, XmlElementNames.XmlData);
    };
    UserConfiguration.ObjectVersion = ExchangeVersion.Exchange2010;
    // For consistency with ServiceObject behavior, access to ItemId is permitted for a new object.
    UserConfiguration.PropertiesAvailableForNewObject = UserConfigurationProperties.BinaryData | UserConfigurationProperties.Dictionary | UserConfigurationProperties.XmlData;
    UserConfiguration.NoProperties = 0;
    return UserConfiguration;
}());
exports.UserConfiguration = UserConfiguration;
var AbstractFolderIdWrapper = (function () {
    function AbstractFolderIdWrapper() {
    }
    AbstractFolderIdWrapper.prototype.GetFolder = function () { return null; };
    //InternalToJson(service: ExchangeService): void { throw new Error("AbstractFolderIdWrapper.ts - InternalToJson : Not implemented."); }
    //object IJsonSerializable.ToJson(ExchangeService service)
    //{
    //      return this.InternalToJson(service);
    //}
    AbstractFolderIdWrapper.prototype.Validate = function (version) { };
    /**@internal */
    AbstractFolderIdWrapper.prototype.WriteToXml = function (writer) { throw new Error("AbstractFolderIdWrapper.ts - WriteToXml - abstract; must implemented."); };
    return AbstractFolderIdWrapper;
}());
exports.AbstractFolderIdWrapper = AbstractFolderIdWrapper;
var FolderIdWrapper = (function (_super) {
    __extends(FolderIdWrapper, _super);
    function FolderIdWrapper(folderId) {
        var _this = _super.call(this) || this;
        EwsLogging.Assert(folderId != null, "FolderIdWrapper.ctor", "folderId is null");
        _this.folderId = folderId;
        return _this;
    }
    //InternalToJson(service: ExchangeService): any{ throw new Error("FolderIdWrapper.ts - InternalToJson : Not implemented.");}
    FolderIdWrapper.prototype.Validate = function (version) { this.folderId.Validate(version); };
    /**@internal */
    FolderIdWrapper.prototype.WriteToXml = function (writer) { this.folderId.WriteToXml(writer); };
    return FolderIdWrapper;
}(AbstractFolderIdWrapper));
exports.FolderIdWrapper = FolderIdWrapper;
var FolderWrapper = (function (_super) {
    __extends(FolderWrapper, _super);
    function FolderWrapper(folder) {
        var _this = _super.call(this) || this;
        EwsLogging.Assert(folder != null, "FolderWrapper.ctor", "folder is null");
        EwsLogging.Assert(!folder.IsNew, "FolderWrapper.ctor", "folder does not have an Id");
        _this.folder = folder;
        return _this;
    }
    FolderWrapper.prototype.GetFolder = function () { return this.folder; };
    //InternalToJson(service: ExchangeService): void{ throw new Error("FolderWrapper.ts - InternalToJson : Not implemented.");}
    /**@internal */
    FolderWrapper.prototype.WriteToXml = function (writer) { this.folder.Id.WriteToXml(writer); };
    return FolderWrapper;
}(AbstractFolderIdWrapper));
exports.FolderWrapper = FolderWrapper;
var AbstractItemIdWrapper = (function () {
    function AbstractItemIdWrapper() {
    }
    AbstractItemIdWrapper.prototype.GetItem = function () { return null; };
    AbstractItemIdWrapper.prototype.IternalToJson = function (service) { throw new Error("AbstractItemIdWrapper.ts - IternalToJson : Not implemented."); };
    /**@internal */
    AbstractItemIdWrapper.prototype.WriteToXml = function (writer) { };
    return AbstractItemIdWrapper;
}());
exports.AbstractItemIdWrapper = AbstractItemIdWrapper;
var ItemIdWrapper = (function (_super) {
    __extends(ItemIdWrapper, _super);
    function ItemIdWrapper(itemId) {
        var _this = _super.call(this) || this;
        EwsLogging.Assert(itemId != null, "ItemIdWrapper.ctor", "itemId is null");
        _this.itemId = itemId;
        return _this;
    }
    ItemIdWrapper.prototype.IternalToJson = function (service) { throw new Error("ItemIdWrapper.ts - IternalToJson : Not implemented."); };
    /**@internal */
    ItemIdWrapper.prototype.WriteToXml = function (writer) { this.itemId.WriteToXml(writer); };
    return ItemIdWrapper;
}(AbstractItemIdWrapper));
exports.ItemIdWrapper = ItemIdWrapper;
var ItemWrapper = (function (_super) {
    __extends(ItemWrapper, _super);
    function ItemWrapper(item) {
        var _this = _super.call(this) || this;
        EwsLogging.Assert(item != null, "ItemWrapper.ctor", "item is null");
        EwsLogging.Assert(!item.IsNew, "ItemWrapper.ctor", "item does not have an Id");
        _this.item = item;
        return _this;
    }
    ItemWrapper.prototype.GetItem = function () { return this.item; };
    ItemWrapper.prototype.IternalToJson = function (service) { throw new Error("ItemWrapper.ts - IternalToJson : Not implemented."); };
    /**@internal */
    ItemWrapper.prototype.WriteToXml = function (writer) { this.item.Id.WriteToXml(writer); };
    return ItemWrapper;
}(AbstractItemIdWrapper));
exports.ItemWrapper = ItemWrapper;
/**
 * Represents a collection of notification events.
 */
var GetEventsResults = (function () {
    /**
     * @internal Initializes a new instance of the **GetEventsResults** class.
     */
    function GetEventsResults() {
        /**
         * Watermark in event.
         */
        this.newWatermark = null;
        /**
         * Subscription id.
         */
        this.subscriptionId = null;
        /**
         * Previous watermark.
         */
        this.previousWatermark = null;
        /**
         * True if more events available for this subscription.
         */
        this.moreEventsAvailable = false;
        /**
         * Collection of notification events.
         */
        this.events = [];
    }
    Object.defineProperty(GetEventsResults, "XmlElementNameToEventTypeMap", {
        /**
         * Gets the XML element name to event type mapping.
         *
         * @value	The XML element name to event type mapping.
         */
        get: function () {
            return GetEventsResults.xmlElementNameToEventTypeMap.Member;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetEventsResults.prototype, "SubscriptionId", {
        /**
         * @internal Gets the Id of the subscription the collection is associated with.
         */
        get: function () {
            return this.subscriptionId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetEventsResults.prototype, "PreviousWatermark", {
        /**
         * @internal Gets the subscription's previous watermark.
         */
        get: function () {
            return this.previousWatermark;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetEventsResults.prototype, "NewWatermark", {
        /**
         * @internal Gets the subscription's new watermark.
         */
        get: function () {
            return this.newWatermark;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetEventsResults.prototype, "MoreEventsAvailable", {
        /**
         * @internal Gets a value indicating whether more events are available on the Exchange server.
         */
        get: function () {
            return this.moreEventsAvailable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetEventsResults.prototype, "FolderEvents", {
        /**
         * Gets the collection of folder events.
         *
         * @value	The folder events.
         */
        get: function () {
            return ArrayHelper.OfType(this.events, function (item) { return item instanceof FolderEvent; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetEventsResults.prototype, "ItemEvents", {
        /**
         * Gets the collection of item events.
         *
         * @value	The item events.
         */
        get: function () {
            return ArrayHelper.OfType(this.events, function (item) { return item instanceof ItemEvent; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GetEventsResults.prototype, "AllEvents", {
        /**
         * Gets the collection of all events.
         *
         * @value	The events.
         */
        get: function () {
            return this.events;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Loads the events from XML.
     *
     * @param   {any[]}               jsEventsArray         The json events array.
     * @param   {string}     		  xmlElementName		Name of the element.
     * @param   {ExchangeService}     service               The service.
     */
    GetEventsResults.prototype.LoadEventsFromXmlJsObject = function (jsEventsArray, eventElementName, service) {
        for (var _a = 0, jsEventsArray_1 = jsEventsArray; _a < jsEventsArray_1.length; _a++) {
            var jsEvent = jsEventsArray_1[_a];
            this.newWatermark = jsEvent[XmlElementNames.Watermark];
            var eventType = GetEventsResults.XmlElementNameToEventTypeMap.get(eventElementName);
            if (eventType == EventType.Status) {
                continue;
            }
            var timeStamp = service.ConvertUniversalDateTimeStringToLocalDateTime(jsEvent[XmlElementNames.TimeStamp]);
            var notificationEvent = void 0;
            if (jsEvent[XmlElementNames.FolderId]) {
                notificationEvent = new FolderEvent(eventType, timeStamp);
            }
            else {
                notificationEvent = new ItemEvent(eventType, timeStamp);
            }
            notificationEvent.LoadFromXmlJsObject(jsEvent, service);
            this.events.push(notificationEvent);
        }
    };
    /**
     * @internal Loads from XML.
     *
     * @param   {any}                 eventsResponse         The events response Object converted from XML.
     * @param   {ExchangeService}     service                The service.
     */
    GetEventsResults.prototype.LoadFromXmlJsObject = function (eventsResponse, service) {
        var response = eventsResponse;
        if (eventsResponse[XmlElementNames.Notification]) {
            response = eventsResponse[XmlElementNames.Notification];
        }
        for (var key in response) {
            switch (key) {
                case XmlElementNames.SubscriptionId:
                    this.subscriptionId = response[key];
                    break;
                case XmlElementNames.PreviousWatermark:
                    this.previousWatermark = response[key];
                    break;
                case XmlElementNames.MoreEvents:
                    this.moreEventsAvailable = Convert.toBool(response[key]);
                    break;
                default:
                    if (GetEventsResults.XmlElementNameToEventTypeMap.containsKey(key)) {
                        this.LoadEventsFromXmlJsObject(EwsServiceJsonReader.ReadAsArray(response, key), key, service);
                    }
                    break;
            }
        }
    };
    /**
     * Map XML element name to notification event type.
     *
     * /remarks/ 	If you add a new notification event type, you'll need to add a new entry to the dictionary here.
     */
    GetEventsResults.xmlElementNameToEventTypeMap = new LazyMember(function () {
        var dictionary = new DictionaryWithStringKey();
        dictionary.Add("CopiedEvent", EventType.Copied);
        dictionary.Add("CreatedEvent", EventType.Created);
        dictionary.Add("DeletedEvent", EventType.Deleted);
        dictionary.Add("ModifiedEvent", EventType.Modified);
        dictionary.Add("MovedEvent", EventType.Moved);
        dictionary.Add("NewMailEvent", EventType.NewMail);
        dictionary.Add("StatusEvent", EventType.Status);
        dictionary.Add("FreeBusyChangedEvent", EventType.FreeBusyChanged);
        return dictionary;
    });
    return GetEventsResults;
}());
exports.GetEventsResults = GetEventsResults;
/**
 * @internal Represents a collection of notification events.
 *
 * @sealed
 */
var GetStreamingEventsResults = (function () {
    /**
     * @internal Initializes a new instance of the **GetStreamingEventsResults** class.
     */
    function GetStreamingEventsResults() {
        /**
         * Collection of notification events.
         */
        this.events = [];
    }
    Object.defineProperty(GetStreamingEventsResults.prototype, "Notifications", {
        /**
         * @internal Gets the notification collection.
         *
         * @value	The notification collection.
         */
        get: function () { return this.events; },
        enumerable: true,
        configurable: true
    });
    /**
     * Loads the events from XML.
     *
     * @param   {any[]}               	jsEventsArray         	The json events array.
     * @param   {string}     		  	xmlElementName			Name of the element.
     * @param   {NotificationGroup}		notifications			Collection of notifications.
     * @param   {ExchangeService}     	service               	The service.
     */
    GetStreamingEventsResults.prototype.LoadNotificationEventFromXmlJsObject = function (jsEventsArray, eventElementName, notifications, service) {
        for (var _a = 0, jsEventsArray_2 = jsEventsArray; _a < jsEventsArray_2.length; _a++) {
            var jsEvent = jsEventsArray_2[_a];
            var eventType = GetEventsResults.XmlElementNameToEventTypeMap.get(eventElementName);
            if (eventType == EventType.Status) {
                continue;
            }
            var timeStamp = service.ConvertUniversalDateTimeStringToLocalDateTime(jsEvent[XmlElementNames.TimeStamp]);
            var notificationEvent = void 0;
            if (jsEvent[XmlElementNames.FolderId]) {
                notificationEvent = new FolderEvent(eventType, timeStamp);
            }
            else {
                notificationEvent = new ItemEvent(eventType, timeStamp);
            }
            notificationEvent.LoadFromXmlJsObject(jsEvent, service);
            notifications.Events.push(notificationEvent);
        }
    };
    /**
     * @internal Loads from XML.
     *
     * @param   {any}                 eventsResponse         The events response Object converted from XML.
     * @param   {ExchangeService}     service                The service.
     */
    GetStreamingEventsResults.prototype.LoadFromXmlJsObject = function (eventsResponse, service) {
        var streamingNotifications = EwsServiceJsonReader.ReadAsArray(eventsResponse, XmlElementNames.Notification);
        for (var _a = 0, streamingNotifications_1 = streamingNotifications; _a < streamingNotifications_1.length; _a++) {
            var streamingNotification = streamingNotifications_1[_a];
            var notifications = new NotificationGroup();
            notifications.SubscriptionId = streamingNotification[XmlElementNames.SubscriptionId];
            notifications.Events = [];
            this.events.push(notifications);
            for (var key in streamingNotification) {
                switch (key) {
                    default:
                        if (GetEventsResults.XmlElementNameToEventTypeMap.containsKey(key)) {
                            this.LoadNotificationEventFromXmlJsObject(EwsServiceJsonReader.ReadAsArray(streamingNotification, key), key, notifications, service);
                        }
                        break;
                }
            }
        }
    };
    return GetStreamingEventsResults;
}());
exports.GetStreamingEventsResults = GetStreamingEventsResults;
/**
 * Provides data to a StreamingSubscriptionConnection's OnNotificationEvent event.
 */
var NotificationEventArgs = (function () {
    /**
     * @internal Initializes a new instance of the **NotificationEventArgs** class.
     *
     * @param   {StreamingSubscription}   	subscription   The subscription for which notifications have been received.
     * @param   {NotificationEvent[]}   	events         The events that were received.
     */
    function NotificationEventArgs(subscription, events) {
        this.Events = events;
        this.Subscription = subscription;
    }
    return NotificationEventArgs;
}());
exports.NotificationEventArgs = NotificationEventArgs;
/**
 * @internal Structure to track a subscription and its associated notification events.
 */
var NotificationGroup = (function () {
    function NotificationGroup() {
        /**
         * @internal Subscription Id
         */
        this.SubscriptionId = null;
        /**
         * @internal Events in the response associated with the subscription id.
         */
        this.Events = [];
    }
    return NotificationGroup;
}());
exports.NotificationGroup = NotificationGroup;
/**
 * Represents a connection to an ongoing stream of events.
 *
 * @sealed
 */
var StreamingSubscriptionConnection = (function () {
    function StreamingSubscriptionConnection(service, lifetimeOrSubscriptions, lifetime) {
        var _this = this;
        /**
         * Mapping of streaming id to subscriptions currently on the connection.
         */
        this.subscriptions = new DictionaryWithStringKey();
        /**
         * connection lifetime, in minutes
         */
        this.connectionTimeout = 0;
        /**
         * ExchangeService instance used to make the EWS call.
         */
        this.session = null;
        /**
         * Value indicating whether the class is disposed.
         */
        this.isDisposed = false;
        /**
         * Currently used instance of a GetStreamingEventsRequest connected to EWS.
         */
        this.currentHangingRequest = null;
        /**
         * Lock object
         */
        this.lockObject = { isLocked: false };
        /**
         * Occurs when notifications are received from the server.
         */
        this.OnNotificationEvent = [];
        /**
         * Occurs when a subscription encounters an error.
         */
        this.OnSubscriptionError = [];
        /**
         * Occurs when a streaming subscription connection is disconnected from the server.
         */
        this.OnDisconnect = [];
        /**
         * Occurs when a streaming subscription connection gets headers from the server.
         */
        this.OnResponseHeader = [];
        EwsUtilities.ValidateParam(service, "service");
        EwsUtilities.ValidateClassVersion(service, ExchangeVersion.Exchange2010_SP1, "StreamingSubscriptionConnection");
        var argsLength = arguments.length;
        var lifeTime = argsLength === 2 ? lifetimeOrSubscriptions : lifetime;
        if (lifeTime < 1 || lifeTime > 30) {
            throw new ArgumentOutOfRangeException("lifetime");
        }
        this.session = service;
        this.connectionTimeout = lifeTime;
        if (argsLength === 3) {
            var subscriptions = lifetimeOrSubscriptions;
            EwsUtilities.ValidateParamCollection(subscriptions, "subscriptions");
            subscriptions.forEach(function (subscription) {
                _this.subscriptions.Add(subscription.Id, subscription);
            });
        }
    }
    Object.defineProperty(StreamingSubscriptionConnection.prototype, "CurrentSubscriptions", {
        /**
         * Getting the current subscriptions in this connection.
         */
        get: function () {
            var list = [];
            //while (this.lockObject.isLocked) { }; //todo: implement blocking and non blocking multi threading when available.
            //this.lockObject.isLocked = true;
            //try {
            ArrayHelper.AddRange(list, this.subscriptions.Values);
            // } finally {
            // 	this.lockObject.isLocked = false;
            // }
            return list;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StreamingSubscriptionConnection.prototype, "IsOpen", {
        /**
         * Gets a value indicating whether this connection is opened
         */
        get: function () {
            this.ThrowIfDisposed();
            if (this.currentHangingRequest == null) {
                return false;
            }
            else {
                return this.currentHangingRequest.IsConnected;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds a subscription to this connection.
     *
     * @param   {StreamingSubscription}   subscription   The subscription to add.
     */
    StreamingSubscriptionConnection.prototype.AddSubscription = function (subscription) {
        this.ThrowIfDisposed();
        EwsUtilities.ValidateParam(subscription, "subscription");
        this.ValidateConnectionState(false, Strings.CannotAddSubscriptionToLiveConnection);
        //while (this.lockObject.isLocked) { }; //todo: implement blocking and non blocking multi threading when available.
        //this.lockObject.isLocked = true;
        //try {
        if (!this.subscriptions.containsKey(subscription.Id)) {
            this.subscriptions.Add(subscription.Id, subscription);
        }
        // } finally {
        // 	this.lockObject.isLocked = false;
        // }
    };
    /**
     * Closes this connection so it stops receiving events from the server.
     * This terminates a long-standing call to EWS.
     *
     * @exception	{InvalidOperationException}		Thrown when Close is called while not connected.
     */
    StreamingSubscriptionConnection.prototype.Close = function () {
        //todo: implement blocking and non blocking multi threading when available.
        //lock(this.lockObject) {
        this.ThrowIfDisposed();
        this.ValidateConnectionState(true, Strings.CannotCallDisconnectWithNoLiveConnection);
        // Further down in the stack, this will result in a call to our OnRequestDisconnect event handler,
        // doing the necessary cleanup.
        this.currentHangingRequest.Disconnect();
        //}
    };
    StreamingSubscriptionConnection.prototype.Dispose = function (suppressFinalizer) {
        if (suppressFinalizer === void 0) { suppressFinalizer = false; }
        if (suppressFinalizer) {
            //GC.SuppressFinalize(this);
        }
        //todo: implement blocking and non blocking multi threading when available.
        //lock(this.lockObject) {
        if (!this.isDisposed) {
            if (this.currentHangingRequest != null) {
                this.currentHangingRequest = null;
            }
            this.subscriptions = null;
            this.session = null;
            this.isDisposed = true;
        }
        //}
    };
    /**
     * Handles the service response object.
     *
     * @param   {any}   response   The response.
     */
    StreamingSubscriptionConnection.prototype.HandleServiceResponseObject = function (response) {
        var gseResponse = response;
        if (!(gseResponse instanceof GetStreamingEventsResponse)) {
            throw new ArgumentException();
        }
        else {
            if (gseResponse.Result == ServiceResult.Success || gseResponse.Result == ServiceResult.Warning) {
                if (gseResponse.Results.Notifications.length > 0) {
                    // We got notifications; dole them out.
                    this.IssueNotificationEvents(gseResponse);
                }
                else {
                    //// This was just a heartbeat, nothing to do here.
                }
            }
            else if (gseResponse.Result == ServiceResult.Error) {
                if (gseResponse.ErrorSubscriptionIds == null ||
                    gseResponse.ErrorSubscriptionIds.length == 0) {
                    // General error
                    this.IssueGeneralFailure(gseResponse);
                }
                else {
                    // subscription-specific errors
                    this.IssueSubscriptionFailures(gseResponse);
                }
            }
        }
    };
    /**
     * Internal helper method called when the request disconnects.
     *
     * @param   {Exception}   ex   The exception that caused the disconnection. May be null.
     */
    StreamingSubscriptionConnection.prototype.InternalOnDisconnect = function (ex) {
        var _this = this;
        this.currentHangingRequest = null;
        if (this.OnDisconnect && ArrayHelper.isArray(this.OnDisconnect)) {
            try {
                this.OnDisconnect.forEach(function (onDisconnect) { onDisconnect(_this, new SubscriptionErrorEventArgs(null, ex)); });
            }
            catch (e) { }
        }
    };
    /**
     * Internal helper method called when the request receives headers.
     *
     * @param   {any}   headers   The headerf from server.
     */
    StreamingSubscriptionConnection.prototype.InternalOnResponseHeader = function (headers) {
        if (this.OnResponseHeader && ArrayHelper.isArray(this.OnResponseHeader)) {
            try {
                this.OnResponseHeader.forEach(function (onHeader) { onHeader(headers); });
            }
            catch (e) { }
        }
    };
    /**
     * Issues the general failure.
     *
     * @param   {GetStreamingEventsResponse}   gseResponse   The GetStreamingEvents response.
     */
    StreamingSubscriptionConnection.prototype.IssueGeneralFailure = function (gseResponse) {
        var _this = this;
        var eventArgs = new SubscriptionErrorEventArgs(null, new ServiceResponseException(gseResponse));
        if (this.OnSubscriptionError && ArrayHelper.isArray(this.OnSubscriptionError)) {
            try {
                this.OnSubscriptionError.forEach(function (OnSubscriptionError) { OnSubscriptionError(_this, eventArgs); });
            }
            catch (e) { }
        }
    };
    /**
     * Issues the notification events.
     *
     * @param   {GetStreamingEventsResponse}   gseResponse   The GetStreamingEvents response.
     */
    StreamingSubscriptionConnection.prototype.IssueNotificationEvents = function (gseResponse) {
        var _this = this;
        var _loop_1 = function (events) {
            var subscription = null;
            //todo: implement blocking and non blocking multi threading when available.
            //lock(this.lockObject) {
            // Client can do any good or bad things in the below event handler
            if (this_1.subscriptions != null && this_1.subscriptions.containsKey(events.SubscriptionId)) {
                subscription = this_1.subscriptions.get(events.SubscriptionId);
            }
            //}
            if (subscription != null) {
                var eventArgs_1 = new NotificationEventArgs(subscription, events.Events);
                if (this_1.OnNotificationEvent && ArrayHelper.isArray(this_1.OnNotificationEvent)) {
                    try {
                        this_1.OnNotificationEvent.forEach(function (OnNotificationEvent) { OnNotificationEvent(_this, eventArgs_1); });
                    }
                    catch (e) { }
                }
            }
        };
        var this_1 = this;
        for (var _a = 0, _b = gseResponse.Results.Notifications; _a < _b.length; _a++) {
            var events = _b[_a];
            _loop_1(events);
        }
    };
    /**
     * Issues the subscription failures.
     *
     * @param   {GetStreamingEventsResponse}   gseResponse   The GetStreamingEvents response.
     */
    StreamingSubscriptionConnection.prototype.IssueSubscriptionFailures = function (gseResponse) {
        var _this = this;
        var exception = new ServiceResponseException(gseResponse);
        var _loop_2 = function (id) {
            var subscription = null;
            //todo: implement blocking and non blocking multi threading when available.
            //lock(this.lockObject) {
            // Client can do any good or bad things in the below event handler
            if (this_2.subscriptions != null && this_2.subscriptions.containsKey(id)) {
                subscription = this_2.subscriptions.get(id);
            }
            //}
            if (subscription != null) {
                var eventArgs_2 = new SubscriptionErrorEventArgs(subscription, exception);
                if (this_2.OnSubscriptionError && ArrayHelper.isArray(this_2.OnSubscriptionError)) {
                    try {
                        this_2.OnSubscriptionError.forEach(function (OnSubscriptionError) { OnSubscriptionError(_this, eventArgs_2); });
                    }
                    catch (e) { }
                }
            }
            if (gseResponse.ErrorCode != ServiceError.ErrorMissedNotificationEvents) {
                // Client can do any good or bad things in the above event handler
                //todo: implement blocking and non blocking multi threading when available.
                //lock(this.lockObject) {
                if (this_2.subscriptions != null && this_2.subscriptions.containsKey(id)) {
                    // We are no longer servicing the subscription.
                    this_2.subscriptions.remove(id);
                }
                //}
            }
        };
        var this_2 = this;
        for (var _a = 0, _b = gseResponse.ErrorSubscriptionIds; _a < _b.length; _a++) {
            var id = _b[_a];
            _loop_2(id);
        }
    };
    /**
     * Called when the request is disconnected.
     *
     * @param   {any}   								sender   The sender.
     * @param   {HangingRequestDisconnectEventArgs}   	args     The  instance containing the event data.
     */
    StreamingSubscriptionConnection.prototype.OnRequestDisconnect = function (sender, args) {
        this.InternalOnDisconnect(args.Exception);
    };
    /**
     * Opens this connection so it starts receiving events from the server.
     * This results in a long-standing call to EWS.
     *
     * @exception	{InvalidOperationException}		Thrown when Open is called while connected.
     */
    StreamingSubscriptionConnection.prototype.Open = function () {
        //todo: implement blocking and non blocking multi threading when available.		
        //lock(this.lockObject) {
        this.ThrowIfDisposed();
        this.ValidateConnectionState(false, Strings.CannotCallConnectDuringLiveConnection);
        if (this.subscriptions.Count == 0) {
            throw new ServiceLocalException(Strings.NoSubscriptionsOnConnection);
        }
        this.currentHangingRequest = new GetStreamingEventsRequest(this.session, this.HandleServiceResponseObject.bind(this), this.subscriptions.Keys, this.connectionTimeout);
        this.currentHangingRequest.OnDisconnect.push(this.OnRequestDisconnect.bind(this)); //todo: fix if needed multiple instance new HangingServiceRequestBase.HangingRequestDisconnectHandler(this.OnRequestDisconnect)
        this.currentHangingRequest.OnResponseHeader = this.InternalOnResponseHeader.bind(this); //todo: fix if needed multiple instance new HangingServiceRequestBase.HangingRequestDisconnectHandler(this.OnRequestDisconnect)
        return this.currentHangingRequest.InternalExecute();
        //}
    };
    /**
     * Removes the specified streaming subscription from the connection.
     *
     * @param   {StreamingSubscription}   subscription   The subscription to remove.
     */
    StreamingSubscriptionConnection.prototype.RemoveSubscription = function (subscription) {
        this.ThrowIfDisposed();
        EwsUtilities.ValidateParam(subscription, "subscription");
        this.ValidateConnectionState(false, Strings.CannotRemoveSubscriptionFromLiveConnection);
        //while (this.lockObject.isLocked) { }; //todo: implement blocking and non blocking multi threading when available.
        //this.lockObject.isLocked = true;
        //try {
        this.subscriptions.remove(subscription.Id);
        // } finally {
        // 	this.lockObject.isLocked = false;
        // }
    };
    /**
     * Throws if disposed.
     */
    StreamingSubscriptionConnection.prototype.ThrowIfDisposed = function () {
        if (this.isDisposed) {
            throw new Error("ObjectDisposedException - StreamingSubscriptionConnection"); //ObjectDisposedException
        }
    };
    /**
     * Validates the state of the connection.
     *
     * @param   {boolean}   isConnectedExpected   Value indicating whether we expect to be currently connected.
     * @param   {string}   	errorMessage          The error message.
     */
    StreamingSubscriptionConnection.prototype.ValidateConnectionState = function (isConnectedExpected, errorMessage) {
        if ((isConnectedExpected && !this.IsOpen) ||
            (!isConnectedExpected && this.IsOpen)) {
            throw new ServiceLocalException(errorMessage);
        }
    };
    return StreamingSubscriptionConnection;
}());
exports.StreamingSubscriptionConnection = StreamingSubscriptionConnection;
/**
 * Provides data to a StreamingSubscriptionConnection's OnSubscriptionError and OnDisconnect events.
 */
var SubscriptionErrorEventArgs /*extends System.EventArgs*/ = (function () {
    /**
     * @internal Initializes a new instance of the **SubscriptionErrorEventArgs** class.
     *
     * @param   {StreamingSubscription}   	subscription   The subscription for which an error occurred. If subscription is null, the error applies to the entire connection.
     * @param   {Exception}   				exception      The exception representing the error. If exception is null, the connection was cleanly closed by the server.
     */
    function SubscriptionErrorEventArgs(subscription, exception) {
        this.Subscription = subscription;
        this.Exception = exception;
    }
    return SubscriptionErrorEventArgs;
}());
exports.SubscriptionErrorEventArgs = SubscriptionErrorEventArgs;
/**
 * Represents an event as exposed by push and pull notifications.
 */
var NotificationEvent = (function () {
    /**
     * @internal Initializes a new instance of the **NotificationEvent** class.
     *
     * @param   {EventType}		eventType   Type of the event.
     * @param   {DateTime}   	timestamp   The event timestamp.
     */
    function NotificationEvent(eventType, timestamp) {
        /**
         * Type of this event.
         */
        this.eventType = EventType.Status;
        /**
         * Date and time when the event occurred.
         */
        this.timestamp = null;
        /**
         * Id of parent folder of the item or folder this event applies to.
         */
        this.parentFolderId = null;
        /**
         * Id of the old prarent foldero of the item or folder this event applies to.
         * This property is only meaningful when EventType is equal to either EventType.Moved or EventType.Copied.
         * For all other event types, oldParentFolderId will be null.
         */
        this.oldParentFolderId = null;
        this.eventType = eventType;
        this.timestamp = timestamp;
    }
    Object.defineProperty(NotificationEvent.prototype, "EventType", {
        /**
         * Gets the type of this event.
         */
        get: function () {
            return this.eventType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotificationEvent.prototype, "TimeStamp", {
        /**
         * Gets the date and time when the event occurred.
         */
        get: function () {
            return this.timestamp;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotificationEvent.prototype, "ParentFolderId", {
        /**
         * Gets the Id of the parent folder of the item or folder this event applie to.
         */
        get: function () {
            return this.parentFolderId;
        },
        set: function (value) {
            this.parentFolderId = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotificationEvent.prototype, "OldParentFolderId", {
        /**
         * Gets the Id of the old parent folder of the item or folder this event applies to.
         * OldParentFolderId is only meaningful when EventType is equal to either EventType.Moved or EventType.Copied.
         * For all other event types, OldParentFolderId is null.
         */
        get: function () {
            return this.oldParentFolderId;
        },
        set: function (value) {
            this.oldParentFolderId = value;
        },
        enumerable: true,
        configurable: true
    });
    return NotificationEvent;
}());
exports.NotificationEvent = NotificationEvent;
/**
 * Represents an event that applies to a folder.
 */
var FolderEvent = (function (_super) {
    __extends(FolderEvent, _super);
    /**
     * @internal Initializes a new instance of the **FolderEvent** class.
     *
     * @param   {EventType}		eventType   Type of the event.
     * @param   {DateTime}   	timestamp   The event timestamp.
     */
    function FolderEvent(eventType, timestamp) {
        var _this = _super.call(this, eventType, timestamp) || this;
        _this.folderId = null;
        _this.oldFolderId = null;
        /**
         * The new number of unread messages. This is is only meaningful when EventType is equal to EventType.Modified. For all other event types, it's null.
         */
        _this.unreadCount = null;
        return _this;
    }
    Object.defineProperty(FolderEvent.prototype, "FolderId", {
        /**
         * Gets the Id of the folder this event applies to.
         */
        get: function () {
            return this.folderId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderEvent.prototype, "OldFolderId", {
        /**
         * Gets the Id of the folder that was moved or copied. OldFolderId is only meaningful when EventType is equal to either EventType.Moved or EventType.Copied. For all other event types, OldFolderId is null.
         */
        get: function () {
            return this.oldFolderId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderEvent.prototype, "UnreadCount", {
        /**
         * Gets the new number of unread messages. This is is only meaningful when EventType is equal to EventType.Modified. For all other event types, UnreadCount is null.
         */
        get: function () {
            return this.unreadCount;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads from XML.
     *
     * @param   {any}                 jsEvent                Json Object converted from XML.
     * @param   {ExchangeService}     service                The service.
     */
    FolderEvent.prototype.LoadFromXmlJsObject = function (jsEvent, service) {
        this.folderId = new FolderId();
        this.folderId.LoadFromXmlJsObject(jsEvent[XmlElementNames.FolderId], service);
        this.ParentFolderId = new FolderId();
        this.ParentFolderId.LoadFromXmlJsObject(jsEvent[XmlElementNames.ParentFolderId], service);
        switch (this.EventType) {
            case EventType.Moved:
            case EventType.Copied:
                this.oldFolderId = new FolderId();
                this.oldFolderId.LoadFromXmlJsObject(jsEvent[JsonNames.OldFolderId], service);
                this.OldParentFolderId = new FolderId();
                this.OldParentFolderId.LoadFromXmlJsObject(jsEvent[XmlElementNames.OldParentFolderId], service);
                break;
            case EventType.Modified:
                if (jsEvent[XmlElementNames.UnreadCount]) {
                    this.unreadCount = Convert.toNumber(jsEvent[XmlElementNames.UnreadCount]);
                }
                break;
            default:
                break;
        }
    };
    return FolderEvent;
}(NotificationEvent));
exports.FolderEvent = FolderEvent;
/**
 * Represents an event that applies to an item.
 */
var ItemEvent = (function (_super) {
    __extends(ItemEvent, _super);
    /**
     * @internal Initializes a new instance of the **FolderEvent** class.
     *
     * @param   {EventType}		eventType   Type of the event.
     * @param   {DateTime}   	timestamp   The event timestamp.
     */
    function ItemEvent(eventType, timestamp) {
        var _this = _super.call(this, eventType, timestamp) || this;
        /**
         * Id of the item this event applies to.
         */
        _this.itemId = null;
        /**
         * Id of the item that moved or copied. This is only meaningful when EventType is equal to either EventType.Moved or EventType.Copied.
         * For all other event types, it's null.
         */
        _this.oldItemId = null;
        return _this;
    }
    Object.defineProperty(ItemEvent.prototype, "ItemId", {
        /**
         * Gets the Id of the item this event applies to.
         */
        get: function () {
            return this.itemId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ItemEvent.prototype, "OldItemId", {
        /**
         * Gets the Id of the item that was moved or copied. OldItemId is only meaningful when EventType is equal to either EventType.Moved or EventType.Copied.
         * For all other event types, OldItemId is null.
         */
        get: function () {
            return this.oldItemId;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads from XML.
     *
     * @param   {any}                 jsEvent                Json Object converted from XML.
     * @param   {ExchangeService}     service                The service.
     */
    ItemEvent.prototype.LoadFromXmlJsObject = function (jsEvent, service) {
        this.itemId = new ItemId();
        this.itemId.LoadFromXmlJsObject(jsEvent[XmlElementNames.ItemId], service);
        this.ParentFolderId = new FolderId();
        this.ParentFolderId.LoadFromXmlJsObject(jsEvent[XmlElementNames.ParentFolderId], service);
        switch (this.EventType) {
            case EventType.Moved:
            case EventType.Copied:
                this.oldItemId = new ItemId();
                this.oldItemId.LoadFromXmlJsObject(jsEvent[JsonNames.OldItemId], service);
                this.OldParentFolderId = new FolderId();
                this.OldParentFolderId.LoadFromXmlJsObject(jsEvent[XmlElementNames.OldParentFolderId], service);
                break;
            default:
                break;
        }
    };
    return ItemEvent;
}(NotificationEvent));
exports.ItemEvent = ItemEvent;
/**
 * Represents the base class for event subscriptions.
 */
var SubscriptionBase = (function () {
    function SubscriptionBase(service, id, watermark) {
        if (id === void 0) { id = null; }
        if (watermark === void 0) { watermark = null; }
        this.service = null;
        this.id = null;
        this.watermark = null;
        EwsUtilities.ValidateParam(service, "service");
        this.service = service;
        if (arguments.length >= 2) {
            EwsUtilities.ValidateParam(id, "id");
        }
        this.id = id;
        this.watermark = watermark;
    }
    Object.defineProperty(SubscriptionBase.prototype, "Service", {
        /**
         * Gets the session.
         *
         * @value The session.
         */
        get: function () {
            return this.service;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubscriptionBase.prototype, "Id", {
        /**
         * Gets the Id of the subscription.
         *
         * internal set
         */
        get: function () {
            return this.id;
        },
        set: function (value) {
            this.id = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubscriptionBase.prototype, "Watermark", {
        /**
         * Gets the latest watermark of the subscription. Watermark is always null for streaming subscriptions.
         *
         * internal set
         */
        get: function () {
            return this.watermark;
        },
        set: function (value) {
            this.watermark = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubscriptionBase.prototype, "UsesWatermark", {
        /**
         * Gets whether or not this subscription uses watermarks.
         */
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Loads from XML.
     *
     * @param   {any}                 jsObject               Json Object converted from XML.
     * @param   {ExchangeService}     service                The service.
     */
    SubscriptionBase.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        this.id = jsObject[XmlElementNames.SubscriptionId];
        if (this.UsesWatermark) {
            this.watermark = jsObject[XmlElementNames.Watermark];
        }
    };
    return SubscriptionBase;
}());
exports.SubscriptionBase = SubscriptionBase;
/**
 * Represents a pull subscription.
 *
 * @sealed
 */
var PullSubscription = (function (_super) {
    __extends(PullSubscription, _super);
    /**
     * @internal Initializes a new instance of the **PullSubscription** class.
     *
     * @param   {ExchangeService}   service     The service.
     */
    function PullSubscription(service) {
        var _this = _super.call(this, service) || this;
        _this.moreEventsAvailable = null;
        return _this;
    }
    Object.defineProperty(PullSubscription.prototype, "MoreEventsAvailable", {
        /**
         * Gets a value indicating whether more events are available on the server.
         * MoreEventsAvailable is undefined (null) until GetEvents is called.
         */
        get: function () {
            return this.moreEventsAvailable;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Obtains a collection of events that occurred on the subscribed folders since the point in time defined by the Watermark property. When GetEvents succeeds, Watermark is updated.
     *
     * @return  {Promise<GetEventsResults>}      Returns a collection of events that occurred since the last watermark	:Promise.
     */
    PullSubscription.prototype.GetEvents = function () {
        var _this = this;
        return this.Service.GetEvents(this.Id, this.Watermark).then(function (results) {
            _this.Watermark = results.NewWatermark;
            _this.moreEventsAvailable = results.MoreEventsAvailable;
            return results;
        });
    };
    /**
     * Unsubscribes from the pull subscription.
     */
    PullSubscription.prototype.Unsubscribe = function () { return this.Service.Unsubscribe(this.Id); };
    return PullSubscription;
}(SubscriptionBase));
exports.PullSubscription = PullSubscription;
/**
 * Represents a push subscriptions.
 *
 * @sealed
 */
var PushSubscription = (function (_super) {
    __extends(PushSubscription, _super);
    /**
     * @internal Initializes a new instance of the **PushSubscription** class.
     *
     * @param   {ExchangeService}   service     The service.
     */
    function PushSubscription(service) {
        return _super.call(this, service) || this;
    }
    return PushSubscription;
}(SubscriptionBase));
exports.PushSubscription = PushSubscription;
/**
 * Represents a streaming subscription.
 *
 * @sealed
 */
var StreamingSubscription = (function (_super) {
    __extends(StreamingSubscription, _super);
    /**
     * @internal Initializes a new instance of the **StreamingSubscription** class.
     *
     * @param   {ExchangeService}   service     The service.
     */
    function StreamingSubscription(service) {
        var _this = _super.call(this, service) || this;
        _this.service = service;
        return _this;
    }
    Object.defineProperty(StreamingSubscription.prototype, "Service", {
        /**
         * Gets the service used to create this subscription.
         */
        get: function () {
            return this.service;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StreamingSubscription.prototype, "UsesWatermark", {
        /**
         * Gets a value indicating whether this subscription uses watermarks.
         */
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Unsubscribes from the streaming subscription.
     */
    StreamingSubscription.prototype.Unsubscribe = function () { return this.Service.Unsubscribe(this.Id); };
    return StreamingSubscription;
}(SubscriptionBase));
exports.StreamingSubscription = StreamingSubscription;
/**
 * Represents the base search filter class. Use descendant search filter classes such as SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection to define search filters.
 */
var SearchFilter = (function (_super) {
    __extends(SearchFilter, _super);
    /**
     * Initializes a new instance of the **SearchFilter** class.
     */
    function SearchFilter() {
        return _super.call(this) || this;
    }
    /**
     * Gets the search filter instance.
     *
     * @param {string} localName Name of the local.
     * @returns {SearchFilter}
     */
    SearchFilter.GetSearchFilterInstance = function (localName) {
        var searchFilter;
        switch (localName) {
            case XmlElementNames.Exists:
                searchFilter = new SearchFilter.Exists();
                break;
            case XmlElementNames.Contains:
                searchFilter = new SearchFilter.ContainsSubstring();
                break;
            case XmlElementNames.Excludes:
                searchFilter = new SearchFilter.ExcludesBitmask();
                break;
            case XmlElementNames.Not:
                searchFilter = new SearchFilter.Not();
                break;
            case XmlElementNames.And:
                searchFilter = new SearchFilter.SearchFilterCollection(LogicalOperator.And);
                break;
            case XmlElementNames.Or:
                searchFilter = new SearchFilter.SearchFilterCollection(LogicalOperator.Or);
                break;
            case XmlElementNames.IsEqualTo:
                searchFilter = new SearchFilter.IsEqualTo();
                break;
            case XmlElementNames.IsNotEqualTo:
                searchFilter = new SearchFilter.IsNotEqualTo();
                break;
            case XmlElementNames.IsGreaterThan:
                searchFilter = new SearchFilter.IsGreaterThan();
                break;
            case XmlElementNames.IsGreaterThanOrEqualTo:
                searchFilter = new SearchFilter.IsGreaterThanOrEqualTo();
                break;
            case XmlElementNames.IsLessThan:
                searchFilter = new SearchFilter.IsLessThan();
                break;
            case XmlElementNames.IsLessThanOrEqualTo:
                searchFilter = new SearchFilter.IsLessThanOrEqualTo();
                break;
            default:
                searchFilter = null;
                break;
        }
        return searchFilter;
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}               jsObject                Json Object converted from XML.
     * @param   {ExchangeService}   service                 The service.
     * @param   {string}            typeName                 type name, when provided prevent call for type name check.
     * @return  {SearchFilter}      SearchFilter instance.
     */
    SearchFilter.LoadFromXmlJsObject = function (jsObject, service, typeName) {
        if (typeName === void 0) { typeName = null; }
        if (!typeName) {
            typeName = TypeSystem.GetJsObjectTypeName(jsObject);
        }
        var searchFilter = SearchFilter.GetSearchFilterInstance(jsObject.ReadTypeString());
        if (searchFilter != null) {
            searchFilter.LoadFromXmlJsObject(jsObject, service);
        }
        return searchFilter;
    };
    /**
     * @internal Writes to XML.
     *
     * @param {EwsServiceXmlWriter} writer  The writer.
     */
    SearchFilter.prototype.WriteToXml = function (writer) {
        _super.prototype.WriteToXml.call(this, writer, this.GetXmlElementName());
    };
    return SearchFilter;
}(ComplexProperty));
exports.SearchFilter = SearchFilter;
(function (SearchFilter) {
})(SearchFilter = exports.SearchFilter || (exports.SearchFilter = {}));
exports.SearchFilter = SearchFilter;
/**
 * Represents a search filter that negates another. Applications can use NotFilter to define conditions such as "NOT(other filter)".
 */
var Not = (function (_super) {
    __extends(Not, _super);
    function Not(searchFilter) {
        if (searchFilter === void 0) { searchFilter = null; }
        var _this = _super.call(this) || this;
        _this.searchFilter = searchFilter;
        return _this;
    }
    Object.defineProperty(Not.prototype, "SearchFilter", {
        /**
         * Gets or sets the search filter to negate. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection.
         */
        get: function () {
            return this.searchFilter;
        },
        set: function (value) {
            var _this = this;
            if (this.searchFilter !== null) {
                ArrayHelper.RemoveEntry(this.searchFilter.OnChange, this.SearchFilterChanged);
            }
            this.SetFieldValue({ getValue: function () { return _this.searchFilter; }, setValue: function (updateValue) { _this.searchFilter = updateValue; } }, value);
            if (this.searchFilter !== null) {
                this.searchFilter.OnChange.push(this.SearchFilterChanged.bind(this));
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    Not.prototype.GetXmlElementName = function () { return XmlElementNames.Not; };
    /**
     * @internal Validate instance.
     */
    Not.prototype.InternalValidate = function () {
        if (this.searchFilter == null) {
            throw new ServiceValidationException(Strings.SearchFilterMustBeSet);
        }
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    Not.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        this.searchFilter = SearchFilter.LoadFromXmlJsObject(jsObject, service);
    };
    /**
     * Gets or sets the search filter to negate. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection.
     */
    Not.prototype.SearchFilterChanged = function (complexProperty) { this.Changed(); };
    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    Not.prototype.WriteElementsToXml = function (writer) { this.SearchFilter.WriteToXml(writer); };
    return Not;
}(SearchFilter));
exports.Not = Not;
/**
 * Represents a collection of search filters linked by a logical operator. Applications can use SearchFilterCollection to define complex search filters such as "Condition1 AND Condition2".
 */
var SearchFilterCollection = (function (_super) {
    __extends(SearchFilterCollection, _super);
    function SearchFilterCollection(logicalOperator, _searchFilters) {
        var _this = _super.call(this) || this;
        _this.searchFilters = [];
        _this.logicalOperator = LogicalOperator.And;
        var searchFilters = [];
        if (arguments.length <= 2) {
            if (ArrayHelper.isArray(_searchFilters)) {
                searchFilters = _searchFilters;
            }
            else if (typeof SearchFilter[_searchFilters] !== 'undefined') {
                searchFilters.push(arguments[1]);
            }
        }
        else {
            for (var _i = 1; _i < arguments.length; _i++) {
                searchFilters[_i - 1] = arguments[_i];
            }
        }
        _this.logicalOperator = logicalOperator || _this.logicalOperator;
        _this.AddRange(searchFilters);
        return _this;
    }
    Object.defineProperty(SearchFilterCollection.prototype, "Count", {
        /**
         * Gets the total number of search filters in the collection.
         */
        get: function () {
            return this.searchFilters.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchFilterCollection.prototype, "LogicalOperator", {
        /**
         * Gets or sets the logical operator that links the serach filters in this collection.
         */
        get: function () {
            return this.logicalOperator;
        },
        set: function (value) {
            this.logicalOperator = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets or sets the search filter at the specified index.
     *
     * @param   {number}   index   The zero-based index of the search filter to get or set.
     * @return  {SearchFilter}           The search filter at the specified index.
     */
    SearchFilterCollection.prototype._getItem = function (index) {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }
        return this.searchFilters[index];
    };
    /**
     * Gets or sets the search filter at the specified index.
     *
     * @param   {number}   index   The zero-based index of the search filter to get or set.
     * @return  {SearchFilter}           The search filter at the specified index.
     */
    SearchFilterCollection.prototype._setItem = function (index, value) {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }
        this.searchFilters[index] = value;
    };
    /**
     * Adds a search filter of any type to the collection.
     *
     * @param   {SearchFilter}   searchFilter   The search filter to add. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection.
     */
    SearchFilterCollection.prototype.Add = function (searchFilter) {
        if (searchFilter == null) {
            throw new ArgumentNullException("searchFilter");
        }
        searchFilter.OnChange.push(this.SearchFilterChanged.bind(this));
        this.searchFilters.push(searchFilter);
        this.Changed();
    };
    /**
     * Adds multiple search filters to the collection.
     *
     * @param   {SearchFilter[]}   searchFilters   The search filters to add. Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection.
     */
    SearchFilterCollection.prototype.AddRange = function (searchFilters) {
        if (searchFilters == null) {
            throw new ArgumentNullException("searchFilters");
        }
        for (var _a = 0, searchFilters_1 = searchFilters; _a < searchFilters_1.length; _a++) {
            var searchFilter = searchFilters_1[_a];
            searchFilter.OnChange.push(this.SearchFilterChanged.bind(this));
        }
        ArrayHelper.AddRange(this.searchFilters, searchFilters);
        this.Changed();
    };
    /**
     * Clears the collection.
     */
    SearchFilterCollection.prototype.Clear = function () {
        if (this.Count > 0) {
            for (var _a = 0, _b = this.searchFilters; _a < _b.length; _a++) {
                var searchFilter = _b[_a];
                ArrayHelper.RemoveEntry(searchFilter.OnChange, this.SearchFilterChanged);
                //searchFilter.OnChange -= this.SearchFilterChanged;
            }
            this.searchFilters.splice(0);
            this.Changed();
        }
    };
    /**
     * Determines whether a specific search filter is in the collection.
     *
     * @param   {SearchFilter} 	searchFilter   The search filter to locate in the collection.
     * @return  {boolean}		True is the search filter was found in the collection, false otherwise.
     */
    SearchFilterCollection.prototype.Contains = function (searchFilter) {
        return this.searchFilters.indexOf(searchFilter) >= 0;
    };
    /**
     *  Returns an enumerator that iterates through the collection. this case this.items
     */
    SearchFilterCollection.prototype.GetEnumerator = function () {
        return this.searchFilters;
    };
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    SearchFilterCollection.prototype.GetXmlElementName = function () { return LogicalOperator[this.LogicalOperator]; };
    /**
     * @internal Validate instance.
     */
    SearchFilterCollection.prototype.InternalValidate = function () {
        for (var i = 0; i < this.Count; i++) {
            try {
                this._getItem(i).InternalValidate();
            }
            catch (e) {
                if (e instanceof ServiceValidationException) {
                    throw new ServiceValidationException(StringHelper.Format(Strings.SearchFilterAtIndexIsInvalid, i), e);
                }
            }
        }
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}                 jsObject                Json Object converted from XML.
     * @param   {ExchangeService}     service                 The service.
     */
    SearchFilterCollection.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        for (var key in jsObject) {
            if (key.indexOf("__") === 0)
                continue;
            var filter = SearchFilter.LoadFromXmlJsObject(jsObject[key], service, key);
            if (filter) {
                this.Add(filter);
            }
        }
    };
    /**
     * Removes a search filter from the collection.
     *
     * @param   {SearchFilter}   searchFilter   The search filter to remove.
     */
    SearchFilterCollection.prototype.Remove = function (searchFilter) {
        if (searchFilter == null) {
            throw new ArgumentNullException("searchFilter");
        }
        if (this.Contains(searchFilter)) {
            ArrayHelper.RemoveEntry(searchFilter.OnChange, this.SearchFilterChanged);
            ArrayHelper.RemoveEntry(this.searchFilters, searchFilter);
            this.Changed();
        }
    };
    /**
     * Removes the search filter at the specified index from the collection.
     *
     * @param   {number}   index   The zero-based index of the search filter to remove.
     */
    SearchFilterCollection.prototype.RemoveAt = function (index) {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }
        ArrayHelper.RemoveEntry(this._getItem(index).OnChange, this.SearchFilterChanged);
        this.searchFilters.splice(index, 1);
        this.Changed();
    };
    /**
     * A search filter has changed.
     *
     * @param   {ComplexProperty}   complexProperty   The complex property.
     */
    SearchFilterCollection.prototype.SearchFilterChanged = function (complexProperty) { this.Changed(); };
    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    SearchFilterCollection.prototype.WriteElementsToXml = function (writer) {
        for (var _a = 0, _b = this.searchFilters; _a < _b.length; _a++) {
            var searchFilter = _b[_a];
            searchFilter.WriteToXml(writer);
        }
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    SearchFilterCollection.prototype.WriteToXml = function (writer) {
        // If there is only one filter in the collection, which developers tend to do,
        // we need to not emit the collection and instead only emit the one filter within
        // the collection. This is to work around the fact that EWS does not allow filter
        // collections that have less than two elements.
        if (this.Count == 1) {
            this._getItem(0).WriteToXml(writer);
        }
        else {
            _super.prototype.WriteToXml.call(this, writer);
        }
    };
    return SearchFilterCollection;
}(SearchFilter));
exports.SearchFilterCollection = SearchFilterCollection;
var PropertyBasedFilter = (function (_super) {
    __extends(PropertyBasedFilter, _super);
    function PropertyBasedFilter(propertyDefinition) {
        var _this = _super.call(this) || this;
        _this.propertyDefinition = null;
        if (arguments.length === 1) {
            _this.propertyDefinition = propertyDefinition;
        }
        return _this;
    }
    Object.defineProperty(PropertyBasedFilter.prototype, "PropertyDefinition", {
        /**
         * Gets or sets the definition of the property that is involved in the search filter. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
         */
        get: function () {
            return this.propertyDefinition;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.propertyDefinition; }, setValue: function (updateValue) { _this.propertyDefinition = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Validate instance.
     */
    PropertyBasedFilter.prototype.InternalValidate = function () {
        if (this.propertyDefinition == null) {
            throw new ServiceValidationException(Strings.PropertyDefinitionPropertyMustBeSet);
        }
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    PropertyBasedFilter.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        this.PropertyDefinition = PropertyDefinitionBase.LoadFromXmlJsObject(jsObject);
    };
    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    PropertyBasedFilter.prototype.WriteElementsToXml = function (writer) { this.PropertyDefinition.WriteToXml(writer); };
    return PropertyBasedFilter;
}(SearchFilter));
exports.PropertyBasedFilter = PropertyBasedFilter;
/**
 * Represents a search filter that checks for the presence of a substring inside a text property. Applications can use ContainsSubstring to define conditions such as "Field CONTAINS Value" or "Field IS PREFIXED WITH Value".
 */
var ContainsSubstring = (function (_super) {
    __extends(ContainsSubstring, _super);
    function ContainsSubstring(propertyDefinition, value, containmentMode, comparisonMode) {
        if (propertyDefinition === void 0) { propertyDefinition = null; }
        if (value === void 0) { value = null; }
        if (containmentMode === void 0) { containmentMode = ContainmentMode.Substring; }
        if (comparisonMode === void 0) { comparisonMode = ComparisonMode.IgnoreCase; }
        var _this = this;
        arguments.length === 0 ? _this = _super.call(this) || this : _this = _super.call(this, propertyDefinition) || this;
        _this.value = value;
        _this.containmentMode = containmentMode;
        _this.comparisonMode = comparisonMode;
        return _this;
    }
    Object.defineProperty(ContainsSubstring.prototype, "ContainmentMode", {
        /**
         * Gets or sets the containment mode.
         */
        get: function () {
            return this.containmentMode;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.containmentMode; }, setValue: function (updateValue) { _this.containmentMode = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContainsSubstring.prototype, "ComparisonMode", {
        /**
         * Gets or sets the comparison mode.
         */
        get: function () {
            return this.comparisonMode;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.comparisonMode; }, setValue: function (updateValue) { _this.comparisonMode = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContainsSubstring.prototype, "Value", {
        /**
         * Gets or sets the value to compare the specified property with.
         */
        get: function () {
            return this.value;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.value; }, setValue: function (updateValue) { _this.value = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    ContainsSubstring.prototype.GetXmlElementName = function () { return XmlElementNames.Contains; };
    /**
     * @internal Validate instance.
     */
    ContainsSubstring.prototype.InternalValidate = function () {
        _super.prototype.InternalValidate.call(this);
        if (StringHelper.IsNullOrEmpty(this.value)) {
            throw new ServiceValidationException(Strings.ValuePropertyMustBeSet);
        }
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    ContainsSubstring.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        this.value = jsObject[XmlElementNames.Constant][XmlElementNames.Value];
        this.containmentMode = ContainmentMode[jsObject[XmlAttributeNames.ContainmentMode]];
        this.comparisonMode = ComparisonMode[jsObject[XmlAttributeNames.ContainmentComparison]];
    };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ContainsSubstring.prototype.WriteAttributesToXml = function (writer) {
        _super.prototype.WriteAttributesToXml.call(this, writer);
        writer.WriteAttributeValue(XmlAttributeNames.ContainmentMode, ContainmentMode[this.ContainmentMode]);
        writer.WriteAttributeValue(XmlAttributeNames.ContainmentComparison, ComparisonMode[this.ComparisonMode]);
    };
    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ContainsSubstring.prototype.WriteElementsToXml = function (writer) {
        _super.prototype.WriteElementsToXml.call(this, writer);
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Constant);
        writer.WriteAttributeValue(XmlAttributeNames.Value, this.Value);
        writer.WriteEndElement(); // Constant
    };
    return ContainsSubstring;
}(PropertyBasedFilter));
exports.ContainsSubstring = ContainsSubstring;
/**
 * Represents a bitmask exclusion search filter. Applications can use ExcludesBitExcludesBitmaskFilter to define conditions such as "(OrdinalField and 0x0010) != 0x0010"
 */
var ExcludesBitmask = (function (_super) {
    __extends(ExcludesBitmask, _super);
    function ExcludesBitmask(propertyDefinition, bitmask) {
        if (bitmask === void 0) { bitmask = 0; }
        var _this = this;
        arguments.length === 0 ? _this = _super.call(this) || this : _this = _super.call(this, propertyDefinition) || this;
        _this.bitmask = bitmask;
        return _this;
    }
    Object.defineProperty(ExcludesBitmask.prototype, "Bitmask", {
        /**
         * Gets or sets the bitmask to compare the property with.
         */
        get: function () {
            return this.bitmask;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.bitmask; }, setValue: function (updateValue) { _this.bitmask = updateValue; } }, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    ExcludesBitmask.prototype.GetXmlElementName = function () { return XmlElementNames.Excludes; };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}               jsObject                Json Object converted from XML.
     * @param   {ExchangeService}   service                 The service.
     * @param   {string}            typeName                 type name, when provided prevent call for type name check.
     * @return  {SearchFilter}      SearchFilter instance.
     */
    ExcludesBitmask.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        this.bitmask = Convert.toInt(jsObject[XmlElementNames.Bitmask][XmlElementNames.Value]);
    };
    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ExcludesBitmask.prototype.WriteElementsToXml = function (writer) {
        _super.prototype.WriteElementsToXml.call(this, writer);
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Bitmask);
        writer.WriteAttributeValue(XmlAttributeNames.Value, this.Bitmask);
        writer.WriteEndElement(); // Bitmask
    };
    return ExcludesBitmask;
}(PropertyBasedFilter));
exports.ExcludesBitmask = ExcludesBitmask;
/**
 * Represents a search filter checking if a field is set. Applications can use ExistsFilter to define conditions such as "Field IS SET".
 */
var Exists = (function (_super) {
    __extends(Exists, _super);
    function Exists(propertyDefinition) {
        var _this = this;
        arguments.length === 0 ? _this = _super.call(this) || this : _this = _super.call(this, propertyDefinition) || this;
        return _this;
    }
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    Exists.prototype.GetXmlElementName = function () { return XmlElementNames.Exists; };
    return Exists;
}(PropertyBasedFilter));
exports.Exists = Exists;
/**
 * Represents the base class for relational filters (for example, IsEqualTo, IsGreaterThan or IsLessThanOrEqualTo).
 */
var RelationalFilter = (function (_super) {
    __extends(RelationalFilter, _super);
    function RelationalFilter(propertyDefinition, otherPropertyDefinitionOrValue) {
        if (propertyDefinition === void 0) { propertyDefinition = null; }
        if (otherPropertyDefinitionOrValue === void 0) { otherPropertyDefinitionOrValue = null; }
        var _this = this;
        arguments.length === 0 ? _this = _super.call(this) || this : _this = _super.call(this, propertyDefinition) || this;
        if (arguments.length === 0) {
            return;
        }
        if (otherPropertyDefinitionOrValue instanceof PropertyDefinitionBase) {
            _this.otherPropertyDefinition = otherPropertyDefinitionOrValue;
        }
        else {
            _this.value = otherPropertyDefinitionOrValue;
        }
        return _this;
    }
    Object.defineProperty(RelationalFilter.prototype, "OtherPropertyDefinition", {
        /**
         * Gets or sets the definition of the property to compare with. Property definitions are available as static members from schema classes (for example, EmailMessageSchema.Subject, AppointmentSchema.Start, ContactSchema.GivenName, etc.)
         * The OtherPropertyDefinition and Value properties are mutually exclusive; setting one resets the other to null.
         */
        get: function () {
            return this.otherPropertyDefinition;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.otherPropertyDefinition; }, setValue: function (updateValue) { _this.otherPropertyDefinition = updateValue; } }, value);
            this.value = null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RelationalFilter.prototype, "Value", {
        /**
         * Gets or sets the value to compare with. The Value and OtherPropertyDefinition properties are mutually exclusive; setting one resets the other to null.
         */
        get: function () {
            return this.value;
        },
        set: function (value) {
            var _this = this;
            this.SetFieldValue({ getValue: function () { return _this.value; }, setValue: function (updateValue) { _this.value = updateValue; } }, value);
            this.otherPropertyDefinition = null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Validate instance.
     */
    RelationalFilter.prototype.InternalValidate = function () {
        _super.prototype.InternalValidate.call(this);
        if (this.otherPropertyDefinition == null && this.value == null) {
            throw new ServiceValidationException(Strings.EqualityComparisonFilterIsInvalid);
        }
        else if (this.value != null) {
            // All common value types (String, Int32, DateTime, ...) implement IConvertible.
            // Value types that don't implement IConvertible must implement ISearchStringProvider 
            // in order to be used in a search filter.
            if (!(TypeSystem.IsGenericType(this.value) || (typeof this.value.GetSearchString === 'function'))) {
                throw new ServiceValidationException(StringHelper.Format(Strings.SearchFilterComparisonValueTypeIsNotSupported, this.constructor.name));
            }
        }
    };
    /**
     * @internal Loads service object from XML.
     *
     * @param   {any}				jsObject	Json Object converted from XML.
     * @param   {ExchangeService}	service	The service.
     */
    RelationalFilter.prototype.LoadFromXmlJsObject = function (jsObject, service) {
        _super.prototype.LoadFromXmlJsObject.call(this, jsObject, service);
        var jsonFieldUriOrConstant = jsObject[XmlElementNames.FieldURIOrConstant];
        if (TypeSystem.GetJsObjectTypeName(jsonFieldUriOrConstant) == XmlElementNames.Constant) {
            this.value = jsonFieldUriOrConstant[XmlElementNames.Value];
        }
        else {
            this.otherPropertyDefinition = PropertyDefinitionBase.LoadFromXmlJsObject(jsObject);
        }
    };
    /**
     * @internal Writes the elements to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    RelationalFilter.prototype.WriteElementsToXml = function (writer) {
        _super.prototype.WriteElementsToXml.call(this, writer);
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.FieldURIOrConstant);
        if (this.Value != null) {
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Constant);
            writer.WriteAttributeValue(XmlAttributeNames.Value, true /* alwaysWriteEmptyString */, this.Value);
            writer.WriteEndElement(); // Constant
        }
        else {
            this.OtherPropertyDefinition.WriteToXml(writer);
        }
        writer.WriteEndElement(); // FieldURIOrConstant
    };
    return RelationalFilter;
}(PropertyBasedFilter));
exports.RelationalFilter = RelationalFilter;
/**
 * Represents a search filter that checks if a property is equal to a given value or other property.
 */
var IsEqualTo = (function (_super) {
    __extends(IsEqualTo, _super);
    function IsEqualTo(propertyDefinition, otherPropertyDefinitionOrValue) {
        var _this = this;
        arguments.length === 0 ? _this = _super.call(this) || this : _this = _super.call(this, propertyDefinition, otherPropertyDefinitionOrValue) || this;
        return _this;
    }
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    IsEqualTo.prototype.GetXmlElementName = function () { return XmlElementNames.IsEqualTo; };
    return IsEqualTo;
}(RelationalFilter));
exports.IsEqualTo = IsEqualTo;
/**
 * Represents a search filter that checks if a property is greater than a given value or other property.
 */
var IsGreaterThan = (function (_super) {
    __extends(IsGreaterThan, _super);
    function IsGreaterThan(propertyDefinition, otherPropertyDefinitionOrValue) {
        var _this = this;
        arguments.length === 0 ? _this = _super.call(this) || this : _this = _super.call(this, propertyDefinition, otherPropertyDefinitionOrValue) || this;
        return _this;
    }
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    IsGreaterThan.prototype.GetXmlElementName = function () { return XmlElementNames.IsGreaterThan; };
    return IsGreaterThan;
}(RelationalFilter));
exports.IsGreaterThan = IsGreaterThan;
/**
 * Represents a search filter that checks if a property is greater than or equal to a given value or other property.
 */
var IsGreaterThanOrEqualTo = (function (_super) {
    __extends(IsGreaterThanOrEqualTo, _super);
    function IsGreaterThanOrEqualTo(propertyDefinition, otherPropertyDefinitionOrValue) {
        var _this = this;
        arguments.length === 0 ? _this = _super.call(this) || this : _this = _super.call(this, propertyDefinition, otherPropertyDefinitionOrValue) || this;
        return _this;
    }
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    IsGreaterThanOrEqualTo.prototype.GetXmlElementName = function () { return XmlElementNames.IsGreaterThanOrEqualTo; };
    return IsGreaterThanOrEqualTo;
}(RelationalFilter));
exports.IsGreaterThanOrEqualTo = IsGreaterThanOrEqualTo;
/**
 * Represents a search filter that checks if a property is less than a given value or other property.
 */
var IsLessThan = (function (_super) {
    __extends(IsLessThan, _super);
    function IsLessThan(propertyDefinition, otherPropertyDefinitionOrValue) {
        var _this = this;
        arguments.length === 0 ? _this = _super.call(this) || this : _this = _super.call(this, propertyDefinition, otherPropertyDefinitionOrValue) || this;
        return _this;
    }
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    IsLessThan.prototype.GetXmlElementName = function () { return XmlElementNames.IsLessThan; };
    return IsLessThan;
}(RelationalFilter));
exports.IsLessThan = IsLessThan;
/**
 * Represents a search filter that checks if a property is less than or equal to a given value or other property.
 */
var IsLessThanOrEqualTo = (function (_super) {
    __extends(IsLessThanOrEqualTo, _super);
    function IsLessThanOrEqualTo(propertyDefinition, otherPropertyDefinitionOrValue) {
        var _this = this;
        arguments.length === 0 ? _this = _super.call(this) || this : _this = _super.call(this, propertyDefinition, otherPropertyDefinitionOrValue) || this;
        return _this;
    }
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    IsLessThanOrEqualTo.prototype.GetXmlElementName = function () { return XmlElementNames.IsLessThanOrEqualTo; };
    return IsLessThanOrEqualTo;
}(RelationalFilter));
exports.IsLessThanOrEqualTo = IsLessThanOrEqualTo;
/**
 * Represents a search filter that checks if a property is not equal to a given value or other property.
 */
var IsNotEqualTo = (function (_super) {
    __extends(IsNotEqualTo, _super);
    function IsNotEqualTo(propertyDefinition, otherPropertyDefinitionOrValue) {
        var _this = this;
        arguments.length === 0 ? _this = _super.call(this) || this : _this = _super.call(this, propertyDefinition, otherPropertyDefinitionOrValue) || this;
        return _this;
    }
    /**
     * @internal Gets the name of the XML element.
     *
     * @return  {string}      XML element name.
     */
    IsNotEqualTo.prototype.GetXmlElementName = function () { return XmlElementNames.IsNotEqualTo; };
    return IsNotEqualTo;
}(RelationalFilter));
exports.IsNotEqualTo = IsNotEqualTo;
SearchFilter.ContainsSubstring = ContainsSubstring;
SearchFilter.ExcludesBitmask = ExcludesBitmask;
SearchFilter.Exists = Exists;
SearchFilter.IsEqualTo = IsEqualTo;
SearchFilter.IsGreaterThan = IsGreaterThan;
SearchFilter.IsGreaterThanOrEqualTo = IsGreaterThanOrEqualTo;
SearchFilter.IsLessThan = IsLessThan;
SearchFilter.IsLessThanOrEqualTo = IsLessThanOrEqualTo;
SearchFilter.IsNotEqualTo = IsNotEqualTo;
SearchFilter.Not = Not;
SearchFilter.PropertyBasedFilter = PropertyBasedFilter;
SearchFilter.RelationalFilter = RelationalFilter;
SearchFilter.SearchFilterCollection = SearchFilterCollection;
/**
 * Represents the base view class for search operations.
 */
var ViewBase = (function () {
    /**
     * @internal Initializes a new instance of the **ViewBase** class.
     */
    function ViewBase() {
        this.propertySet = null;
    }
    Object.defineProperty(ViewBase.prototype, "PropertySet", {
        /**
         * Gets or sets the property set. PropertySet determines which properties will be loaded on found items. If PropertySet is null, all first class properties are loaded on found items.
         */
        get: function () {
            return this.propertySet;
        },
        set: function (value) {
            this.propertySet = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets the property set or the default.
     *
     * @return  {PropertySet}      PropertySet
     */
    ViewBase.prototype.GetPropertySetOrDefault = function () { return this.PropertySet || PropertySet.FirstClassProperties; };
    /**
     * @internal Gets the type of service object this view applies to.
     *
     * @return  {ServiceObjectType}      A ServiceObjectType value.
     */
    ViewBase.prototype.GetServiceObjectType = function () { throw new Error("abstract - ViewBase.ts - GetServiceObjectType : Not implemented."); };
    /**
     * @internal Validates this view.
     *
     * @param   {ServiceRequestBase}   request   The request using this view.
     */
    ViewBase.prototype.InternalValidate = function (request) {
        if (this.PropertySet !== null && typeof this.PropertySet !== 'undefined') {
            this.PropertySet.InternalValidate();
            this.PropertySet.ValidateForRequest(request, true /*summaryPropertiesOnly*/);
        }
    };
    /**
     * @internal Writes this view to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ViewBase.prototype.InternalWriteViewToXml = function (writer) {
        var maxEntriesReturned = this.GetMaxEntriesReturned();
        if (!isNaN(maxEntriesReturned)) {
            writer.WriteAttributeValue(XmlAttributeNames.MaxEntriesReturned, maxEntriesReturned);
        }
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer    The writer.
     * @param   {Grouping}              groupBy   The group by clause.
     */
    ViewBase.prototype.WriteToXml = function (writer, groupBy) {
        this.GetPropertySetOrDefault().WriteToXml(writer, this.GetServiceObjectType());
        writer.WriteStartElement(XmlNamespace.Messages, this.GetViewXmlElementName());
        this.InternalWriteViewToXml(writer);
        writer.WriteEndElement(); // this.GetViewXmlElementName()
        this.InternalWriteSearchSettingsToXml(writer, groupBy);
    };
    return ViewBase;
}());
exports.ViewBase = ViewBase;
/**
 * Represents a date range view of appointments in calendar folder search operations.
 */
var CalendarView = (function (_super) {
    __extends(CalendarView, _super);
    function CalendarView(startDate, endDate, maxItemsReturned) {
        if (maxItemsReturned === void 0) { maxItemsReturned = null; }
        var _this = _super.call(this) || this;
        _this.traversal = ItemTraversal.Shallow;
        _this.maxItemsReturned = null;
        _this.startDate = null;
        _this.endDate = null;
        _this.startDate = startDate;
        _this.endDate = endDate;
        _this.MaxItemsReturned = maxItemsReturned;
        return _this;
    }
    Object.defineProperty(CalendarView.prototype, "StartDate", {
        /**
         * Gets or sets the start date.
         */
        get: function () {
            return this.startDate;
        },
        set: function (value) {
            this.startDate = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarView.prototype, "EndDate", {
        /**
         * Gets or sets the end date.
         */
        get: function () {
            return this.endDate;
        },
        set: function (value) {
            this.endDate = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarView.prototype, "MaxItemsReturned", {
        /**
         * The maximum number of items the search operation should return.
         */
        get: function () {
            return this.maxItemsReturned;
        },
        set: function (value) {
            if (value !== null && value <= 0) {
                throw new ArgumentException(Strings.ValueMustBeGreaterThanZero);
            }
            this.maxItemsReturned = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarView.prototype, "Traversal", {
        /**
         * Gets or sets the search traversal mode. Defaults to ItemTraversal.Shallow.
         */
        get: function () {
            return this.traversal;
        },
        set: function (value) {
            this.traversal = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets the maximum number of items or folders the search operation should return.
     *
     * @return  {number}      The maximum number of items the search operation should return.
     */
    CalendarView.prototype.GetMaxEntriesReturned = function () { return this.MaxItemsReturned; };
    /**
     * @internal Gets the type of service object this view applies to.
     *
     * @return  {ServiceObjectType}      A ServiceObjectType value.
     */
    CalendarView.prototype.GetServiceObjectType = function () { return ServiceObjectType.Item; };
    /**
     * @internal Gets the name of the view XML element.
     *
     * @return  {string}      XML element name.
     */
    CalendarView.prototype.GetViewXmlElementName = function () { return XmlElementNames.CalendarView; };
    /**
     * @internal Validate instance.
     *
     * @param   {ServiceRequestBase}   request   The request using this view.
     */
    CalendarView.prototype.InternalValidate = function (request) {
        _super.prototype.InternalValidate.call(this, request);
        if (this.endDate < this.StartDate) {
            throw new ServiceValidationException(Strings.EndDateMustBeGreaterThanStartDate);
        }
    };
    /**
     * @internal Writes the search settings to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer    The writer.
     * @param   {Grouping}              groupBy   The group by clause.
     */
    CalendarView.prototype.InternalWriteSearchSettingsToXml = function (writer, groupBy) { };
    /**
     * @internal Write to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    CalendarView.prototype.InternalWriteViewToXml = function (writer) {
        _super.prototype.InternalWriteViewToXml.call(this, writer);
        writer.WriteAttributeValue(XmlAttributeNames.StartDate, this.StartDate);
        writer.WriteAttributeValue(XmlAttributeNames.EndDate, this.EndDate);
    };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    CalendarView.prototype.WriteAttributesToXml = function (writer) { writer.WriteAttributeValue(XmlAttributeNames.Traversal, ItemTraversal[this.Traversal]); };
    /**
     * @internal Writes OrderBy property to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer
     */
    CalendarView.prototype.WriteOrderByToXml = function (writer) { };
    return CalendarView;
}(ViewBase));
exports.CalendarView = CalendarView;
/**
 * Represents the view settings in a folder search operation.
 *
 * @sealed
 */
var SeekToConditionItemView = (function (_super) {
    __extends(SeekToConditionItemView, _super);
    function SeekToConditionItemView(condition, pageSize, offsetBasePoint) {
        if (offsetBasePoint === void 0) { offsetBasePoint = OffsetBasePoint.Beginning; }
        var _this = _super.call(this) || this;
        _this.pageSize = null;
        _this.traversal = ItemTraversal.Shallow;
        _this.condition = null;
        _this.offsetBasePoint = OffsetBasePoint.Beginning;
        _this.orderBy = new OrderByCollection();
        _this.serviceObjType = ServiceObjectType.Folder;
        _this.condition = condition;
        _this.pageSize = pageSize;
        _this.serviceObjType = ServiceObjectType.Item;
        _this.offsetBasePoint = offsetBasePoint;
        return _this;
    }
    Object.defineProperty(SeekToConditionItemView.prototype, "PageSize", {
        /**
         * The maximum number of items or folders the search operation should return.
         */
        get: function () {
            return this.pageSize;
        },
        set: function (value) {
            if (value <= 0) {
                throw new ArgumentException(Strings.ValueMustBeGreaterThanZero);
            }
            this.pageSize = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SeekToConditionItemView.prototype, "OffsetBasePoint", {
        /**
         * Gets or sets the base point of the offset.
         */
        get: function () {
            return this.offsetBasePoint;
        },
        set: function (value) {
            this.offsetBasePoint = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SeekToConditionItemView.prototype, "Condition", {
        /**
         * Gets or sets the condition for seek.
         * Available search filter classes include SearchFilter.IsEqualTo, SearchFilter.ContainsSubstring and SearchFilter.SearchFilterCollection.
         * If SearchFilter is null, no search filters are applied.
         */
        get: function () {
            return this.condition;
        },
        set: function (value) {
            if (value === null) {
                throw new ArgumentNullException("Condition");
            }
            this.condition = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SeekToConditionItemView.prototype, "Traversal", {
        /**
         * Gets or sets the search traversal mode. Defaults to ItemTraversal.Shallow.
         */
        get: function () {
            return this.traversal;
        },
        set: function (value) {
            this.traversal = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SeekToConditionItemView.prototype, "OrderBy", {
        /**
         * Gets the properties against which the returned items should be ordered.
         */
        get: function () {
            return this.orderBy;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets the maximum number of items or folders the search operation should return.
     *
     * @return  {number?}      The maximum number of items or folders that should be returned by the search operation.
     */
    SeekToConditionItemView.prototype.GetMaxEntriesReturned = function () {
        return this.PageSize;
    };
    /**
     * @internal Gets the type of service object this view applies to.
     *
     * @return  {ServiceObjectType}      A ServiceObjectType value.
     */
    SeekToConditionItemView.prototype.GetServiceObjectType = function () {
        return this.serviceObjType;
    };
    /**
     * @internal Gets the name of the view XML element.
     *
     * @return  {string}      XML element name.
     */
    SeekToConditionItemView.prototype.GetViewXmlElementName = function () {
        return XmlElementNames.SeekToConditionPageItemView;
    };
    /**
     * @internal Validates this view.
     *
     * @param   {ServiceRequestBase}   request   The request using this view.
     */
    SeekToConditionItemView.prototype.InternalValidate = function (request) {
        _super.prototype.InternalValidate.call(this, request);
    };
    /**
     * @internal Writes the search settings to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer    The writer.
     * @param   {Grouping}              groupBy   The group by clause.
     */
    SeekToConditionItemView.prototype.InternalWriteSearchSettingsToXml = function (writer, groupBy) {
        if (groupBy != null) {
            groupBy.WriteToXml(writer);
        }
    };
    /**
     * @internal Writes this view to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    SeekToConditionItemView.prototype.InternalWriteViewToXml = function (writer) {
        _super.prototype.InternalWriteViewToXml.call(this, writer);
        writer.WriteAttributeValue(XmlAttributeNames.BasePoint, this.OffsetBasePoint);
        if (this.Condition != null) {
            writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.Condition);
            this.Condition.WriteToXml(writer);
            writer.WriteEndElement(); // Restriction
        }
    };
    /**
     * @internal Sets the type of service object this view applies to.
     *
     * @return  {ServiceObjectType}      Service object type
     */
    SeekToConditionItemView.prototype.SetServiceObjectType = function (objType) {
        this.serviceObjType = objType;
    };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    SeekToConditionItemView.prototype.WriteAttributesToXml = function (writer) {
        if (this.serviceObjType == ServiceObjectType.Item) {
            writer.WriteAttributeValue(XmlAttributeNames.Traversal, this.Traversal);
        }
    };
    /**
     * @internal Writes OrderBy property to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    SeekToConditionItemView.prototype.WriteOrderByToXml = function (writer) {
        this.orderBy.WriteToXml(writer, XmlElementNames.SortOrder);
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer    The writer.
     * @param   {Grouping}              groupBy   The group by clause.
     */
    SeekToConditionItemView.prototype.WriteToXml = function (writer, groupBy) {
        if (this.serviceObjType == ServiceObjectType.Item) {
            this.GetPropertySetOrDefault().WriteToXml(writer, this.GetServiceObjectType());
        }
        writer.WriteStartElement(XmlNamespace.Messages, this.GetViewXmlElementName());
        this.InternalWriteViewToXml(writer);
        writer.WriteEndElement(); // this.GetViewXmlElementName()
    };
    return SeekToConditionItemView;
}(ViewBase));
exports.SeekToConditionItemView = SeekToConditionItemView;
/**
 * Represents a view settings that support paging in a search operation.
 */
var PagedView = (function (_super) {
    __extends(PagedView, _super);
    function PagedView(pageSize, offset, offsetBasePoint) {
        if (offset === void 0) { offset = 0; }
        if (offsetBasePoint === void 0) { offsetBasePoint = OffsetBasePoint.Beginning; }
        var _this = _super.call(this) || this;
        _this.pageSize = 0;
        _this.offsetBasePoint = OffsetBasePoint.Beginning;
        _this.offset = 0;
        _this.pageSize = pageSize;
        _this.Offset = offset;
        _this.OffsetBasePoint = offsetBasePoint;
        return _this;
    }
    Object.defineProperty(PagedView.prototype, "PageSize", {
        /**
         * The maximum number of items or folders the search operation should return.
         */
        get: function () { return this.pageSize; },
        set: function (value) {
            if (value <= 0) {
                throw new Error(Strings.ValueMustBeGreaterThanZero);
            }
            this.pageSize = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PagedView.prototype, "OffsetBasePoint", {
        /**
         * Gets or sets the base point of the offset.
         */
        get: function () {
            return this.offsetBasePoint;
        },
        set: function (value) {
            this.offsetBasePoint = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PagedView.prototype, "Offset", {
        /**
         * Gets or sets the offset.
         */
        get: function () { return this.offset; },
        set: function (value) {
            if (value >= 0) {
                this.offset = value;
            }
            else {
                throw new Error(Strings.OffsetMustBeGreaterThanZero);
            }
        },
        enumerable: true,
        configurable: true
    });
    ;
    /**
     * @internal Gets the maximum number of items or folders the search operation should return.
     *
     * @return  {number?}      The maximum number of items or folders that should be returned by the search operation.
     */
    PagedView.prototype.GetMaxEntriesReturned = function () { return this.PageSize; };
    /**
     * @internal Validates this view.
     *
     * @param   {ServiceRequestBase}   request   The request using this view.
     */
    PagedView.prototype.InternalValidate = function (request) { _super.prototype.InternalValidate.call(this, request); };
    /**
     * @internal Writes the search settings to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer    The writer.
     * @param   {Grouping}              groupBy   The group by clause.
     */
    PagedView.prototype.InternalWriteSearchSettingsToXml = function (writer, groupBy) {
        if (groupBy !== null && typeof groupBy !== 'undefined') {
            groupBy.WriteToXml(writer);
        }
    };
    /**
     * @internal Writes this view to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    PagedView.prototype.InternalWriteViewToXml = function (writer) {
        _super.prototype.InternalWriteViewToXml.call(this, writer);
        writer.WriteAttributeValue(XmlAttributeNames.Offset, this.Offset);
        writer.WriteAttributeValue(XmlAttributeNames.BasePoint, OffsetBasePoint[this.OffsetBasePoint]);
    };
    /**
     * @internal Writes OrderBy property to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    PagedView.prototype.WriteOrderByToXml = function (writer) {
        /* No order by for paged view*/
    };
    return PagedView;
}(ViewBase));
exports.PagedView = PagedView;
/**
 * Represents the view settings in a folder search operation.
 *
 * @sealed
 */
var ConversationIndexedItemView = (function (_super) {
    __extends(ConversationIndexedItemView, _super);
    function ConversationIndexedItemView(pageSize, offset, offsetBasePoint) {
        if (offset === void 0) { offset = 0; }
        if (offsetBasePoint === void 0) { offsetBasePoint = OffsetBasePoint.Beginning; }
        var _this = _super.call(this, pageSize, offset, offsetBasePoint) || this;
        _this.orderBy = new OrderByCollection();
        _this.traversal = null;
        _this.viewFilter = null;
        return _this;
    }
    Object.defineProperty(ConversationIndexedItemView.prototype, "OrderBy", {
        /**
         * Gets the properties against which the returned items should be ordered.
         */
        get: function () {
            return this.orderBy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConversationIndexedItemView.prototype, "Traversal", {
        /**
         * Gets or sets the conversation query traversal mode.
         *
         * @Nullable
         */
        get: function () {
            return this.traversal;
        },
        set: function (value) {
            this.traversal = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConversationIndexedItemView.prototype, "ViewFilter", {
        /**
         * Gets or sets the view filter.
         *
         * @Nullable
         */
        get: function () {
            return this.viewFilter;
        },
        set: function (value) {
            this.viewFilter = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets the type of service object this view applies to.
     *
     * @return  {ServiceObjectType}      A ServiceObjectType value.
     */
    ConversationIndexedItemView.prototype.GetServiceObjectType = function () {
        return ServiceObjectType.Conversation;
    };
    /**
     * @internal Gets the name of the view XML element.
     *
     * @return  {type}      XML element name.
     */
    ConversationIndexedItemView.prototype.GetViewXmlElementName = function () {
        return XmlElementNames.IndexedPageItemView;
    };
    /**
     * @internal Validates this view.
     *
     * @param   {ServiceRequestBase}   request   The request using this view.
     */
    ConversationIndexedItemView.prototype.InternalValidate = function (request) {
        _super.prototype.InternalValidate.call(this, request);
        if (this.Traversal) {
            EwsUtilities.ValidateEnumVersionValue(ConversationQueryTraversal, this.traversal, request.Service.RequestedServerVersion, "ConversationQueryTraversal");
        }
        if (this.ViewFilter) {
            EwsUtilities.ValidateEnumVersionValue(ViewFilter, this.viewFilter, request.Service.RequestedServerVersion, "ViewFilter");
        }
    };
    /**
     * @internal Writes the search settings to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer    The writer.
     * @param   {Grouping}              groupBy   The group by clause.
     */
    ConversationIndexedItemView.prototype.InternalWriteSearchSettingsToXml = function (writer, groupBy) {
        _super.prototype.InternalWriteSearchSettingsToXml.call(this, writer, groupBy);
    };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ConversationIndexedItemView.prototype.WriteAttributesToXml = function (writer) {
        if (this.Traversal) {
            writer.WriteAttributeValue(XmlAttributeNames.Traversal, ConversationQueryTraversal[this.Traversal]);
        }
        if (this.ViewFilter) {
            writer.WriteAttributeValue(XmlAttributeNames.ViewFilter, ViewFilter[this.ViewFilter]);
        }
    };
    /**
     * @internal Writes OrderBy property to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ConversationIndexedItemView.prototype.WriteOrderByToXml = function (writer) {
        this.orderBy.WriteToXml(writer, XmlElementNames.SortOrder);
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer    The writer.
     * @param   {Grouping}              groupBy   The group by clause.
     */
    ConversationIndexedItemView.prototype.WriteToXml = function (writer, groupBy) {
        writer.WriteStartElement(XmlNamespace.Messages, this.GetViewXmlElementName());
        this.InternalWriteViewToXml(writer);
        writer.WriteEndElement(); // this.GetViewXmlElementName()
    };
    return ConversationIndexedItemView;
}(PagedView));
exports.ConversationIndexedItemView = ConversationIndexedItemView;
/**
 * Represents the view settings in a folder search operation.
 *
 * @sealed
 */
var FolderView = (function (_super) {
    __extends(FolderView, _super);
    function FolderView(pageSize, offset, offsetBasePoint) {
        if (offset === void 0) { offset = 0; }
        if (offsetBasePoint === void 0) { offsetBasePoint = OffsetBasePoint.Beginning; }
        var _this = _super.call(this, pageSize, offset, offsetBasePoint) || this;
        _this.traversal = FolderTraversal.Shallow;
        return _this;
    }
    Object.defineProperty(FolderView.prototype, "Traversal", {
        /**
         * Gets or sets the search traversal mode. Defaults to FolderTraversal.Shallow.     *
         */
        get: function () {
            return this.traversal;
        },
        set: function (value) {
            this.traversal = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets the type of service object this view applies to.
     *
     * @return  {ServiceObjectType}      A ServiceObjectType value.
     */
    FolderView.prototype.GetServiceObjectType = function () { return ServiceObjectType.Folder; };
    /**
     * @internal Gets the name of the view XML element.
     *
     * @return  {type}      XML element name.
     */
    FolderView.prototype.GetViewXmlElementName = function () { return XmlElementNames.IndexedPageFolderView; };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    FolderView.prototype.WriteAttributesToXml = function (writer) { writer.WriteAttributeValue(XmlAttributeNames.Traversal, FolderTraversal[this.Traversal]); };
    return FolderView;
}(PagedView));
exports.FolderView = FolderView;
/**
 * Represents the view settings in a folder search operation.
 *
 * @sealed
 */
var ItemView = (function (_super) {
    __extends(ItemView, _super);
    function ItemView(pageSize, offset, offsetBasePoint) {
        if (offset === void 0) { offset = 0; }
        if (offsetBasePoint === void 0) { offsetBasePoint = OffsetBasePoint.Beginning; }
        var _this = _super.call(this, pageSize, offset, offsetBasePoint) || this;
        _this.traversal = ItemTraversal.Shallow;
        _this.orderBy = new OrderByCollection();
        return _this;
    }
    Object.defineProperty(ItemView.prototype, "Traversal", {
        /**
         * Gets or sets the search traversal mode. Defaults to ItemTraversal.Shallow.
         */
        get: function () {
            return this.traversal;
        },
        set: function (value) {
            this.traversal = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ItemView.prototype, "OrderBy", {
        /**
         * Gets the properties against which the returned items should be ordered.
         */
        get: function () { return this.orderBy; },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Gets the type of service object this view applies to.
     *
     * @return  {ServiceObjectType}      A ServiceObjectType value.
     */
    ItemView.prototype.GetServiceObjectType = function () { return ServiceObjectType.Item; };
    /**
     * @internal Gets the name of the view XML element.
     *
     * @return  {type}      XML element name.
     */
    ItemView.prototype.GetViewXmlElementName = function () { return XmlElementNames.IndexedPageItemView; };
    /**
     * @internal Validates this view.
     *
     * @param   {ServiceRequestBase}   request   The request using this view.
     */
    ItemView.prototype.InternalValidate = function (request) {
        _super.prototype.InternalValidate.call(this, request);
        EwsUtilities.ValidateEnumVersionValue(ItemTraversal, this.Traversal, request.Service.RequestedServerVersion, "ItemTraversal");
    };
    /**
     * @internal Writes the search settings to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer    The writer.
     * @param   {Grouping}              groupBy   The group by clause.
     */
    ItemView.prototype.InternalWriteSearchSettingsToXml = function (writer, groupBy) {
        _super.prototype.InternalWriteSearchSettingsToXml.call(this, writer, groupBy);
    };
    /**
     * @internal Writes the attributes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ItemView.prototype.WriteAttributesToXml = function (writer) {
        writer.WriteAttributeValue(XmlAttributeNames.Traversal, ItemTraversal[this.Traversal]);
    };
    /**
     * @internal Writes OrderBy property to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    ItemView.prototype.WriteOrderByToXml = function (writer) {
        this.orderBy.WriteToXml(writer, XmlElementNames.SortOrder);
    };
    return ItemView;
}(PagedView));
exports.ItemView = ItemView;
/**
 * Represents the results of an conversation search operation.
 *
 * @sealed
 */
var FindConversationResults = (function () {
    /**
     * @internal Initializes a new instance of the **FindConversationResults** class.
     */
    function FindConversationResults() {
        /**
         * Gets a collection containing the conversations that were found by the search operation.
         */
        this.Conversations = [];
        /**
         * Gets a collection containing the HighlightTerms that were returned by the search operation.
         */
        this.HighlightTerms = [];
        /**
         * Gets the total count of conversations in view.
         */
        this.TotalCount = null;
        /**
         * Gets the indexed offset of the first conversation by the search operation.
         */
        this.IndexedOffset = null;
    }
    return FindConversationResults;
}());
exports.FindConversationResults = FindConversationResults;
/**
 * Represents the results of a folder search operation.
 *
 * @sealed
 */
var FindFoldersResults = (function () {
    /**
     * @internal Initializes a new instance of the **FindFoldersResults** class.
     *
     */
    function FindFoldersResults() {
        this.totalCount = 0;
        this.nextPageOffset = null;
        this.moreAvailable = false;
        this.folders = [];
    }
    Object.defineProperty(FindFoldersResults.prototype, "TotalCount", {
        /**
         * Gets the total number of folders matching the search criteria available in the searched folder.
         */
        get: function () {
            return this.totalCount;
        },
        set: function (value) {
            this.totalCount = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindFoldersResults.prototype, "NextPageOffset", {
        /**
         * Gets the offset that should be used with FolderView to retrieve the next page of folders in a FindFolders operation.
         */
        get: function () {
            return this.nextPageOffset;
        },
        set: function (value) {
            this.nextPageOffset = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindFoldersResults.prototype, "MoreAvailable", {
        /**
         * Gets a value indicating whether more folders matching the search criteria.
         */
        get: function () {
            return this.moreAvailable;
        },
        set: function (value) {
            this.moreAvailable = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindFoldersResults.prototype, "Folders", {
        /**
         * Gets a collection containing the folders that were found by the search operation.
         */
        get: function () {
            return this.folders;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *  Returns an enumerator that iterates through the collection. this case this.items
     */
    FindFoldersResults.prototype.GetEnumerator = function () {
        return this.folders;
    };
    return FindFoldersResults;
}());
exports.FindFoldersResults = FindFoldersResults;
/**
 * Represents the results of an item search operation.
 *
 * @sealed
 * @type    {TItem}  Item type
 */
var FindItemsResults = (function () {
    /**
     * @internal Initializes a new instance of the **FindItemsResults<T>** class.
     */
    function FindItemsResults() {
        this.totalCount = 0;
        this.nextPageOffset = null;
        this.moreAvailable = false;
        this.items = [];
        this.highlightTerms = [];
    }
    Object.defineProperty(FindItemsResults.prototype, "TotalCount", {
        /**
         * Gets the total number of items matching the search criteria available in the searched folder.
         */
        get: function () {
            return this.totalCount;
        },
        set: function (value) {
            this.totalCount = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindItemsResults.prototype, "NextPageOffset", {
        /**
         * Gets the offset that should be used with ItemView to retrieve the next page of items in a FindItems operation.
         */
        get: function () {
            return this.nextPageOffset;
        },
        set: function (value) {
            this.nextPageOffset = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindItemsResults.prototype, "MoreAvailable", {
        /**
         * Gets a value indicating whether more items matching the search criteria are available in the searched folder.
         */
        get: function () {
            return this.moreAvailable;
        },
        set: function (value) {
            this.moreAvailable = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindItemsResults.prototype, "Items", {
        /**
         * Gets a collection containing the items that were found by the search operation.
         */
        get: function () {
            return this.items;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FindItemsResults.prototype, "HighlightTerms", {
        /**
         * Gets a collection containing the highlight terms that were found by the search operation.
         */
        get: function () {
            return this.highlightTerms;
        },
        enumerable: true,
        configurable: true
    });
    return FindItemsResults;
}());
exports.FindItemsResults = FindItemsResults;
/**
 * Represents the results of an item search operation.
 *
 * @sealed
 * @type    {TItem} The type of item returned by the search operation.
 */
var GroupedFindItemsResults = (function () {
    /**
     * @internal Initializes a new instance of the **GroupedFindItemsResults<TItem>** class.
     */
    function GroupedFindItemsResults() {
        this.totalCount = 0;
        this.nextPageOffset = null;
        this.moreAvailable = false;
        /**
         * List of ItemGroups.
         */
        this.itemGroups = [];
    }
    Object.defineProperty(GroupedFindItemsResults.prototype, "TotalCount", {
        /**
         * Gets the total number of items matching the search criteria available in the searched folder.
         */
        get: function () {
            return this.totalCount;
        },
        set: function (value) {
            this.totalCount = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GroupedFindItemsResults.prototype, "NextPageOffset", {
        /**
         * Gets the offset that should be used with ItemView to retrieve the next page of items in a FindItems operation.
         */
        get: function () {
            return this.nextPageOffset;
        },
        set: function (value) {
            this.nextPageOffset = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GroupedFindItemsResults.prototype, "MoreAvailable", {
        /**
         * Gets a value indicating whether more items corresponding to the search criteria are available in the searched folder.
         */
        get: function () {
            return this.moreAvailable;
        },
        set: function (value) {
            this.moreAvailable = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GroupedFindItemsResults.prototype, "ItemGroups", {
        /**
         * Gets the item groups returned by the search operation.
         */
        get: function () {
            return this.itemGroups;
        },
        enumerable: true,
        configurable: true
    });
    GroupedFindItemsResults.prototype.GetEnumerator = function () { throw new Error("GroupedFindItemsResults.ts - GetEnumerator : Not implemented."); };
    return GroupedFindItemsResults;
}());
exports.GroupedFindItemsResults = GroupedFindItemsResults;
/**
 * Represents grouping options in item search operations.
 *
 * @sealed
 */
var Grouping = (function () {
    function Grouping(groupOn, sortDirection, aggregateOn, aggregateType) {
        /**
         * Gets or sets the sort direction.
         */
        this.SortDirection = SortDirection.Ascending;
        /**
         * Gets or sets the property to group on.
         */
        this.GroupOn = null;
        /**
         * Gets or sets the property to aggregate on.
         */
        this.AggregateOn = null;
        /**
         * Gets or sets the types of aggregate to calculate.
         */
        this.AggregateType = AggregateType.Minimum;
        if (arguments.length > 0 && arguments.length < 4) {
            throw new Error("Grouping.ts - ctor: incorrect number of parameters for constructor call");
        }
        EwsUtilities.ValidateParam(groupOn, "groupOn");
        EwsUtilities.ValidateParam(aggregateOn, "aggregateOn");
        this.GroupOn = groupOn;
        this.SortDirection = sortDirection;
        this.AggregateOn = aggregateOn;
        this.AggregateType = aggregateType;
    }
    /**
     * Validates this grouping.
     */
    Grouping.prototype.InternalValidate = function () {
        EwsUtilities.ValidateParam(this.GroupOn, "GroupOn");
        EwsUtilities.ValidateParam(this.AggregateOn, "AggregateOn");
    };
    /**
     * Implements ISelfValidate.Validate. Validates this grouping.
     */
    Grouping.prototype.Validate = function () {
        this.InternalValidate();
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     */
    Grouping.prototype.WriteToXml = function (writer) {
        writer.WriteStartElement(XmlNamespace.Messages, XmlElementNames.GroupBy);
        writer.WriteAttributeValue(XmlAttributeNames.Order, SortDirection[this.SortDirection]);
        this.GroupOn.WriteToXml(writer);
        writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.AggregateOn);
        writer.WriteAttributeValue(XmlAttributeNames.Aggregate, AggregateType[this.AggregateType]);
        this.AggregateOn.WriteToXml(writer);
        writer.WriteEndElement(); // AggregateOn
        writer.WriteEndElement(); // GroupBy
    };
    return Grouping;
}());
exports.Grouping = Grouping;
var ItemGroup = (function () {
    function ItemGroup(groupIndex, items) {
        this.Items = []; //System.Collections.ObjectModel.Collection<TItem>;
        EwsLogging.Assert(items != null, "ItemGroup.ctor", "items is null");
        this.GroupIndex = groupIndex;
        this.Items = items; //new Collection<TItem>(items);
    }
    return ItemGroup;
}());
exports.ItemGroup = ItemGroup;
/**
 * Represents an ordered collection of property definitions qualified with a sort direction.
 *
 * @sealed
 */
var OrderByCollection = (function () {
    /**
     * @internal Initializes a new instance of the **OrderByCollection** class.
     */
    function OrderByCollection() {
        this.propDefSortOrderPairList = [];
    }
    Object.defineProperty(OrderByCollection.prototype, "Count", {
        /**
         * Gets the number of elements contained in the collection.
         */
        get: function () {
            return this.propDefSortOrderPairList.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the element at the specified index from the collection.
     *
     * @param   {number}   index   Index.
     */
    OrderByCollection.prototype._getItem = function (index) {
        return this.propDefSortOrderPairList[index];
    };
    /**
     * Adds the specified property definition / sort direction pair to the collection.
     *
     * @param   {PropertyDefinitionBase}    propertyDefinition   The property definition.
     * @param   {SortDirection}             sortDirection        The sort direction.
     */
    OrderByCollection.prototype.Add = function (propertyDefinition, sortDirection) {
        if (this.Contains(propertyDefinition)) {
            throw new ServiceLocalException(StringHelper.Format(Strings.PropertyAlreadyExistsInOrderByCollection, propertyDefinition.GetPrintableName()));
        }
        this.propDefSortOrderPairList.push({ key: propertyDefinition, value: sortDirection }); //new PropertyDefinitionSortDirectionPair() not seamless in javascript
    };
    /**
     * Removes all elements from the collection.
     */
    OrderByCollection.prototype.Clear = function () {
        this.propDefSortOrderPairList.splice(0);
    };
    /**
     * @internal Determines whether the collection contains the specified property definition.
     *
     * @param   {PropertyDefinitionBase}   propertyDefinition   The property definition.
     * @return  {boolean}   True if the collection contains the specified property definition; otherwise, false.
     */
    OrderByCollection.prototype.Contains = function (propertyDefinition) {
        this.propDefSortOrderPairList.forEach(function (pair, index) {
            debugger; // check if equality works or need to use any property
            if (pair.key === propertyDefinition)
                return true;
        });
        return false;
    };
    /**
     *  Returns an enumerator that iterates through the collection. this case this.propDefSortOrderPairList
     */
    OrderByCollection.prototype.GetEnumerator = function () {
        return this.propDefSortOrderPairList;
    };
    /**
     * @internal Removes the specified property definition from the collection.
     *
     * @param   {PropertyDefinitionBase}   propertyDefinition   The property definition.
     * @return  {boolean}   True if the property definition is successfully removed; otherwise, false
     */
    OrderByCollection.prototype.Remove = function (propertyDefinition) {
        var oldCount = this.Count;
        this.propDefSortOrderPairList = this.propDefSortOrderPairList.filter(function (value) { return value.key !== propertyDefinition; });
        return oldCount > this.Count;
    };
    /**
     * @internal Removes the element at the specified index from the collection.
     *
     * @param   {number}   index   The index.
     */
    OrderByCollection.prototype.RemoveAt = function (index) {
        this.propDefSortOrderPairList.splice(index, 1);
    };
    /**
     * Tries to get the value for a property definition in the collection.
     *
     * @param   {PropertyDefinitionBase}    propertyDefinition   The property definition.
     * @param   {IOutParam<SortDirection>}  sortDirection        The sort direction.
     * @return  {boolean}                   True if collection contains property definition, otherwise false.
     */
    OrderByCollection.prototype.TryGetValue = function (propertyDefinition, sortDirection) {
        for (var _a = 0, _b = this.propDefSortOrderPairList; _a < _b.length; _a++) {
            var pair = _b[_a];
            if (pair.key == propertyDefinition) {
                sortDirection.outValue = pair.value;
                return true;
            }
        }
        sortDirection.outValue = SortDirection.Ascending; // out parameter has to be set to some value.
        return false;
    };
    /**
     * @internal Writes to XML.
     *
     * @param   {EwsServiceXmlWriter}   writer   The writer.
     * @param   {string}                xmlElementName   Name of the XML element.
     */
    OrderByCollection.prototype.WriteToXml = function (writer, xmlElementName) {
        if (this.Count > 0) {
            writer.WriteStartElement(XmlNamespace.Messages, xmlElementName);
            for (var _a = 0, _b = this.propDefSortOrderPairList; _a < _b.length; _a++) {
                var keyValuePair = _b[_a];
                writer.WriteStartElement(XmlNamespace.Types, XmlElementNames.FieldOrder);
                writer.WriteAttributeValue(XmlAttributeNames.Order, keyValuePair.value);
                keyValuePair.key.WriteToXml(writer);
                writer.WriteEndElement(); // FieldOrder
            }
            writer.WriteEndElement();
        }
    };
    return OrderByCollection;
}());
exports.OrderByCollection = OrderByCollection;
// class SafeXmlDocument extends System.Xml.XmlDocument {
//	private settings: any /*System.Xml.XmlReaderSettings*/;
//	Load(inStream: any /*System.IO.Stream*/): void{ throw new Error("SafeXmlDocument.ts - Load : Not implemented.");}
//	//Load(filename: string): void{ throw new Error("SafeXmlDocument.ts - Load : Not implemented.");}
//	//Load(txtReader: any /*System.IO.TextReader*/): void{ throw new Error("SafeXmlDocument.ts - Load : Not implemented.");}
//	//Load(reader: any /*System.Xml.XmlReader*/): void{ throw new Error("SafeXmlDocument.ts - Load : Not implemented.");}
//	LoadXml(xml: string): void{ throw new Error("SafeXmlDocument.ts - LoadXml : Not implemented.");}
//}
var SafeXmlFactory = (function () {
    function SafeXmlFactory() {
    }
    SafeXmlFactory.prototype.CreateSafeXmlTextReader = function (stream /*System.IO.Stream*/) { throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented."); };
    //CreateSafeXmlTextReader(xmlFragment: string, fragType: any /*System.Xml.XmlNodeType*/, context: any /*System.Xml.XmlParserContext*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
    //CreateSafeXmlTextReader(url: string, input: any /*System.IO.TextReader*/, nt: any /*System.Xml.XmlNameTable*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
    //CreateSafeXmlTextReader(url: string, input: any /*System.IO.Stream*/, nt: any /*System.Xml.XmlNameTable*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
    //CreateSafeXmlTextReader(input: any /*System.IO.TextReader*/, nt: any /*System.Xml.XmlNameTable*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
    //CreateSafeXmlTextReader(url: string, nt: any /*System.Xml.XmlNameTable*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
    //CreateSafeXmlTextReader(xmlFragment: any /*System.IO.Stream*/, fragType: any /*System.Xml.XmlNodeType*/, context: any /*System.Xml.XmlParserContext*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
    //CreateSafeXmlTextReader(url: string, input: any /*System.IO.Stream*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
    //CreateSafeXmlTextReader(input: any /*System.IO.Stream*/, nt: any /*System.Xml.XmlNameTable*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
    //CreateSafeXmlTextReader(input: any /*System.IO.TextReader*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
    //CreateSafeXmlTextReader(url: string): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
    //CreateSafeXmlTextReader(url: string, input: any /*System.IO.TextReader*/): any /*System.Xml.XmlTextReader*/{ throw new Error("SafeXmlFactory.ts - CreateSafeXmlTextReader : Not implemented.");}
    SafeXmlFactory.prototype.CreateXPathDocument = function (uri, space /*System.Xml.XmlSpace*/) { throw new Error("SafeXmlFactory.ts - CreateXPathDocument : Not implemented."); };
    return SafeXmlFactory;
}());
exports.SafeXmlFactory = SafeXmlFactory;
// class SafeXmlSchema extends System.Xml.Schema.XmlSchema {
//	private static defaultSettings: any /*System.Xml.XmlReaderSettings*/;
//	Read(stream: any /*System.IO.Stream*/, validationEventHandler: any /*System.Xml.Schema.ValidationEventHandler*/): any /*System.Xml.Schema.XmlSchema*/{ throw new Error("SafeXmlSchema.ts - Read : Not implemented.");}
//	//Read(reader: any /*System.IO.TextReader*/, validationEventHandler: any /*System.Xml.Schema.ValidationEventHandler*/): any /*System.Xml.Schema.XmlSchema*/{ throw new Error("SafeXmlSchema.ts - Read : Not implemented.");}
//	//Read(reader: any /*System.Xml.XmlReader*/, validationEventHandler: any /*System.Xml.Schema.ValidationEventHandler*/): any /*System.Xml.Schema.XmlSchema*/{ throw new Error("SafeXmlSchema.ts - Read : Not implemented.");}
//}
//export = SafeXmlSchema;
var SecurityTimestamp = (function () {
    function SecurityTimestamp() {
    }
    SecurityTimestamp.prototype.GetCreationTimeChars = function () { throw new Error("SecurityTimestamp.ts - GetCreationTimeChars : Not implemented."); };
    SecurityTimestamp.prototype.GetDigest = function () { throw new Error("SecurityTimestamp.ts - GetDigest : Not implemented."); };
    SecurityTimestamp.prototype.GetExpiryTimeChars = function () { throw new Error("SecurityTimestamp.ts - GetExpiryTimeChars : Not implemented."); };
    SecurityTimestamp.prototype.ToChars = function (utcTime) { throw new Error("SecurityTimestamp.ts - ToChars : Not implemented."); };
    //ToChars(n: number, buffer: any[] /*System.Char[]*/, offset: number /*System.Int32&*/, count: number): void{ throw new Error("SecurityTimestamp.ts - ToChars : Not implemented.");}
    SecurityTimestamp.prototype.ToString = function () { throw new Error("SecurityTimestamp.ts - ToString : Not implemented."); };
    SecurityTimestamp.DefaultTimestampValidityDurationString = "00:05:00";
    SecurityTimestamp.DefaultFormat = "yyyy-MM-ddTHH:mm:ss.fffZ";
    return SecurityTimestamp;
}());
exports.SecurityTimestamp = SecurityTimestamp;
// class XmlDtdException extends System.Xml.XmlException {
//	Message: string;
//}
//export = XmlDtdException;
/**
 * Represents a change as returned by a synchronization operation.
 */
var Change = (function () {
    /**
     * @internal Initializes a new instance of **Change** class.
     */
    function Change() {
        /**
         * The type of change.
         */
        this.changeType = ChangeType.Create;
        /**
         * The service object the change applies to.
         */
        this.serviceObject = null;
        /**
         * The Id of the service object the change applies to.
         */
        this.id = null;
    }
    Object.defineProperty(Change.prototype, "ChangeType", {
        /**
         * Gets the type of the change.
         */
        get: function () {
            return this.changeType;
        },
        set: function (value) {
            this.changeType = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Change.prototype, "ServiceObject", {
        /**
         * @internal Gets or sets the service object the change applies to.
         */
        get: function () {
            return this.serviceObject;
        },
        set: function (value) {
            this.serviceObject = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Change.prototype, "Id", {
        /**
         * @internal Gets or sets the Id of the service object the change applies to.
         */
        get: function () {
            return this.ServiceObject != null ? this.ServiceObject.GetId() : this.id;
        },
        set: function (value) {
            this.id = value;
        },
        enumerable: true,
        configurable: true
    });
    return Change;
}());
exports.Change = Change;
/**
 * Represents a collection of changes as returned by a synchronization operation.
 *
 * @sealed
 * @typeparam	{TChange}	Type representing the type of change (e.g. FolderChange or ItemChange)
 */
var ChangeCollection = (function () {
    /**
     * @internal Initializes a new instance of the **ChangeCollection<TChange>** class.
     */
    function ChangeCollection() {
        this.___typeGenerics = ["Change"];
        this.changes = [];
        this.syncState = null;
        this.moreChangesAvailable = false;
    }
    Object.defineProperty(ChangeCollection.prototype, "Count", {
        /**
         * Gets the number of changes in the collection.
         */
        get: function () {
            return this.changes.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChangeCollection.prototype, "SyncState", {
        /**
         * Gets the SyncState blob returned by a synchronization operation.
         */
        get: function () {
            return this.syncState;
        },
        set: function (value) {
            this.syncState = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChangeCollection.prototype, "MoreChangesAvailable", {
        /**
         * Gets a value indicating whether the there are more changes to be synchronized from the server.
         */
        get: function () {
            return this.moreChangesAvailable;
        },
        set: function (value) {
            this.moreChangesAvailable = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets an individual change from the change collection.
     *
     * @param   {number}   index   Zero-based index.
     * @return  {TChange}		An single change.
     */
    ChangeCollection.prototype._getItem = function (index) {
        if (index < 0 || index >= this.Count) {
            throw new ArgumentOutOfRangeException("index", Strings.IndexIsOutOfRange);
        }
        return this.changes[index];
    };
    /**
     * @internal Adds the specified change.
     *
     * @param   {TChange}   change   The change.
     */
    ChangeCollection.prototype.Add = function (change) {
        EwsLogging.Assert(change != null, "ChangeList.Add", "change is null");
        this.changes.push(change);
    };
    /**
     *  Returns an enumerator that iterates through the collection. this case this.changes
     */
    ChangeCollection.prototype.GetEnumerator = function () {
        return this.changes;
    };
    return ChangeCollection;
}());
exports.ChangeCollection = ChangeCollection;
/**
 * Represents a change on a folder as returned by a synchronization operation.
 *
 * @sealed
 */
var FolderChange = (function (_super) {
    __extends(FolderChange, _super);
    /**
     * @internal Initializes a new instance of **FolderChange** class.
     */
    function FolderChange() {
        return _super.call(this) || this;
    }
    Object.defineProperty(FolderChange.prototype, "Folder", {
        /**
         * Gets the folder the change applies to. Folder is null when ChangeType is equal to ChangeType.Delete. In that case, use the FolderId property to retrieve the Id of the folder that was deleted.
         */
        get: function () {
            return this.ServiceObject;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FolderChange.prototype, "FolderId", {
        /**
         * Gets the Id of the folder the change applies to.
         */
        get: function () {
            return this.Id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates an FolderId instance.
     *
     * @return  {ServiceId}      A FolderId.
     */
    FolderChange.prototype.CreateId = function () {
        return new FolderId();
    };
    return FolderChange;
}(Change));
exports.FolderChange = FolderChange;
/**
 * Represents a change on an item as returned by a synchronization operation.
 *
 * @sealed
 */
var ItemChange = (function (_super) {
    __extends(ItemChange, _super);
    /**
     * @internal Initializes a new instance of **ItemChange** class.
     */
    function ItemChange() {
        var _this = _super.call(this) || this;
        _this.isRead = false;
        return _this;
    }
    Object.defineProperty(ItemChange.prototype, "Item", {
        /**
         * Gets the item the change applies to. Item is null when ChangeType is equal to either ChangeType.Delete or ChangeType.ReadFlagChange. In those cases, use the ItemId property to retrieve the Id of the item that was deleted or whose IsRead property changed.
         */
        get: function () {
            return this.ServiceObject;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ItemChange.prototype, "IsRead", {
        /**
         * Gets the IsRead property for the item that the change applies to. IsRead is only valid when ChangeType is equal to ChangeType.ReadFlagChange.
         */
        get: function () {
            return this.isRead;
        },
        set: function (value) {
            this.isRead = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ItemChange.prototype, "ItemId", {
        /**
         * Gets the Id of the item the change applies to.
         */
        get: function () {
            return this.Id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal Creates an ItemId instance.
     *
     * @return  {ServiceId}      A ItemId.
     */
    ItemChange.prototype.CreateId = function () {
        return new ItemId();
    };
    return ItemChange;
}(Change));
exports.ItemChange = ItemChange;
var PhoneCall = (function (_super) {
    __extends(PhoneCall, _super);
    function PhoneCall() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PhoneCall.prototype.Disconnect = function () { throw new Error("PhoneCall.ts - Disconnect : Not implemented."); };
    PhoneCall.prototype.LoadFromJson = function (jsonProperty, service) { throw new Error("PhoneCall.ts - LoadFromJson : Not implemented."); };
    PhoneCall.prototype.Refresh = function () { throw new Error("PhoneCall.ts - Refresh : Not implemented."); };
    /**@internal */
    PhoneCall.prototype.ReadElementsFromXmlJsObject = function (reader) { throw new Error("PhoneCall.ts - TryReadElementFromXmlJsObject : Not implemented."); };
    PhoneCall.SuccessfulResponseText = "OK";
    PhoneCall.SuccessfulResponseCode = 200;
    return PhoneCall;
}(ComplexProperty));
exports.PhoneCall = PhoneCall;
//}
var PhoneCallId = (function (_super) {
    __extends(PhoneCallId, _super);
    function PhoneCallId() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PhoneCallId.prototype.InternalToJson = function (service) { throw new Error("PhoneCallId.ts - InternalToJson : Not implemented."); };
    PhoneCallId.prototype.LoadFromJson = function (jsonProperty, service) { throw new Error("PhoneCallId.ts - LoadFromJson : Not implemented."); };
    /**@internal */
    PhoneCallId.prototype.ReadAttributesFromXmlJsObject = function (reader) { throw new Error("PhoneCallId.ts - ReadAttributesFromXml : Not implemented."); };
    /**@internal */
    PhoneCallId.prototype.WriteAttributesToXml = function (writer) { throw new Error("PhoneCallId.ts - WriteAttributesToXml : Not implemented."); };
    /**@internal */
    PhoneCallId.prototype.WriteToXml = function (writer) { throw new Error("PhoneCallId.ts - WriteToXml : Not implemented."); };
    return PhoneCallId;
}(ComplexProperty));
exports.PhoneCallId = PhoneCallId;
//}
var UnifiedMessaging = (function () {
    function UnifiedMessaging(service) {
        this.service = service;
    }
    UnifiedMessaging.prototype.DisconnectPhoneCall = function (id) { throw new Error("UnifiedMessaging.ts - DisconnectPhoneCall : Not implemented."); };
    UnifiedMessaging.prototype.GetPhoneCallInformation = function (id) { throw new Error("UnifiedMessaging.ts - GetPhoneCallInformation : Not implemented."); };
    UnifiedMessaging.prototype.PlayOnPhone = function (itemId, dialString) { throw new Error("UnifiedMessaging.ts - PlayOnPhone : Not implemented."); };
    return UnifiedMessaging;
}());
exports.UnifiedMessaging = UnifiedMessaging;
TypeContainer.ServiceObject = ServiceObject;
TypeContainer.Folder = Folder;
TypeContainer.CalendarFolder = CalendarFolder;
TypeContainer.ContactsFolder = ContactsFolder;
TypeContainer.SearchFolder = SearchFolder;
TypeContainer.TasksFolder = TasksFolder;
TypeContainer.Item = Item;
TypeContainer.Appointment = Appointment;
TypeContainer.MeetingRequest = MeetingRequest;
TypeContainer.MeetingResponse = MeetingResponse;
TypeContainer.MeetingCancellation = MeetingCancellation;
TypeContainer.ItemAttachment = ItemAttachment;
TypeContainer.ItemAttachmentOf = ItemAttachmentOf;
TypeContainer.ExchangeService = ExchangeService;
TypeContainer.IndexedPropertyDefinition = IndexedPropertyDefinition;
TypeContainer.ExtendedPropertyDefinition = ExtendedPropertyDefinition;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/dist\\ExchangeWebService.js","/dist")
},{"_process":4,"base64-js":7,"buffer":2,"moment-timezone":9,"uuid":12}],6:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";
// Copyright (c) 2014-2017 Gautam Singh
// MIT License; Full text at - https://github.com/gautamsi/ews-javascript-api/blob/master/LICENSE
// Packages license notices pending
Object.defineProperty(exports, "__esModule", { value: true });
var ews = require("../ExchangeWebService");
var XHROutlook = (function () {
    function XHROutlook() {
    }
    XHROutlook.prototype.xhr = function (xhroptions, progressDelegate) {
        return new ews.Promise(function (resolve, reject) {
            Office.context.mailbox.makeEwsRequestAsync(xhroptions.data, function (result) {
                var res = {
                    status: 200,
                    responseText: result.value,
                    getAllResponseHeaders: function () { return []; },
                    getResponseHeader: function (str) { return ""; }
                };
                if (result.status === 'succeeded') {
                    resolve(res);
                }
                else {
                    res.message = result.error.message;
                    res.status = 500;
                    reject(res);
                }
            });
        });
    };
    XHROutlook.prototype.xhrStream = function (xhroptions, progressDelegate) {
        return new ews.Promise(function (resolve, reject) {
            reject(new Error("not implemented/ not used"));
        });
    };
    XHROutlook.prototype.disconnect = function () {
    };
    Object.defineProperty(XHROutlook.prototype, "apiName", {
        get: function () {
            return "outlook";
        },
        enumerable: true,
        configurable: true
    });
    return XHROutlook;
}());
exports.XHROutlook = XHROutlook;
ews["XHROutlook"] = XHROutlook;
function ConfigureForOutlook() {
    ews.ConfigurationApi.ConfigureXHR(new XHROutlook());
}
exports.ConfigureForOutlook = ConfigureForOutlook;
ews["ConfigureForOutlook"] = ConfigureForOutlook;
//ews.ConfigurationApi.ConfigureXHR(new XHROutlook());
window["EwsJS"] = ews;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/dist\\outlook\\ExchangeWebService.js","/dist\\outlook")
},{"../ExchangeWebService":5,"_process":4,"buffer":2}],7:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules\\base64-js\\index.js","/node_modules\\base64-js")
},{"_process":4,"buffer":2}],8:[function(require,module,exports){
module.exports={
	"version": "2017b",
	"zones": [
		"Africa/Abidjan|LMT GMT|g.8 0|01|-2ldXH.Q|48e5",
		"Africa/Accra|LMT GMT +0020|.Q 0 -k|012121212121212121212121212121212121212121212121|-26BbX.8 6tzX.8 MnE 1BAk MnE 1BAk MnE 1BAk MnE 1C0k MnE 1BAk MnE 1BAk MnE 1BAk MnE 1C0k MnE 1BAk MnE 1BAk MnE 1BAk MnE 1C0k MnE 1BAk MnE 1BAk MnE 1BAk MnE 1C0k MnE 1BAk MnE 1BAk MnE 1BAk MnE 1C0k MnE 1BAk MnE 1BAk MnE|41e5",
		"Africa/Nairobi|LMT EAT +0230 +0245|-2r.g -30 -2u -2J|01231|-1F3Cr.g 3Dzr.g okMu MFXJ|47e5",
		"Africa/Algiers|PMT WET WEST CET CEST|-9.l 0 -10 -10 -20|0121212121212121343431312123431213|-2nco9.l cNb9.l HA0 19A0 1iM0 11c0 1oo0 Wo0 1rc0 QM0 1EM0 UM0 DA0 Imo0 rd0 De0 9Xz0 1fb0 1ap0 16K0 2yo0 mEp0 hwL0 jxA0 11A0 dDd0 17b0 11B0 1cN0 2Dy0 1cN0 1fB0 1cL0|26e5",
		"Africa/Lagos|LMT WAT|-d.A -10|01|-22y0d.A|17e6",
		"Africa/Bissau|LMT -01 GMT|12.k 10 0|012|-2ldWV.E 2xonV.E|39e4",
		"Africa/Maputo|LMT CAT|-2a.k -20|01|-2GJea.k|26e5",
		"Africa/Cairo|EET EEST|-20 -30|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-1bIO0 vb0 1ip0 11z0 1iN0 1nz0 12p0 1pz0 10N0 1pz0 16p0 1jz0 s3d0 Vz0 1oN0 11b0 1oO0 10N0 1pz0 10N0 1pb0 10N0 1pb0 10N0 1pb0 10N0 1pz0 10N0 1pb0 10N0 1pb0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1WL0 rd0 1Rz0 wp0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1qL0 Xd0 1oL0 11d0 1oL0 11d0 1pb0 11d0 1oL0 11d0 1oL0 11d0 1ny0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 WL0 1qN0 Rb0 1wp0 On0 1zd0 Lz0 1EN0 Fb0 c10 8n0 8Nd0 gL0 e10 mn0|15e6",
		"Africa/Casablanca|LMT WET WEST CET|u.k 0 -10 -10|0121212121212121213121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2gMnt.E 130Lt.E rb0 Dd0 dVb0 b6p0 TX0 EoB0 LL0 gnd0 rz0 43d0 AL0 1Nd0 XX0 1Cp0 pz0 dEp0 4mn0 SyN0 AL0 1Nd0 wn0 1FB0 Db0 1zd0 Lz0 1Nf0 wM0 co0 go0 1o00 s00 dA0 vc0 11A0 A00 e00 y00 11A0 uM0 e00 Dc0 11A0 s00 e00 IM0 WM0 mo0 gM0 LA0 WM0 jA0 e00 Rc0 11A0 e00 e00 U00 11A0 8o0 e00 11A0 11A0 5A0 e00 17c0 1fA0 1a00 1a00 1fA0 17c0 1io0 14o0 1lc0 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1lc0 14o0 1fA0|32e5",
		"Africa/Ceuta|WET WEST CET CEST|0 -10 -10 -20|010101010101010101010232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-25KN0 11z0 drd0 18p0 3HX0 17d0 1fz0 1a10 1io0 1a00 1y7o0 LL0 gnd0 rz0 43d0 AL0 1Nd0 XX0 1Cp0 pz0 dEp0 4VB0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|85e3",
		"Africa/El_Aaiun|LMT -01 WET WEST|Q.M 10 0 -10|01232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-1rDz7.c 1GVA7.c 6L0 AL0 1Nd0 XX0 1Cp0 pz0 1cBB0 AL0 1Nd0 wn0 1FB0 Db0 1zd0 Lz0 1Nf0 wM0 co0 go0 1o00 s00 dA0 vc0 11A0 A00 e00 y00 11A0 uM0 e00 Dc0 11A0 s00 e00 IM0 WM0 mo0 gM0 LA0 WM0 jA0 e00 Rc0 11A0 e00 e00 U00 11A0 8o0 e00 11A0 11A0 5A0 e00 17c0 1fA0 1a00 1a00 1fA0 17c0 1io0 14o0 1lc0 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1lc0 14o0 1fA0|20e4",
		"Africa/Johannesburg|SAST SAST SAST|-1u -20 -30|012121|-2GJdu 1Ajdu 1cL0 1cN0 1cL0|84e5",
		"Africa/Khartoum|LMT CAT CAST EAT|-2a.8 -20 -30 -30|01212121212121212121212121212121213|-1yW2a.8 1zK0a.8 16L0 1iN0 17b0 1jd0 17b0 1ip0 17z0 1i10 17X0 1hB0 18n0 1hd0 19b0 1gp0 19z0 1iN0 17b0 1ip0 17z0 1i10 18n0 1hd0 18L0 1gN0 19b0 1gp0 19z0 1iN0 17z0 1i10 17X0 yGd0|51e5",
		"Africa/Monrovia|MMT MMT GMT|H.8 I.u 0|012|-23Lzg.Q 28G01.m|11e5",
		"Africa/Ndjamena|LMT WAT WAST|-10.c -10 -20|0121|-2le10.c 2J3c0.c Wn0|13e5",
		"Africa/Tripoli|LMT CET CEST EET|-Q.I -10 -20 -20|012121213121212121212121213123123|-21JcQ.I 1hnBQ.I vx0 4iP0 xx0 4eN0 Bb0 7ip0 U0n0 A10 1db0 1cN0 1db0 1dd0 1db0 1eN0 1bb0 1e10 1cL0 1c10 1db0 1dd0 1db0 1cN0 1db0 1q10 fAn0 1ep0 1db0 AKq0 TA0 1o00|11e5",
		"Africa/Tunis|PMT CET CEST|-9.l -10 -20|0121212121212121212121212121212121|-2nco9.l 18pa9.l 1qM0 DA0 3Tc0 11B0 1ze0 WM0 7z0 3d0 14L0 1cN0 1f90 1ar0 16J0 1gXB0 WM0 1rA0 11c0 nwo0 Ko0 1cM0 1cM0 1rA0 10M0 zuM0 10N0 1aN0 1qM0 WM0 1qM0 11A0 1o00|20e5",
		"Africa/Windhoek|+0130 SAST SAST CAT WAT WAST|-1u -20 -30 -20 -10 -20|012134545454545454545454545454545454545454545454545454545454545454545454545454545454545454545|-2GJdu 1Ajdu 1cL0 1SqL0 9NA0 11D0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0|32e4",
		"America/Adak|NST NWT NPT BST BDT AHST HST HDT|b0 a0 a0 b0 a0 a0 a0 90|012034343434343434343434343434343456767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676|-17SX0 8wW0 iB0 Qlb0 52O0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 cm0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|326",
		"America/Anchorage|AST AWT APT AHST AHDT YST AKST AKDT|a0 90 90 a0 90 90 90 80|012034343434343434343434343434343456767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676|-17T00 8wX0 iA0 Qlb0 52O0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 cm0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|30e4",
		"America/Port_of_Spain|LMT AST|46.4 40|01|-2kNvR.U|43e3",
		"America/Araguaina|LMT -03 -02|3c.M 30 20|0121212121212121212121212121212121212121212121212121|-2glwL.c HdKL.c 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 dMN0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 ny10 Lz0|14e4",
		"America/Argentina/Buenos_Aires|CMT -04 -03 -02|4g.M 40 30 20|01212121212121212121212121212121212121212123232323232323232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wp0 Rb0 1wp0 TX0 A4p0 uL0 1qN0 WL0",
		"America/Argentina/Catamarca|CMT -04 -03 -02|4g.M 40 30 20|01212121212121212121212121212121212121212123232323132321232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wq0 Ra0 1wp0 TX0 rlB0 7B0 8zb0 uL0",
		"America/Argentina/Cordoba|CMT -04 -03 -02|4g.M 40 30 20|01212121212121212121212121212121212121212123232323132323232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wq0 Ra0 1wp0 TX0 A4p0 uL0 1qN0 WL0",
		"America/Argentina/Jujuy|CMT -04 -03 -02|4g.M 40 30 20|012121212121212121212121212121212121212121232323121323232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1ze0 TX0 1ld0 WK0 1wp0 TX0 A4p0 uL0",
		"America/Argentina/La_Rioja|CMT -04 -03 -02|4g.M 40 30 20|012121212121212121212121212121212121212121232323231232321232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Qn0 qO0 16n0 Rb0 1wp0 TX0 rlB0 7B0 8zb0 uL0",
		"America/Argentina/Mendoza|CMT -04 -03 -02|4g.M 40 30 20|01212121212121212121212121212121212121212123232312121321232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1u20 SL0 1vd0 Tb0 1wp0 TW0 ri10 Op0 7TX0 uL0",
		"America/Argentina/Rio_Gallegos|CMT -04 -03 -02|4g.M 40 30 20|01212121212121212121212121212121212121212123232323232321232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wp0 Rb0 1wp0 TX0 rlB0 7B0 8zb0 uL0",
		"America/Argentina/Salta|CMT -04 -03 -02|4g.M 40 30 20|012121212121212121212121212121212121212121232323231323232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wq0 Ra0 1wp0 TX0 A4p0 uL0",
		"America/Argentina/San_Juan|CMT -04 -03 -02|4g.M 40 30 20|012121212121212121212121212121212121212121232323231232321232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Qn0 qO0 16n0 Rb0 1wp0 TX0 rld0 m10 8lb0 uL0",
		"America/Argentina/San_Luis|CMT -04 -03 -02|4g.M 40 30 20|012121212121212121212121212121212121212121232323121212321212|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 XX0 1q20 SL0 AN0 vDb0 m10 8lb0 8L0 jd0 1qN0 WL0 1qN0",
		"America/Argentina/Tucuman|CMT -04 -03 -02|4g.M 40 30 20|0121212121212121212121212121212121212121212323232313232123232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wq0 Ra0 1wp0 TX0 rlB0 4N0 8BX0 uL0 1qN0 WL0",
		"America/Argentina/Ushuaia|CMT -04 -03 -02|4g.M 40 30 20|01212121212121212121212121212121212121212123232323232321232|-20UHH.c pKnH.c Mn0 1iN0 Tb0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 1C10 LX0 1C10 LX0 1C10 LX0 1C10 Mn0 MN0 2jz0 MN0 4lX0 u10 5Lb0 1pB0 Fnz0 u10 uL0 1vd0 SL0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 zvd0 Bz0 1tB0 TX0 1wp0 Rb0 1wp0 Rb0 1wp0 TX0 rkN0 8p0 8zb0 uL0",
		"America/Curacao|LMT -0430 AST|4z.L 4u 40|012|-2kV7o.d 28KLS.d|15e4",
		"America/Asuncion|AMT -04 -03|3O.E 40 30|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212|-1x589.k 1DKM9.k 3CL0 3Dd0 10L0 1pB0 10n0 1pB0 10n0 1pB0 1cL0 1dd0 1db0 1dd0 1cL0 1dd0 1cL0 1dd0 1cL0 1dd0 1db0 1dd0 1cL0 1dd0 1cL0 1dd0 1cL0 1dd0 1db0 1dd0 1cL0 1lB0 14n0 1dd0 1cL0 1fd0 WL0 1rd0 1aL0 1dB0 Xz0 1qp0 Xb0 1qN0 10L0 1rB0 TX0 1tB0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 1cL0 WN0 1qL0 11B0 1nX0 1ip0 WL0 1qN0 WL0 1qN0 WL0 1tB0 TX0 1tB0 TX0 1tB0 19X0 1a10 1fz0 1a10 1fz0 1cN0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0|28e5",
		"America/Atikokan|CST CDT CWT CPT EST|60 50 50 50 50|0101234|-25TQ0 1in0 Rnb0 3je0 8x30 iw0|28e2",
		"America/Bahia|LMT -03 -02|2y.4 30 20|01212121212121212121212121212121212121212121212121212121212121|-2glxp.U HdLp.U 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 1EN0 Lz0 1C10 IL0 1HB0 Db0 1HB0 On0 1zd0 On0 1zd0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 l5B0 Rb0|27e5",
		"America/Bahia_Banderas|LMT MST CST PST MDT CDT|71 70 60 80 60 50|0121212131414141414141414141414141414152525252525252525252525252525252525252525252525252525252|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 otX0 gmN0 P2N0 13Vd0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nW0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|84e3",
		"America/Barbados|LMT BMT AST ADT|3W.t 3W.t 40 30|01232323232|-1Q0I1.v jsM0 1ODC1.v IL0 1ip0 17b0 1ip0 17b0 1ld0 13b0|28e4",
		"America/Belem|LMT -03 -02|3d.U 30 20|012121212121212121212121212121|-2glwK.4 HdKK.4 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0|20e5",
		"America/Belize|LMT CST -0530 CDT|5Q.M 60 5u 50|01212121212121212121212121212121212121212121212121213131|-2kBu7.c fPA7.c Onu 1zcu Rbu 1wou Rbu 1wou Rbu 1zcu Onu 1zcu Onu 1zcu Rbu 1wou Rbu 1wou Rbu 1wou Rbu 1zcu Onu 1zcu Onu 1zcu Rbu 1wou Rbu 1wou Rbu 1zcu Onu 1zcu Onu 1zcu Onu 1zcu Rbu 1wou Rbu 1wou Rbu 1zcu Onu 1zcu Onu 1zcu Rbu 1wou Rbu 1f0Mu qn0 lxB0 mn0|57e3",
		"America/Blanc-Sablon|AST ADT AWT APT|40 30 30 30|010230|-25TS0 1in0 UGp0 8x50 iu0|11e2",
		"America/Boa_Vista|LMT -04 -03|42.E 40 30|0121212121212121212121212121212121|-2glvV.k HdKV.k 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 smp0 WL0 1tB0 2L0|62e2",
		"America/Bogota|BMT -05 -04|4U.g 50 40|0121|-2eb73.I 38yo3.I 2en0|90e5",
		"America/Boise|PST PDT MST MWT MPT MDT|80 70 70 60 60 60|0101023425252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252|-261q0 1nX0 11B0 1nX0 8C10 JCL0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 Dd0 1Kn0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|21e4",
		"America/Cambridge_Bay|-00 MST MWT MPT MDDT MDT CST CDT EST|0 70 60 60 50 60 60 50 50|0123141515151515151515151515151515151515151515678651515151515151515151515151515151515151515151515151515151515151515151515151|-21Jc0 RO90 8x20 ix0 LCL0 1fA0 zgO0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11A0 1nX0 2K0 WQ0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|15e2",
		"America/Campo_Grande|LMT -04 -03|3C.s 40 30|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212|-2glwl.w HdLl.w 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 1EN0 Lz0 1C10 IL0 1HB0 Db0 1HB0 On0 1zd0 On0 1zd0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 1C10 Lz0 1Ip0 HX0 1zd0 On0 1HB0 IL0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10 Lz0 1C10 On0 1zd0 Rb0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0|77e4",
		"America/Cancun|LMT CST EST EDT CDT|5L.4 60 50 40 50|0123232341414141414141414141414141414141412|-1UQG0 2q2o0 yLB0 1lb0 14p0 1lb0 14p0 Lz0 xB0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 Dd0|63e4",
		"America/Caracas|CMT -0430 -04|4r.E 4u 40|01212|-2kV7w.k 28KM2.k 1IwOu kqo0|29e5",
		"America/Cayenne|LMT -04 -03|3t.k 40 30|012|-2mrwu.E 2gWou.E|58e3",
		"America/Panama|CMT EST|5j.A 50|01|-2uduE.o|15e5",
		"America/Chicago|CST CDT EST CWT CPT|60 50 50 50 50|01010101010101010101010101010101010102010101010103401010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261s0 1nX0 11B0 1nX0 1wp0 TX0 WN0 1qL0 1cN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 11B0 1Hz0 14p0 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 RB0 8x30 iw0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|92e5",
		"America/Chihuahua|LMT MST CST CDT MDT|74.k 70 60 50 60|0121212323241414141414141414141414141414141414141414141414141414141414141414141414141414141|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 2zQN0 1lb0 14p0 1lb0 14q0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|81e4",
		"America/Costa_Rica|SJMT CST CDT|5A.d 60 50|0121212121|-1Xd6n.L 2lu0n.L Db0 1Kp0 Db0 pRB0 15b0 1kp0 mL0|12e5",
		"America/Creston|MST PST|70 80|010|-29DR0 43B0|53e2",
		"America/Cuiaba|LMT -04 -03|3I.k 40 30|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212|-2glwf.E HdLf.E 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 1EN0 Lz0 1C10 IL0 1HB0 Db0 1HB0 On0 1zd0 On0 1zd0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 4a10 HX0 1zd0 On0 1HB0 IL0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10 Lz0 1C10 On0 1zd0 Rb0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0|54e4",
		"America/Danmarkshavn|LMT -03 -02 GMT|1e.E 30 20 0|01212121212121212121212121212121213|-2a5WJ.k 2z5fJ.k 19U0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 DC0|8",
		"America/Dawson|YST YDT YWT YPT YDDT PST PDT|90 80 80 80 70 80 70|0101023040565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-25TN0 1in0 1o10 13V0 Ser0 8x00 iz0 LCL0 1fA0 jrA0 fNd0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|13e2",
		"America/Dawson_Creek|PST PDT PWT PPT MST|80 70 70 70 70|0102301010101010101010101010101010101010101010101010101014|-25TO0 1in0 UGp0 8x10 iy0 3NB0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 ML0|12e3",
		"America/Denver|MST MDT MWT MPT|70 60 60 60|01010101023010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261r0 1nX0 11B0 1nX0 11B0 1qL0 WN0 mn0 Ord0 8x20 ix0 LCN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|26e5",
		"America/Detroit|LMT CST EST EWT EPT EDT|5w.b 60 50 40 40 40|01234252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252|-2Cgir.N peqr.N 156L0 8x40 iv0 6fd0 11z0 Jy10 SL0 dnB0 1cL0 s10 1Vz0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|37e5",
		"America/Edmonton|LMT MST MDT MWT MPT|7x.Q 70 60 60 60|01212121212121341212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2yd4q.8 shdq.8 1in0 17d0 hz0 2dB0 1fz0 1a10 11z0 1qN0 WL0 1qN0 11z0 IGN0 8x20 ix0 3NB0 11z0 LFB0 1cL0 3Cp0 1cL0 66N0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|10e5",
		"America/Eirunepe|LMT -05 -04|4D.s 50 40|0121212121212121212121212121212121|-2glvk.w HdLk.w 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 dPB0 On0 yTd0 d5X0|31e3",
		"America/El_Salvador|LMT CST CDT|5U.M 60 50|012121|-1XiG3.c 2Fvc3.c WL0 1qN0 WL0|11e5",
		"America/Tijuana|LMT MST PST PDT PWT PPT|7M.4 70 80 70 70 70|012123245232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-1UQE0 4PX0 8mM0 8lc0 SN0 1cL0 pHB0 83r0 zI0 5O10 1Rz0 cOO0 11A0 1o00 11A0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 BUp0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 U10 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|20e5",
		"America/Fort_Nelson|PST PDT PWT PPT MST|80 70 70 70 70|01023010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010104|-25TO0 1in0 UGp0 8x10 iy0 3NB0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0|39e2",
		"America/Fort_Wayne|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|010101023010101010101010101040454545454545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 QI10 Db0 RB0 8x30 iw0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 5Tz0 1o10 qLb0 1cL0 1cN0 1cL0 1qhd0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0",
		"America/Fortaleza|LMT -03 -02|2y 30 20|0121212121212121212121212121212121212121|-2glxq HdLq 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 nsp0 WL0 1tB0 5z0 2mN0 On0|34e5",
		"America/Glace_Bay|LMT AST ADT AWT APT|3X.M 40 30 30 30|012134121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2IsI0.c CwO0.c 1in0 UGp0 8x50 iu0 iq10 11z0 Jg10 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|19e3",
		"America/Godthab|LMT -03 -02|3q.U 30 20|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2a5Ux.4 2z5dx.4 19U0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|17e3",
		"America/Goose_Bay|NST NDT NST NDT NWT NPT AST ADT ADDT|3u.Q 2u.Q 3u 2u 2u 2u 40 30 20|010232323232323245232323232323232323232323232323232323232326767676767676767676767676767676767676767676768676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676|-25TSt.8 1in0 DXb0 2HbX.8 WL0 1qN0 WL0 1qN0 WL0 1tB0 TX0 1tB0 WL0 1qN0 WL0 1qN0 7UHu itu 1tB0 WL0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1tB0 WL0 1ld0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 S10 g0u 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14n1 1lb0 14p0 1nW0 11C0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zcX Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|76e2",
		"America/Grand_Turk|KMT EST EDT AST|57.b 50 40 40|0121212121212121212121212121212121212121212121212121212121212121212121212123|-2l1uQ.N 2HHBQ.N 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|37e2",
		"America/Guatemala|LMT CST CDT|62.4 60 50|0121212121|-24KhV.U 2efXV.U An0 mtd0 Nz0 ifB0 17b0 zDB0 11z0|13e5",
		"America/Guayaquil|QMT -05 -04|5e 50 40|0121|-1yVSK 2uILK rz0|27e5",
		"America/Guyana|LMT -0345 -03 -04|3Q.E 3J 30 40|0123|-2dvU7.k 2r6LQ.k Bxbf|80e4",
		"America/Halifax|LMT AST ADT AWT APT|4e.o 40 30 30 30|0121212121212121212121212121212121212121212121212134121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2IsHJ.A xzzJ.A 1db0 3I30 1in0 3HX0 IL0 1E10 ML0 1yN0 Pb0 1Bd0 Mn0 1Bd0 Rz0 1w10 Xb0 1w10 LX0 1w10 Xb0 1w10 Lz0 1C10 Jz0 1E10 OL0 1yN0 Un0 1qp0 Xb0 1qp0 11X0 1w10 Lz0 1HB0 LX0 1C10 FX0 1w10 Xb0 1qp0 Xb0 1BB0 LX0 1td0 Xb0 1qp0 Xb0 Rf0 8x50 iu0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 3Qp0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 3Qp0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 6i10 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|39e4",
		"America/Havana|HMT CST CDT|5t.A 50 40|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1Meuu.o 72zu.o ML0 sld0 An0 1Nd0 Db0 1Nd0 An0 6Ep0 An0 1Nd0 An0 JDd0 Mn0 1Ap0 On0 1fd0 11X0 1qN0 WL0 1wp0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 14n0 1ld0 14L0 1kN0 15b0 1kp0 1cL0 1cN0 1fz0 1a10 1fz0 1fB0 11z0 14p0 1nX0 11B0 1nX0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 14n0 1ld0 14n0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 1a10 1in0 1a10 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 17c0 1o00 11A0 1qM0 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 11A0 6i00 Rc0 1wo0 U00 1tA0 Rc0 1wo0 U00 1wo0 U00 1zc0 U00 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0|21e5",
		"America/Hermosillo|LMT MST CST PST MDT|7n.Q 70 60 80 60|0121212131414141|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 otX0 gmN0 P2N0 13Vd0 1lb0 14p0 1lb0 14p0 1lb0|64e4",
		"America/Indiana/Knox|CST CDT CWT CPT EST|60 50 50 50 50|0101023010101010101010101010101010101040101010101010101010101010101010101010101010101010141010101010101010101010101010101010101010101010101010101010101010|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 3NB0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 11z0 1o10 11z0 1o10 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 3Cn0 8wp0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 z8o0 1o00 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0",
		"America/Indiana/Marengo|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|0101023010101010101010104545454545414545454545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 dyN0 11z0 6fd0 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 jrz0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1VA0 LA0 1BX0 1e6p0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0",
		"America/Indiana/Petersburg|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|01010230101010101010101010104010101010101010101010141014545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 njX0 WN0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 3Fb0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 19co0 1o00 Rd0 1zb0 Oo0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0",
		"America/Indiana/Tell_City|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|01010230101010101010101010101010454541010101010101010101010101010101010101010101010101010101010101010|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 1o10 11z0 g0p0 11z0 1o10 11z0 1qL0 WN0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 WL0 1qN0 1cL0 1cN0 1cL0 1cN0 caL0 1cL0 1cN0 1cL0 1qhd0 1o00 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0",
		"America/Indiana/Vevay|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|010102304545454545454545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 kPB0 Awn0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1lnd0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0",
		"America/Indiana/Vincennes|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|01010230101010101010101010101010454541014545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 1o10 11z0 g0p0 11z0 1o10 11z0 1qL0 WN0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 WL0 1qN0 1cL0 1cN0 1cL0 1cN0 caL0 1cL0 1cN0 1cL0 1qhd0 1o00 Rd0 1zb0 Oo0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0",
		"America/Indiana/Winamac|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|01010230101010101010101010101010101010454541054545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 jrz0 1cL0 1cN0 1cL0 1qhd0 1o00 Rd0 1za0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0",
		"America/Inuvik|-00 PST PDDT MST MDT|0 80 60 70 60|0121343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343|-FnA0 tWU0 1fA0 wPe0 2pz0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|35e2",
		"America/Iqaluit|-00 EWT EPT EST EDDT EDT CST CDT|0 40 40 50 30 40 60 50|01234353535353535353535353535353535353535353567353535353535353535353535353535353535353535353535353535353535353535353535353|-16K00 7nX0 iv0 LCL0 1fA0 zgO0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11C0 1nX0 11A0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|67e2",
		"America/Jamaica|KMT EST EDT|57.b 50 40|0121212121212121212121|-2l1uQ.N 2uM1Q.N 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0|94e4",
		"America/Juneau|PST PWT PPT PDT YDT YST AKST AKDT|80 70 70 70 80 90 90 80|01203030303030303030303030403030356767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676|-17T20 8x10 iy0 Vo10 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cM0 1cM0 1cL0 1cN0 1fz0 1a10 1fz0 co0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|33e3",
		"America/Kentucky/Louisville|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|0101010102301010101010101010101010101454545454545414545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 3Fd0 Nb0 LPd0 11z0 RB0 8x30 iw0 Bb0 10N0 2bB0 8in0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 xz0 gso0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1VA0 LA0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0",
		"America/Kentucky/Monticello|CST CDT CWT CPT EST EDT|60 50 50 50 50 40|0101023010101010101010101010101010101010101010101010101010101010101010101454545454545454545454545454545454545454545454545454545454545454545454545454|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 SWp0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11A0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0",
		"America/La_Paz|CMT BOST -04|4w.A 3w.A 40|012|-1x37r.o 13b0|19e5",
		"America/Lima|LMT -05 -04|58.A 50 40|0121212121212121|-2tyGP.o 1bDzP.o zX0 1aN0 1cL0 1cN0 1cL0 1PrB0 zX0 1O10 zX0 6Gp0 zX0 98p0 zX0|11e6",
		"America/Los_Angeles|PST PDT PWT PPT|80 70 70 70|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261q0 1nX0 11B0 1nX0 SgN0 8x10 iy0 5Wp1 1VaX 3dA0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1a00 1fA0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|15e6",
		"America/Maceio|LMT -03 -02|2m.Q 30 20|012121212121212121212121212121212121212121|-2glxB.8 HdLB.8 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 dMN0 Lz0 8Q10 WL0 1tB0 5z0 2mN0 On0|93e4",
		"America/Managua|MMT CST EST CDT|5J.c 60 50 50|0121313121213131|-1quie.M 1yAMe.M 4mn0 9Up0 Dz0 1K10 Dz0 s3F0 1KH0 DB0 9In0 k8p0 19X0 1o30 11y0|22e5",
		"America/Manaus|LMT -04 -03|40.4 40 30|01212121212121212121212121212121|-2glvX.U HdKX.U 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 dPB0 On0|19e5",
		"America/Martinique|FFMT AST ADT|44.k 40 30|0121|-2mPTT.E 2LPbT.E 19X0|39e4",
		"America/Matamoros|LMT CST CDT|6E 60 50|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1UQG0 2FjC0 1nX0 i6p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 U10 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|45e4",
		"America/Mazatlan|LMT MST CST PST MDT|75.E 70 60 80 60|0121212131414141414141414141414141414141414141414141414141414141414141414141414141414141414141|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 otX0 gmN0 P2N0 13Vd0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|44e4",
		"America/Menominee|CST CDT CWT CPT EST|60 50 50 50 50|01010230101041010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 1o10 11z0 LCN0 1fz0 6410 9Jb0 1cM0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|85e2",
		"America/Merida|LMT CST EST CDT|5W.s 60 50 50|0121313131313131313131313131313131313131313131313131313131313131313131313131313131313131|-1UQG0 2q2o0 2hz0 wu30 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|11e5",
		"America/Metlakatla|PST PWT PPT PDT AKST AKDT|80 70 70 70 90 80|0120303030303030303030303030303030454545454545454545454545454545454545454545454|-17T20 8x10 iy0 Vo10 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1hU10 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|14e2",
		"America/Mexico_City|LMT MST CST CDT CWT|6A.A 70 60 50 50|012121232324232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 gEn0 TX0 3xd0 Jb0 6zB0 SL0 e5d0 17b0 1Pff0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|20e6",
		"America/Miquelon|LMT AST -03 -02|3I.E 40 30 20|012323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-2mKkf.k 2LTAf.k gQ10 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|61e2",
		"America/Moncton|EST AST ADT AWT APT|50 40 30 30 30|012121212121212121212134121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2IsH0 CwN0 1in0 zAo0 An0 1Nd0 An0 1Nd0 An0 1Nd0 An0 1Nd0 An0 1Nd0 An0 1K10 Lz0 1zB0 NX0 1u10 Wn0 S20 8x50 iu0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 3Cp0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14n1 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 ReX 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|64e3",
		"America/Monterrey|LMT CST CDT|6F.g 60 50|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1UQG0 2FjC0 1nX0 i6p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|41e5",
		"America/Montevideo|MMT -0330 -03 -02 -0230|3I.I 3u 30 20 2u|012121212121212121212121213232323232324242423243232323232323232323232323232323232323232|-20UIf.g 8jzJ.g 1cLu 1dcu 1cLu 1dcu 1cLu ircu 11zu 1o0u 11zu 1o0u 11zu 1qMu WLu 1qMu WLu 1qMu WLu 1qMu 11zu 1o0u 11zu NAu 11bu 2iMu zWu Dq10 19X0 pd0 jz0 cm10 19X0 1fB0 1on0 11d0 1oL0 1nB0 1fzu 1aou 1fzu 1aou 1fzu 3nAu Jb0 3MN0 1SLu 4jzu 2PB0 Lb0 3Dd0 1pb0 ixd0 An0 1MN0 An0 1wp0 On0 1wp0 Rb0 1zd0 On0 1wp0 Rb0 s8p0 1fB0 1ip0 11z0 1ld0 14n0 1o10 11z0 1o10 11z0 1o10 14n0 1ld0 14n0 1ld0 14n0 1o10 11z0 1o10 11z0 1o10 11z0|17e5",
		"America/Toronto|EST EDT EWT EPT|50 40 40 40|01010101010101010101010101010101010101010101012301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-25TR0 1in0 11Wu 1nzu 1fD0 WJ0 1wr0 Nb0 1Ap0 On0 1zd0 On0 1wp0 TX0 1tB0 TX0 1tB0 TX0 1tB0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 4kM0 8x40 iv0 1o10 11z0 1nX0 11z0 1o10 11z0 1o10 1qL0 11D0 1nX0 11B0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|65e5",
		"America/Nassau|LMT EST EDT|59.u 50 40|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2kNuO.u 26XdO.u 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|24e4",
		"America/New_York|EST EDT EWT EPT|50 40 40 40|01010101010101010101010101010101010101010101010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261t0 1nX0 11B0 1nX0 11B0 1qL0 1a10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 RB0 8x40 iv0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|21e6",
		"America/Nipigon|EST EDT EWT EPT|50 40 40 40|010123010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-25TR0 1in0 Rnb0 3je0 8x40 iv0 19yN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|16e2",
		"America/Nome|NST NWT NPT BST BDT YST AKST AKDT|b0 a0 a0 b0 a0 90 90 80|012034343434343434343434343434343456767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676767676|-17SX0 8wW0 iB0 Qlb0 52O0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 cl0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|38e2",
		"America/Noronha|LMT -02 -01|29.E 20 10|0121212121212121212121212121212121212121|-2glxO.k HdKO.k 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 nsp0 WL0 1tB0 2L0 2pB0 On0|30e2",
		"America/North_Dakota/Beulah|MST MDT MWT MPT CST CDT|70 60 60 60 60 50|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101014545454545454545454545454545454545454545454545454545454|-261r0 1nX0 11B0 1nX0 SgN0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Oo0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0",
		"America/North_Dakota/Center|MST MDT MWT MPT CST CDT|70 60 60 60 60 50|010102301010101010101010101010101010101010101010101010101014545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-261r0 1nX0 11B0 1nX0 SgN0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14o0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0",
		"America/North_Dakota/New_Salem|MST MDT MWT MPT CST CDT|70 60 60 60 60 50|010102301010101010101010101010101010101010101010101010101010101010101010101010101454545454545454545454545454545454545454545454545454545454545454545454|-261r0 1nX0 11B0 1nX0 SgN0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14o0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0",
		"America/Ojinaga|LMT MST CST CDT MDT|6V.E 70 60 50 60|0121212323241414141414141414141414141414141414141414141414141414141414141414141414141414141|-1UQF0 deL0 8lc0 17c0 10M0 1dd0 2zQN0 1lb0 14p0 1lb0 14q0 1lb0 14p0 1nX0 11B0 1nX0 1fB0 WL0 1fB0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 U10 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e3",
		"America/Pangnirtung|-00 AST AWT APT ADDT ADT EDT EST CST CDT|0 40 30 30 20 30 40 50 60 50|012314151515151515151515151515151515167676767689767676767676767676767676767676767676767676767676767676767676767676767676767|-1XiM0 PnG0 8x50 iu0 LCL0 1fA0 zgO0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1o00 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11C0 1nX0 11A0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|14e2",
		"America/Paramaribo|LMT PMT PMT -0330 -03|3E.E 3E.Q 3E.A 3u 30|01234|-2nDUj.k Wqo0.c qanX.I 1yVXN.o|24e4",
		"America/Phoenix|MST MDT MWT|70 60 60|01010202010|-261r0 1nX0 11B0 1nX0 SgN0 4Al1 Ap0 1db0 SWqX 1cL0|42e5",
		"America/Port-au-Prince|PPMT EST EDT|4N 50 40|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-28RHb 2FnMb 19X0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14q0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 i6n0 1nX0 11B0 1nX0 d430 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 3iN0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e5",
		"America/Rio_Branco|LMT -05 -04|4v.c 50 40|01212121212121212121212121212121|-2glvs.M HdLs.M 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 NBd0 d5X0|31e4",
		"America/Porto_Velho|LMT -04 -03|4f.A 40 30|012121212121212121212121212121|-2glvI.o HdKI.o 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0|37e4",
		"America/Puerto_Rico|AST AWT APT|40 30 30|0120|-17lU0 7XT0 iu0|24e5",
		"America/Punta_Arenas|SMT -05 -04 -03|4G.K 50 40 30|0102021212121212121232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323|-2q2jh.e fJAh.e 5knG.K 1Vzh.e jRAG.K 1pbh.e 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 nHX0 op0 blz0 ko0 Qeo0 WL0 1zd0 On0 1ip0 11z0 1o10 11z0 1qN0 WL0 1ld0 14n0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 1cL0 1cN0 11z0 1o10 11z0 1qN0 WL0 1fB0 19X0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1ip0 1fz0 1fB0 11z0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1o10 19X0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0",
		"America/Rainy_River|CST CDT CWT CPT|60 50 50 50|010123010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-25TQ0 1in0 Rnb0 3je0 8x30 iw0 19yN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|842",
		"America/Rankin_Inlet|-00 CST CDDT CDT EST|0 60 40 50 50|012131313131313131313131313131313131313131313431313131313131313131313131313131313131313131313131313131313131313131313131|-vDc0 keu0 1fA0 zgO0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|26e2",
		"America/Recife|LMT -03 -02|2j.A 30 20|0121212121212121212121212121212121212121|-2glxE.o HdLE.o 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 nsp0 WL0 1tB0 2L0 2pB0 On0|33e5",
		"America/Regina|LMT MST MDT MWT MPT CST|6W.A 70 60 60 60 60|012121212121212121212121341212121212121212121212121215|-2AD51.o uHe1.o 1in0 s2L0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 66N0 1cL0 1cN0 19X0 1fB0 1cL0 1fB0 1cL0 1cN0 1cL0 M30 8x20 ix0 1ip0 1cL0 1ip0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 3NB0 1cL0 1cN0|19e4",
		"America/Resolute|-00 CST CDDT CDT EST|0 60 40 50 50|012131313131313131313131313131313131313131313431313131313431313131313131313131313131313131313131313131313131313131313131|-SnA0 GWS0 1fA0 zgO0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|229",
		"America/Santarem|LMT -04 -03|3C.M 40 30|0121212121212121212121212121212|-2glwl.c HdLl.c 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 qe10 xb0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 NBd0|21e4",
		"America/Santiago|SMT -05 -04 -03|4G.K 50 40 30|010202121212121212321232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323|-2q2jh.e fJAh.e 5knG.K 1Vzh.e jRAG.K 1pbh.e 11d0 1oL0 11d0 1oL0 11d0 1oL0 11d0 1pb0 11d0 nHX0 op0 9Bz0 jb0 1oN0 ko0 Qeo0 WL0 1zd0 On0 1ip0 11z0 1o10 11z0 1qN0 WL0 1ld0 14n0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 1cL0 1cN0 11z0 1o10 11z0 1qN0 WL0 1fB0 19X0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1ip0 1fz0 1fB0 11z0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1o10 19X0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Dd0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Dd0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Dd0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0|62e5",
		"America/Santo_Domingo|SDMT EST EDT -0430 AST|4E 50 40 4u 40|01213131313131414|-1ttjk 1lJMk Mn0 6sp0 Lbu 1Cou yLu 1RAu wLu 1QMu xzu 1Q0u xXu 1PAu 13jB0 e00|29e5",
		"America/Sao_Paulo|LMT -03 -02|36.s 30 20|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212|-2glwR.w HdKR.w 1cc0 1e10 1bX0 Ezd0 So0 1vA0 Mn0 1BB0 ML0 1BB0 zX0 pTd0 PX0 2ep0 nz0 1C10 zX0 1C10 LX0 1C10 Mn0 H210 Rb0 1tB0 IL0 1Fd0 FX0 1EN0 FX0 1HB0 Lz0 1EN0 Lz0 1C10 IL0 1HB0 Db0 1HB0 On0 1zd0 On0 1zd0 Lz0 1zd0 Rb0 1wN0 Wn0 1tB0 Rb0 1tB0 WL0 1tB0 Rb0 1zd0 On0 1HB0 FX0 1C10 Lz0 1Ip0 HX0 1zd0 On0 1HB0 IL0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 Rb0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10 Lz0 1C10 On0 1zd0 Rb0 1wp0 On0 1C10 Lz0 1C10 On0 1zd0|20e6",
		"America/Scoresbysund|LMT -02 -01 +00|1r.Q 20 10 0|0121323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-2a5Ww.8 2z5ew.8 1a00 1cK0 1cL0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|452",
		"America/Sitka|PST PWT PPT PDT YST AKST AKDT|80 70 70 70 90 90 80|01203030303030303030303030303030345656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-17T20 8x10 iy0 Vo10 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 co0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|90e2",
		"America/St_Johns|NST NDT NST NDT NWT NPT NDDT|3u.Q 2u.Q 3u 2u 2u 2u 1u|01010101010101010101010101010101010102323232323232324523232323232323232323232323232323232323232323232323232323232323232323232323232323232326232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-28oit.8 14L0 1nB0 1in0 1gm0 Dz0 1JB0 1cL0 1cN0 1cL0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1fB0 1cL0 1cN0 1cL0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1fB0 1cL0 1fB0 19X0 1fB0 19X0 10O0 eKX.8 19X0 1iq0 WL0 1qN0 WL0 1qN0 WL0 1tB0 TX0 1tB0 WL0 1qN0 WL0 1qN0 7UHu itu 1tB0 WL0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1tB0 WL0 1ld0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14n1 1lb0 14p0 1nW0 11C0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zcX Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|11e4",
		"America/Swift_Current|LMT MST MDT MWT MPT CST|7b.k 70 60 60 60 60|012134121212121212121215|-2AD4M.E uHdM.E 1in0 UGp0 8x20 ix0 1o10 17b0 1ip0 11z0 1o10 11z0 1o10 11z0 isN0 1cL0 3Cp0 1cL0 1cN0 11z0 1qN0 WL0 pMp0|16e3",
		"America/Tegucigalpa|LMT CST CDT|5M.Q 60 50|01212121|-1WGGb.8 2ETcb.8 WL0 1qN0 WL0 GRd0 AL0|11e5",
		"America/Thule|LMT AST ADT|4z.8 40 30|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2a5To.Q 31NBo.Q 1cL0 1cN0 1cL0 1fB0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|656",
		"America/Thunder_Bay|CST EST EWT EPT EDT|60 50 40 40 40|0123141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141|-2q5S0 1iaN0 8x40 iv0 XNB0 1cL0 1cN0 1fz0 1cN0 1cL0 3Cp0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|11e4",
		"America/Vancouver|PST PDT PWT PPT|80 70 70 70|0102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-25TO0 1in0 UGp0 8x10 iy0 1o10 17b0 1ip0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e5",
		"America/Whitehorse|YST YDT YWT YPT YDDT PST PDT|90 80 80 80 70 80 70|0101023040565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565656565|-25TN0 1in0 1o10 13V0 Ser0 8x00 iz0 LCL0 1fA0 3NA0 vrd0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e3",
		"America/Winnipeg|CST CDT CWT CPT|60 50 50 50|010101023010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aIi0 WL0 3ND0 1in0 Jap0 Rb0 aCN0 8x30 iw0 1tB0 11z0 1ip0 11z0 1o10 11z0 1o10 11z0 1rd0 10L0 1op0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 1cL0 1cN0 11z0 6i10 WL0 6i10 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1a00 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1a00 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1o00 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1o00 11A0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|66e4",
		"America/Yakutat|YST YWT YPT YDT AKST AKDT|90 80 80 80 90 80|01203030303030303030303030303030304545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-17T10 8x00 iz0 Vo10 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 cn0 10q0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|642",
		"America/Yellowknife|-00 MST MWT MPT MDDT MDT|0 70 60 60 50 60|012314151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151|-1pdA0 hix0 8x20 ix0 LCL0 1fA0 zgO0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|19e3",
		"Antarctica/Casey|-00 +08 +11|0 -80 -b0|0121212|-2q00 1DjS0 T90 40P0 KL0 blz0|10",
		"Antarctica/Davis|-00 +07 +05|0 -70 -50|01012121|-vyo0 iXt0 alj0 1D7v0 VB0 3Wn0 KN0|70",
		"Antarctica/DumontDUrville|-00 +10|0 -a0|0101|-U0o0 cfq0 bFm0|80",
		"Antarctica/Macquarie|AEST AEDT -00 +11|-a0 -b0 0 -b0|0102010101010101010101010101010101010101010101010101010101010101010101010101010101010101013|-29E80 19X0 4SL0 1ayy0 Lvs0 1cM0 1o00 Rc0 1wo0 Rc0 1wo0 U00 1wo0 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 11A0 1qM0 WM0 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1wo0 WM0 1tA0 WM0 1tA0 U00 1tA0 U00 1tA0 11A0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 11A0 1o00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1cM0 1cM0 1cM0|1",
		"Antarctica/Mawson|-00 +06 +05|0 -60 -50|012|-CEo0 2fyk0|60",
		"Pacific/Auckland|NZMT NZST NZST NZDT|-bu -cu -c0 -d0|01020202020202020202020202023232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323|-1GCVu Lz0 1tB0 11zu 1o0u 11zu 1o0u 11zu 1o0u 14nu 1lcu 14nu 1lcu 1lbu 11Au 1nXu 11Au 1nXu 11Au 1nXu 11Au 1nXu 11Au 1qLu WMu 1qLu 11Au 1n1bu IM0 1C00 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1qM0 14o0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1io0 17c0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1io0 17c0 1io0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00|14e5",
		"Antarctica/Palmer|-00 -03 -04 -02|0 30 40 20|0121212121213121212121212121212121212121212121212121212121212121212121212121212121|-cao0 nD0 1vd0 SL0 1vd0 17z0 1cN0 1fz0 1cN0 1cL0 1cN0 asn0 Db0 jsN0 14N0 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 1cL0 1cN0 11z0 1o10 11z0 1qN0 WL0 1fB0 19X0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1ip0 1fz0 1fB0 11z0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1o10 19X0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0|40",
		"Antarctica/Rothera|-00 -03|0 30|01|gOo0|130",
		"Antarctica/Syowa|-00 +03|0 -30|01|-vs00|20",
		"Antarctica/Troll|-00 +00 +02|0 0 -20|01212121212121212121212121212121212121212121212121212121212121212121|1puo0 hd0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|40",
		"Antarctica/Vostok|-00 +06|0 -60|01|-tjA0|25",
		"Europe/Oslo|CET CEST|-10 -20|010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2awM0 Qm0 W6o0 5pf0 WM0 1fA0 1cM0 1cM0 1cM0 1cM0 wJc0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1qM0 WM0 zpc0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|62e4",
		"Asia/Riyadh|LMT +03|-36.Q -30|01|-TvD6.Q|57e5",
		"Asia/Almaty|LMT +05 +06 +07|-57.M -50 -60 -70|012323232323232323232321232323232323232323232323232|-1Pc57.M eUo7.M 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0|15e5",
		"Asia/Amman|LMT EET EEST|-2n.I -20 -30|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1yW2n.I 1HiMn.I KL0 1oN0 11b0 1oN0 11b0 1pd0 1dz0 1cp0 11b0 1op0 11b0 fO10 1db0 1e10 1cL0 1cN0 1cL0 1cN0 1fz0 1pd0 10n0 1ld0 14n0 1hB0 15b0 1ip0 19X0 1cN0 1cL0 1cN0 17b0 1ld0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1So0 y00 1fc0 1dc0 1co0 1dc0 1cM0 1cM0 1cM0 1o00 11A0 1lc0 17c0 1cM0 1cM0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 4bX0 Dd0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|25e5",
		"Asia/Anadyr|LMT +12 +13 +14 +11|-bN.U -c0 -d0 -e0 -b0|01232121212121212121214121212121212121212121212121212121212141|-1PcbN.U eUnN.U 23CL0 1db0 2q10 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 2sp0 WM0|13e3",
		"Asia/Aqtau|LMT +04 +05 +06|-3l.4 -40 -50 -60|012323232323232323232123232312121212121212121212|-1Pc3l.4 eUnl.4 24PX0 2pX0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0|15e4",
		"Asia/Aqtobe|LMT +04 +05 +06|-3M.E -40 -50 -60|0123232323232323232321232323232323232323232323232|-1Pc3M.E eUnM.E 23CL0 3Db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0|27e4",
		"Asia/Ashgabat|LMT +04 +05 +06|-3R.w -40 -50 -60|0123232323232323232323212|-1Pc3R.w eUnR.w 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0|41e4",
		"Asia/Atyrau|LMT +03 +05 +06 +04|-3r.I -30 -50 -60 -40|01232323232323232323242323232323232324242424242|-1Pc3r.I eUor.I 24PW0 2pX0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 2sp0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0",
		"Asia/Baghdad|BMT +03 +04|-2V.A -30 -40|012121212121212121212121212121212121212121212121212121|-26BeV.A 2ACnV.A 11b0 1cp0 1dz0 1dd0 1db0 1cN0 1cp0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1de0 1dc0 1dc0 1dc0 1cM0 1dc0 1cM0 1dc0 1cM0 1dc0 1dc0 1dc0 1cM0 1dc0 1cM0 1dc0 1cM0 1dc0 1dc0 1dc0 1cM0 1dc0 1cM0 1dc0 1cM0 1dc0 1dc0 1dc0 1cM0 1dc0 1cM0 1dc0 1cM0 1dc0|66e5",
		"Asia/Qatar|LMT +04 +03|-3q.8 -40 -30|012|-21Jfq.8 27BXq.8|96e4",
		"Asia/Baku|LMT +03 +04 +05|-3j.o -30 -40 -50|01232323232323232323232123232323232323232323232323232323232323232|-1Pc3j.o 1jUoj.o WCL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 1cM0 9Je0 1o00 11z0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|27e5",
		"Asia/Bangkok|BMT +07|-6G.4 -70|01|-218SG.4|15e6",
		"Asia/Barnaul|LMT +06 +07 +08|-5z -60 -70 -80|0123232323232323232323212323232321212121212121212121212121212121212|-21S5z pCnz 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 p90 LE0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3rd0",
		"Asia/Beirut|EET EEST|-20 -30|010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-21aq0 1on0 1410 1db0 19B0 1in0 1ip0 WL0 1lQp0 11b0 1oN0 11b0 1oN0 11b0 1pd0 11b0 1oN0 11b0 q6N0 En0 1oN0 11b0 1oN0 11b0 1oN0 11b0 1pd0 11b0 1oN0 11b0 1op0 11b0 dA10 17b0 1iN0 17b0 1iN0 17b0 1iN0 17b0 1vB0 SL0 1mp0 13z0 1iN0 17b0 1iN0 17b0 1jd0 12n0 1a10 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0|22e5",
		"Asia/Bishkek|LMT +05 +06 +07|-4W.o -50 -60 -70|012323232323232323232321212121212121212121212121212|-1Pc4W.o eUnW.o 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2e00 1tX0 17b0 1ip0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1cPu 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0|87e4",
		"Asia/Brunei|LMT +0730 +08|-7D.E -7u -80|012|-1KITD.E gDc9.E|42e4",
		"Asia/Kolkata|HMT +0630 IST|-5R.k -6u -5u|01212|-18LFR.k 1unn.k HB0 7zX0|15e6",
		"Asia/Chita|LMT +08 +09 +10|-7x.Q -80 -90 -a0|012323232323232323232321232323232323232323232323232323232323232312|-21Q7x.Q pAnx.Q 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3re0|33e4",
		"Asia/Choibalsan|LMT +07 +08 +10 +09|-7C -70 -80 -a0 -90|0123434343434343434343434343434343434343434343424242|-2APHC 2UkoC cKn0 1da0 1dd0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 6hD0 11z0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 3Db0 h1f0 1cJ0 1cP0 1cJ0|38e3",
		"Asia/Shanghai|CST CDT|-80 -90|01010101010101010|-1c1I0 LX0 16p0 1jz0 1Myp0 Rb0 1o10 11z0 1o10 11z0 1qN0 11z0 1o10 11z0 1o10 11z0|23e6",
		"Asia/Colombo|MMT +0530 +06 +0630|-5j.w -5u -60 -6u|01231321|-2zOtj.w 1rFbN.w 1zzu 7Apu 23dz0 11zu n3cu|22e5",
		"Asia/Dhaka|HMT +0630 +0530 +06 +07|-5R.k -6u -5u -60 -70|0121343|-18LFR.k 1unn.k HB0 m6n0 2kxbu 1i00|16e6",
		"Asia/Damascus|LMT EET EEST|-2p.c -20 -30|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-21Jep.c Hep.c 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1xRB0 11X0 1oN0 10L0 1pB0 11b0 1oN0 10L0 1mp0 13X0 1oN0 11b0 1pd0 11b0 1oN0 11b0 1oN0 11b0 1oN0 11b0 1pd0 11b0 1oN0 11b0 1oN0 11b0 1oN0 11b0 1pd0 11b0 1oN0 Nb0 1AN0 Nb0 bcp0 19X0 1gp0 19X0 3ld0 1xX0 Vd0 1Bz0 Sp0 1vX0 10p0 1dz0 1cN0 1cL0 1db0 1db0 1g10 1an0 1ap0 1db0 1fd0 1db0 1cN0 1db0 1dd0 1db0 1cp0 1dz0 1c10 1dX0 1cN0 1db0 1dd0 1db0 1cN0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1db0 1cN0 1db0 1cN0 19z0 1fB0 1qL0 11B0 1on0 Wp0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0|26e5",
		"Asia/Dili|LMT +08 +09|-8m.k -80 -90|01212|-2le8m.k 1dnXm.k 1nfA0 Xld0|19e4",
		"Asia/Dubai|LMT +04|-3F.c -40|01|-21JfF.c|39e5",
		"Asia/Dushanbe|LMT +05 +06 +07|-4z.c -50 -60 -70|012323232323232323232321|-1Pc4z.c eUnz.c 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2hB0|76e4",
		"Asia/Famagusta|LMT EET EEST +03|-2f.M -20 -30 -30|01212121212121212121212121212121212121212121212121212121212121212121212121212121212123|-1Vc2f.M 2a3cf.M 1cL0 1qp0 Xz0 19B0 19X0 1fB0 1db0 1cp0 1cL0 1fB0 19X0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1o30 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 15U0",
		"Asia/Gaza|EET EEST IST IDT|-20 -30 -20 -30|010101010101010101010101010101012323232323232323232323232320101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-1c2q0 5Rb0 10r0 1px0 10N0 1pz0 16p0 1jB0 16p0 1jx0 pBd0 Vz0 1oN0 11b0 1oO0 10N0 1pz0 10N0 1pb0 10N0 1pb0 10N0 1pb0 10N0 1pz0 10N0 1pb0 10N0 1pb0 11d0 1oL0 dW0 hfB0 Db0 1fB0 Rb0 npB0 11z0 1C10 IL0 1s10 10n0 1o10 WL0 1zd0 On0 1ld0 11z0 1o10 14n0 1o10 14n0 1nd0 12n0 1nd0 Xz0 1q10 12n0 M10 C00 17c0 1io0 17c0 1io0 17c0 1o00 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 17c0 1io0 18N0 1bz0 19z0 1gp0 1610 1iL0 11z0 1o10 14o0 1lA1 SKX 1xd1 MKX 1AN0 1a00 1fA0 1cL0 1cN0 1nX0 1210 1nz0 1220 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0|18e5",
		"Asia/Hebron|EET EEST IST IDT|-20 -30 -20 -30|01010101010101010101010101010101232323232323232323232323232010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-1c2q0 5Rb0 10r0 1px0 10N0 1pz0 16p0 1jB0 16p0 1jx0 pBd0 Vz0 1oN0 11b0 1oO0 10N0 1pz0 10N0 1pb0 10N0 1pb0 10N0 1pb0 10N0 1pz0 10N0 1pb0 10N0 1pb0 11d0 1oL0 dW0 hfB0 Db0 1fB0 Rb0 npB0 11z0 1C10 IL0 1s10 10n0 1o10 WL0 1zd0 On0 1ld0 11z0 1o10 14n0 1o10 14n0 1nd0 12n0 1nd0 Xz0 1q10 12n0 M10 C00 17c0 1io0 17c0 1io0 17c0 1o00 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 17c0 1io0 18N0 1bz0 19z0 1gp0 1610 1iL0 12L0 1mN0 14o0 1lc0 Tb0 1xd1 MKX bB0 cn0 1cN0 1a00 1fA0 1cL0 1cN0 1nX0 1210 1nz0 1220 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0|25e4",
		"Asia/Ho_Chi_Minh|LMT PLMT +07 +08 +09|-76.E -76.u -70 -80 -90|0123423232|-2yC76.E bK00.a 1h7b6.u 5lz0 18o0 3Oq0 k5b0 aW00 BAM0|90e5",
		"Asia/Hong_Kong|LMT HKT HKST JST|-7A.G -80 -90 -90|0121312121212121212121212121212121212121212121212121212121212121212121|-2CFHA.G 1sEP6.G 1cL0 ylu 93X0 1qQu 1tX0 Rd0 1In0 NB0 1cL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1kL0 14N0 1nX0 U10 1tz0 U10 1wn0 Rd0 1wn0 U10 1tz0 U10 1tz0 U10 1tz0 U10 1wn0 Rd0 1wn0 Rd0 1wn0 U10 1tz0 U10 1tz0 17d0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 s10 1Vz0 1cN0 1cL0 1cN0 1cL0 6fd0 14n0|73e5",
		"Asia/Hovd|LMT +06 +07 +08|-66.A -60 -70 -80|012323232323232323232323232323232323232323232323232|-2APG6.A 2Uko6.A cKn0 1db0 1dd0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 6hD0 11z0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 kEp0 1cJ0 1cP0 1cJ0|81e3",
		"Asia/Irkutsk|IMT +07 +08 +09|-6V.5 -70 -80 -90|01232323232323232323232123232323232323232323232323232323232323232|-21zGV.5 pjXV.5 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|60e4",
		"Europe/Istanbul|IMT EET EEST +04 +03|-1U.U -20 -30 -40 -30|012121212121212121212121212121212121212121212121212121234343434342121212121212121212121212121212121212121212121212121212121212124|-2ogNU.U dzzU.U 11b0 8tB0 1on0 1410 1db0 19B0 1in0 3Rd0 Un0 1oN0 11b0 zSp0 CL0 mN0 1Vz0 1gN0 1pz0 5Rd0 1fz0 1yp0 ML0 1kp0 17b0 1ip0 17b0 1fB0 19X0 1jB0 18L0 1ip0 17z0 qdd0 xX0 3S10 Tz0 dA10 11z0 1o10 11z0 1qN0 11z0 1ze0 11B0 WM0 1qO0 WI0 1nX0 1rB0 10L0 11B0 1in0 17d0 1in0 2pX0 19E0 1fU0 16Q0 1iI0 16Q0 1iI0 1Vd0 pb0 3Kp0 14o0 1de0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1a00 1fA0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WO0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 Xc0 1qo0 WM0 1qM0 11A0 1o00 1200 1nA0 11A0 1tA0 U00 15w0|13e6",
		"Asia/Jakarta|BMT +0720 +0730 +09 +08 WIB|-77.c -7k -7u -90 -80 -70|01232425|-1Q0Tk luM0 mPzO 8vWu 6kpu 4PXu xhcu|31e6",
		"Asia/Jayapura|LMT +09 +0930 WIT|-9m.M -90 -9u -90|0123|-1uu9m.M sMMm.M L4nu|26e4",
		"Asia/Jerusalem|JMT IST IDT IDDT|-2k.E -20 -30 -40|01212121212132121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-26Bek.E SyMk.E 5Rb0 10r0 1px0 10N0 1pz0 16p0 1jB0 16p0 1jx0 3LB0 Em0 or0 1cn0 1dB0 16n0 10O0 1ja0 1tC0 14o0 1cM0 1a00 11A0 1Na0 An0 1MP0 AJ0 1Kp0 LC0 1oo0 Wl0 EQN0 Db0 1fB0 Rb0 npB0 11z0 1C10 IL0 1s10 10n0 1o10 WL0 1zd0 On0 1ld0 11z0 1o10 14n0 1o10 14n0 1nd0 12n0 1nd0 Xz0 1q10 12n0 1hB0 1dX0 1ep0 1aL0 1eN0 17X0 1nf0 11z0 1tB0 19W0 1e10 17b0 1ep0 1gL0 18N0 1fz0 1eN0 17b0 1gq0 1gn0 19d0 1dz0 1c10 17X0 1hB0 1gn0 19d0 1dz0 1c10 17X0 1kp0 1dz0 1c10 1aL0 1eN0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0|81e4",
		"Asia/Kabul|+04 +0430|-40 -4u|01|-10Qs0|46e5",
		"Asia/Kamchatka|LMT +11 +12 +13|-ay.A -b0 -c0 -d0|012323232323232323232321232323232323232323232323232323232323212|-1SLKy.A ivXy.A 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 2sp0 WM0|18e4",
		"Asia/Karachi|LMT +0530 +0630 +05 PKT PKST|-4s.c -5u -6u -50 -50 -60|012134545454|-2xoss.c 1qOKW.c 7zX0 eup0 LqMu 1fy00 1cL0 dK10 11b0 1610 1jX0|24e6",
		"Asia/Urumqi|LMT +06|-5O.k -60|01|-1GgtO.k|32e5",
		"Asia/Kathmandu|LMT +0530 +0545|-5F.g -5u -5J|012|-21JhF.g 2EGMb.g|12e5",
		"Asia/Khandyga|LMT +08 +09 +10 +11|-92.d -80 -90 -a0 -b0|0123232323232323232323212323232323232323232323232343434343434343432|-21Q92.d pAp2.d 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 qK0 yN0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 17V0 7zD0|66e2",
		"Asia/Krasnoyarsk|LMT +06 +07 +08|-6b.q -60 -70 -80|01232323232323232323232123232323232323232323232323232323232323232|-21Hib.q prAb.q 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|10e5",
		"Asia/Kuala_Lumpur|SMT +07 +0720 +0730 +09 +08|-6T.p -70 -7k -7u -90 -80|0123435|-2Bg6T.p 17anT.p l5XE 17bO 8Fyu 1so1u|71e5",
		"Asia/Kuching|LMT +0730 +08 +0820 +09|-7l.k -7u -80 -8k -90|0123232323232323242|-1KITl.k gDbP.k 6ynu AnE 1O0k AnE 1NAk AnE 1NAk AnE 1NAk AnE 1O0k AnE 1NAk AnE pAk 8Fz0|13e4",
		"Asia/Macau|LMT CST CDT|-7y.k -80 -90|012121212121212121212121212121212121212121|-2le7y.k 1XO34.k 1wn0 Rd0 1wn0 R9u 1wqu U10 1tz0 TVu 1tz0 17gu 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cJu 1cL0 1cN0 1fz0 1cN0 1cOu 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cJu 1cL0 1cN0 1fz0 1cN0 1cL0|57e4",
		"Asia/Magadan|LMT +10 +11 +12|-a3.c -a0 -b0 -c0|012323232323232323232321232323232323232323232323232323232323232312|-1Pca3.c eUo3.c 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3Cq0|95e3",
		"Asia/Makassar|LMT MMT +08 +09 WITA|-7V.A -7V.A -80 -90 -80|01234|-21JjV.A vfc0 myLV.A 8ML0|15e5",
		"Asia/Manila|+08 +09|-80 -90|010101010|-1kJI0 AL0 cK10 65X0 mXB0 vX0 VK10 1db0|24e6",
		"Asia/Nicosia|LMT EET EEST|-2d.s -20 -30|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1Vc2d.s 2a3cd.s 1cL0 1qp0 Xz0 19B0 19X0 1fB0 1db0 1cp0 1cL0 1fB0 19X0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1o30 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|32e4",
		"Asia/Novokuznetsk|LMT +06 +07 +08|-5M.M -60 -70 -80|012323232323232323232321232323232323232323232323232323232323212|-1PctM.M eULM.M 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 2sp0 WM0|55e4",
		"Asia/Novosibirsk|LMT +06 +07 +08|-5v.E -60 -70 -80|0123232323232323232323212323212121212121212121212121212121212121212|-21Qnv.E pAFv.E 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 ml0 Os0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 4eN0|15e5",
		"Asia/Omsk|LMT +05 +06 +07|-4R.u -50 -60 -70|01232323232323232323232123232323232323232323232323232323232323232|-224sR.u pMLR.u 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|12e5",
		"Asia/Oral|LMT +03 +05 +06 +04|-3p.o -30 -50 -60 -40|01232323232323232424242424242424242424242424242|-1Pc3p.o eUop.o 23CK0 3Db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1fA0 1cM0 1cM0 IM0 1EM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0|27e4",
		"Asia/Pontianak|LMT PMT +0730 +09 +08 WITA WIB|-7h.k -7h.k -7u -90 -80 -80 -70|012324256|-2ua7h.k XE00 munL.k 8Rau 6kpu 4PXu xhcu Wqnu|23e4",
		"Asia/Pyongyang|LMT KST JST KST|-8n -8u -90 -90|01231|-2um8n 97XR 1lTzu 2Onc0|29e5",
		"Asia/Qyzylorda|LMT +04 +05 +06|-4l.Q -40 -50 -60|0123232323232323232323232323232323232323232323|-1Pc4l.Q eUol.Q 23CL0 3Db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 3ao0 1EM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0|73e4",
		"Asia/Rangoon|RMT +0630 +09|-6o.E -6u -90|0121|-21Jio.E SmnS.E 7j9u|48e5",
		"Asia/Sakhalin|LMT +09 +11 +12 +10|-9u.M -90 -b0 -c0 -a0|01232323232323232323232423232323232424242424242424242424242424242|-2AGVu.M 1BoMu.M 1qFa0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 2pB0 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3rd0|58e4",
		"Asia/Samarkand|LMT +04 +05 +06|-4r.R -40 -50 -60|01232323232323232323232|-1Pc4r.R eUor.R 23CL0 3Db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0|36e4",
		"Asia/Seoul|LMT KST JST KST KDT KDT|-8r.Q -8u -90 -90 -9u -a0|0123141414141414135353|-2um8r.Q 97XV.Q 1m1zu kKo0 2I0u OL0 1FB0 Rb0 1qN0 TX0 1tB0 TX0 1tB0 TX0 1tB0 TX0 2ap0 12FBu 11A0 1o00 11A0|23e6",
		"Asia/Srednekolymsk|LMT +10 +11 +12|-ae.Q -a0 -b0 -c0|01232323232323232323232123232323232323232323232323232323232323232|-1Pcae.Q eUoe.Q 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|35e2",
		"Asia/Taipei|CST JST CDT|-80 -90 -90|01020202020202020202020202020202020202020|-1iw80 joM0 1yo0 Tz0 1ip0 1jX0 1cN0 11b0 1oN0 11b0 1oN0 11b0 1oN0 11b0 10N0 1BX0 10p0 1pz0 10p0 1pz0 10p0 1db0 1dd0 1db0 1cN0 1db0 1cN0 1db0 1cN0 1db0 1BB0 ML0 1Bd0 ML0 uq10 1db0 1cN0 1db0 97B0 AL0|74e5",
		"Asia/Tashkent|LMT +05 +06 +07|-4B.b -50 -60 -70|012323232323232323232321|-1Pc4B.b eUnB.b 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0|23e5",
		"Asia/Tbilisi|TBMT +03 +04 +05|-2X.b -30 -40 -50|0123232323232323232323212121232323232323232323212|-1Pc2X.b 1jUnX.b WCL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 1cK0 1cL0 1cN0 1cL0 1cN0 2pz0 1cL0 1fB0 3Nz0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 An0 Os0 WM0|11e5",
		"Asia/Tehran|LMT TMT +0330 +04 +05 +0430|-3p.I -3p.I -3u -40 -50 -4u|01234325252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252|-2btDp.I 1d3c0 1huLT.I TXu 1pz0 sN0 vAu 1cL0 1dB0 1en0 pNB0 UL0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 64p0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0|14e6",
		"Asia/Thimphu|LMT +0530 +06|-5W.A -5u -60|012|-Su5W.A 1BGMs.A|79e3",
		"Asia/Tokyo|JST JDT|-90 -a0|010101010|-QJH0 QL0 1lB0 13X0 1zB0 NX0 1zB0 NX0|38e6",
		"Asia/Tomsk|LMT +06 +07 +08|-5D.P -60 -70 -80|0123232323232323232323212323232323232323232323212121212121212121212|-21NhD.P pxzD.P 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 co0 1bB0 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3Qp0|10e5",
		"Asia/Ulaanbaatar|LMT +07 +08 +09|-77.w -70 -80 -90|012323232323232323232323232323232323232323232323232|-2APH7.w 2Uko7.w cKn0 1db0 1dd0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 6hD0 11z0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 kEp0 1cJ0 1cP0 1cJ0|12e5",
		"Asia/Ust-Nera|LMT +08 +09 +12 +11 +10|-9w.S -80 -90 -c0 -b0 -a0|012343434343434343434345434343434343434343434343434343434343434345|-21Q9w.S pApw.S 23CL0 1d90 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 17V0 7zD0|65e2",
		"Asia/Vladivostok|LMT +09 +10 +11|-8L.v -90 -a0 -b0|01232323232323232323232123232323232323232323232323232323232323232|-1SJIL.v itXL.v 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|60e4",
		"Asia/Yakutsk|LMT +08 +09 +10|-8C.W -80 -90 -a0|01232323232323232323232123232323232323232323232323232323232323232|-21Q8C.W pAoC.W 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|28e4",
		"Asia/Yekaterinburg|LMT PMT +04 +05 +06|-42.x -3J.5 -40 -50 -60|012343434343434343434343234343434343434343434343434343434343434343|-2ag42.x 7mQh.s qBvJ.5 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|14e5",
		"Asia/Yerevan|LMT +03 +04 +05|-2W -30 -40 -50|0123232323232323232323212121212323232323232323232323232323232|-1Pc2W 1jUnW WCL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 2pB0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 4RX0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|13e5",
		"Atlantic/Azores|HMT -02 -01 +00 WET|1S.w 20 10 0 0|01212121212121212121212121212121212121212121232123212321232121212121212121212121212121212121212121232323232323232323232323232323234323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-2ldW5.s aPX5.s Sp0 LX0 1vc0 Tc0 1uM0 SM0 1vc0 Tc0 1vc0 SM0 1vc0 6600 1co0 3E00 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 3I00 17c0 1cM0 1cM0 3Fc0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Dc0 1tA0 1cM0 1dc0 1400 gL0 IM0 s10 U00 dX0 Rc0 pd0 Rc0 gL0 Oo0 pd0 Rc0 gL0 Oo0 pd0 14o0 1cM0 1cP0 1cM0 1cM0 1cM0 1cM0 1cM0 3Co0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 qIl0 1cM0 1fA0 1cM0 1cM0 1cN0 1cL0 1cN0 1cM0 1cM0 1cM0 1cM0 1cN0 1cL0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cL0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|25e4",
		"Atlantic/Bermuda|LMT AST ADT|4j.i 40 30|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1BnRE.G 1LTbE.G 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|65e3",
		"Atlantic/Canary|LMT -01 WET WEST|11.A 10 0 -10|01232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-1UtaW.o XPAW.o 1lAK0 1a10 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|54e4",
		"Atlantic/Cape_Verde|LMT -02 -01|1y.4 20 10|01212|-2xomp.U 1qOMp.U 7zX0 1djf0|50e4",
		"Atlantic/Faroe|LMT WET WEST|r.4 0 -10|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2uSnw.U 2Wgow.U 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|49e3",
		"Atlantic/Madeira|FMT -01 +00 +01 WET WEST|17.A 10 0 -10 0 -10|01212121212121212121212121212121212121212121232123212321232121212121212121212121212121212121212121454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-2ldWQ.o aPWQ.o Sp0 LX0 1vc0 Tc0 1uM0 SM0 1vc0 Tc0 1vc0 SM0 1vc0 6600 1co0 3E00 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 3I00 17c0 1cM0 1cM0 3Fc0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Dc0 1tA0 1cM0 1dc0 1400 gL0 IM0 s10 U00 dX0 Rc0 pd0 Rc0 gL0 Oo0 pd0 Rc0 gL0 Oo0 pd0 14o0 1cM0 1cP0 1cM0 1cM0 1cM0 1cM0 1cM0 3Co0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 qIl0 1cM0 1fA0 1cM0 1cM0 1cN0 1cL0 1cN0 1cM0 1cM0 1cM0 1cM0 1cN0 1cL0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|27e4",
		"Atlantic/Reykjavik|LMT -01 +00 GMT|1s 10 0 0|012121212121212121212121212121212121212121212121212121212121212121213|-2uWmw mfaw 1Bd0 ML0 1LB0 Cn0 1LB0 3fX0 C10 HrX0 1cO0 LB0 1EL0 LA0 1C00 Oo0 1wo0 Rc0 1wo0 Rc0 1wo0 Rc0 1zc0 Oo0 1zc0 14o0 1lc0 14o0 1lc0 14o0 1o00 11A0 1lc0 14o0 1o00 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1o00 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1o00 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1lc0 14o0 1o00 14o0|12e4",
		"Atlantic/South_Georgia|-02|20|0||30",
		"Atlantic/Stanley|SMT -04 -03 -02|3P.o 40 30 20|012121212121212323212121212121212121212121212121212121212121212121212|-2kJw8.A 12bA8.A 19X0 1fB0 19X0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 Cn0 1Cc10 WL0 1qL0 U10 1tz0 2mN0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1tz0 U10 1tz0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1tz0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qL0 WN0 1qN0 U10 1wn0 Rd0 1wn0 U10 1tz0 U10 1tz0 U10 1tz0 U10 1tz0 U10 1wn0 U10 1tz0 U10 1tz0 U10|21e2",
		"Australia/Sydney|AEST AEDT|-a0 -b0|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101|-293lX xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 14o0 1o00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 U00 1qM0 WM0 1tA0 WM0 1tA0 U00 1tA0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 11A0 1o00 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 14o0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|40e5",
		"Australia/Adelaide|ACST ACDT|-9u -au|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101|-293lt xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 U00 1qM0 WM0 1tA0 WM0 1tA0 U00 1tA0 U00 1tA0 Oo0 1zc0 WM0 1qM0 Rc0 1zc0 U00 1tA0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 14o0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|11e5",
		"Australia/Brisbane|AEST AEDT|-a0 -b0|01010101010101010|-293lX xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 H1A0 Oo0 1zc0 Oo0 1zc0 Oo0|20e5",
		"Australia/Broken_Hill|ACST ACDT|-9u -au|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101|-293lt xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 14o0 1o00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 U00 1qM0 WM0 1tA0 WM0 1tA0 U00 1tA0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 14o0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|18e3",
		"Australia/Currie|AEST AEDT|-a0 -b0|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101|-29E80 19X0 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 11A0 1qM0 WM0 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1wo0 WM0 1tA0 WM0 1tA0 U00 1tA0 U00 1tA0 11A0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 11A0 1o00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|746",
		"Australia/Darwin|ACST ACDT|-9u -au|010101010|-293lt xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0|12e4",
		"Australia/Eucla|+0845 +0945|-8J -9J|0101010101010101010|-293kI xcX 10jd0 yL0 1cN0 1cL0 1gSp0 Oo0 l5A0 Oo0 iJA0 G00 zU00 IM0 1qM0 11A0 1o00 11A0|368",
		"Australia/Hobart|AEST AEDT|-a0 -b0|010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101|-29E80 19X0 10jd0 yL0 1cN0 1cL0 1fB0 19X0 VfB0 1cM0 1o00 Rc0 1wo0 Rc0 1wo0 U00 1wo0 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 11A0 1qM0 WM0 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1wo0 WM0 1tA0 WM0 1tA0 U00 1tA0 U00 1tA0 11A0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 11A0 1o00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|21e4",
		"Australia/Lord_Howe|AEST +1030 +1130 +11|-a0 -au -bu -b0|0121212121313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313|raC0 1zdu Rb0 1zd0 On0 1zd0 On0 1zd0 On0 1zd0 TXu 1qMu WLu 1tAu WLu 1tAu TXu 1tAu Onu 1zcu Onu 1zcu Onu 1zcu Rbu 1zcu Onu 1zcu Onu 1zcu 11zu 1o0u 11zu 1o0u 11zu 1o0u 11zu 1qMu WLu 11Au 1nXu 1qMu 11zu 1o0u 11zu 1o0u 11zu 1qMu WLu 1qMu 11zu 1o0u WLu 1qMu 14nu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu|347",
		"Australia/Lindeman|AEST AEDT|-a0 -b0|010101010101010101010|-293lX xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 H1A0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0|10",
		"Australia/Melbourne|AEST AEDT|-a0 -b0|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101|-293lX xcX 10jd0 yL0 1cN0 1cL0 1fB0 19X0 17c10 LA0 1C00 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 U00 1qM0 WM0 1qM0 11A0 1tA0 U00 1tA0 U00 1tA0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 11A0 1o00 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 14o0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|39e5",
		"Australia/Perth|AWST AWDT|-80 -90|0101010101010101010|-293jX xcX 10jd0 yL0 1cN0 1cL0 1gSp0 Oo0 l5A0 Oo0 iJA0 G00 zU00 IM0 1qM0 11A0 1o00 11A0|18e5",
		"CET|CET CEST|-10 -20|01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 1cM0 1cM0 16M0 1gMM0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00",
		"CST6CDT|CST CDT CWT CPT|60 50 50 50|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261s0 1nX0 11B0 1nX0 SgN0 8x30 iw0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0",
		"Pacific/Easter|EMT -07 -06 -05|7h.s 70 60 50|012121212121212121212121212123232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323|-1uSgG.w 1s4IG.w WL0 1zd0 On0 1ip0 11z0 1o10 11z0 1qN0 WL0 1ld0 14n0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 2pA0 11z0 1o10 11z0 1qN0 WL0 1qN0 WL0 1qN0 1cL0 1cN0 11z0 1o10 11z0 1qN0 WL0 1fB0 19X0 1qN0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1ip0 1fz0 1fB0 11z0 1qN0 WL0 1qN0 WL0 1qN0 WL0 1qN0 11z0 1o10 11z0 1o10 11z0 1qN0 WL0 1qN0 17b0 1ip0 11z0 1o10 19X0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Dd0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Dd0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Dd0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0|30e2",
		"EET|EET EEST|-20 -30|010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|hDB0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00",
		"EST|EST|50|0|",
		"EST5EDT|EST EDT EWT EPT|50 40 40 40|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261t0 1nX0 11B0 1nX0 SgN0 8x40 iv0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0",
		"Europe/Dublin|DMT IST GMT BST IST|p.l -y.D 0 -10 -10|01232323232324242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242|-2ax9y.D Rc0 1fzy.D 14M0 1fc0 1g00 1co0 1dc0 1co0 1oo0 1400 1dc0 19A0 1io0 1io0 WM0 1o00 14o0 1o00 17c0 1io0 17c0 1fA0 1a00 1lc0 17c0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1cM0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1io0 1qM0 Dc0 g5X0 14p0 1wn0 17d0 1io0 11A0 1o00 17c0 1fA0 1a00 1fA0 1cM0 1fA0 1a00 17c0 1fA0 1a00 1io0 17c0 1lc0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1a00 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1tA0 IM0 90o0 U00 1tA0 U00 1tA0 U00 1tA0 U00 1tA0 WM0 1qM0 WM0 1qM0 WM0 1tA0 U00 1tA0 U00 1tA0 11z0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 14o0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|12e5",
		"Etc/GMT+0|GMT|0|0|",
		"Etc/GMT+1|-01|10|0|",
		"Etc/GMT+10|-10|a0|0|",
		"Etc/GMT+11|-11|b0|0|",
		"Etc/GMT+12|-12|c0|0|",
		"Etc/GMT+3|-03|30|0|",
		"Etc/GMT+4|-04|40|0|",
		"Etc/GMT+5|-05|50|0|",
		"Etc/GMT+6|-06|60|0|",
		"Etc/GMT+7|-07|70|0|",
		"Etc/GMT+8|-08|80|0|",
		"Etc/GMT+9|-09|90|0|",
		"Etc/GMT-1|+01|-10|0|",
		"Pacific/Port_Moresby|+10|-a0|0||25e4",
		"Pacific/Pohnpei|+11|-b0|0||34e3",
		"Pacific/Tarawa|+12|-c0|0||29e3",
		"Etc/GMT-13|+13|-d0|0|",
		"Etc/GMT-14|+14|-e0|0|",
		"Etc/GMT-2|+02|-20|0|",
		"Etc/GMT-3|+03|-30|0|",
		"Etc/GMT-4|+04|-40|0|",
		"Etc/GMT-5|+05|-50|0|",
		"Etc/GMT-6|+06|-60|0|",
		"Indian/Christmas|+07|-70|0||21e2",
		"Etc/GMT-8|+08|-80|0|",
		"Pacific/Palau|+09|-90|0||21e3",
		"Etc/UCT|UCT|0|0|",
		"Etc/UTC|UTC|0|0|",
		"Europe/Amsterdam|AMT NST +0120 +0020 CEST CET|-j.w -1j.w -1k -k -20 -10|010101010101010101010101010101010101010101012323234545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545|-2aFcj.w 11b0 1iP0 11A0 1io0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1co0 1io0 1yo0 Pc0 1a00 1fA0 1Bc0 Mo0 1tc0 Uo0 1tA0 U00 1uo0 W00 1s00 VA0 1so0 Vc0 1sM0 UM0 1wo0 Rc0 1u00 Wo0 1rA0 W00 1s00 VA0 1sM0 UM0 1w00 fV0 BCX.w 1tA0 U00 1u00 Wo0 1sm0 601k WM0 1fA0 1cM0 1cM0 1cM0 16M0 1gMM0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|16e5",
		"Europe/Andorra|WET CET CEST|0 -10 -20|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-UBA0 1xIN0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|79e3",
		"Europe/Astrakhan|LMT +03 +04 +05|-3c.c -30 -40 -50|012323232323232323212121212121212121212121212121212121212121212|-1Pcrc.c eUMc.c 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1fA0 1cM0 3Co0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3rd0",
		"Europe/Athens|AMT EET EEST CEST CET|-1y.Q -20 -30 -20 -10|012123434121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2a61x.Q CNbx.Q mn0 kU10 9b0 3Es0 Xa0 1fb0 1dd0 k3X0 Nz0 SCp0 1vc0 SO0 1cM0 1a00 1ao0 1fc0 1a10 1fG0 1cg0 1dX0 1bX0 1cQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|35e5",
		"Europe/London|GMT BST BDST|0 -10 -20|0101010101010101010101010101010101010101010101010121212121210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2axa0 Rc0 1fA0 14M0 1fc0 1g00 1co0 1dc0 1co0 1oo0 1400 1dc0 19A0 1io0 1io0 WM0 1o00 14o0 1o00 17c0 1io0 17c0 1fA0 1a00 1lc0 17c0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1cM0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1io0 1qM0 Dc0 2Rz0 Dc0 1zc0 Oo0 1zc0 Rc0 1wo0 17c0 1iM0 FA0 xB0 1fA0 1a00 14o0 bb0 LA0 xB0 Rc0 1wo0 11A0 1o00 17c0 1fA0 1a00 1fA0 1cM0 1fA0 1a00 17c0 1fA0 1a00 1io0 17c0 1lc0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1a00 1qM0 WM0 1qM0 11A0 1o00 WM0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1tA0 IM0 90o0 U00 1tA0 U00 1tA0 U00 1tA0 U00 1tA0 WM0 1qM0 WM0 1qM0 WM0 1tA0 U00 1tA0 U00 1tA0 11z0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 14o0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|10e6",
		"Europe/Belgrade|CET CEST|-10 -20|01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-19RC0 3IP0 WM0 1fA0 1cM0 1cM0 1rc0 Qo0 1vmo0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|12e5",
		"Europe/Berlin|CET CEST CEMT|-10 -20 -30|01010101010101210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 1cM0 1cM0 kL0 Nc0 m10 WM0 1ao0 1cp0 dX0 jz0 Dd0 1io0 17c0 1fA0 1a00 1ehA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|41e5",
		"Europe/Prague|CET CEST|-10 -20|010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 16M0 1lc0 1tA0 17A0 11c0 1io0 17c0 1io0 17c0 1fc0 1ao0 1bNc0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|13e5",
		"Europe/Brussels|WET CET CEST WEST|0 -10 -20 -10|0121212103030303030303030303030303030303030303030303212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2ehc0 3zX0 11c0 1iO0 11A0 1o00 11A0 my0 Ic0 1qM0 Rc0 1EM0 UM0 1u00 10o0 1io0 1io0 17c0 1a00 1fA0 1cM0 1cM0 1io0 17c0 1fA0 1a00 1io0 1a30 1io0 17c0 1fA0 1a00 1io0 17c0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Dc0 y00 5Wn0 WM0 1fA0 1cM0 16M0 1iM0 16M0 1C00 Uo0 1eeo0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|21e5",
		"Europe/Bucharest|BMT EET EEST|-1I.o -20 -30|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1xApI.o 20LI.o RA0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1Axc0 On0 1fA0 1a10 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cK0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cL0 1cN0 1cL0 1fB0 1nX0 11E0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|19e5",
		"Europe/Budapest|CET CEST|-10 -20|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1ip0 17b0 1op0 1tb0 Q2m0 3Ne0 WM0 1fA0 1cM0 1cM0 1oJ0 1dc0 1030 1fA0 1cM0 1cM0 1cM0 1cM0 1fA0 1a00 1iM0 1fA0 8Ha0 Rb0 1wN0 Rb0 1BB0 Lz0 1C20 LB0 SNX0 1a10 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|17e5",
		"Europe/Zurich|CET CEST|-10 -20|01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-19Lc0 11A0 1o00 11A0 1xG10 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|38e4",
		"Europe/Chisinau|CMT BMT EET EEST CEST CET MSK MSD|-1T -1I.o -20 -30 -20 -10 -30 -40|012323232323232323234545467676767676767676767323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232|-26jdT wGMa.A 20LI.o RA0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 27A0 2en0 39g0 WM0 1fA0 1cM0 V90 1t7z0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 gL0 WO0 1cM0 1cM0 1cK0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1nX0 11D0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|67e4",
		"Europe/Copenhagen|CET CEST|-10 -20|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2azC0 Tz0 VuO0 60q0 WM0 1fA0 1cM0 1cM0 1cM0 S00 1HA0 Nc0 1C00 Dc0 1Nc0 Ao0 1h5A0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|12e5",
		"Europe/Gibraltar|GMT BST BDST CET CEST|0 -10 -20 -10 -20|010101010101010101010101010101010101010101010101012121212121010121010101010101010101034343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343|-2axa0 Rc0 1fA0 14M0 1fc0 1g00 1co0 1dc0 1co0 1oo0 1400 1dc0 19A0 1io0 1io0 WM0 1o00 14o0 1o00 17c0 1io0 17c0 1fA0 1a00 1lc0 17c0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1cM0 1io0 17c0 1fA0 1a00 1io0 17c0 1io0 17c0 1fA0 1a00 1io0 1qM0 Dc0 2Rz0 Dc0 1zc0 Oo0 1zc0 Rc0 1wo0 17c0 1iM0 FA0 xB0 1fA0 1a00 14o0 bb0 LA0 xB0 Rc0 1wo0 11A0 1o00 17c0 1fA0 1a00 1fA0 1cM0 1fA0 1a00 17c0 1fA0 1a00 1io0 17c0 1lc0 17c0 1fA0 10Jz0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|30e3",
		"Europe/Helsinki|HMT EET EEST|-1D.N -20 -30|0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-1WuND.N OULD.N 1dA0 1xGq0 1cM0 1cM0 1cM0 1cN0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|12e5",
		"Europe/Kaliningrad|CET CEST CET CEST MSK MSD EEST EET +03|-10 -20 -20 -30 -30 -40 -30 -20 -30|0101010101010232454545454545454546767676767676767676767676767676767676767676787|-2aFe0 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 1cM0 Am0 Lb0 1en0 op0 1pNz0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|44e4",
		"Europe/Kiev|KMT EET MSK CEST CET MSD EEST|-22.4 -20 -30 -20 -10 -40 -30|0123434252525252525252525256161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161|-1Pc22.4 eUo2.4 rnz0 2Hg0 WM0 1fA0 da0 1v4m0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 Db0 3220 1cK0 1cL0 1cN0 1cL0 1cN0 1cL0 1cQ0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|34e5",
		"Europe/Kirov|LMT +03 +04 +05|-3i.M -30 -40 -50|01232323232323232321212121212121212121212121212121212121212121|-22WM0 qH90 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1fA0 1cM0 3Co0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|48e4",
		"Europe/Lisbon|LMT WET WEST WEMT CET CEST|A.J 0 -10 -20 -10 -20|012121212121212121212121212121212121212121212321232123212321212121212121212121212121212121212121214121212121212121212121212121212124545454212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2ldXn.f aPWn.f Sp0 LX0 1vc0 Tc0 1uM0 SM0 1vc0 Tc0 1vc0 SM0 1vc0 6600 1co0 3E00 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 3I00 17c0 1cM0 1cM0 3Fc0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Dc0 1tA0 1cM0 1dc0 1400 gL0 IM0 s10 U00 dX0 Rc0 pd0 Rc0 gL0 Oo0 pd0 Rc0 gL0 Oo0 pd0 14o0 1cM0 1cP0 1cM0 1cM0 1cM0 1cM0 1cM0 3Co0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 pvy0 1cM0 1cM0 1fA0 1cM0 1cM0 1cN0 1cL0 1cN0 1cM0 1cM0 1cM0 1cM0 1cN0 1cL0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|27e5",
		"Europe/Luxembourg|LMT CET CEST WET WEST WEST WET|-o.A -10 -20 0 -10 -20 -10|0121212134343434343434343434343434343434343434343434565651212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2DG0o.A t6mo.A TB0 1nX0 Up0 1o20 11A0 rW0 CM0 1qP0 R90 1EO0 UK0 1u20 10m0 1ip0 1in0 17e0 19W0 1fB0 1db0 1cp0 1in0 17d0 1fz0 1a10 1in0 1a10 1in0 17f0 1fA0 1a00 1io0 17c0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Dc0 vA0 60L0 WM0 1fA0 1cM0 17c0 1io0 16M0 1C00 Uo0 1eeo0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|54e4",
		"Europe/Madrid|WET WEST WEMT CET CEST|0 -10 -20 -10 -20|010101010101010101210343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343|-25Td0 19B0 1cL0 1dd0 b1z0 18p0 3HX0 17d0 1fz0 1a10 1io0 1a00 1in0 17d0 iIn0 Hd0 1cL0 bb0 1200 2s20 14n0 5aL0 Mp0 1vz0 17d0 1in0 17d0 1in0 17d0 1in0 17d0 6hX0 11B0 XHX0 1a10 1fz0 1a10 19X0 1cN0 1fz0 1a10 1fC0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|62e5",
		"Europe/Malta|CET CEST|-10 -20|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2arB0 Lz0 1cN0 1db0 1410 1on0 Wp0 1qL0 17d0 1cL0 M3B0 5M20 WM0 1fA0 1co0 17c0 1iM0 16m0 1de0 1lc0 14m0 1lc0 WO0 1qM0 GTW0 On0 1C10 LA0 1C00 LA0 1EM0 LA0 1C00 LA0 1zc0 Oo0 1C00 Oo0 1co0 1cM0 1lA0 Xc0 1qq0 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1o10 11z0 1iN0 19z0 1fB0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|42e4",
		"Europe/Minsk|MMT EET MSK CEST CET MSD EEST +03|-1O -20 -30 -20 -10 -40 -30 -30|01234343252525252525252525261616161616161616161616161616161616161617|-1Pc1O eUnO qNX0 3gQ0 WM0 1fA0 1cM0 Al0 1tsn0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 3Fc0 1cN0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0|19e5",
		"Europe/Monaco|PMT WET WEST WEMT CET CEST|-9.l 0 -10 -20 -10 -20|01212121212121212121212121212121212121212121212121232323232345454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-2nco9.l cNb9.l HA0 19A0 1iM0 11c0 1oo0 Wo0 1rc0 QM0 1EM0 UM0 1u00 10o0 1io0 1wo0 Rc0 1a00 1fA0 1cM0 1cM0 1io0 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 1fA0 1a00 1io0 17c0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Df0 2RV0 11z0 11B0 1ze0 WM0 1fA0 1cM0 1fa0 1aq0 16M0 1ekn0 1cL0 1fC0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|38e3",
		"Europe/Moscow|MMT MMT MST MDST MSD MSK +05 EET EEST MSK|-2u.h -2v.j -3v.j -4v.j -40 -30 -50 -20 -30 -40|012132345464575454545454545454545458754545454545454545454545454545454545454595|-2ag2u.h 2pyW.W 1bA0 11X0 GN0 1Hb0 c4v.j ik0 3DA0 dz0 15A0 c10 2q10 iM10 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|16e6",
		"Europe/Paris|PMT WET WEST CEST CET WEMT|-9.l 0 -10 -20 -10 -20|0121212121212121212121212121212121212121212121212123434352543434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434343434|-2nco8.l cNb8.l HA0 19A0 1iM0 11c0 1oo0 Wo0 1rc0 QM0 1EM0 UM0 1u00 10o0 1io0 1wo0 Rc0 1a00 1fA0 1cM0 1cM0 1io0 17c0 1fA0 1a00 1io0 1a00 1io0 17c0 1fA0 1a00 1io0 17c0 1cM0 1cM0 1a00 1io0 1cM0 1cM0 1a00 1fA0 1io0 17c0 1cM0 1cM0 1a00 1fA0 1io0 1qM0 Df0 Ik0 5M30 WM0 1fA0 1cM0 Vx0 hB0 1aq0 16M0 1ekn0 1cL0 1fC0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|11e6",
		"Europe/Riga|RMT LST EET MSK CEST CET MSD EEST|-1A.y -2A.y -20 -30 -20 -10 -40 -30|010102345454536363636363636363727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272727272|-25TzA.y 11A0 1iM0 ko0 gWm0 yDXA.y 2bX0 3fE0 WM0 1fA0 1cM0 1cM0 4m0 1sLy0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cN0 1o00 11A0 1o00 11A0 1qM0 3oo0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|64e4",
		"Europe/Rome|CET CEST|-10 -20|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2arB0 Lz0 1cN0 1db0 1410 1on0 Wp0 1qL0 17d0 1cL0 M3B0 5M20 WM0 1fA0 1cM0 16M0 1iM0 16m0 1de0 1lc0 14m0 1lc0 WO0 1qM0 GTW0 On0 1C10 LA0 1C00 LA0 1EM0 LA0 1C00 LA0 1zc0 Oo0 1C00 Oo0 1C00 LA0 1zc0 Oo0 1C00 LA0 1C00 LA0 1zc0 Oo0 1C00 Oo0 1zc0 Oo0 1fC0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|39e5",
		"Europe/Samara|LMT +03 +04 +05|-3k.k -30 -40 -50|0123232323232323232121232323232323232323232323232323232323212|-22WM0 qH90 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1fA0 2y10 14m0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 2sp0 WM0|12e5",
		"Europe/Saratov|LMT +03 +04 +05|-34.i -30 -40 -50|012323232323232321212121212121212121212121212121212121212121212|-22WM0 qH90 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1cM0 1cM0 1fA0 1cM0 3Co0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 5810",
		"Europe/Simferopol|SMT EET MSK CEST CET MSD EEST MSK|-2g -20 -30 -20 -10 -40 -30 -40|012343432525252525252525252161616525252616161616161616161616161616161616172|-1Pc2g eUog rEn0 2qs0 WM0 1fA0 1cM0 3V0 1u0L0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1Q00 4eL0 1cL0 1cN0 1cL0 1cN0 dX0 WL0 1cN0 1cL0 1fB0 1o30 11B0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11z0 1nW0|33e4",
		"Europe/Sofia|EET CET CEST EEST|-20 -10 -20 -30|01212103030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030|-168L0 WM0 1fA0 1cM0 1cM0 1cN0 1mKH0 1dd0 1fb0 1ap0 1fb0 1a20 1fy0 1a30 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cK0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 1nX0 11E0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|12e5",
		"Europe/Stockholm|CET CEST|-10 -20|01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2azC0 TB0 2yDe0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|15e5",
		"Europe/Tallinn|TMT CET CEST EET MSK MSD EEST|-1D -10 -20 -20 -30 -40 -30|012103421212454545454545454546363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363|-26oND teD 11A0 1Ta0 4rXl KSLD 2FX0 2Jg0 WM0 1fA0 1cM0 18J0 1sTX0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o10 11A0 1qM0 5QM0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|41e4",
		"Europe/Tirane|LMT CET CEST|-1j.k -10 -20|01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2glBj.k 14pcj.k 5LC0 WM0 4M0 1fCK0 10n0 1op0 11z0 1pd0 11z0 1qN0 WL0 1qp0 Xb0 1qp0 Xb0 1qp0 11z0 1lB0 11z0 1qN0 11z0 1iN0 16n0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|42e4",
		"Europe/Ulyanovsk|LMT +03 +04 +05 +02|-3d.A -30 -40 -50 -20|01232323232323232321214121212121212121212121212121212121212121212|-22WM0 qH90 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1fA0 2pB0 IM0 rX0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0 3rd0",
		"Europe/Uzhgorod|CET CEST MSK MSD EET EEST|-10 -20 -30 -40 -20 -30|010101023232323232323232320454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454|-1cqL0 6i00 WM0 1fA0 1cM0 1ml0 1Cp0 1r3W0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1Q00 1Nf0 2pw0 1cL0 1cN0 1cL0 1cN0 1cL0 1cQ0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|11e4",
		"Europe/Vienna|CET CEST|-10 -20|0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1o00 11A0 3KM0 14o0 LA00 6i00 WM0 1fA0 1cM0 1cM0 1cM0 400 2qM0 1a00 1cM0 1cM0 1io0 17c0 1gHa0 19X0 1cP0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|18e5",
		"Europe/Vilnius|WMT KMT CET EET MSK CEST MSD EEST|-1o -1z.A -10 -20 -30 -20 -40 -30|012324525254646464646464646473737373737373737352537373737373737373737373737373737373737373737373737373737373737373737373|-293do 6ILM.o 1Ooz.A zz0 Mfd0 29W0 3is0 WM0 1fA0 1cM0 LV0 1tgL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11B0 1o00 11A0 1qM0 8io0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|54e4",
		"Europe/Volgograd|LMT +03 +04 +05|-2V.E -30 -40 -50|01232323232323232121212121212121212121212121212121212121212121|-21IqV.E psLV.E 23CL0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 2pB0 1cM0 1cM0 1cM0 1fA0 1cM0 3Co0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 8Hz0|10e5",
		"Europe/Warsaw|WMT CET CEST EET EEST|-1o -10 -20 -20 -30|012121234312121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121|-2ctdo 1LXo 11d0 1iO0 11A0 1o00 11A0 1on0 11A0 6zy0 HWP0 5IM0 WM0 1fA0 1cM0 1dz0 1mL0 1en0 15B0 1aq0 1nA0 11A0 1io0 17c0 1fA0 1a00 iDX0 LA0 1cM0 1cM0 1C00 Oo0 1cM0 1cM0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1C00 LA0 uso0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cN0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|17e5",
		"Europe/Zaporozhye|+0220 EET MSK CEST CET MSD EEST|-2k -20 -30 -20 -10 -40 -30|01234342525252525252525252526161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161|-1Pc2k eUok rdb0 2RE0 WM0 1fA0 8m0 1v9a0 1db0 1cN0 1db0 1cN0 1db0 1dd0 1cO0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cK0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cQ0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|77e4",
		"HST|HST|a0|0|",
		"Indian/Chagos|LMT +05 +06|-4N.E -50 -60|012|-2xosN.E 3AGLN.E|30e2",
		"Indian/Cocos|+0630|-6u|0||596",
		"Indian/Kerguelen|-00 +05|0 -50|01|-MG00|130",
		"Indian/Mahe|LMT +04|-3F.M -40|01|-2yO3F.M|79e3",
		"Indian/Maldives|MMT +05|-4S -50|01|-olgS|35e4",
		"Indian/Mauritius|LMT +04 +05|-3O -40 -50|012121|-2xorO 34unO 14L0 12kr0 11z0|15e4",
		"Indian/Reunion|LMT +04|-3F.Q -40|01|-2mDDF.Q|84e4",
		"Pacific/Kwajalein|+11 -12 +12|-b0 c0 -c0|012|-AX0 W9X0|14e3",
		"MET|MET MEST|-10 -20|01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-2aFe0 11d0 1iO0 11A0 1o00 11A0 Qrc0 6i00 WM0 1fA0 1cM0 1cM0 1cM0 16M0 1gMM0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00",
		"MST|MST|70|0|",
		"MST7MDT|MST MDT MWT MPT|70 60 60 60|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261r0 1nX0 11B0 1nX0 SgN0 8x20 ix0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0",
		"Pacific/Chatham|+1215 +1245 +1345|-cf -cJ -dJ|012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212|-WqAf 1adef IM0 1C00 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1qM0 14o0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1io0 17c0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1lc0 14o0 1lc0 14o0 1lc0 17c0 1io0 17c0 1io0 17c0 1io0 17c0 1io0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00|600",
		"PST8PDT|PST PDT PWT PPT|80 70 70 70|010102301010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|-261q0 1nX0 11B0 1nX0 SgN0 8x10 iy0 QwN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1cN0 1cL0 1cN0 1cL0 s10 1Vz0 LB0 1BX0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1fz0 1a10 1fz0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0",
		"Pacific/Apia|LMT -1130 -11 -10 +14 +13|bq.U bu b0 a0 -e0 -d0|01232345454545454545454545454545454545454545454545454545454|-2nDMx.4 1yW03.4 2rRbu 1ff0 1a00 CI0 AQ0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00|37e3",
		"Pacific/Bougainville|+10 +09 +11|-a0 -90 -b0|0102|-16Wy0 7CN0 2MQp0|18e4",
		"Pacific/Efate|LMT +11 +12|-bd.g -b0 -c0|0121212121212121212121|-2l9nd.g 2Szcd.g 1cL0 1oN0 10L0 1fB0 19X0 1fB0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1cN0 1cL0 1fB0 Lz0 1Nd0 An0|66e3",
		"Pacific/Enderbury|-12 -11 +13|c0 b0 -d0|012|nIc0 B8n0|1",
		"Pacific/Fakaofo|-11 +13|b0 -d0|01|1Gfn0|483",
		"Pacific/Fiji|LMT +12 +13|-bT.I -c0 -d0|0121212121212121212121212121212121212121212121212121212121212121|-2bUzT.I 3m8NT.I LA0 1EM0 IM0 nJc0 LA0 1o00 Rc0 1wo0 Ao0 1Nc0 Ao0 1Q00 xz0 1SN0 uM0 1SM0 uM0 1VA0 s00 1VA0 uM0 1SM0 uM0 1SM0 uM0 1SM0 uM0 1VA0 s00 1VA0 s00 1VA0 uM0 1SM0 uM0 1SM0 uM0 1SM0 uM0 1VA0 s00 1VA0 uM0 1SM0 uM0 1SM0 uM0 1SM0 uM0 1VA0 s00 1VA0 s00 1VA0 uM0 1SM0 uM0 1SM0 uM0 1SM0 uM0|88e4",
		"Pacific/Galapagos|LMT -05 -06|5W.o 50 60|01212|-1yVS1.A 2dTz1.A gNd0 rz0|25e3",
		"Pacific/Gambier|LMT -09|8X.M 90|01|-2jof0.c|125",
		"Pacific/Guadalcanal|LMT +11|-aD.M -b0|01|-2joyD.M|11e4",
		"Pacific/Guam|GST ChST|-a0 -a0|01|1fpq0|17e4",
		"Pacific/Honolulu|HST HDT HST|au 9u a0|010102|-1thLu 8x0 lef0 8Pz0 46p0|37e4",
		"Pacific/Kiritimati|-1040 -10 +14|aE a0 -e0|012|nIaE B8nk|51e2",
		"Pacific/Kosrae|+11 +12|-b0 -c0|010|-AX0 1bdz0|66e2",
		"Pacific/Majuro|+11 +12|-b0 -c0|01|-AX0|28e3",
		"Pacific/Marquesas|LMT -0930|9i 9u|01|-2joeG|86e2",
		"Pacific/Pago_Pago|LMT SST|bm.M b0|01|-2nDMB.c|37e2",
		"Pacific/Nauru|LMT +1130 +09 +12|-b7.E -bu -90 -c0|01213|-1Xdn7.E PvzB.E 5RCu 1ouJu|10e3",
		"Pacific/Niue|-1120 -1130 -11|bk bu b0|012|-KfME 17y0a|12e2",
		"Pacific/Norfolk|+1112 +1130 +1230 +11|-bc -bu -cu -b0|01213|-Kgbc W01G On0 1COp0|25e4",
		"Pacific/Noumea|LMT +11 +12|-b5.M -b0 -c0|01212121|-2l9n5.M 2EqM5.M xX0 1PB0 yn0 HeP0 Ao0|98e3",
		"Pacific/Pitcairn|-0830 -08|8u 80|01|18Vku|56",
		"Pacific/Rarotonga|-1030 -0930 -10|au 9u a0|012121212121212121212121212|lyWu IL0 1zcu Onu 1zcu Onu 1zcu Rbu 1zcu Onu 1zcu Onu 1zcu Onu 1zcu Onu 1zcu Onu 1zcu Rbu 1zcu Onu 1zcu Onu 1zcu Onu|13e3",
		"Pacific/Tahiti|LMT -10|9W.g a0|01|-2joe1.I|18e4",
		"Pacific/Tongatapu|+1220 +13 +14|-ck -d0 -e0|0121212121212121212121212121212121212121212121212121|-1aB0k 2n5dk 15A0 1wo0 xz0 1Q10 xz0 zWN0 s00 1VA0 uM0 1SM0 uM0 1SM0 uM0 1SM0 uM0 1VA0 s00 1VA0 s00 1VA0 uM0 1SM0 uM0 1SM0 uM0 1SM0 uM0 1VA0 s00 1VA0 uM0 1SM0 uM0 1SM0 uM0 1SM0 uM0 1VA0 s00 1VA0 s00 1VA0 uM0 1SM0 uM0 1SM0 uM0 1SM0 uM0|75e3",
		"WET|WET WEST|0 -10|010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010|hDB0 1a00 1fA0 1cM0 1cM0 1cM0 1fA0 1a00 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00"
	],
	"links": [
		"Africa/Abidjan|Africa/Bamako",
		"Africa/Abidjan|Africa/Banjul",
		"Africa/Abidjan|Africa/Conakry",
		"Africa/Abidjan|Africa/Dakar",
		"Africa/Abidjan|Africa/Freetown",
		"Africa/Abidjan|Africa/Lome",
		"Africa/Abidjan|Africa/Nouakchott",
		"Africa/Abidjan|Africa/Ouagadougou",
		"Africa/Abidjan|Africa/Sao_Tome",
		"Africa/Abidjan|Africa/Timbuktu",
		"Africa/Abidjan|Atlantic/St_Helena",
		"Africa/Cairo|Egypt",
		"Africa/Johannesburg|Africa/Maseru",
		"Africa/Johannesburg|Africa/Mbabane",
		"Africa/Khartoum|Africa/Juba",
		"Africa/Lagos|Africa/Bangui",
		"Africa/Lagos|Africa/Brazzaville",
		"Africa/Lagos|Africa/Douala",
		"Africa/Lagos|Africa/Kinshasa",
		"Africa/Lagos|Africa/Libreville",
		"Africa/Lagos|Africa/Luanda",
		"Africa/Lagos|Africa/Malabo",
		"Africa/Lagos|Africa/Niamey",
		"Africa/Lagos|Africa/Porto-Novo",
		"Africa/Maputo|Africa/Blantyre",
		"Africa/Maputo|Africa/Bujumbura",
		"Africa/Maputo|Africa/Gaborone",
		"Africa/Maputo|Africa/Harare",
		"Africa/Maputo|Africa/Kigali",
		"Africa/Maputo|Africa/Lubumbashi",
		"Africa/Maputo|Africa/Lusaka",
		"Africa/Nairobi|Africa/Addis_Ababa",
		"Africa/Nairobi|Africa/Asmara",
		"Africa/Nairobi|Africa/Asmera",
		"Africa/Nairobi|Africa/Dar_es_Salaam",
		"Africa/Nairobi|Africa/Djibouti",
		"Africa/Nairobi|Africa/Kampala",
		"Africa/Nairobi|Africa/Mogadishu",
		"Africa/Nairobi|Indian/Antananarivo",
		"Africa/Nairobi|Indian/Comoro",
		"Africa/Nairobi|Indian/Mayotte",
		"Africa/Tripoli|Libya",
		"America/Adak|America/Atka",
		"America/Adak|US/Aleutian",
		"America/Anchorage|US/Alaska",
		"America/Argentina/Buenos_Aires|America/Buenos_Aires",
		"America/Argentina/Catamarca|America/Argentina/ComodRivadavia",
		"America/Argentina/Catamarca|America/Catamarca",
		"America/Argentina/Cordoba|America/Cordoba",
		"America/Argentina/Cordoba|America/Rosario",
		"America/Argentina/Jujuy|America/Jujuy",
		"America/Argentina/Mendoza|America/Mendoza",
		"America/Atikokan|America/Coral_Harbour",
		"America/Chicago|US/Central",
		"America/Curacao|America/Aruba",
		"America/Curacao|America/Kralendijk",
		"America/Curacao|America/Lower_Princes",
		"America/Denver|America/Shiprock",
		"America/Denver|Navajo",
		"America/Denver|US/Mountain",
		"America/Detroit|US/Michigan",
		"America/Edmonton|Canada/Mountain",
		"America/Fort_Wayne|America/Indiana/Indianapolis",
		"America/Fort_Wayne|America/Indianapolis",
		"America/Fort_Wayne|US/East-Indiana",
		"America/Halifax|Canada/Atlantic",
		"America/Havana|Cuba",
		"America/Indiana/Knox|America/Knox_IN",
		"America/Indiana/Knox|US/Indiana-Starke",
		"America/Jamaica|Jamaica",
		"America/Kentucky/Louisville|America/Louisville",
		"America/Los_Angeles|US/Pacific",
		"America/Los_Angeles|US/Pacific-New",
		"America/Manaus|Brazil/West",
		"America/Mazatlan|Mexico/BajaSur",
		"America/Mexico_City|Mexico/General",
		"America/New_York|US/Eastern",
		"America/Noronha|Brazil/DeNoronha",
		"America/Panama|America/Cayman",
		"America/Phoenix|US/Arizona",
		"America/Port_of_Spain|America/Anguilla",
		"America/Port_of_Spain|America/Antigua",
		"America/Port_of_Spain|America/Dominica",
		"America/Port_of_Spain|America/Grenada",
		"America/Port_of_Spain|America/Guadeloupe",
		"America/Port_of_Spain|America/Marigot",
		"America/Port_of_Spain|America/Montserrat",
		"America/Port_of_Spain|America/St_Barthelemy",
		"America/Port_of_Spain|America/St_Kitts",
		"America/Port_of_Spain|America/St_Lucia",
		"America/Port_of_Spain|America/St_Thomas",
		"America/Port_of_Spain|America/St_Vincent",
		"America/Port_of_Spain|America/Tortola",
		"America/Port_of_Spain|America/Virgin",
		"America/Regina|Canada/East-Saskatchewan",
		"America/Regina|Canada/Saskatchewan",
		"America/Rio_Branco|America/Porto_Acre",
		"America/Rio_Branco|Brazil/Acre",
		"America/Santiago|Chile/Continental",
		"America/Sao_Paulo|Brazil/East",
		"America/St_Johns|Canada/Newfoundland",
		"America/Tijuana|America/Ensenada",
		"America/Tijuana|America/Santa_Isabel",
		"America/Tijuana|Mexico/BajaNorte",
		"America/Toronto|America/Montreal",
		"America/Toronto|Canada/Eastern",
		"America/Vancouver|Canada/Pacific",
		"America/Whitehorse|Canada/Yukon",
		"America/Winnipeg|Canada/Central",
		"Asia/Ashgabat|Asia/Ashkhabad",
		"Asia/Bangkok|Asia/Phnom_Penh",
		"Asia/Bangkok|Asia/Vientiane",
		"Asia/Dhaka|Asia/Dacca",
		"Asia/Dubai|Asia/Muscat",
		"Asia/Ho_Chi_Minh|Asia/Saigon",
		"Asia/Hong_Kong|Hongkong",
		"Asia/Jerusalem|Asia/Tel_Aviv",
		"Asia/Jerusalem|Israel",
		"Asia/Kathmandu|Asia/Katmandu",
		"Asia/Kolkata|Asia/Calcutta",
		"Asia/Kuala_Lumpur|Asia/Singapore",
		"Asia/Kuala_Lumpur|Singapore",
		"Asia/Macau|Asia/Macao",
		"Asia/Makassar|Asia/Ujung_Pandang",
		"Asia/Nicosia|Europe/Nicosia",
		"Asia/Qatar|Asia/Bahrain",
		"Asia/Rangoon|Asia/Yangon",
		"Asia/Riyadh|Asia/Aden",
		"Asia/Riyadh|Asia/Kuwait",
		"Asia/Seoul|ROK",
		"Asia/Shanghai|Asia/Chongqing",
		"Asia/Shanghai|Asia/Chungking",
		"Asia/Shanghai|Asia/Harbin",
		"Asia/Shanghai|PRC",
		"Asia/Taipei|ROC",
		"Asia/Tehran|Iran",
		"Asia/Thimphu|Asia/Thimbu",
		"Asia/Tokyo|Japan",
		"Asia/Ulaanbaatar|Asia/Ulan_Bator",
		"Asia/Urumqi|Asia/Kashgar",
		"Atlantic/Faroe|Atlantic/Faeroe",
		"Atlantic/Reykjavik|Iceland",
		"Atlantic/South_Georgia|Etc/GMT+2",
		"Australia/Adelaide|Australia/South",
		"Australia/Brisbane|Australia/Queensland",
		"Australia/Broken_Hill|Australia/Yancowinna",
		"Australia/Darwin|Australia/North",
		"Australia/Hobart|Australia/Tasmania",
		"Australia/Lord_Howe|Australia/LHI",
		"Australia/Melbourne|Australia/Victoria",
		"Australia/Perth|Australia/West",
		"Australia/Sydney|Australia/ACT",
		"Australia/Sydney|Australia/Canberra",
		"Australia/Sydney|Australia/NSW",
		"Etc/GMT+0|Etc/GMT",
		"Etc/GMT+0|Etc/GMT-0",
		"Etc/GMT+0|Etc/GMT0",
		"Etc/GMT+0|Etc/Greenwich",
		"Etc/GMT+0|GMT",
		"Etc/GMT+0|GMT+0",
		"Etc/GMT+0|GMT-0",
		"Etc/GMT+0|GMT0",
		"Etc/GMT+0|Greenwich",
		"Etc/UCT|UCT",
		"Etc/UTC|Etc/Universal",
		"Etc/UTC|Etc/Zulu",
		"Etc/UTC|UTC",
		"Etc/UTC|Universal",
		"Etc/UTC|Zulu",
		"Europe/Belgrade|Europe/Ljubljana",
		"Europe/Belgrade|Europe/Podgorica",
		"Europe/Belgrade|Europe/Sarajevo",
		"Europe/Belgrade|Europe/Skopje",
		"Europe/Belgrade|Europe/Zagreb",
		"Europe/Chisinau|Europe/Tiraspol",
		"Europe/Dublin|Eire",
		"Europe/Helsinki|Europe/Mariehamn",
		"Europe/Istanbul|Asia/Istanbul",
		"Europe/Istanbul|Turkey",
		"Europe/Lisbon|Portugal",
		"Europe/London|Europe/Belfast",
		"Europe/London|Europe/Guernsey",
		"Europe/London|Europe/Isle_of_Man",
		"Europe/London|Europe/Jersey",
		"Europe/London|GB",
		"Europe/London|GB-Eire",
		"Europe/Moscow|W-SU",
		"Europe/Oslo|Arctic/Longyearbyen",
		"Europe/Oslo|Atlantic/Jan_Mayen",
		"Europe/Prague|Europe/Bratislava",
		"Europe/Rome|Europe/San_Marino",
		"Europe/Rome|Europe/Vatican",
		"Europe/Warsaw|Poland",
		"Europe/Zurich|Europe/Busingen",
		"Europe/Zurich|Europe/Vaduz",
		"Indian/Christmas|Etc/GMT-7",
		"Pacific/Auckland|Antarctica/McMurdo",
		"Pacific/Auckland|Antarctica/South_Pole",
		"Pacific/Auckland|NZ",
		"Pacific/Chatham|NZ-CHAT",
		"Pacific/Easter|Chile/EasterIsland",
		"Pacific/Guam|Pacific/Saipan",
		"Pacific/Honolulu|Pacific/Johnston",
		"Pacific/Honolulu|US/Hawaii",
		"Pacific/Kwajalein|Kwajalein",
		"Pacific/Pago_Pago|Pacific/Midway",
		"Pacific/Pago_Pago|Pacific/Samoa",
		"Pacific/Pago_Pago|US/Samoa",
		"Pacific/Palau|Etc/GMT-9",
		"Pacific/Pohnpei|Etc/GMT-11",
		"Pacific/Pohnpei|Pacific/Ponape",
		"Pacific/Port_Moresby|Etc/GMT-10",
		"Pacific/Port_Moresby|Pacific/Chuuk",
		"Pacific/Port_Moresby|Pacific/Truk",
		"Pacific/Port_Moresby|Pacific/Yap",
		"Pacific/Tarawa|Etc/GMT-12",
		"Pacific/Tarawa|Pacific/Funafuti",
		"Pacific/Tarawa|Pacific/Wake",
		"Pacific/Tarawa|Pacific/Wallis"
	]
}
},{}],9:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var moment = module.exports = require("./moment-timezone");
moment.tz.load(require('./data/packed/latest.json'));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules\\moment-timezone\\index.js","/node_modules\\moment-timezone")
},{"./data/packed/latest.json":8,"./moment-timezone":10,"_process":4,"buffer":2}],10:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//! moment-timezone.js
//! version : 0.5.13
//! Copyright (c) JS Foundation and other contributors
//! license : MIT
//! github.com/moment/moment-timezone

(function (root, factory) {
	"use strict";

	/*global define*/
	if (typeof define === 'function' && define.amd) {
		define(['moment'], factory);                 // AMD
	} else if (typeof module === 'object' && module.exports) {
		module.exports = factory(require('moment')); // Node
	} else {
		factory(root.moment);                        // Browser
	}
}(this, function (moment) {
	"use strict";

	// Do not load moment-timezone a second time.
	// if (moment.tz !== undefined) {
	// 	logError('Moment Timezone ' + moment.tz.version + ' was already loaded ' + (moment.tz.dataVersion ? 'with data from ' : 'without any data') + moment.tz.dataVersion);
	// 	return moment;
	// }

	var VERSION = "0.5.13",
		zones = {},
		links = {},
		names = {},
		guesses = {},
		cachedGuess,

		momentVersion = moment.version.split('.'),
		major = +momentVersion[0],
		minor = +momentVersion[1];

	// Moment.js version check
	if (major < 2 || (major === 2 && minor < 6)) {
		logError('Moment Timezone requires Moment.js >= 2.6.0. You are using Moment.js ' + moment.version + '. See momentjs.com');
	}

	/************************************
		Unpacking
	************************************/

	function charCodeToInt(charCode) {
		if (charCode > 96) {
			return charCode - 87;
		} else if (charCode > 64) {
			return charCode - 29;
		}
		return charCode - 48;
	}

	function unpackBase60(string) {
		var i = 0,
			parts = string.split('.'),
			whole = parts[0],
			fractional = parts[1] || '',
			multiplier = 1,
			num,
			out = 0,
			sign = 1;

		// handle negative numbers
		if (string.charCodeAt(0) === 45) {
			i = 1;
			sign = -1;
		}

		// handle digits before the decimal
		for (i; i < whole.length; i++) {
			num = charCodeToInt(whole.charCodeAt(i));
			out = 60 * out + num;
		}

		// handle digits after the decimal
		for (i = 0; i < fractional.length; i++) {
			multiplier = multiplier / 60;
			num = charCodeToInt(fractional.charCodeAt(i));
			out += num * multiplier;
		}

		return out * sign;
	}

	function arrayToInt (array) {
		for (var i = 0; i < array.length; i++) {
			array[i] = unpackBase60(array[i]);
		}
	}

	function intToUntil (array, length) {
		for (var i = 0; i < length; i++) {
			array[i] = Math.round((array[i - 1] || 0) + (array[i] * 60000)); // minutes to milliseconds
		}

		array[length - 1] = Infinity;
	}

	function mapIndices (source, indices) {
		var out = [], i;

		for (i = 0; i < indices.length; i++) {
			out[i] = source[indices[i]];
		}

		return out;
	}

	function unpack (string) {
		var data = string.split('|'),
			offsets = data[2].split(' '),
			indices = data[3].split(''),
			untils  = data[4].split(' ');

		arrayToInt(offsets);
		arrayToInt(indices);
		arrayToInt(untils);

		intToUntil(untils, indices.length);

		return {
			name       : data[0],
			abbrs      : mapIndices(data[1].split(' '), indices),
			offsets    : mapIndices(offsets, indices),
			untils     : untils,
			population : data[5] | 0
		};
	}

	/************************************
		Zone object
	************************************/

	function Zone (packedString) {
		if (packedString) {
			this._set(unpack(packedString));
		}
	}

	Zone.prototype = {
		_set : function (unpacked) {
			this.name       = unpacked.name;
			this.abbrs      = unpacked.abbrs;
			this.untils     = unpacked.untils;
			this.offsets    = unpacked.offsets;
			this.population = unpacked.population;
		},

		_index : function (timestamp) {
			var target = +timestamp,
				untils = this.untils,
				i;

			for (i = 0; i < untils.length; i++) {
				if (target < untils[i]) {
					return i;
				}
			}
		},

		parse : function (timestamp) {
			var target  = +timestamp,
				offsets = this.offsets,
				untils  = this.untils,
				max     = untils.length - 1,
				offset, offsetNext, offsetPrev, i;

			for (i = 0; i < max; i++) {
				offset     = offsets[i];
				offsetNext = offsets[i + 1];
				offsetPrev = offsets[i ? i - 1 : i];

				if (offset < offsetNext && tz.moveAmbiguousForward) {
					offset = offsetNext;
				} else if (offset > offsetPrev && tz.moveInvalidForward) {
					offset = offsetPrev;
				}

				if (target < untils[i] - (offset * 60000)) {
					return offsets[i];
				}
			}

			return offsets[max];
		},

		abbr : function (mom) {
			return this.abbrs[this._index(mom)];
		},

		offset : function (mom) {
			return this.offsets[this._index(mom)];
		}
	};

	/************************************
		Current Timezone
	************************************/

	function OffsetAt(at) {
		var timeString = at.toTimeString();
		var abbr = timeString.match(/\([a-z ]+\)/i);
		if (abbr && abbr[0]) {
			// 17:56:31 GMT-0600 (CST)
			// 17:56:31 GMT-0600 (Central Standard Time)
			abbr = abbr[0].match(/[A-Z]/g);
			abbr = abbr ? abbr.join('') : undefined;
		} else {
			// 17:56:31 CST
			// 17:56:31 GMT+0800 ()
			abbr = timeString.match(/[A-Z]{3,5}/g);
			abbr = abbr ? abbr[0] : undefined;
		}

		if (abbr === 'GMT') {
			abbr = undefined;
		}

		this.at = +at;
		this.abbr = abbr;
		this.offset = at.getTimezoneOffset();
	}

	function ZoneScore(zone) {
		this.zone = zone;
		this.offsetScore = 0;
		this.abbrScore = 0;
	}

	ZoneScore.prototype.scoreOffsetAt = function (offsetAt) {
		this.offsetScore += Math.abs(this.zone.offset(offsetAt.at) - offsetAt.offset);
		if (this.zone.abbr(offsetAt.at).replace(/[^A-Z]/g, '') !== offsetAt.abbr) {
			this.abbrScore++;
		}
	};

	function findChange(low, high) {
		var mid, diff;

		while ((diff = ((high.at - low.at) / 12e4 | 0) * 6e4)) {
			mid = new OffsetAt(new Date(low.at + diff));
			if (mid.offset === low.offset) {
				low = mid;
			} else {
				high = mid;
			}
		}

		return low;
	}

	function userOffsets() {
		var startYear = new Date().getFullYear() - 2,
			last = new OffsetAt(new Date(startYear, 0, 1)),
			offsets = [last],
			change, next, i;

		for (i = 1; i < 48; i++) {
			next = new OffsetAt(new Date(startYear, i, 1));
			if (next.offset !== last.offset) {
				change = findChange(last, next);
				offsets.push(change);
				offsets.push(new OffsetAt(new Date(change.at + 6e4)));
			}
			last = next;
		}

		for (i = 0; i < 4; i++) {
			offsets.push(new OffsetAt(new Date(startYear + i, 0, 1)));
			offsets.push(new OffsetAt(new Date(startYear + i, 6, 1)));
		}

		return offsets;
	}

	function sortZoneScores (a, b) {
		if (a.offsetScore !== b.offsetScore) {
			return a.offsetScore - b.offsetScore;
		}
		if (a.abbrScore !== b.abbrScore) {
			return a.abbrScore - b.abbrScore;
		}
		return b.zone.population - a.zone.population;
	}

	function addToGuesses (name, offsets) {
		var i, offset;
		arrayToInt(offsets);
		for (i = 0; i < offsets.length; i++) {
			offset = offsets[i];
			guesses[offset] = guesses[offset] || {};
			guesses[offset][name] = true;
		}
	}

	function guessesForUserOffsets (offsets) {
		var offsetsLength = offsets.length,
			filteredGuesses = {},
			out = [],
			i, j, guessesOffset;

		for (i = 0; i < offsetsLength; i++) {
			guessesOffset = guesses[offsets[i].offset] || {};
			for (j in guessesOffset) {
				if (guessesOffset.hasOwnProperty(j)) {
					filteredGuesses[j] = true;
				}
			}
		}

		for (i in filteredGuesses) {
			if (filteredGuesses.hasOwnProperty(i)) {
				out.push(names[i]);
			}
		}

		return out;
	}

	function rebuildGuess () {

		// use Intl API when available and returning valid time zone
		try {
			var intlName = Intl.DateTimeFormat().resolvedOptions().timeZone;
			if (intlName){
				var name = names[normalizeName(intlName)];
				if (name) {
					return name;
				}
				logError("Moment Timezone found " + intlName + " from the Intl api, but did not have that data loaded.");
			}
		} catch (e) {
			// Intl unavailable, fall back to manual guessing.
		}

		var offsets = userOffsets(),
			offsetsLength = offsets.length,
			guesses = guessesForUserOffsets(offsets),
			zoneScores = [],
			zoneScore, i, j;

		for (i = 0; i < guesses.length; i++) {
			zoneScore = new ZoneScore(getZone(guesses[i]), offsetsLength);
			for (j = 0; j < offsetsLength; j++) {
				zoneScore.scoreOffsetAt(offsets[j]);
			}
			zoneScores.push(zoneScore);
		}

		zoneScores.sort(sortZoneScores);

		return zoneScores.length > 0 ? zoneScores[0].zone.name : undefined;
	}

	function guess (ignoreCache) {
		if (!cachedGuess || ignoreCache) {
			cachedGuess = rebuildGuess();
		}
		return cachedGuess;
	}

	/************************************
		Global Methods
	************************************/

	function normalizeName (name) {
		return (name || '').toLowerCase().replace(/\//g, '_');
	}

	function addZone (packed) {
		var i, name, split, normalized;

		if (typeof packed === "string") {
			packed = [packed];
		}

		for (i = 0; i < packed.length; i++) {
			split = packed[i].split('|');
			name = split[0];
			normalized = normalizeName(name);
			zones[normalized] = packed[i];
			names[normalized] = name;
			if (split[5]) {
				addToGuesses(normalized, split[2].split(' '));
			}
		}
	}

	function getZone (name, caller) {
		name = normalizeName(name);

		var zone = zones[name];
		var link;

		if (zone instanceof Zone) {
			return zone;
		}

		if (typeof zone === 'string') {
			zone = new Zone(zone);
			zones[name] = zone;
			return zone;
		}

		// Pass getZone to prevent recursion more than 1 level deep
		if (links[name] && caller !== getZone && (link = getZone(links[name], getZone))) {
			zone = zones[name] = new Zone();
			zone._set(link);
			zone.name = names[name];
			return zone;
		}

		return null;
	}

	function getNames () {
		var i, out = [];

		for (i in names) {
			if (names.hasOwnProperty(i) && (zones[i] || zones[links[i]]) && names[i]) {
				out.push(names[i]);
			}
		}

		return out.sort();
	}

	function addLink (aliases) {
		var i, alias, normal0, normal1;

		if (typeof aliases === "string") {
			aliases = [aliases];
		}

		for (i = 0; i < aliases.length; i++) {
			alias = aliases[i].split('|');

			normal0 = normalizeName(alias[0]);
			normal1 = normalizeName(alias[1]);

			links[normal0] = normal1;
			names[normal0] = alias[0];

			links[normal1] = normal0;
			names[normal1] = alias[1];
		}
	}

	function loadData (data) {
		addZone(data.zones);
		addLink(data.links);
		tz.dataVersion = data.version;
	}

	function zoneExists (name) {
		if (!zoneExists.didShowError) {
			zoneExists.didShowError = true;
				logError("moment.tz.zoneExists('" + name + "') has been deprecated in favor of !moment.tz.zone('" + name + "')");
		}
		return !!getZone(name);
	}

	function needsOffset (m) {
		return !!(m._a && (m._tzm === undefined));
	}

	function logError (message) {
		if (typeof console !== 'undefined' && typeof console.error === 'function') {
			console.error(message);
		}
	}

	/************************************
		moment.tz namespace
	************************************/

	function tz (input) {
		var args = Array.prototype.slice.call(arguments, 0, -1),
			name = arguments[arguments.length - 1],
			zone = getZone(name),
			out  = moment.utc.apply(null, args);

		if (zone && !moment.isMoment(input) && needsOffset(out)) {
			out.add(zone.parse(out), 'minutes');
		}

		out.tz(name);

		return out;
	}

	tz.version      = VERSION;
	tz.dataVersion  = '';
	tz._zones       = zones;
	tz._links       = links;
	tz._names       = names;
	tz.add          = addZone;
	tz.link         = addLink;
	tz.load         = loadData;
	tz.zone         = getZone;
	tz.zoneExists   = zoneExists; // deprecated in 0.1.0
	tz.guess        = guess;
	tz.names        = getNames;
	tz.Zone         = Zone;
	tz.unpack       = unpack;
	tz.unpackBase60 = unpackBase60;
	tz.needsOffset  = needsOffset;
	tz.moveInvalidForward   = true;
	tz.moveAmbiguousForward = false;

	/************************************
		Interface with Moment.js
	************************************/

	var fn = moment.fn;

	moment.tz = tz;

	moment.defaultZone = null;

	moment.updateOffset = function (mom, keepTime) {
		var zone = moment.defaultZone,
			offset;

		if (mom._z === undefined) {
			if (zone && needsOffset(mom) && !mom._isUTC) {
				mom._d = moment.utc(mom._a)._d;
				mom.utc().add(zone.parse(mom), 'minutes');
			}
			mom._z = zone;
		}
		if (mom._z) {
			offset = mom._z.offset(mom);
			if (Math.abs(offset) < 16) {
				offset = offset / 60;
			}
			if (mom.utcOffset !== undefined) {
				mom.utcOffset(-offset, keepTime);
			} else {
				mom.zone(offset, keepTime);
			}
		}
	};

	fn.tz = function (name) {
		if (name) {
			this._z = getZone(name);
			if (this._z) {
				moment.updateOffset(this);
			} else {
				logError("Moment Timezone has no data for " + name + ". See http://momentjs.com/timezone/docs/#/data-loading/.");
			}
			return this;
		}
		if (this._z) { return this._z.name; }
	};

	function abbrWrap (old) {
		return function () {
			if (this._z) { return this._z.abbr(this); }
			return old.call(this);
		};
	}

	function resetZoneWrap (old) {
		return function () {
			this._z = null;
			return old.apply(this, arguments);
		};
	}

	fn.zoneName = abbrWrap(fn.zoneName);
	fn.zoneAbbr = abbrWrap(fn.zoneAbbr);
	fn.utc      = resetZoneWrap(fn.utc);

	moment.tz.setDefault = function(name) {
		if (major < 2 || (major === 2 && minor < 9)) {
			logError('Moment Timezone setDefault() requires Moment.js >= 2.9.0. You are using Moment.js ' + moment.version + '.');
		}
		moment.defaultZone = name ? getZone(name) : null;
		return moment;
	};

	// Cloning a moment should include the _z property.
	var momentProperties = moment.momentProperties;
	if (Object.prototype.toString.call(momentProperties) === '[object Array]') {
		// moment 2.8.1+
		momentProperties.push('_z');
		momentProperties.push('_a');
	} else if (momentProperties) {
		// moment 2.7.0
		momentProperties._z = null;
	}

	// INJECT DATA

	return moment;
}));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules\\moment-timezone\\moment-timezone.js","/node_modules\\moment-timezone")
},{"_process":4,"buffer":2,"moment":11}],11:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//! moment.js
//! version : 2.18.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    var k;
    for (k in obj) {
        // even if its not own property I'd still call it non-empty
        return false;
    }
    return true;
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

var some$1 = some;

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var keys$1 = keys;

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid()) {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

var indexOf$1 = indexOf;

function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            require('./locale/' + name);
            // because defineLocale currently also sets the global locale, we
            // want to undo that for lazy loaded locales
            getSetGlobalLocale(oldLocale);
        } catch (e) { }
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, parentConfig = baseConfig;
        // MERGE
        if (locales[name] != null) {
            parentConfig = locales[name]._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys$1(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/;

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var string, match, dayFormat,
        dateFormat, timeFormat, tzFormat;
    var timezones = {
        ' GMT': ' +0000',
        ' EDT': ' -0400',
        ' EST': ' -0500',
        ' CDT': ' -0500',
        ' CST': ' -0600',
        ' MDT': ' -0600',
        ' MST': ' -0700',
        ' PDT': ' -0700',
        ' PST': ' -0800'
    };
    var military = 'YXWVUTSRQPONZABCDEFGHIKLM';
    var timezone, timezoneIndex;

    string = config._i
        .replace(/\([^\)]*\)|[\n\t]/g, ' ') // Remove comments and folding whitespace
        .replace(/(\s\s+)/g, ' ') // Replace multiple-spaces with a single space
        .replace(/^\s|\s$/g, ''); // Remove leading and trailing spaces
    match = basicRfcRegex.exec(string);

    if (match) {
        dayFormat = match[1] ? 'ddd' + ((match[1].length === 5) ? ', ' : ' ') : '';
        dateFormat = 'D MMM ' + ((match[2].length > 10) ? 'YYYY ' : 'YY ');
        timeFormat = 'HH:mm' + (match[4] ? ':ss' : '');

        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        if (match[1]) { // day of week given
            var momentDate = new Date(match[2]);
            var momentDay = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][momentDate.getDay()];

            if (match[1].substr(0,3) !== momentDay) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return;
            }
        }

        switch (match[5].length) {
            case 2: // military
                if (timezoneIndex === 0) {
                    timezone = ' +0000';
                } else {
                    timezoneIndex = military.indexOf(match[5][1].toUpperCase()) - 12;
                    timezone = ((timezoneIndex < 0) ? ' -' : ' +') +
                        (('' + timezoneIndex).replace(/^-?/, '0')).match(/..$/)[0] + '00';
                }
                break;
            case 4: // Zone
                timezone = timezones[match[5]];
                break;
            default: // UT or +/-9999
                timezone = timezones[' GMT'];
        }
        match[5] = timezone;
        config._i = match.splice(1).join('');
        tzFormat = ' ZZ';
        config._f = dayFormat + dateFormat + timeFormat + tzFormat;
        configFromStringAndFormat(config);
        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(ordering.indexOf(key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    if (units === 'year' || units === 'month' || units === 'quarter') {
        output = monthDiff(this, that);
        if (units === 'quarter') {
            output = output / 3;
        } else if (units === 'year') {
            output = output / 12;
        }
    } else {
        delta = this - that;
        output = units === 'second' ? delta / 1e3 : // 1000
            units === 'minute' ? delta / 6e4 : // 1000 * 60
            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
            delta;
    }
    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString() {
    if (!this.isValid()) {
        return null;
    }
    var m = this.clone().utc();
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        return this.toDate().toISOString();
    }
    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds;
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    return (total < 0 ? '-' : '') +
        'P' +
        (Y ? Y + 'Y' : '') +
        (M ? M + 'M' : '') +
        (D ? D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? h + 'H' : '') +
        (m ? m + 'M' : '') +
        (s ? s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.18.1';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

return hooks;

})));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules\\moment\\moment.js","/node_modules\\moment")
},{"_process":4,"buffer":2}],12:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var v1 = require('./v1');
var v4 = require('./v4');

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules\\uuid\\index.js","/node_modules\\uuid")
},{"./v1":15,"./v4":16,"_process":4,"buffer":2}],13:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

module.exports = bytesToUuid;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules\\uuid\\lib\\bytesToUuid.js","/node_modules\\uuid\\lib")
},{"_process":4,"buffer":2}],14:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection
var rng;

var crypto = global.crypto || global.msCrypto; // for IE 11
if (crypto && crypto.getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef
  rng = function whatwgRNG() {
    crypto.getRandomValues(rnds8);
    return rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

module.exports = rng;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules\\uuid\\lib\\rng-browser.js","/node_modules\\uuid\\lib")
},{"_process":4,"buffer":2}],15:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [
  _seedBytes[0] | 0x01,
  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0, _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules\\uuid\\v1.js","/node_modules\\uuid")
},{"./lib/bytesToUuid":13,"./lib/rng":14,"_process":4,"buffer":2}],16:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules\\uuid\\v4.js","/node_modules\\uuid")
},{"./lib/bytesToUuid":13,"./lib/rng":14,"_process":4,"buffer":2}]},{},[6]);
